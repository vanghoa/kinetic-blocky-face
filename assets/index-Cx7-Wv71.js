var tse=Object.defineProperty;var oP=r=>{throw TypeError(r)};var rse=(r,t,n)=>t in r?tse(r,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):r[t]=n;var Ar=(r,t,n)=>rse(r,typeof t!="symbol"?t+"":t,n),sE=(r,t,n)=>t.has(r)||oP("Cannot "+n);var ut=(r,t,n)=>(sE(r,t,"read from private field"),n?n.call(r):t.get(r)),cn=(r,t,n)=>t.has(r)?oP("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(r):t.set(r,n),Xs=(r,t,n,s)=>(sE(r,t,"write to private field"),s?s.call(r,n):t.set(r,n),n),es=(r,t,n)=>(sE(r,t,"access private method"),n);function nse(r,t){for(var n=0;n<t.length;n++){const s=t[n];if(typeof s!="string"&&!Array.isArray(s)){for(const i in s)if(i!=="default"&&!(i in r)){const a=Object.getOwnPropertyDescriptor(s,i);a&&Object.defineProperty(r,i,a.get?a:{enumerable:!0,get:()=>s[i]})}}}return Object.freeze(Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const a of i)if(a.type==="childList")for(const o of a.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function n(i){const a={};return i.integrity&&(a.integrity=i.integrity),i.referrerPolicy&&(a.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?a.credentials="include":i.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(i){if(i.ep)return;i.ep=!0;const a=n(i);fetch(i.href,a)}})();const Fd=Math.PI,Xz="2.0.2",Vh="p2d",sse="p2d-hdr",ic="webgl",ts="webgl2",Yz="default",AI="simple",DI="full",Zz="crosshair",Jz="pointer",Qz="move",eU="text",tU="wait",uh=Fd/2,FI=Fd,ise=Fd/4,ase=Fd*2,bi=Fd*2,lh=Fd/180,ch=180/Fd,xa="corner",tb="corners",rb="radius",Ow="right",rU="left",Ki="center",ose="top",$I="bottom",nU="alphabetic",Mw=0,wm=1,use=3,lse=2,em=4,_S=6,nb=5,Uy="quads",sb="quad_strip",cse="tess",tm=7,Eo=8,ib="close",zh="open",Lw="chord",ab="pie",cT="square",hT="butt",Ql="round",dT="bevel",pT="miter",sU="auto",hse="Alt",dse="Backspace",pse="Control",fse="Delete",mse="ArrowDown",gse="Enter",yse="Escape",bse="ArrowLeft",xse="Alt",vse="Enter",wse="ArrowRight",Sse="Shift",Cse="Tab",_se="ArrowUp",Si="source-over",Uh="destination-out",ob="lighter",ES="darken",IS="lighten",iU="difference",kS="subtract",NS="exclusion",TS="multiply",AS="screen",DS="copy",fT="overlay",mT="hard-light",gT="soft-light",yT="color-dodge",bT="color-burn",FS="threshold",xT="gray",vT="opaque",wT="invert",$S="posterize",ST="dilate",CT="erode",Sm="blur",eu="normal",Ese="italic",Ise="bold",kse="bold italic",Nse="CHAR",aU="WORD",Tse="#000000",Ase=1.25,Dse="middle",RI="linear",Fse="quadratic",$se="bezier",Rse="curve",Ose="stroke",Pw="fill",Bw="texture",Mse="immediate",RS="image",oU="nearest",OI="repeat",MI="clamp",LI="mirror",uU="flat",lU="smooth",Lse="landscape",Pse="portrait",cU="#000000",hU="#FFFFFF",dU="grid",pU="axes",Bse="label",Vse="fallback",fU="contain",mU="cover",Bl="unsigned-byte",Wy="unsigned-int",Bi="float",Uf="half-float",rm=Symbol("include"),Xf=Symbol("exclude"),PI=Symbol("join");var Wh=Object.freeze({__proto__:null,ADD:ob,ALT:hse,ARROW:Yz,AUTO:sU,AXES:pU,BACKSPACE:dse,BASELINE:nU,BEVEL:dT,BEZIER:$se,BLEND:Si,BLUR:Sm,BOLD:Ise,BOLDITALIC:kse,BOTTOM:$I,BURN:bT,CENTER:Ki,CHAR:Nse,CHORD:Lw,CLAMP:MI,CLOSE:ib,CONTAIN:fU,CONTROL:pse,CORNER:xa,CORNERS:tb,COVER:mU,CROSS:Zz,CURVE:Rse,DARKEST:ES,DEG_TO_RAD:lh,DELETE:fse,DIFFERENCE:iU,DILATE:ST,DODGE:yT,DOWN_ARROW:mse,EMPTY_PATH:tm,ENTER:gse,ERODE:CT,ESCAPE:yse,EXCLUDE:Xf,EXCLUSION:NS,FALLBACK:Vse,FILL:Pw,FLAT:uU,FLOAT:Bi,FULL:DI,GRAY:xT,GRID:dU,HALF_FLOAT:Uf,HALF_PI:uh,HAND:Jz,HARD_LIGHT:mT,IMAGE:RS,IMMEDIATE:Mse,INCLUDE:rm,INVERT:wT,ITALIC:Ese,JOIN:PI,LABEL:Bse,LANDSCAPE:Lse,LEFT:rU,LEFT_ARROW:bse,LIGHTEST:IS,LINEAR:RI,LINES:wm,LINE_LOOP:lse,LINE_STRIP:use,MIRROR:LI,MITER:pT,MOVE:Qz,MULTIPLY:TS,NEAREST:oU,NORMAL:eu,OPAQUE:vT,OPEN:zh,OPTION:xse,OVERLAY:fT,P2D:Vh,P2DHDR:sse,PATH:Eo,PI:FI,PIE:ab,POINTS:Mw,PORTRAIT:Pse,POSTERIZE:$S,PROJECT:cT,QUADRATIC:Fse,QUADS:Uy,QUAD_STRIP:sb,QUARTER_PI:ise,RADIUS:rb,RAD_TO_DEG:ch,REMOVE:Uh,REPEAT:OI,REPLACE:DS,RETURN:vse,RIGHT:Ow,RIGHT_ARROW:wse,ROUND:Ql,SCREEN:AS,SHIFT:Sse,SIMPLE:AI,SMOOTH:lU,SOFT_LIGHT:gT,SQUARE:hT,STROKE:Ose,SUBTRACT:kS,TAB:Cse,TAU:ase,TESS:cse,TEXT:eU,TEXTURE:Bw,THRESHOLD:FS,TOP:ose,TRIANGLES:em,TRIANGLE_FAN:_S,TRIANGLE_STRIP:nb,TWO_PI:bi,UNSIGNED_BYTE:Bl,UNSIGNED_INT:Wy,UP_ARROW:_se,VERSION:Xz,WAIT:tU,WEBGL:ic,WEBGL2:ts,WORD:aU,_CTX_MIDDLE:Dse,_DEFAULT_FILL:hU,_DEFAULT_LEADMULT:Ase,_DEFAULT_STROKE:cU,_DEFAULT_TEXT_FILL:Tse});function _T(r,t){t.applyMatrix=function(...n){let s=n[0]instanceof Object.getPrototypeOf(Uint8Array);return Array.isArray(n[0])||s?this._renderer.applyMatrix(...n[0]):this._renderer.applyMatrix(...n),this},t.resetMatrix=function(){return this._renderer.resetMatrix(),this},t.rotate=function(n,s){return this._renderer.rotate(this._toRadians(n),s),this},t.rotateX=function(n){return this._assert3d("rotateX"),this._renderer.rotateX(this._toRadians(n)),this},t.rotateY=function(n){return this._assert3d("rotateY"),this._renderer.rotateY(this._toRadians(n)),this},t.rotateZ=function(n){return this._assert3d("rotateZ"),this._renderer.rotateZ(this._toRadians(n)),this},t.scale=function(n,s,i){if(n instanceof r.Vector){const a=n;n=a.x,s=a.y,i=a.z}else if(Array.isArray(n)){const a=n;n=a[0],s=a[1],i=a[2]||1}return isNaN(s)?s=i=n:isNaN(i)&&(i=1),this._renderer.scale(n,s,i),this},t.shearX=function(n){const s=this._toRadians(n);return this._renderer.applyMatrix(1,0,Math.tan(s),1,0,0),this},t.shearY=function(n){const s=this._toRadians(n);return this._renderer.applyMatrix(1,Math.tan(s),0,1,0,0),this},t.translate=function(n,s,i){return this._renderer.isP3D?this._renderer.translate(n,s,i):this._renderer.translate(n,s),this},t.push=function(){this._renderer.push()},t.pop=function(){this._renderer.pop()}}typeof p5<"u"&&_T(p5,p5.prototype);function gU(r,t){t.noLoop=function(){this._loop=!1},t.loop=function(){this._loop||(this._loop=!0,this._setupDone&&this._draw())},t.isLooping=function(){return this._loop},t.redraw=async function(n){if(this._inUserDraw||!this._setupDone)return;let s=parseInt(n);(isNaN(s)||s<1)&&(s=1);const i=this._isGlobal?window:this;if(typeof i.draw=="function"){typeof i.setup>"u"&&i.scale(i._pixelDensity,i._pixelDensity);for(let a=0;a<s;a++){i.resetMatrix(),(this._accessibleOutputs.grid||this._accessibleOutputs.text)&&this._updateAccsOutput(),this._renderer.isP3D&&this._renderer._update(),this.frameCount=i.frameCount+1,await this._runLifecycleHook("predraw"),this._inUserDraw=!0;try{await i.draw()}finally{this._inUserDraw=!1}await this._runLifecycleHook("postdraw")}}}}typeof p5<"u"&&gU(p5,p5.prototype);const uP=function(r,t){return r!==0&&(this.x=this.x%r),t!==0&&(this.y=this.y%t),this},iE=function(r,t,n){return r!==0&&(this.x=this.x%r),t!==0&&(this.y=this.y%t),n!==0&&(this.z=this.z%n),this};class De{constructor(...t){let n=t.map(i=>i||0);typeof t[0]=="function"&&(this.isPInst=!0,this._fromRadians=t[0],this._toRadians=t[1],n=t.slice(2).map(i=>i||0));let s=n.length;s===0?(this.dimensions=2,this._values=[0,0,0]):(this.dimensions=s,this._values=n)}get values(){return this._values}set values(t){let n=t.length;n===0?(this.dimensions=2,this._values=[0,0,0]):(this.dimensions=n,this._values=t.slice())}get x(){return this._values[0]||0}getValue(t){if(t<this._values.length)return this._values[t];p5._friendlyError("The index parameter is trying to set a value outside the bounds of the vector","p5.Vector.setValue")}setValue(t,n){t<this._values.length?this._values[t]=n:p5._friendlyError("The index parameter is trying to set a value outside the bounds of the vector","p5.Vector.setValue")}get y(){return this._values[1]||0}get z(){return this._values[2]||0}get w(){return this._values[3]||0}set x(t){this._values.length>1&&(this._values[0]=t)}set y(t){this._values.length>1&&(this._values[1]=t)}set z(t){this._values.length>2&&(this._values[2]=t)}set w(t){this._values.length>3&&(this._values[3]=t)}toString(){return`[${this.values.join(", ")}]`}set(...t){return t[0]instanceof De?this.values=t[0].values.slice():Array.isArray(t[0])?this.values=t[0].map(n=>n||0):this.values=t.map(n=>n||0),this.dimensions=this.values.length,this}copy(){return this.isPInst?new De(this._fromRadians,this._toRadians,...this.values):new De(...this.values)}add(...t){return t[0]instanceof De?t=t[0].values:Array.isArray(t[0])&&(t=t[0]),t.forEach((n,s)=>{this.values[s]=(this.values[s]||0)+(n||0)}),this}rem(t,n,s){if(t instanceof De){if([t.x,t.y,t.z].every(Number.isFinite)){const i=parseFloat(t.x),a=parseFloat(t.y),o=parseFloat(t.z);return iE.call(this,i,a,o)}}else if(Array.isArray(t)){if(t.every(i=>Number.isFinite(i))){if(t.length===2)return uP.call(this,t[0],t[1]);if(t.length===3)return iE.call(this,t[0],t[1],t[2])}}else if(arguments.length===1){if(Number.isFinite(arguments[0])&&arguments[0]!==0)return this.x=this.x%arguments[0],this.y=this.y%arguments[0],this.z=this.z%arguments[0],this}else if(arguments.length===2){const i=[...arguments];if(i.every(a=>Number.isFinite(a))&&i.length===2)return uP.call(this,i[0],i[1])}else if(arguments.length===3){const i=[...arguments];if(i.every(a=>Number.isFinite(a))&&i.length===3)return iE.call(this,i[0],i[1],i[2])}}sub(...t){return t[0]instanceof De?t[0].values.forEach((n,s)=>{this.values[s]-=n||0}):Array.isArray(t[0])?t[0].forEach((n,s)=>{this.values[s]-=n||0}):t.forEach((n,s)=>{this.values[s]-=n||0}),this}mult(...t){if(t.length===1&&t[0]instanceof De){const n=t[0],s=Math.min(this.values.length,n.values.length);for(let i=0;i<s;i++)if(Number.isFinite(n.values[i])&&typeof n.values[i]=="number")this._values[i]*=n.values[i];else return console.warn("p5.Vector.prototype.mult:","v contains components that are either undefined or not finite numbers"),this}else if(t.length===1&&Array.isArray(t[0])){const n=t[0],s=Math.min(this.values.length,n.length);for(let i=0;i<s;i++)if(Number.isFinite(n[i])&&typeof n[i]=="number")this._values[i]*=n[i];else return console.warn("p5.Vector.prototype.mult:","arr contains elements that are either undefined or not finite numbers"),this}else if(t.length===1&&typeof t[0]=="number"&&Number.isFinite(t[0]))for(let n=0;n<this._values.length;n++)this._values[n]*=t[0];return this}div(...t){if(t.length===0)return this;if(t.length===1&&t[0]instanceof De){const n=t[0];if(n._values.every(s=>Number.isFinite(s)&&typeof s=="number")){if(n._values.some(s=>s===0))return console.warn("p5.Vector.prototype.div:","divide by 0"),this;this._values=this._values.map((s,i)=>s/n._values[i])}else console.warn("p5.Vector.prototype.div:","vector contains components that are either undefined or not finite numbers");return this}if(t.length===1&&Array.isArray(t[0])){const n=t[0];if(n.every(s=>Number.isFinite(s)&&typeof s=="number")){if(n.some(s=>s===0))return console.warn("p5.Vector.prototype.div:","divide by 0"),this;this._values=this._values.map((s,i)=>s/n[i])}else console.warn("p5.Vector.prototype.div:","array contains components that are either undefined or not finite numbers");return this}if(t.every(n=>Number.isFinite(n)&&typeof n=="number")){if(t.some(n=>n===0))return console.warn("p5.Vector.prototype.div:","divide by 0"),this;this._values=this._values.map((n,s)=>n/t[0])}else console.warn("p5.Vector.prototype.div:","arguments contain components that are either undefined or not finite numbers");return this}mag(){return Math.sqrt(this.magSq())}magSq(){return this._values.reduce((t,n)=>t+n*n,0)}dot(...t){return t[0]instanceof De?this.dot(...t[0]._values):this._values.reduce((n,s,i)=>n+s*(t[i]||0),0)}cross(t){const n=this.y*t.z-this.z*t.y,s=this.z*t.x-this.x*t.z,i=this.x*t.y-this.y*t.x;return this.isPInst?new De(this._fromRadians,this._toRadians,n,s,i):new De(n,s,i)}dist(t){return t.copy().sub(this).mag()}normalize(){const t=this.mag();return t!==0&&this.mult(1/t),this}limit(t){const n=this.magSq();return n>t*t&&this.div(Math.sqrt(n)).mult(t),this}setMag(t){return this.normalize().mult(t)}heading(){const t=Math.atan2(this.y,this.x);return this.isPInst?this._fromRadians(t):t}setHeading(t){this.isPInst&&(t=this._toRadians(t));let n=this.mag();return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this}rotate(t){let n=this.heading()+t;this.isPInst&&(n=this._toRadians(n));const s=this.mag();return this.x=Math.cos(n)*s,this.y=Math.sin(n)*s,this}angleBetween(t){if(this.magSq()*t.magSq()===0)return NaN;const s=this.cross(t);let i=Math.atan2(s.mag(),this.dot(t))*Math.sign(s.z||1);return this.isPInst&&(i=this._fromRadians(i)),i}lerp(t,n,s,i){return t instanceof De?this.lerp(t.x,t.y,t.z,n):(this.x+=(t-this.x)*i||0,this.y+=(n-this.y)*i||0,this.z+=(s-this.z)*i||0,this)}slerp(t,n){if(n===0)return this;if(n===1)return this.set(t);const s=this.mag(),i=t.mag();if(s*i===0)return this.mult(1-n).add(t.x*n,t.y*n,t.z*n),this;const o=this.cross(t),u=o.mag(),l=Math.atan2(u,this.dot(t));if(u>0)o.x/=u,o.y/=u,o.z/=u;else{if(l<Math.PI*.5)return this.mult(1-n).add(t.x*n,t.y*n,t.z*n),this;this.z===0&&t.z===0?o.set(0,0,1):this.x!==0?o.set(this.y,-this.x,0).normalize():o.set(1,0,0)}const c=o.cross(this),h=1-n+n*i/s,d=h*Math.cos(n*l),p=h*Math.sin(n*l);return this.x=this.x*d+c.x*p,this.y=this.y*d+c.y*p,this.z=this.z*d+c.z*p,this}reflect(t){const n=De.normalize(t);return this.sub(n.mult(2*this.dot(n)))}array(){return[this.x||0,this.y||0,this.z||0]}equals(...t){let n;t[0]instanceof De?n=t[0]._values:Array.isArray(t[0])?n=t[0]:n=t;for(let s=0;s<this._values.length;s++)if(this._values[s]!==(n[s]||0))return!1;return!0}clampToZero(){for(let t=0;t<this._values.length;t++)this._values[t]=this._clampToZero(this._values[t]);return this}_clampToZero(t){return Math.abs((t||0)-0)<=Number.EPSILON?0:t}static fromAngle(t,n){return typeof n>"u"&&(n=1),new De(n*Math.cos(t),n*Math.sin(t),0)}static fromAngles(t,n,s){typeof s>"u"&&(s=1);const i=Math.cos(n),a=Math.sin(n),o=Math.cos(t),u=Math.sin(t);return new De(s*u*a,-s*o,s*u*i)}static random2D(){return this.fromAngle(Math.random()*bi)}static random3D(){const t=Math.random()*bi,n=Math.random()*2-1,s=Math.sqrt(1-n*n),i=s*Math.cos(t),a=s*Math.sin(t);return new De(i,a,n)}static copy(t){return t.copy(t)}static add(t,n,s){return s?s.set(t):(s=t.copy(),arguments.length===3&&p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector","p5.Vector.add")),s.add(n),s}static rem(t,n){if(t instanceof De&&n instanceof De){let s=t.copy();return s.rem(n),s}}static sub(t,n,s){return s?s.set(t):(s=t.copy(),arguments.length===3&&p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector","p5.Vector.sub")),s.sub(n),s}static mult(t,n,s){return s?s.set(t):(s=t.copy(),arguments.length===3&&p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector","p5.Vector.mult")),s.mult(n),s}static rotate(t,n,s){return arguments.length===2?s=t.copy():(s instanceof De||p5._friendlyError("The target parameter should be of type p5.Vector","p5.Vector.rotate"),s.set(t)),s.rotate(n),s}static div(t,n,s){return s?s.set(t):(s=t.copy(),arguments.length===3&&p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector","p5.Vector.div")),s.div(n),s}static dot(t,n){return t.dot(n)}static cross(t,n){return t.cross(n)}static dist(t,n){return t.dist(n)}static lerp(t,n,s,i){return i?i.set(t):(i=t.copy(),arguments.length===4&&p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector","p5.Vector.lerp")),i.lerp(n,s),i}static slerp(t,n,s,i){return i?i.set(t):(i=t.copy(),arguments.length===4&&p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector","p5.Vector.slerp")),i.slerp(n,s),i}static mag(t){return t.mag()}static magSq(t){return t.magSq()}static normalize(t,n){return arguments.length<2?n=t.copy():(n instanceof De||p5._friendlyError("The target parameter should be of type p5.Vector","p5.Vector.normalize"),n.set(t)),n.normalize()}static limit(t,n,s){return arguments.length<3?s=t.copy():(s instanceof De||p5._friendlyError("The target parameter should be of type p5.Vector","p5.Vector.limit"),s.set(t)),s.limit(n)}static setMag(t,n,s){return arguments.length<3?s=t.copy():(s instanceof De||p5._friendlyError("The target parameter should be of type p5.Vector","p5.Vector.setMag"),s.set(t)),s.setMag(n)}static heading(t){return t.heading()}static angleBetween(t,n){return t.angleBetween(n)}static reflect(t,n,s){return arguments.length<3?s=t.copy():(s instanceof De||p5._friendlyError("The target parameter should be of type p5.Vector","p5.Vector.reflect"),s.set(t)),s.reflect(n)}static array(t){return t.array()}static equals(t,n){let s;return t instanceof De?s=t:t instanceof Array?s=new De().set(t):p5._friendlyError("The v1 parameter should be of type Array or p5.Vector","p5.Vector.equals"),s.equals(n)}}function yU(r,t){r.Vector=De}typeof p5<"u"&&yU(p5,p5.prototype);function bU(r,t){const n=[Yz,Zz,Jz,Qz,eU,tU];t._frameRate=0,t._lastFrameTime=window.performance.now(),t._targetFrameRate=60;const s=window.print;let i=!1;t.print=function(...c){c.length?console.log(...c):i||(s(),window.confirm("You just tried to print the webpage. Do you want to prevent this from running again?")&&(i=!0))},t.frameCount=0,t.deltaTime=0,t.focused=document.hasFocus(),t.cursor=function(c,h,d){let p="auto";const f=this._curElement.elt;if(n.includes(c))p=c;else if(typeof c=="string"){let m="";h&&d&&typeof h=="number"&&typeof d=="number"&&(m=`${h} ${d}`),c.substring(0,7)==="http://"||c.substring(0,8)==="https://"?p=`url(${c}) ${m}, auto`:/\.(cur|jpg|jpeg|gif|png|CUR|JPG|JPEG|GIF|PNG)$/.test(c)?p=`url(${c}) ${m}, auto`:p=c}f.style.cursor=p},t.frameRate=function(c){return typeof c!="number"||c<0?this._frameRate:(this._targetFrameRate=c,c===0&&(this._frameRate=c),this)},t.getFrameRate=function(){return this.frameRate()},t.setFrameRate=function(c){return this.frameRate(c)},t.getTargetFrameRate=function(){return this._targetFrameRate},t.noCursor=function(){this._curElement.elt.style.cursor="none"},t.webglVersion=Vh,t.displayWidth=screen.width,t.displayHeight=screen.height,t.windowWidth=0,t.windowHeight=0,t._onresize=function(c){this.windowWidth=a(),this.windowHeight=o();const h=this._isGlobal?window:this;let d;typeof h.windowResized=="function"&&(d=h.windowResized(c),d!==void 0&&!d&&c.preventDefault())};function a(){return window.innerWidth||document.documentElement&&document.documentElement.clientWidth||document.body&&document.body.clientWidth||0}function o(){return window.innerHeight||document.documentElement&&document.documentElement.clientHeight||document.body&&document.body.clientHeight||0}t._updateWindowSize=function(){this.windowWidth=a(),this.windowHeight=o()},Object.defineProperty(t,"width",{get(){return this._renderer.width}}),Object.defineProperty(t,"height",{get(){return this._renderer.height}}),t.fullscreen=function(c){if(typeof c>"u")return document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.msFullscreenElement;c?u(document.documentElement):l()},t.pixelDensity=function(c){let h;return typeof c=="number"?(c!==this._renderer._pixelDensity&&(this._renderer._pixelDensity=c),h=this,this.resizeCanvas(this.width,this.height,!0)):h=this._renderer._pixelDensity,h},t.displayDensity=()=>window.devicePixelRatio;function u(c){if(!(document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullScreenEnabled||document.msFullscreenEnabled))throw new Error("Fullscreen not enabled in this browser.");c.requestFullscreen?c.requestFullscreen():c.mozRequestFullScreen?c.mozRequestFullScreen():c.webkitRequestFullscreen?c.webkitRequestFullscreen():c.msRequestFullscreen&&c.msRequestFullscreen()}function l(){document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen?document.webkitExitFullscreen():document.msExitFullscreen&&document.msExitFullscreen()}t.getURL=()=>location.href,t.getURLPath=()=>location.pathname.split("/").filter(c=>c!==""),t.getURLParams=function(){const c=/[?&]([^&=]+)(?:[&=])([^&=]+)/gim;let h;const d={};for(;(h=c.exec(location.search))!=null;)h.index===c.lastIndex&&c.lastIndex++,d[h[1]]=h[2];return d},t.worldToScreen=function(c){return typeof c=="number"&&(c=this.createVector(...arguments)),this._renderer.getWorldToScreenMatrix().multiplyAndNormalizePoint(c)},t.screenToWorld=function(c){typeof c=="number"&&(c=this.createVector(...arguments));const h=this._renderer.getWorldToScreenMatrix();if(c.dimensions==2){let f=h.mat4[14]/h.mat4[15];c=this.createVector(c.x,c.y,f)}return h.invert(h).multiplyAndNormalizePoint(c)}}typeof p5<"u"&&bU(p5,p5.prototype);function xs(r,t){let n=r.length;Array.isArray(r[0])||(r=[r]),Array.isArray(t[0])||(t=t.map(o=>[o]));let s=t[0].length,i=t[0].map((o,u)=>t.map(l=>l[u])),a=r.map(o=>i.map(u=>{let l=0;if(!Array.isArray(o)){for(let c of u)l+=o*c;return l}for(let c=0;c<o.length;c++)l+=o[c]*(u[c]||0);return l}));return n===1&&(a=a[0]),s===1?a.map(o=>o[0]):a}function xU(r){return nm(r)==="string"}function nm(r){return(Object.prototype.toString.call(r).match(/^\[object\s+(.*?)\]$/)[1]||"").toLowerCase()}function BI(r,{precision:t,unit:n}){return VI(r)?"none":zse(r,t)+(n??"")}function VI(r){return Number.isNaN(r)||r instanceof Number&&(r==null?void 0:r.none)}function zse(r,t){if(r===0)return 0;let n=~~r,s=0;n&&t&&(s=~~Math.log10(Math.abs(n))+1);const i=10**(t-s);return Math.floor(r*i+.5)/i}const Use={deg:1,grad:.9,rad:180/Math.PI,turn:360};function Wse(r){if(!r)return;r=r.trim();const t=/^([a-z]+)\((.+?)\)$/i,n=/^-?[\d.]+$/,s=/%|deg|g?rad|turn$/,i=/\/?\s*(none|[-\w.]+(?:%|deg|g?rad|turn)?)/g;let a=r.match(t);if(a){let o=[];return a[2].replace(i,(u,l)=>{let c=l.match(s),h=l;if(c){let d=c[0],p=h.slice(0,-d.length);d==="%"?(h=new Number(p/100),h.type="<percentage>"):(h=new Number(p*Use[d]),h.type="<angle>",h.unit=d)}else n.test(h)?(h=new Number(h),h.type="<number>"):h==="none"&&(h=new Number(NaN),h.none=!0);u.startsWith("/")&&(h=h instanceof Number?h:new Number(h),h.alpha=!0),typeof h=="object"&&h instanceof Number&&(h.raw=l),o.push(h)}),{name:a[1].toLowerCase(),rawName:a[1],rawArgs:a[2],args:o}}}function Gse(r){return r[r.length-1]}function Vw(r,t,n){return isNaN(r)?t:isNaN(t)?r:r+(t-r)*n}function Hse(r,t,n){return(n-r)/(t-r)}function vU(r,t,n){return Vw(t[0],t[1],Hse(r[0],r[1],n))}function jse(r){return r.map(t=>t.split("|").map(n=>{n=n.trim();let s=n.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);if(s){let i=new String(s[1]);return i.range=[+s[2],+s[3]],i}return n}))}function qse(r,t,n){return Math.max(Math.min(n,t),r)}function ET(r,t){return Math.sign(r)===Math.sign(t)?r:-r}function Hu(r,t){return ET(Math.abs(r)**t,r)}function wU(r,t){return t===0?0:r/t}function Kse(r,t,n=0,s=r.length){for(;n<s;){const i=n+s>>1;r[i]<t?n=i+1:s=i}return n}class Xse{add(t,n,s){if(typeof arguments[0]!="string"){for(var t in arguments[0])this.add(t,arguments[0][t],arguments[1]);return}(Array.isArray(t)?t:[t]).forEach(function(i){this[i]=this[i]||[],n&&this[i][s?"unshift":"push"](n)},this)}run(t,n){this[t]=this[t]||[],this[t].forEach(function(s){s.call(n&&n.context?n.context:n,n)})}}const zw=new Xse,ju={D50:[.3457/.3585,1,(1-.3457-.3585)/.3585],D65:[.3127/.329,1,(1-.3127-.329)/.329]};function zI(r){return Array.isArray(r)?r:ju[r]}function Uw(r,t,n,s={}){if(r=zI(r),t=zI(t),!r||!t)throw new TypeError(`Missing white point to convert ${r?"":"from"}${!r&&!t?"/":""}${t?"":"to"}`);if(r===t)return n;let i={W1:r,W2:t,XYZ:n,options:s};if(zw.run("chromatic-adaptation-start",i),i.M||(i.W1===ju.D65&&i.W2===ju.D50?i.M=[[1.0479297925449969,.022946870601609652,-.05019226628920524],[.02962780877005599,.9904344267538799,-.017073799063418826],[-.009243040646204504,.015055191490298152,.7518742814281371]]:i.W1===ju.D50&&i.W2===ju.D65&&(i.M=[[.955473421488075,-.02309845494876471,.06325924320057072],[-.0283697093338637,1.0099953980813041,.021041441191917323],[.012314014864481998,-.020507649298898964,1.330365926242124]])),zw.run("chromatic-adaptation-end",i),i.M)return xs(i.M,i.XYZ);throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.")}var jz,qz,Kz;const Gh={gamut_mapping:"css",precision:5,deltaE:"76",verbose:((Kz=(qz=(jz=globalThis==null?void 0:globalThis.process)==null?void 0:jz.env)==null?void 0:qz.NODE_ENV)==null?void 0:Kz.toLowerCase())!=="test",warn:function(t){var n,s;this.verbose&&((s=(n=globalThis==null?void 0:globalThis.console)==null?void 0:n.warn)==null||s.call(n,t))}},Yse=new Set(["<number>","<percentage>","<angle>"]);function lP(r,t,n,s){return Object.entries(r.coords).map(([a,o],u)=>{let l=t.coordGrammar[u],c=s[u],h=c==null?void 0:c.type,d;if(c.none?d=l.find(m=>Yse.has(m)):d=l.find(m=>m==h),!d){let m=o.name||a;throw new TypeError(`${h??c.raw} not allowed for ${m} in ${n}()`)}let p=d.range;h==="<percentage>"&&(p||(p=[0,1]));let f=o.range||o.refRange;return p&&f&&(s[u]=vU(p,f,s[u])),d})}function SU(r,{meta:t}={}){var s,i,a,o;let n={str:(s=String(r))==null?void 0:s.trim()};if(zw.run("parse-start",n),n.color)return n.color;if(n.parsed=Wse(n.str),n.parsed){let u=n.parsed.name;if(u==="color"){let l=n.parsed.args.shift(),c=l.startsWith("--")?l.substring(2):`--${l}`,h=[l,c],d=n.parsed.rawArgs.indexOf("/")>0?n.parsed.args.pop():1;for(let m of or.all){let g=m.getFormat("color");if(g&&(h.includes(g.id)||(i=g.ids)!=null&&i.filter(y=>h.includes(y)).length)){const y=Object.keys(m.coords).map((x,w)=>n.parsed.args[w]||0);let b;return g.coordGrammar&&(b=lP(m,g,"color",y)),t&&Object.assign(t,{formatId:"color",types:b}),g.id.startsWith("--")&&!l.startsWith("--")&&Gh.warn(`${m.name} is a non-standard space and not currently supported in the CSS spec. Use prefixed color(${g.id}) instead of color(${l}).`),l.startsWith("--")&&!g.id.startsWith("--")&&Gh.warn(`${m.name} is a standard space and supported in the CSS spec. Use color(${g.id}) instead of prefixed color(${l}).`),{spaceId:m.id,coords:y,alpha:d}}}let p="",f=l in or.registry?l:c;if(f in or.registry){let m=(o=(a=or.registry[f].formats)==null?void 0:a.color)==null?void 0:o.id;m&&(p=`Did you mean color(${m})?`)}throw new TypeError(`Cannot parse color(${l}). `+(p||"Missing a plugin?"))}else for(let l of or.all){let c=l.getFormat(u);if(c&&c.type==="function"){let h=1;(c.lastAlpha||Gse(n.parsed.args).alpha)&&(h=n.parsed.args.pop());let d=n.parsed.args,p;return c.coordGrammar&&(p=lP(l,c,u,d)),t&&Object.assign(t,{formatId:c.name,types:p}),{spaceId:l.id,coords:d,alpha:h}}}}else for(let u of or.all)for(let l in u.formats){let c=u.formats[l];if(c.type!=="custom"||c.test&&!c.test(n.str))continue;let h=c.parse(n.str);if(h)return h.alpha??(h.alpha=1),t&&(t.formatId=l),h}throw new TypeError(`Could not parse ${r} as a color. Missing a plugin?`)}function us(r){if(Array.isArray(r))return r.map(us);if(!r)throw new TypeError("Empty color reference");xU(r)&&(r=SU(r));let t=r.space||r.spaceId;return t instanceof or||(r.space=or.get(t)),r.alpha===void 0&&(r.alpha=1),r}const Zse=75e-6,Wi=class Wi{constructor(t){var i;this.id=t.id,this.name=t.name,this.base=t.base?Wi.get(t.base):null,this.aliases=t.aliases,this.base&&(this.fromBase=t.fromBase,this.toBase=t.toBase);let n=t.coords??this.base.coords;for(let a in n)"name"in n[a]||(n[a].name=a);this.coords=n;let s=t.white??this.base.white??"D65";this.white=zI(s),this.formats=t.formats??{};for(let a in this.formats){let o=this.formats[a];o.type||(o.type="function"),o.name||(o.name=a)}(i=this.formats.color)!=null&&i.id||(this.formats.color={...this.formats.color??{},id:t.cssId||this.id}),t.gamutSpace?this.gamutSpace=t.gamutSpace==="self"?this:Wi.get(t.gamutSpace):this.isPolar?this.gamutSpace=this.base:this.gamutSpace=this,this.gamutSpace.isUnbounded&&(this.inGamut=(a,o)=>!0),this.referred=t.referred,Object.defineProperty(this,"path",{value:Jse(this).reverse(),writable:!1,enumerable:!0,configurable:!0}),zw.run("colorspace-init-end",this)}inGamut(t,{epsilon:n=Zse}={}){if(!this.equals(this.gamutSpace))return t=this.to(this.gamutSpace,t),this.gamutSpace.inGamut(t,{epsilon:n});let s=Object.values(this.coords);return t.every((i,a)=>{let o=s[a];if(o.type!=="angle"&&o.range){if(Number.isNaN(i))return!0;let[u,l]=o.range;return(u===void 0||i>=u-n)&&(l===void 0||i<=l+n)}return!0})}get isUnbounded(){return Object.values(this.coords).every(t=>!("range"in t))}get cssId(){var t,n;return((n=(t=this.formats)==null?void 0:t.color)==null?void 0:n.id)||this.id}get isPolar(){for(let t in this.coords)if(this.coords[t].type==="angle")return!0;return!1}getFormat(t){if(typeof t=="object")return t=cP(t,this),t;let n;return t==="default"?n=Object.values(this.formats)[0]:n=this.formats[t],n?(n=cP(n,this),n):null}equals(t){return t?this===t||this.id===t||this.id===t.id:!1}to(t,n){if(arguments.length===1){const u=us(t);[t,n]=[u.space,u.coords]}if(t=Wi.get(t),this.equals(t))return n;n=n.map(u=>Number.isNaN(u)?0:u);let s=this.path,i=t.path,a,o;for(let u=0;u<s.length&&s[u].equals(i[u]);u++)a=s[u],o=u;if(!a)throw new Error(`Cannot convert between color spaces ${this} and ${t}: no connection space was found`);for(let u=s.length-1;u>o;u--)n=s[u].toBase(n);for(let u=o+1;u<i.length;u++)n=i[u].fromBase(n);return n}from(t,n){if(arguments.length===1){const s=us(t);[t,n]=[s.space,s.coords]}return t=Wi.get(t),t.to(this,n)}toString(){return`${this.name} (${this.id})`}getMinCoords(){let t=[];for(let n in this.coords){let s=this.coords[n],i=s.range||s.refRange;t.push((i==null?void 0:i.min)??0)}return t}static get all(){return[...new Set(Object.values(Wi.registry))]}static register(t,n){if(arguments.length===1&&(n=arguments[0],t=n.id),n=this.get(n),this.registry[t]&&this.registry[t]!==n)throw new Error(`Duplicate color space registration: '${t}'`);if(this.registry[t]=n,arguments.length===1&&n.aliases)for(let s of n.aliases)this.register(s,n);return n}static get(t,...n){if(!t||t instanceof Wi)return t;if(nm(t)==="string"){let i=Wi.registry[t.toLowerCase()];if(!i)throw new TypeError(`No color space found with id = "${t}"`);return i}if(n.length)return Wi.get(...n);throw new TypeError(`${t} is not a valid color space`)}static resolveCoord(t,n){var l;let s=nm(t),i,a;if(s==="string"?t.includes(".")?[i,a]=t.split("."):[i,a]=[,t]:Array.isArray(t)?[i,a]=t:(i=t.space,a=t.coordId),i=Wi.get(i),i||(i=n),!i)throw new TypeError(`Cannot resolve coordinate reference ${t}: No color space specified and relative references are not allowed here`);if(s=nm(a),s==="number"||s==="string"&&a>=0){let c=Object.entries(i.coords)[a];if(c)return{space:i,id:c[0],index:a,...c[1]}}i=Wi.get(i);let o=a.toLowerCase(),u=0;for(let c in i.coords){let h=i.coords[c];if(c.toLowerCase()===o||((l=h.name)==null?void 0:l.toLowerCase())===o)return{space:i,id:c,index:u,...h};u++}throw new TypeError(`No "${a}" coordinate found in ${i.name}. Its coordinates are: ${Object.keys(i.coords).join(", ")}`)}};Ar(Wi,"registry",{}),Ar(Wi,"DEFAULT_FORMAT",{type:"functions",name:"color"});let or=Wi;function Jse(r){let t=[r];for(let n=r;n=n.base;)t.push(n);return t}function cP(r,{coords:t}={}){if(r.coords&&!r.coordGrammar){r.type||(r.type="function"),r.name||(r.name="color"),r.coordGrammar=jse(r.coords);let n=Object.entries(t).map(([s,i],a)=>{let o=r.coordGrammar[a][0],u=i.range||i.refRange,l=o.range,c="";return o=="<percentage>"?(l=[0,100],c="%"):o=="<angle>"&&(c="deg"),{fromRange:u,toRange:l,suffix:c}});r.serializeCoords=(s,i)=>s.map((a,o)=>{let{fromRange:u,toRange:l,suffix:c}=n[o];return u&&l&&(a=vU(u,l,a)),a=BI(a,{precision:i,unit:c}),a})}return r}const ec=new or({id:"xyz-d65",name:"XYZ D65",coords:{x:{name:"X"},y:{name:"Y"},z:{name:"Z"}},white:"D65",formats:{color:{ids:["xyz-d65","xyz"]}},aliases:["xyz"]});class OS extends or{constructor(t){t.coords||(t.coords={r:{range:[0,1],name:"Red"},g:{range:[0,1],name:"Green"},b:{range:[0,1],name:"Blue"}}),t.base||(t.base=ec),t.toXYZ_M&&t.fromXYZ_M&&(t.toBase??(t.toBase=n=>{let s=xs(t.toXYZ_M,n);return this.white!==this.base.white&&(s=Uw(this.white,this.base.white,s)),s}),t.fromBase??(t.fromBase=n=>(n=Uw(this.base.white,this.white,n),xs(t.fromXYZ_M,n)))),t.referred??(t.referred="display"),super(t)}}function CU(r,t){return r=us(r),!t||r.space.equals(t)?r.coords.slice():(t=or.get(t),t.from(r))}function Nh(r,t){r=us(r);let{space:n,index:s}=or.resolveCoord(t,r.space);return CU(r,n)[s]}function _U(r,t,n){return r=us(r),t=or.get(t),r.coords=t.to(r.space,n),r}_U.returns="color";function ub(r,t,n){if(r=us(r),arguments.length===2&&nm(arguments[1])==="object"){let s=arguments[1];for(let i in s)ub(r,i,s[i])}else{typeof n=="function"&&(n=n(Nh(r,t)));let{space:s,index:i}=or.resolveCoord(t,r.space),a=CU(r,s);a[i]=n,_U(r,s,a)}return r}ub.returns="color";const Qse=new or({id:"xyz-d50",name:"XYZ D50",white:"D50",base:ec,fromBase:r=>Uw(ec.white,"D50",r),toBase:r=>Uw("D50",ec.white,r)}),eie=216/24389,hP=24/116,n1=24389/27;let aE=ju.D50;const So=new or({id:"lab",name:"Lab",coords:{l:{refRange:[0,100],name:"Lightness"},a:{refRange:[-125,125]},b:{refRange:[-125,125]}},white:aE,base:Qse,fromBase(r){let n=r.map((s,i)=>s/aE[i]).map(s=>s>eie?Math.cbrt(s):(n1*s+16)/116);return[116*n[1]-16,500*(n[0]-n[1]),200*(n[1]-n[2])]},toBase(r){let t=[];return t[1]=(r[0]+16)/116,t[0]=r[1]/500+t[1],t[2]=t[1]-r[2]/200,[t[0]>hP?Math.pow(t[0],3):(116*t[0]-16)/n1,r[0]>8?Math.pow((r[0]+16)/116,3):r[0]/n1,t[2]>hP?Math.pow(t[2],3):(116*t[2]-16)/n1].map((s,i)=>s*aE[i])},formats:{lab:{coords:["<number> | <percentage>","<number> | <percentage>[-1,1]","<number> | <percentage>[-1,1]"]}}});function pl(r){return(r%360+360)%360}function tie(r,t){if(r==="raw")return t;let[n,s]=t.map(pl),i=s-n;return r==="increasing"?i<0&&(s+=360):r==="decreasing"?i>0&&(n+=360):r==="longer"?-180<i&&i<180&&(i>0?n+=360:s+=360):r==="shorter"&&(i>180?n+=360:i<-180&&(s+=360)),[n,s]}const Cm=new or({id:"lch",name:"LCH",coords:{l:{refRange:[0,100],name:"Lightness"},c:{refRange:[0,150],name:"Chroma"},h:{refRange:[0,360],type:"angle",name:"Hue"}},base:So,fromBase(r){let[t,n,s]=r,i;const a=.02;return Math.abs(n)<a&&Math.abs(s)<a?i=NaN:i=Math.atan2(s,n)*180/Math.PI,[t,Math.sqrt(n**2+s**2),pl(i)]},toBase(r){let[t,n,s]=r;return n<0&&(n=0),isNaN(s)&&(s=0),[t,n*Math.cos(s*Math.PI/180),n*Math.sin(s*Math.PI/180)]},formats:{lch:{coords:["<number> | <percentage>","<number> | <percentage>","<number> | <angle>"]}}}),dP=25**7,Ww=Math.PI,pP=180/Ww,$f=Ww/180;function fP(r){const t=r*r;return t*t*t*r}function EU(r,t,{kL:n=1,kC:s=1,kH:i=1}={}){[r,t]=us([r,t]);let[a,o,u]=So.from(r),l=Cm.from(So,[a,o,u])[1],[c,h,d]=So.from(t),p=Cm.from(So,[c,h,d])[1];l<0&&(l=0),p<0&&(p=0);let f=(l+p)/2,m=fP(f),g=.5*(1-Math.sqrt(m/(m+dP))),y=(1+g)*o,b=(1+g)*h,x=Math.sqrt(y**2+u**2),w=Math.sqrt(b**2+d**2),v=y===0&&u===0?0:Math.atan2(u,y),S=b===0&&d===0?0:Math.atan2(d,b);v<0&&(v+=2*Ww),S<0&&(S+=2*Ww),v*=pP,S*=pP;let E=c-a,C=w-x,I=S-v,_=v+S,A=Math.abs(I),k;x*w===0?k=0:A<=180?k=I:I>180?k=I-360:I<-180?k=I+360:Gh.warn("the unthinkable has happened");let N=2*Math.sqrt(w*x)*Math.sin(k*$f/2),D=(a+c)/2,F=(x+w)/2,P=fP(F),G;x*w===0?G=_:A<=180?G=_/2:_<360?G=(_+360)/2:G=(_-360)/2;let Y=(D-50)**2,Z=1+.015*Y/Math.sqrt(20+Y),ee=1+.045*F,se=1;se-=.17*Math.cos((G-30)*$f),se+=.24*Math.cos(2*G*$f),se+=.32*Math.cos((3*G+6)*$f),se-=.2*Math.cos((4*G-63)*$f);let re=1+.015*F*se,J=30*Math.exp(-1*((G-275)/25)**2),le=2*Math.sqrt(P/(P+dP)),he=-1*Math.sin(2*J*$f)*le,xe=(E/(n*Z))**2;return xe+=(C/(s*ee))**2,xe+=(N/(i*re))**2,xe+=he*(C/(s*ee))*(N/(i*re)),Math.sqrt(xe)}const rie=[[.819022437996703,.3619062600528904,-.1288737815209879],[.0329836539323885,.9292868615863434,.0361446663506424],[.0481771893596242,.2642395317527308,.6335478284694309]],nie=[[1.2268798758459243,-.5578149944602171,.2813910456659647],[-.0405757452148008,1.112286803280317,-.0717110580655164],[-.0763729366746601,-.4214933324022432,1.5869240198367816]],sie=[[.210454268309314,.7936177747023054,-.0040720430116193],[1.9779985324311684,-2.42859224204858,.450593709617411],[.0259040424655478,.7827717124575296,-.8086757549230774]],iie=[[1,.3963377773761749,.2158037573099136],[1,-.1055613458156586,-.0638541728258133],[1,-.0894841775298119,-1.2914855480194092]],Hh=new or({id:"oklab",name:"Oklab",coords:{l:{refRange:[0,1],name:"Lightness"},a:{refRange:[-.4,.4]},b:{refRange:[-.4,.4]}},white:"D65",base:ec,fromBase(r){let n=xs(rie,r).map(s=>Math.cbrt(s));return xs(sie,n)},toBase(r){let n=xs(iie,r).map(s=>s**3);return xs(nie,n)},formats:{oklab:{coords:["<percentage> | <number>","<number> | <percentage>[-1,1]","<number> | <percentage>[-1,1]"]}}});function UI(r,t){[r,t]=us([r,t]);let[n,s,i]=Hh.from(r),[a,o,u]=Hh.from(t),l=n-a,c=s-o,h=i-u;return Math.sqrt(l**2+c**2+h**2)}const aie=75e-6;function sm(r,t,{epsilon:n=aie}={}){r=us(r),t||(t=r.space),t=or.get(t);let s=r.coords;return t!==r.space&&(s=t.from(r)),t.inGamut(s,{epsilon:n})}function lb(r){return{space:r.space,coords:r.coords.slice(),alpha:r.alpha}}function oie(r,t,n="lab"){n=or.get(n);let s=n.from(r),i=n.from(t);return Math.sqrt(s.reduce((a,o,u)=>{let l=i[u];return isNaN(o)||isNaN(l)?a:a+(l-o)**2},0))}function uie(r,t){return oie(r,t,"lab")}const lie=Math.PI,mP=lie/180;function cie(r,t,{l:n=2,c:s=1}={}){[r,t]=us([r,t]);let[i,a,o]=So.from(r),[,u,l]=Cm.from(So,[i,a,o]),[c,h,d]=So.from(t),p=Cm.from(So,[c,h,d])[1];u<0&&(u=0),p<0&&(p=0);let f=i-c,m=u-p,g=a-h,y=o-d,b=g**2+y**2-m**2,x=.511;i>=16&&(x=.040975*i/(1+.01765*i));let w=.0638*u/(1+.0131*u)+.638,v;Number.isNaN(l)&&(l=0),l>=164&&l<=345?v=.56+Math.abs(.2*Math.cos((l+168)*mP)):v=.36+Math.abs(.4*Math.cos((l+35)*mP));let S=Math.pow(u,4),E=Math.sqrt(S/(S+1900)),C=w*(E*v+1-E),I=(f/(n*x))**2;return I+=(m/(s*w))**2,I+=b/C**2,Math.sqrt(I)}const gP=203,IU=new or({id:"xyz-abs-d65",cssId:"--xyz-abs-d65",name:"Absolute XYZ D65",coords:{x:{refRange:[0,9504.7],name:"Xa"},y:{refRange:[0,1e4],name:"Ya"},z:{refRange:[0,10888.3],name:"Za"}},base:ec,fromBase(r){return r.map(t=>Math.max(t*gP,0))},toBase(r){return r.map(t=>Math.max(t/gP,0))}}),s1=1.15,i1=.66,yP=2610/2**14,hie=2**14/2610,bP=3424/2**12,xP=2413/2**7,vP=2392/2**7,die=1.7*2523/2**5,wP=2**5/(1.7*2523),a1=-.56,oE=16295499532821565e-27,pie=[[.41478972,.579999,.014648],[-.20151,1.120649,.0531008],[-.0166008,.2648,.6684799]],fie=[[1.9242264357876067,-1.0047923125953657,.037651404030618],[.35031676209499907,.7264811939316552,-.06538442294808501],[-.09098281098284752,-.3127282905230739,1.5227665613052603]],mie=[[.5,.5,0],[3.524,-4.066708,.542708],[.199076,1.096799,-1.295875]],gie=[[1,.1386050432715393,.05804731615611886],[.9999999999999999,-.1386050432715393,-.05804731615611886],[.9999999999999998,-.09601924202631895,-.8118918960560388]],yie=new or({id:"jzazbz",name:"Jzazbz",coords:{jz:{refRange:[0,1],name:"Jz"},az:{refRange:[-.5,.5]},bz:{refRange:[-.5,.5]}},base:IU,fromBase(r){let[t,n,s]=r,i=s1*t-(s1-1)*s,a=i1*n-(i1-1)*t,u=xs(pie,[i,a,s]).map(function(p){let f=bP+xP*(p/1e4)**yP,m=1+vP*(p/1e4)**yP;return(f/m)**die}),[l,c,h]=xs(mie,u);return[(1+a1)*l/(1+a1*l)-oE,c,h]},toBase(r){let[t,n,s]=r,i=(t+oE)/(1+a1-a1*(t+oE)),o=xs(gie,[i,n,s]).map(function(p){let f=bP-p**wP,m=vP*p**wP-xP;return 1e4*(f/m)**hie}),[u,l,c]=xs(fie,o),h=(u+(s1-1)*c)/s1,d=(l+(i1-1)*h)/i1;return[h,d,c]},formats:{color:{coords:["<number> | <percentage>","<number> | <percentage>[-1,1]","<number> | <percentage>[-1,1]"]}}}),SP=new or({id:"jzczhz",name:"JzCzHz",coords:{jz:{refRange:[0,1],name:"Jz"},cz:{refRange:[0,1],name:"Chroma"},hz:{refRange:[0,360],type:"angle",name:"Hue"}},base:yie,fromBase(r){let[t,n,s]=r,i;const a=2e-4;return Math.abs(n)<a&&Math.abs(s)<a?i=NaN:i=Math.atan2(s,n)*180/Math.PI,[t,Math.sqrt(n**2+s**2),pl(i)]},toBase(r){return[r[0],r[1]*Math.cos(r[2]*Math.PI/180),r[1]*Math.sin(r[2]*Math.PI/180)]}});function bie(r,t){[r,t]=us([r,t]);let[n,s,i]=SP.from(r),[a,o,u]=SP.from(t),l=n-a,c=s-o;Number.isNaN(i)&&Number.isNaN(u)?(i=0,u=0):Number.isNaN(i)?i=u:Number.isNaN(u)&&(u=i);let h=i-u,d=2*Math.sqrt(s*o)*Math.sin(h/2*(Math.PI/180));return Math.sqrt(l**2+c**2+d**2)}const kU=3424/4096,NU=2413/128,TU=2392/128,CP=2610/16384,xie=2523/32,vie=16384/2610,_P=32/2523,wie=[[.3592832590121217,.6976051147779502,-.035891593232029],[-.1920808463704993,1.100476797037432,.0753748658519118],[.0070797844607479,.0748396662186362,.8433265453898765]],Sie=[[2048/4096,2048/4096,0],[6610/4096,-13613/4096,7003/4096],[17933/4096,-17390/4096,-543/4096]],Cie=[[.9999999999999998,.0086090370379328,.111029625003026],[.9999999999999998,-.0086090370379328,-.1110296250030259],[.9999999999999998,.5600313357106791,-.3206271749873188]],_ie=[[2.0701522183894223,-1.3263473389671563,.2066510476294053],[.3647385209748072,.6805660249472273,-.0453045459220347],[-.0497472075358123,-.0492609666966131,1.1880659249923042]],EP=new or({id:"ictcp",name:"ICTCP",coords:{i:{refRange:[0,1],name:"I"},ct:{refRange:[-.5,.5],name:"CT"},cp:{refRange:[-.5,.5],name:"CP"}},base:IU,fromBase(r){let t=xs(wie,r);return Eie(t)},toBase(r){let t=Iie(r);return xs(_ie,t)}});function Eie(r){let t=r.map(function(n){let s=kU+NU*(n/1e4)**CP,i=1+TU*(n/1e4)**CP;return(s/i)**xie});return xs(Sie,t)}function Iie(r){return xs(Cie,r).map(function(s){let i=Math.max(s**_P-kU,0),a=NU-TU*s**_P;return 1e4*(i/a)**vie})}function kie(r,t){[r,t]=us([r,t]);let[n,s,i]=EP.from(r),[a,o,u]=EP.from(t);return 720*Math.sqrt((n-a)**2+.25*(s-o)**2+(i-u)**2)}const Nie=ju.D65,AU=.42,IP=1/AU,uE=2*Math.PI,DU=[[.401288,.650173,-.051461],[-.250268,1.204414,.045854],[-.002079,.048952,.953127]],Tie=[[1.8620678550872327,-1.0112546305316843,.14918677544445175],[.38752654323613717,.6214474419314753,-.008973985167612518],[-.015841498849333856,-.03412293802851557,1.0499644368778496]],Aie=[[460,451,288],[460,-891,-261],[460,-220,-6300]],Die={dark:[.8,.525,.8],dim:[.9,.59,.9],average:[1,.69,1]},gh={h:[20.14,90,164.25,237.53,380.14],e:[.8,.7,1,1.2,.8],H:[0,100,200,300,400]},Fie=180/Math.PI,kP=Math.PI/180;function FU(r,t){return r.map(s=>{const i=Hu(t*Math.abs(s)*.01,AU);return 400*ET(i,s)/(i+27.13)})}function $ie(r,t){const n=100/t*27.13**IP;return r.map(s=>{const i=Math.abs(s);return ET(n*Hu(i/(400-i),IP),s)})}function Rie(r){let t=pl(r);t<=gh.h[0]&&(t+=360);const n=Kse(gh.h,t)-1,[s,i]=gh.h.slice(n,n+2),[a,o]=gh.e.slice(n,n+2),u=gh.H[n],l=(t-s)/a;return u+100*l/(l+(i-t)/o)}function Oie(r){let t=(r%400+400)%400;const n=Math.floor(.01*t);t=t%100;const[s,i]=gh.h.slice(n,n+2),[a,o]=gh.e.slice(n,n+2);return pl((t*(o*s-a*i)-100*s*o)/(t*(o-a)-100*o))}function $U(r,t,n,s,i){const a={};a.discounting=i,a.refWhite=r,a.surround=s;const o=r.map(g=>g*100);a.la=t,a.yb=n;const u=o[1],l=xs(DU,o);s=Die[a.surround];const c=s[0];a.c=s[1],a.nc=s[2];const d=(1/(5*a.la+1))**4;a.fl=d*a.la+.1*(1-d)*(1-d)*Math.cbrt(5*a.la),a.flRoot=a.fl**.25,a.n=a.yb/u,a.z=1.48+Math.sqrt(a.n),a.nbb=.725*a.n**-.2,a.ncb=a.nbb;const p=Math.max(Math.min(c*(1-1/3.6*Math.exp((-a.la-42)/92)),1),0);a.dRgb=l.map(g=>Vw(1,u/g,p)),a.dRgbInv=a.dRgb.map(g=>1/g);const f=l.map((g,y)=>g*a.dRgb[y]),m=FU(f,a.fl);return a.aW=a.nbb*(2*m[0]+m[1]+.05*m[2]),a}const NP=$U(Nie,64/Math.PI*.2,20,"average",!1);function WI(r,t){if(!(r.J!==void 0^r.Q!==void 0))throw new Error("Conversion requires one and only one: 'J' or 'Q'");if(!(r.C!==void 0^r.M!==void 0^r.s!==void 0))throw new Error("Conversion requires one and only one: 'C', 'M' or 's'");if(!(r.h!==void 0^r.H!==void 0))throw new Error("Conversion requires one and only one: 'h' or 'H'");if(r.J===0||r.Q===0)return[0,0,0];let n=0;r.h!==void 0?n=pl(r.h)*kP:n=Oie(r.H)*kP;const s=Math.cos(n),i=Math.sin(n);let a=0;r.J!==void 0?a=Hu(r.J,1/2)*.1:r.Q!==void 0&&(a=.25*t.c*r.Q/((t.aW+4)*t.flRoot));let o=0;r.C!==void 0?o=r.C/a:r.M!==void 0?o=r.M/t.flRoot/a:r.s!==void 0&&(o=4e-4*r.s**2*(t.aW+4)/t.c);const u=Hu(o*Math.pow(1.64-Math.pow(.29,t.n),-.73),10/9),l=.25*(Math.cos(n+2)+3.8),c=t.aW*Hu(a,2/t.c/t.z),h=5e4/13*t.nc*t.ncb*l,d=c/t.nbb,p=23*(d+.305)*wU(u,23*h+u*(11*s+108*i)),f=p*s,m=p*i,g=$ie(xs(Aie,[d,f,m]).map(y=>y*1/1403),t.fl);return xs(Tie,g.map((y,b)=>y*t.dRgbInv[b])).map(y=>y/100)}function RU(r,t){const n=r.map(w=>w*100),s=FU(xs(DU,n).map((w,v)=>w*t.dRgb[v]),t.fl),i=s[0]+(-12*s[1]+s[2])/11,a=(s[0]+s[1]-2*s[2])/9,o=(Math.atan2(a,i)%uE+uE)%uE,u=.25*(Math.cos(o+2)+3.8),l=5e4/13*t.nc*t.ncb*wU(u*Math.sqrt(i**2+a**2),s[0]+s[1]+1.05*s[2]+.305),c=Hu(l,.9)*Math.pow(1.64-Math.pow(.29,t.n),.73),h=t.nbb*(2*s[0]+s[1]+.05*s[2]),d=Hu(h/t.aW,.5*t.c*t.z),p=100*Hu(d,2),f=4/t.c*d*(t.aW+4)*t.flRoot,m=c*d,g=m*t.flRoot,y=pl(o*Fie),b=Rie(y),x=50*Hu(t.c*c/(t.aW+4),1/2);return{J:p,C:m,h:y,s:x,Q:f,M:g,H:b}}new or({id:"cam16-jmh",cssId:"--cam16-jmh",name:"CAM16-JMh",coords:{j:{refRange:[0,100],name:"J"},m:{refRange:[0,105],name:"Colorfulness"},h:{refRange:[0,360],type:"angle",name:"Hue"}},base:ec,fromBase(r){const t=RU(r,NP);return[t.J,t.M,t.h]},toBase(r){return WI({J:r[0],M:r[1],h:r[2]},NP)}});const Mie=ju.D65,Lie=216/24389,OU=24389/27;function Pie(r){return 116*(r>Lie?Math.cbrt(r):(OU*r+16)/116)-16}function GI(r){return r>8?Math.pow((r+16)/116,3):r/OU}function Bie(r,t){let[n,s,i]=r,a=[],o=0;if(i===0)return[0,0,0];let u=GI(i);i>0?o=.00379058511492914*i**2+.608983189401032*i+.9155088574762233:o=9514440756550361e-21*i**2+.08693057439788597*i-21.928975842194614;const l=2e-12,c=15;let h=0,d=1/0;for(;h<=c;){a=WI({J:o,C:s,h:n},t);const p=Math.abs(a[1]-u);if(p<d){if(p<=l)return a;d=p}o=o-(a[1]-u)*o/(2*a[1]),h+=1}return WI({J:o,C:s,h:n},t)}function Vie(r,t){const n=Pie(r[1]);if(n===0)return[0,0,0];const s=RU(r,IT);return[pl(s.h),s.C,n]}const IT=$U(Mie,200/Math.PI*GI(50),GI(50)*100,"average",!1),Gw=new or({id:"hct",name:"HCT",coords:{h:{refRange:[0,360],type:"angle",name:"Hue"},c:{refRange:[0,145],name:"Colorfulness"},t:{refRange:[0,100],name:"Tone"}},base:ec,fromBase(r){return Vie(r)},toBase(r){return Bie(r,IT)},formats:{color:{id:"--hct",coords:["<number> | <angle>","<percentage> | <number>","<percentage> | <number>"]}}}),zie=Math.PI/180,TP=[1,.007,.0228];function AP(r){r[1]<0&&(r=Gw.fromBase(Gw.toBase(r)));const t=Math.log(Math.max(1+TP[2]*r[1]*IT.flRoot,1))/TP[2],n=r[0]*zie,s=t*Math.cos(n),i=t*Math.sin(n);return[r[2],s,i]}function Uie(r,t){[r,t]=us([r,t]);let[n,s,i]=AP(Gw.from(r)),[a,o,u]=AP(Gw.from(t));return Math.sqrt((n-a)**2+(s-o)**2+(i-u)**2)}const DP={deltaE76:uie,deltaECMC:cie,deltaE2000:EU,deltaEJz:bie,deltaEITP:kie,deltaEOK:UI,deltaEHCT:Uie};function Wie(r){const t=r?Math.floor(Math.log10(Math.abs(r))):0;return Math.max(parseFloat(`1e${t-2}`),1e-6)}const FP={hct:{method:"hct.c",jnd:2,deltaEMethod:"hct",blackWhiteClamp:{}},"hct-tonal":{method:"hct.c",jnd:0,deltaEMethod:"hct",blackWhiteClamp:{channel:"hct.t",min:0,max:100}}};function jh(r,{method:t=Gh.gamut_mapping,space:n=void 0,deltaEMethod:s="",jnd:i=2,blackWhiteClamp:a={}}={}){if(r=us(r),xU(arguments[1])?n=arguments[1]:n||(n=r.space),n=or.get(n),sm(r,n,{epsilon:0}))return r;let o;if(t==="css")o=Gie(r,{space:n});else{if(t!=="clip"&&!sm(r,n)){Object.prototype.hasOwnProperty.call(FP,t)&&({method:t,jnd:i,deltaEMethod:s,blackWhiteClamp:a}=FP[t]);let u=EU;if(s!==""){for(let c in DP)if("deltae"+s.toLowerCase()===c.toLowerCase()){u=DP[c];break}}let l=jh(wr(r,n),{method:"clip",space:n});if(u(r,l)>i){if(Object.keys(a).length===3){let x=or.resolveCoord(a.channel),w=Nh(wr(r,x.space),x.id);if(VI(w)&&(w=0),w>=a.max)return wr({space:"xyz-d65",coords:ju.D65},r.space);if(w<=a.min)return wr({space:"xyz-d65",coords:[0,0,0]},r.space)}let c=or.resolveCoord(t),h=c.space,d=c.id,p=wr(r,h);p.coords.forEach((x,w)=>{VI(x)&&(p.coords[w]=0)});let m=(c.range||c.refRange)[0],g=Wie(i),y=m,b=Nh(p,d);for(;b-y>g;){let x=lb(p);x=jh(x,{space:n,method:"clip"}),u(p,x)-i<g?y=Nh(p,d):b=Nh(p,d),ub(p,d,(y+b)/2)}o=wr(p,n)}else o=l}else o=wr(r,n);if(t==="clip"||!sm(o,n,{epsilon:0})){let u=Object.values(n.coords).map(l=>l.range||[]);o.coords=o.coords.map((l,c)=>{let[h,d]=u[c];return h!==void 0&&(l=Math.max(h,l)),d!==void 0&&(l=Math.min(l,d)),l})}}return n!==r.space&&(o=wr(o,r.space)),r.coords=o.coords,r}jh.returns="color";const $P={WHITE:{space:Hh,coords:[1,0,0]},BLACK:{space:Hh,coords:[0,0,0]}};function Gie(r,{space:t}={}){r=us(r),t||(t=r.space),t=or.get(t);const i=or.get("oklch");if(t.isUnbounded)return wr(r,t);const a=wr(r,i);let o=a.coords[0];if(o>=1){const m=wr($P.WHITE,t);return m.alpha=r.alpha,wr(m,t)}if(o<=0){const m=wr($P.BLACK,t);return m.alpha=r.alpha,wr(m,t)}if(sm(a,t,{epsilon:0}))return wr(a,t);function u(m){const g=wr(m,t),y=Object.values(t.coords);return g.coords=g.coords.map((b,x)=>{if("range"in y[x]){const[w,v]=y[x].range;return qse(w,b,v)}return b}),g}let l=0,c=a.coords[1],h=!0,d=lb(a),p=u(d),f=UI(p,d);if(f<.02)return p;for(;c-l>1e-4;){const m=(l+c)/2;if(d.coords[1]=m,h&&sm(d,t,{epsilon:0}))l=m;else if(p=u(d),f=UI(p,d),f<.02){if(.02-f<1e-4)break;h=!1,l=m}else c=m}return p}function wr(r,t,{inGamut:n}={}){r=us(r),t=or.get(t);let s=t.from(r),i={space:t,coords:s,alpha:r.alpha};return n&&(i=jh(i,n===!0?void 0:n)),i}wr.returns="color";function Hie(r,{precision:t=Gh.precision,format:n="default",inGamut:s=!0,...i}={}){var l;let a;r=us(r);let o=n;n=r.space.getFormat(n)??r.space.getFormat("default")??or.DEFAULT_FORMAT;let u=r.coords.slice();if(s||(s=n.toGamut),s&&!sm(r)&&(u=jh(lb(r),s===!0?void 0:s).coords),n.type==="custom")if(i.precision=t,n.serialize)a=n.serialize(u,r.alpha,i);else throw new TypeError(`format ${o} can only be used to parse colors, not for serialization`);else{let c=n.name||"color";n.serializeCoords?u=n.serializeCoords(u,t):t!==null&&(u=u.map(f=>BI(f,{precision:t})));let h=[...u];if(c==="color"){let f=n.id||((l=n.ids)==null?void 0:l[0])||r.space.id;h.unshift(f)}let d=r.alpha;t!==null&&(d=BI(d,{precision:t}));let p=r.alpha>=1||n.noAlpha?"":`${n.commas?",":" /"} ${d}`;a=`${c}(${h.join(n.commas?", ":" ")}${p})`}return a}const jie=[[.4865709486482162,.26566769316909306,.1982172852343625],[.2289745640697488,.6917385218365064,.079286914093745],[0,.04511338185890264,1.043944368900976]],qie=[[2.493496911941425,-.9313836179191239,-.40271078445071684],[-.8294889695615747,1.7626640603183463,.023624685841943577],[.03584583024378447,-.07617238926804182,.9568845240076872]],Kie=new OS({id:"p3-linear",cssId:"--display-p3-linear",name:"Linear P3",white:"D65",toXYZ_M:jie,fromXYZ_M:qie}),Xie=[[.41239079926595934,.357584339383878,.1804807884018343],[.21263900587151027,.715168678767756,.07219231536073371],[.01933081871559182,.11919477979462598,.9505321522496607]],Yie=[[3.2409699419045226,-1.537383177570094,-.4986107602930034],[-.9692436362808796,1.8759675015077202,.04155505740717559],[.05563007969699366,-.20397695888897652,1.0569715142428786]],Zie=new OS({id:"srgb-linear",name:"Linear sRGB",white:"D65",toXYZ_M:Xie,fromXYZ_M:Yie}),RP={aliceblue:[240/255,248/255,1],antiquewhite:[250/255,235/255,215/255],aqua:[0,1,1],aquamarine:[127/255,1,212/255],azure:[240/255,1,1],beige:[245/255,245/255,220/255],bisque:[1,228/255,196/255],black:[0,0,0],blanchedalmond:[1,235/255,205/255],blue:[0,0,1],blueviolet:[138/255,43/255,226/255],brown:[165/255,42/255,42/255],burlywood:[222/255,184/255,135/255],cadetblue:[95/255,158/255,160/255],chartreuse:[127/255,1,0],chocolate:[210/255,105/255,30/255],coral:[1,127/255,80/255],cornflowerblue:[100/255,149/255,237/255],cornsilk:[1,248/255,220/255],crimson:[220/255,20/255,60/255],cyan:[0,1,1],darkblue:[0,0,139/255],darkcyan:[0,139/255,139/255],darkgoldenrod:[184/255,134/255,11/255],darkgray:[169/255,169/255,169/255],darkgreen:[0,100/255,0],darkgrey:[169/255,169/255,169/255],darkkhaki:[189/255,183/255,107/255],darkmagenta:[139/255,0,139/255],darkolivegreen:[85/255,107/255,47/255],darkorange:[1,140/255,0],darkorchid:[153/255,50/255,204/255],darkred:[139/255,0,0],darksalmon:[233/255,150/255,122/255],darkseagreen:[143/255,188/255,143/255],darkslateblue:[72/255,61/255,139/255],darkslategray:[47/255,79/255,79/255],darkslategrey:[47/255,79/255,79/255],darkturquoise:[0,206/255,209/255],darkviolet:[148/255,0,211/255],deeppink:[1,20/255,147/255],deepskyblue:[0,191/255,1],dimgray:[105/255,105/255,105/255],dimgrey:[105/255,105/255,105/255],dodgerblue:[30/255,144/255,1],firebrick:[178/255,34/255,34/255],floralwhite:[1,250/255,240/255],forestgreen:[34/255,139/255,34/255],fuchsia:[1,0,1],gainsboro:[220/255,220/255,220/255],ghostwhite:[248/255,248/255,1],gold:[1,215/255,0],goldenrod:[218/255,165/255,32/255],gray:[128/255,128/255,128/255],green:[0,128/255,0],greenyellow:[173/255,1,47/255],grey:[128/255,128/255,128/255],honeydew:[240/255,1,240/255],hotpink:[1,105/255,180/255],indianred:[205/255,92/255,92/255],indigo:[75/255,0,130/255],ivory:[1,1,240/255],khaki:[240/255,230/255,140/255],lavender:[230/255,230/255,250/255],lavenderblush:[1,240/255,245/255],lawngreen:[124/255,252/255,0],lemonchiffon:[1,250/255,205/255],lightblue:[173/255,216/255,230/255],lightcoral:[240/255,128/255,128/255],lightcyan:[224/255,1,1],lightgoldenrodyellow:[250/255,250/255,210/255],lightgray:[211/255,211/255,211/255],lightgreen:[144/255,238/255,144/255],lightgrey:[211/255,211/255,211/255],lightpink:[1,182/255,193/255],lightsalmon:[1,160/255,122/255],lightseagreen:[32/255,178/255,170/255],lightskyblue:[135/255,206/255,250/255],lightslategray:[119/255,136/255,153/255],lightslategrey:[119/255,136/255,153/255],lightsteelblue:[176/255,196/255,222/255],lightyellow:[1,1,224/255],lime:[0,1,0],limegreen:[50/255,205/255,50/255],linen:[250/255,240/255,230/255],magenta:[1,0,1],maroon:[128/255,0,0],mediumaquamarine:[102/255,205/255,170/255],mediumblue:[0,0,205/255],mediumorchid:[186/255,85/255,211/255],mediumpurple:[147/255,112/255,219/255],mediumseagreen:[60/255,179/255,113/255],mediumslateblue:[123/255,104/255,238/255],mediumspringgreen:[0,250/255,154/255],mediumturquoise:[72/255,209/255,204/255],mediumvioletred:[199/255,21/255,133/255],midnightblue:[25/255,25/255,112/255],mintcream:[245/255,1,250/255],mistyrose:[1,228/255,225/255],moccasin:[1,228/255,181/255],navajowhite:[1,222/255,173/255],navy:[0,0,128/255],oldlace:[253/255,245/255,230/255],olive:[128/255,128/255,0],olivedrab:[107/255,142/255,35/255],orange:[1,165/255,0],orangered:[1,69/255,0],orchid:[218/255,112/255,214/255],palegoldenrod:[238/255,232/255,170/255],palegreen:[152/255,251/255,152/255],paleturquoise:[175/255,238/255,238/255],palevioletred:[219/255,112/255,147/255],papayawhip:[1,239/255,213/255],peachpuff:[1,218/255,185/255],peru:[205/255,133/255,63/255],pink:[1,192/255,203/255],plum:[221/255,160/255,221/255],powderblue:[176/255,224/255,230/255],purple:[128/255,0,128/255],rebeccapurple:[102/255,51/255,153/255],red:[1,0,0],rosybrown:[188/255,143/255,143/255],royalblue:[65/255,105/255,225/255],saddlebrown:[139/255,69/255,19/255],salmon:[250/255,128/255,114/255],sandybrown:[244/255,164/255,96/255],seagreen:[46/255,139/255,87/255],seashell:[1,245/255,238/255],sienna:[160/255,82/255,45/255],silver:[192/255,192/255,192/255],skyblue:[135/255,206/255,235/255],slateblue:[106/255,90/255,205/255],slategray:[112/255,128/255,144/255],slategrey:[112/255,128/255,144/255],snow:[1,250/255,250/255],springgreen:[0,1,127/255],steelblue:[70/255,130/255,180/255],tan:[210/255,180/255,140/255],teal:[0,128/255,128/255],thistle:[216/255,191/255,216/255],tomato:[1,99/255,71/255],turquoise:[64/255,224/255,208/255],violet:[238/255,130/255,238/255],wheat:[245/255,222/255,179/255],white:[1,1,1],whitesmoke:[245/255,245/255,245/255],yellow:[1,1,0],yellowgreen:[154/255,205/255,50/255]};let OP=Array(3).fill("<percentage> | <number>[0, 255]"),MP=Array(3).fill("<number>[0, 255]");const _m=new OS({id:"srgb",name:"sRGB",base:Zie,fromBase:r=>r.map(t=>{let n=t<0?-1:1,s=t*n;return s>.0031308?n*(1.055*s**(1/2.4)-.055):12.92*t}),toBase:r=>r.map(t=>{let n=t<0?-1:1,s=t*n;return s<=.04045?t/12.92:n*((s+.055)/1.055)**2.4}),formats:{rgb:{coords:OP},rgb_number:{name:"rgb",commas:!0,coords:MP,noAlpha:!0},color:{},rgba:{coords:OP,commas:!0,lastAlpha:!0},rgba_number:{name:"rgba",commas:!0,coords:MP},hex:{type:"custom",toGamut:!0,test:r=>/^#([a-f0-9]{3,4}){1,2}$/i.test(r),parse(r){r.length<=5&&(r=r.replace(/[a-f0-9]/gi,"$&$&"));let t=[];return r.replace(/[a-f0-9]{2}/gi,n=>{t.push(parseInt(n,16)/255)}),{spaceId:"srgb",coords:t.slice(0,3),alpha:t.slice(3)[0]}},serialize:(r,t,{collapse:n=!0}={})=>{t<1&&r.push(t),r=r.map(a=>Math.round(a*255));let s=n&&r.every(a=>a%17===0);return"#"+r.map(a=>s?(a/17).toString(16):a.toString(16).padStart(2,"0")).join("")}},keyword:{type:"custom",test:r=>/^[a-z]+$/i.test(r),parse(r){r=r.toLowerCase();let t={spaceId:"srgb",coords:null,alpha:1};if(r==="transparent"?(t.coords=RP.black,t.alpha=0):t.coords=RP[r],t.coords)return t}}}}),LP=new OS({id:"p3",cssId:"display-p3",name:"P3",base:Kie,fromBase:_m.fromBase,toBase:_m.toBase});function MU(r,t,n={}){if(Jie(r)){let[l,c]=[r,t];return MU(...l.rangeArgs.colors,{...l.rangeArgs.options,...c})}let{space:s,outputSpace:i,progression:a,premultiplied:o}=n;r=us(r),t=us(t),r=lb(r),t=lb(t);let u={colors:[r,t],options:n};if(s?s=or.get(s):s=or.registry[Gh.interpolationSpace]||r.space,i=i?or.get(i):s,r=wr(r,s),t=wr(t,s),r=jh(r),t=jh(t),s.coords.h&&s.coords.h.type==="angle"){let l=n.hue=n.hue||"shorter",c=[s,"h"],[h,d]=[Nh(r,c),Nh(t,c)];isNaN(h)&&!isNaN(d)?h=d:isNaN(d)&&!isNaN(h)&&(d=h),[h,d]=tie(l,[h,d]),ub(r,c,h),ub(t,c,d)}return o&&(r.coords=r.coords.map(l=>l*r.alpha),t.coords=t.coords.map(l=>l*t.alpha)),Object.assign(l=>{l=a?a(l):l;let c=r.coords.map((p,f)=>{let m=t.coords[f];return Vw(p,m,l)}),h=Vw(r.alpha,t.alpha,l),d={space:s,coords:c,alpha:h};return o&&(d.coords=d.coords.map(p=>p/h)),i!==s&&(d=wr(d,i)),d},{rangeArgs:u})}function Jie(r){return nm(r)==="function"&&!!r.rangeArgs}Gh.interpolationSpace="lab";const HI=new or({id:"hsl",name:"HSL",coords:{h:{refRange:[0,360],type:"angle",name:"Hue"},s:{range:[0,100],name:"Saturation"},l:{range:[0,100],name:"Lightness"}},base:_m,fromBase:r=>{let t=Math.max(...r),n=Math.min(...r),[s,i,a]=r,[o,u,l]=[NaN,0,(n+t)/2],c=t-n;if(c!==0){switch(u=l===0||l===1?0:(t-l)/Math.min(l,1-l),t){case s:o=(i-a)/c+(i<a?6:0);break;case i:o=(a-s)/c+2;break;case a:o=(s-i)/c+4}o=o*60}return u<0&&(o+=180,u=Math.abs(u)),o>=360&&(o-=360),[o,u*100,l*100]},toBase:r=>{let[t,n,s]=r;t=t%360,t<0&&(t+=360),n/=100,s/=100;function i(a){let o=(a+t/30)%12,u=n*Math.min(s,1-s);return s-u*Math.max(-1,Math.min(o-3,9-o,1))}return[i(0),i(8),i(4)]},formats:{hsl:{coords:["<number> | <angle>","<percentage>","<percentage>"]},hsla:{coords:["<number> | <angle>","<percentage>","<percentage>"],commas:!0,lastAlpha:!0}}}),Qie=new or({id:"hsv",name:"HSV",coords:{h:{refRange:[0,360],type:"angle",name:"Hue"},s:{range:[0,100],name:"Saturation"},v:{range:[0,100],name:"Value"}},base:HI,fromBase(r){let[t,n,s]=r;n/=100,s/=100;let i=s+n*Math.min(s,1-s);return[t,i===0?0:200*(1-s/i),100*i]},toBase(r){let[t,n,s]=r;n/=100,s/=100;let i=s*(1-n/2);return[t,i===0||i===1?0:(s-i)/Math.min(i,1-i)*100,i*100]},formats:{color:{id:"--hsv",coords:["<number> | <angle>","<percentage> | <number>","<percentage> | <number>"]}}}),PP=new or({id:"hwb",name:"HWB",coords:{h:{refRange:[0,360],type:"angle",name:"Hue"},w:{range:[0,100],name:"Whiteness"},b:{range:[0,100],name:"Blackness"}},base:Qie,fromBase(r){let[t,n,s]=r;return[t,s*(100-n)/100,100-s]},toBase(r){let[t,n,s]=r;n/=100,s/=100;let i=n+s;if(i>=1){let u=n/i;return[t,0,u*100]}let a=1-s,o=a===0?0:1-n/a;return[t,o*100,a*100]},formats:{hwb:{coords:["<number> | <angle>","<percentage> | <number>","<percentage> | <number>"]}}}),BP=new or({id:"oklch",name:"Oklch",coords:{l:{refRange:[0,1],name:"Lightness"},c:{refRange:[0,.4],name:"Chroma"},h:{refRange:[0,360],type:"angle",name:"Hue"}},white:"D65",base:Hh,fromBase(r){let[t,n,s]=r,i;const a=2e-4;return Math.abs(n)<a&&Math.abs(s)<a?i=NaN:i=Math.atan2(s,n)*180/Math.PI,[t,Math.sqrt(n**2+s**2),pl(i)]},toBase(r){let[t,n,s]=r,i,a;return isNaN(s)?(i=0,a=0):(i=n*Math.cos(s*Math.PI/180),a=n*Math.sin(s*Math.PI/180)),[t,i,a]},formats:{oklch:{coords:["<percentage> | <number>","<number> | <percentage>[0,1]","<number> | <angle>"]}}});var VP=new or({id:"hsb",name:"HSB",coords:{h:{refRange:[0,360],type:"angle",name:"Hue"},s:{range:[0,100],name:"Saturation"},b:{range:[0,100],name:"Brightness"}},base:_m,fromBase:r=>{const t=Math.max(...r),n=t-Math.min(...r);let[s,i,a]=r,o,u;return n===0?(o=0,u=0):(u=n/t,s===t?o=(i-a)/n:i===t?o=2+(a-s)/n:a===t&&(o=4+(s-i)/n),o<0?o+=6:o>=6&&(o-=6)),[o/6*360,u*100,t*100]},toBase:zP,formats:{default:{type:"custom",serialize:(r,t)=>{const n=zP(r);let s=`rgb(${Math.round(n[0]*100*100)/100}% ${Math.round(n[1]*100*100)/100}% ${Math.round(n[2]*100*100)/100}%`;return t<1&&(s+=` / ${t}`),s+=")",s}},hsb:{coords:["<number> | <angle>","<percentage>","<percentage>"]},hsba:{coords:["<number> | <angle>","<percentage>","<percentage>"],commans:!0,lastAlpha:!0}}});function zP(r){const t=r[0]/360*6,n=r[1]/100,s=r[2]/100;let i=[];if(n===0)i=[s,s,s];else{const a=Math.floor(t),o=s*(1-n),u=s*(1-n*(t-a)),l=s*(1-n*(1+a-t));let c,h,d;a===1?(c=u,h=s,d=o):a===2?(c=o,h=s,d=l):a===3?(c=o,h=u,d=s):a===4?(c=l,h=o,d=s):a===5?(c=s,h=o,d=u):(c=s,h=l,d=o),i=[c,h,d]}return i}const mn=(r,t,n,s,i,a)=>{let o=(r-t)/(n-t)*(i-s)+s;return a&&(o=Math.max(o,Math.min(s,i)),o=Math.min(o,Math.max(s,i))),o},UP={};var pn,Ul,uT,eae;const Qt=class Qt{constructor(t,n,s,{clamp:i=!1}={}){cn(this,uT);Ar(this,"_color");Ar(this,"mode");if(this.mode=n||Cn,t instanceof Qt){const a=n?Qt.colorMap[n]:Qt.colorMap[t.mode];this._color=wr(t._color,a),this.mode=a}else if(typeof t=="object"&&!Array.isArray(t)&&t!==null){const a=n?Qt.colorMap[n]:t.spaceId;this._color=wr(t,a),this.mode=n||Object.entries(Qt.colorMap).find(([o,u])=>u===this._color.spaceId)}else if(typeof t[0]=="string")try{this._color=SU(t[0]);const[a]=Object.entries(Qt.colorMap).find(([o,u])=>u===this._color.spaceId);this.mode=a,this._color=wr(this._color,this._color.spaceId)}catch{throw new Error("Invalid color string")}else{let a;if(s)if(t.length===4)a=Qt.mapColorRange(t,this.mode,s,i);else if(t.length===3)a=Qt.mapColorRange([t[0],t[1],t[2]],this.mode,s,i),a.push(1);else if(t.length===2){ut(Qt,Ul)[this.mode]?a=ut(Qt,Ul)[this.mode](t[0],s,i):a=Qt.mapColorRange([t[0],t[0],t[0]],this.mode,s,i);const c=Array.isArray(s[s.length-1])?s[s.length-1]:[0,s[s.length-1]];a.push(mn(t[1],c[0],c[1],0,1,i))}else if(t.length===1)ut(Qt,Ul)[this.mode]?a=ut(Qt,Ul)[this.mode](t[0],s,i):a=Qt.mapColorRange([t[0],t[0],t[0]],this.mode,s,i),a.push(1);else throw new Error("Invalid color");else a=t;const o=Qt.colorMap[this.mode]||console.error("Invalid color mode"),u=a.slice(0,3),l={space:o,coords:u,alpha:a[3]};this._color=wr(l,o)}}static addColorMode(t,n){or.register(n),Qt.colorMap[t]=n.id,ut(Qt,pn)[t]=Object.values(n.coords).reduce((s,i)=>(s.push(i.refRange||i.range),s),[]),ut(Qt,pn)[t].push([0,1]),ut(Qt,Ul)[t]=n.fromGray}static mapColorRange(t,n,s,i){const a=s.map(u=>Array.isArray(u)?u:[0,u]),o=ut(Qt,pn)[n];return t.map((u,l)=>mn(u,a[l][0],a[l][1],o[l][0],o[l][1],i))}static unmapColorRange(t,n,s){const i=s.map(o=>Array.isArray(o)?o:[0,o]),a=ut(Qt,pn)[n];return t.map((o,u)=>mn(o,a[u][0],a[u][1],i[u][0],i[u][1]))}get _array(){return this._getRGBA()}array(){return this._array}lerp(t,n,s){let i=-1;for(;(i+1<this._color.space.path.length||i+1<t._color.space.path.length)&&this._color.space.path[i+1]===t._color.space.path[i+1];)i+=1;if(i===-1)throw new Error("Cannot lerp colors. No common color space found");const a=MU(this._color,t._color,{space:this._color.space.path[i].id})(n);return new Qt(a,s||this.mode)}toString(t){const n=`${this._color.space.id}-${this._color.coords.join(",")}-${this._color.alpha}-${t}`;let s=UP[n];return s||(s=Hie(this._color,{format:t}),UP[n]=s),s}setRed(t,n=[0,1]){Array.isArray(n)||(n=[0,n]);const s=ut(Qt,pn)[Cn][0],i=mn(t,n[0],n[1],s[0],s[1]);if(this.mode===Cn||this.mode===xi)this._color.coords[0]=i;else{const a=this._color.space.id,o=wr(this._color,"srgb");o.coords[0]=i,this._color=wr(o,a)}}setGreen(t,n=[0,1]){Array.isArray(n)||(n=[0,n]);const s=ut(Qt,pn)[Cn][1],i=mn(t,n[0],n[1],s[0],s[1]);if(this.mode===Cn||this.mode===xi)this._color.coords[1]=i;else{const a=this._color.space.id,o=wr(this._color,"srgb");o.coords[1]=i,this._color=wr(o,a)}}setBlue(t,n=[0,1]){Array.isArray(n)||(n=[0,n]);const s=ut(Qt,pn)[Cn][2],i=mn(t,n[0],n[1],s[0],s[1]);if(this.mode===Cn||this.mode===xi)this._color.coords[2]=i;else{const a=this._color.space.id,o=wr(this._color,"srgb");o.coords[2]=i,this._color=wr(o,a)}}setAlpha(t,n=[0,1]){Array.isArray(n)||(n=[0,n]);const s=ut(Qt,pn)[this.mode][3],i=mn(t,n[0],n[1],s[0],s[1]);this._color.alpha=i}_getRGBA(t=[1,1,1,1]){const n=ut(Qt,pn)[Cn];let s=structuredClone(wr(this._color,"srgb").coords);s.push(this._color.alpha);const i=t.map(a=>Array.isArray(a)?a:[0,a]);return s=s.map((a,o)=>mn(a,n[o][0],n[o][1],i[o][0],i[o][1])),s}_getMode(){return this.mode}_getRed(t=[0,1]){if(Array.isArray(t)||(t=[0,t]),this.mode===Cn||this.mode===xi){const n=ut(Qt,pn)[this.mode][0];return mn(this._color.coords[0],n[0],n[1],t[0],t[1])}else{const n=ut(Qt,pn)[Cn][0];return mn(wr(this._color,"srgb").coords[0],n[0],n[1],t[0],t[1])}}_getGreen(t=[0,1]){if(Array.isArray(t)||(t=[0,t]),this.mode===Cn||this.mode===xi){const n=ut(Qt,pn)[this.mode][1];return mn(this._color.coords[1],n[0],n[1],t[0],t[1])}else{const n=ut(Qt,pn)[Cn][1];return mn(wr(this._color,"srgb").coords[1],n[0],n[1],t[0],t[1])}}_getBlue(t=[0,1]){if(Array.isArray(t)||(t=[0,t]),this.mode===Cn||this.mode===xi){const n=ut(Qt,pn)[this.mode][2];return mn(this._color.coords[2],n[0],n[1],t[0],t[1])}else{const n=ut(Qt,pn)[Cn][2];return mn(wr(this._color,"srgb").coords[2],n[0],n[1],t[0],t[1])}}_getAlpha(t=[0,1]){Array.isArray(t)||(t=[0,t]);const n=ut(Qt,pn)[this.mode][3];return mn(this._color.alpha,n[0],n[1],t[0],t[1])}_getHue(t=[0,360]){if(Array.isArray(t)||(t=[0,t]),this.mode===za||this.mode===Xi){const n=ut(Qt,pn)[this.mode][0];return mn(this._color.coords[0],n[0],n[1],t[0],t[1])}else{const n=ut(Qt,pn)[Xi][0];return mn(wr(this._color,"hsl").coords[0],n[0],n[1],t[0],t[1])}}_getSaturation(t=[0,100]){if(Array.isArray(t)||(t=[0,t]),this.mode===za||this.mode===Xi){const n=ut(Qt,pn)[this.mode][1];return mn(this._color.coords[1],n[0],n[1],t[0],t[1])}else{const n=ut(Qt,pn)[Xi][1];return mn(wr(this._color,"hsl").coords[1],n[0],n[1],t[0],t[1])}}_getBrightness(t=[0,100]){if(Array.isArray(t)||(t=[0,t]),this.mode===za){const n=ut(Qt,pn)[this.mode][2];return mn(this._color.coords[2],n[0],n[1],t[0],t[1])}else{const n=ut(Qt,pn)[za][2];return mn(wr(this._color,"hsb").coords[2],n[0],n[1],t[0],t[1])}}_getLightness(t=[0,100]){if(Array.isArray(t)||(t=[0,t]),this.mode===Xi){const n=ut(Qt,pn)[this.mode][2];return mn(this._color.coords[2],n[0],n[1],t[0],t[1])}else{const n=ut(Qt,pn)[Xi][2];return mn(wr(this._color,"hsl").coords[2],n[0],n[1],t[0],t[1])}}};pn=new WeakMap,Ul=new WeakMap,uT=new WeakSet,eae=function(t){return new Qt(this._color,t)},Ar(Qt,"colorMap",{}),cn(Qt,pn,{}),cn(Qt,Ul,{});let _n=Qt;function LU(r,t,n){r.Color=_n,_m.fromGray=LP.fromGray=function(s,i,a){const o=i.map(l=>Array.isArray(l)?l:[0,l]),u=mn(s,o[2][0],o[2][1],0,1,a);return[u,u,u]},VP.fromGray=HI.fromGray=function(s,i,a){const o=i.map(l=>Array.isArray(l)?l:[0,l]);return[0,0,mn(s,o[2][0],o[2][1],0,100,a)]},PP.fromGray=function(s,i,a){const o=i.map(d=>Array.isArray(d)?d:[0,d]),u=Math.abs(o[1][0]-o[1][1])/2+Math.abs(o[2][0]-o[2][1])/2,l=mn(s,0,u,0,100);let c,h;return l<50?(h=l,c=100-l):l>=50&&(c=l,h=100-l),[0,c,h]},So.fromGray=Cm.fromGray=Hh.fromGray=BP.fromGray=function(s,i,a){const o=i.map(l=>Array.isArray(l)?l:[0,l]);return[mn(s,o[0][0],o[0][1],0,100,a),0,0]},r.Color.addColorMode(Cn,_m),r.Color.addColorMode(xi,LP),r.Color.addColorMode(za,VP),r.Color.addColorMode(Xi,HI),r.Color.addColorMode(im,PP),r.Color.addColorMode(cb,So),r.Color.addColorMode(am,Cm),r.Color.addColorMode(hb,Hh),r.Color.addColorMode(om,BP),n.presetup=function(){const s=this,i=["Red","Green","Blue","Alpha"];for(let o in i){const u=i[o],l=r.Color.prototype["set"+u];r.Color.prototype["set"+u]=function(c,h){var d,p,f;return h=h||((f=(p=(d=s==null?void 0:s._renderer)==null?void 0:d.states)==null?void 0:p.colorMaxes)==null?void 0:f[Cn][o]),l.call(this,c,h)}}function a(o,u){const l=r.Color.prototype["_get"+o];r.Color.prototype["_get"+o]=function(c){var h,d,p,f,m,g;if(Object.keys(u).includes(this.mode))c=c||((p=(d=(h=s==null?void 0:s._renderer)==null?void 0:h.states)==null?void 0:d.colorMaxes)==null?void 0:p[this.mode][u[this.mode]]);else{const y=Object.keys(u)[0];c=c||((g=(m=(f=s==null?void 0:s._renderer)==null?void 0:f.states)==null?void 0:m.colorMaxes)==null?void 0:g[y][u[y]])}return l.call(this,c)}}a("Red",{[Cn]:0,[xi]:0}),a("Green",{[Cn]:1,[xi]:1}),a("Blue",{[Cn]:2,[xi]:2}),a("Alpha",{[Cn]:3,[xi]:3,[za]:3,[Xi]:3,[im]:3,[cb]:3,[am]:3,[hb]:3,[om]:3}),a("Hue",{[Xi]:0,[za]:0,[im]:0,[am]:2,[om]:2}),a("Saturation",{[Xi]:1,[za]:1}),a("Brightness",{[za]:2}),a("Lightness",{[Xi]:2})}}typeof p5<"u"&&LU(p5,p5.prototype);const Cn="rgb",xi="rgbhdr",za="hsb",Xi="hsl",im="hwb",cb="lab",am="lch",hb="oklab",om="oklch",ow="rgba";function kT(r,t){t.RGB=Cn,t.RGBHDR=xi,t.HSB=za,t.HSL=Xi,t.HWB=im,t.LAB=cb,t.LCH=am,t.OKLAB=hb,t.OKLCH=om,t.RGBA=ow,r.Renderer.states.colorMode=Cn,r.Renderer.states.colorMaxes={[Cn]:[255,255,255,255],[xi]:[255,255,255,255],[za]:[360,100,100,1],[Xi]:[360,100,100,1],[im]:[360,100,100,1],[cb]:[100,[-125,125],[-125,125],1],[am]:[100,150,360,1],[hb]:[100,[-125,125],[-125,125],1],[om]:[100,150,360,1],clone:function(){const n={...this};for(const s in n)n[s]instanceof Array&&(n[s]=[...n[s]]);return n}},t.color=function(...n){if(n[0]instanceof _n)return n[0];const s=Array.isArray(n[0])?n[0]:n;return new _n(s,this._renderer.states.colorMode,this._renderer.states.colorMaxes[this._renderer.states.colorMode],{clamp:!0})},t.red=function(n){return this.color(n)._getRed()},t.green=function(n){return this.color(n)._getGreen()},t.blue=function(n){return this.color(n)._getBlue()},t.alpha=function(n){return this.color(n)._getAlpha()},t.hue=function(n){return this.color(n)._getHue()},t.saturation=function(n){return this.color(n)._getSaturation()},t.brightness=function(n){return this.color(n)._getBrightness()},t.lightness=function(n){return this.color(n)._getLightness()},t.lerpColor=function(n,s,i){return n.lerp(s,i,this._renderer.states.colorMode)},t.paletteLerp=function(n,s){const i=n[0];if(s<i[1])return this.color(i[0]);for(let a=1;a<n.length;a++){const o=n[a];if(s<o[1]){const u=n[a-1];return this.lerpColor(this.color(u[0]),this.color(o[0]),(s-u[1])/(o[1]-u[1]))}}return this.color(n[n.length-1][0])}}typeof p5<"u"&&kT(p5,p5.prototype);class Wl{constructor(t){if(t)this.DOM=t;else{const n=document.implementation.createDocument(null,"doc");this.DOM=n.createElement("root")}}getParent(){return new Wl(this.DOM.parentElement)}getName(){return this.DOM.tagName}setName(t){const n=this.DOM.innerHTML,s=this.DOM.attributes,a=document.implementation.createDocument(null,"default").createElement(t);a.innerHTML=n;for(let o=0;o<s.length;o++)a.setAttribute(s[o].nodeName,s[o].nodeValue);this.DOM=a}hasChildren(){return this.DOM.children.length>0}listChildren(){const t=[];for(let n=0;n<this.DOM.childNodes.length;n++)t.push(this.DOM.childNodes[n].nodeName);return t}getChildren(t){return WP(t?this.DOM.getElementsByTagName(t):this.DOM.children)}getChild(t){if(typeof t=="string"){for(const n of this.DOM.children)if(n.tagName===t)return new Wl(n)}else return new Wl(this.DOM.children[t])}addChild(t){t instanceof Wl&&this.DOM.appendChild(t.DOM)}removeChild(t){let n=-1;if(typeof t=="string"){for(let s=0;s<this.DOM.children.length;s++)if(this.DOM.children[s].tagName===t){n=s;break}}else n=t;n!==-1&&this.DOM.removeChild(this.DOM.children[n])}getAttributeCount(){return this.DOM.attributes.length}listAttributes(){const t=[];for(const n of this.DOM.attributes)t.push(n.nodeName);return t}hasAttribute(t){const n={};for(const s of this.DOM.attributes)n[s.nodeName]=s.nodeValue;return!!n[t]}getNum(t,n){const s={};for(const i of this.DOM.attributes)s[i.nodeName]=i.nodeValue;return Number(s[t])||n||0}getString(t,n){const s={};for(const i of this.DOM.attributes)s[i.nodeName]=i.nodeValue;return s[t]?String(s[t]):n||null}setAttribute(t,n){this.DOM.setAttribute(t,n)}getContent(t){let n;return n=this.DOM.textContent,n=n.replace(/\s\s+/g,","),n||t||null}setContent(t){this.DOM.children.length||(this.DOM.textContent=t)}serialize(){return new XMLSerializer().serializeToString(this.DOM)}}function WP(r){const t=[];for(let n=0;n<r.length;n++)t.push(new Wl(r[n]));return t}function PU(r,t){r.XML=Wl}typeof p5<"u"&&PU(p5,p5.prototype);let NT=class vy{constructor(t,n){this.file=t,this._pInst=n;const s=t.type.split("/");this.type=s[0],this.subtype=s[1],this.name=t.name,this.size=t.size,this.data=void 0}static _createLoader(t,n){const s=new FileReader;return s.onload=function(i){const a=new vy(t);if(a.file.type==="application/json")a.data=JSON.parse(i.target.result);else if(a.file.type==="text/xml"){const u=new DOMParser().parseFromString(i.target.result,"text/xml");a.data=new Wl(u.documentElement)}else a.data=i.target.result;n(a)},s}static _load(t,n){if(/^text\//.test(t.type)||t.type==="application/json")vy._createLoader(t,n).readAsText(t);else if(!/^(video|audio)\//.test(t.type))vy._createLoader(t,n).readAsDataURL(t);else{const s=new vy(t);s.data=URL.createObjectURL(t),n(s)}}};function BU(r,t){r.File=NT}typeof p5<"u"&&BU(p5,p5.prototype);class Sr{constructor(t,n){Ar(this,"width");Ar(this,"height");Ar(this,"elt");this.elt=t,this._pInst=this._pixelsState=n,this._events={},this.width=this.elt.offsetWidth,this.height=this.elt.offsetHeight}remove(){if(this.stop){this.stop();const n=this.elt.srcObject;n!==null&&n.getTracks().forEach(i=>{i.stop()})}const t=this._pInst._elements.indexOf(this);t!==-1&&this._pInst._elements.splice(t,1);for(let n in this._events)this.elt.removeEventListener(n,this._events[n]);this.elt&&this.elt.parentNode&&this.elt.parentNode.removeChild(this.elt)}parent(t){return typeof t>"u"?this.elt.parentNode:(typeof t=="string"?(t[0]==="#"&&(t=t.substring(1)),t=document.getElementById(t)):t instanceof Sr&&(t=t.elt),t.appendChild(this.elt),this)}child(t){return typeof t>"u"?this.elt.childNodes:(typeof t=="string"?(t[0]==="#"&&(t=t.substring(1)),t=document.getElementById(t)):t instanceof Sr&&(t=t.elt),t instanceof HTMLElement&&this.elt.appendChild(t),this)}html(...t){return t.length===0?this.elt.innerHTML:t[1]?(this.elt.insertAdjacentHTML("beforeend",t[0]),this):(this.elt.innerHTML=t[0],this)}id(t){return typeof t>"u"?this.elt.id:(this.elt.id=t,this.width=this.elt.offsetWidth,this.height=this.elt.offsetHeight,this)}class(t){return typeof t>"u"?this.elt.className:(this.elt.className=t,this)}addClass(t){return this.elt.className?this.hasClass(t)||(this.elt.className=this.elt.className+" "+t):this.elt.className=t,this}removeClass(t){return this.elt.classList.remove(t),this}hasClass(t){return this.elt.classList.contains(t)}toggleClass(t){return this.elt.classList.contains(t)?this.elt.classList.remove(t):this.elt.classList.add(t),this}center(t){const n=this.elt.style.display,s=this.elt.style.display==="none",i=this.parent().style.display==="none",a={x:this.elt.offsetLeft,y:this.elt.offsetTop};s&&this.show(),i&&this.parent().show(),this.elt.style.display="block",this.position(0,0);const o=Math.abs(this.parent().offsetWidth-this.elt.offsetWidth),u=Math.abs(this.parent().offsetHeight-this.elt.offsetHeight);return t==="both"||t===void 0?this.position(o/2+this.parent().offsetLeft,u/2+this.parent().offsetTop):t==="horizontal"?this.position(o/2+this.parent().offsetLeft,a.y):t==="vertical"&&this.position(a.x,u/2+this.parent().offsetTop),this.style("display",n),s&&this.hide(),i&&this.parent().hide(),this}position(...t){if(t.length===0)return{x:this.elt.offsetLeft,y:this.elt.offsetTop};{let n="absolute";return(t[2]==="static"||t[2]==="fixed"||t[2]==="relative"||t[2]==="sticky"||t[2]==="initial"||t[2]==="inherit")&&(n=t[2]),this.elt.style.position=n,this.elt.style.left=t[0]+"px",this.elt.style.top=t[1]+"px",this.x=t[0],this.y=t[1],this}}show(){return this.elt.style.display="block",this}hide(){return this.elt.style.display="none",this}size(t,n){if(arguments.length===0)return{width:this.elt.offsetWidth,height:this.elt.offsetHeight};{let s=t,i=n;const a=sU;if(s!==a||i!==a){if(s===a?s=n*this.width/this.height:i===a&&(i=t*this.height/this.width),this.elt instanceof HTMLCanvasElement){const o={},u=this.elt.getContext("2d");let l;for(l in u)o[l]=u[l];this.elt.setAttribute("width",s*this._pInst._pixelDensity),this.elt.setAttribute("height",i*this._pInst._pixelDensity),this.elt.style.width=s+"px",this.elt.style.height=i+"px",this._pInst.scale(this._pInst._pixelDensity,this._pInst._pixelDensity);for(l in o)this.elt.getContext("2d")[l]=o[l]}else this.elt.style.width=s+"px",this.elt.style.height=i+"px",this.elt.width=s,this.elt.height=i;this.width=s,this.height=i,this._pInst&&this._pInst._curElement&&this._pInst._curElement.elt===this.elt&&(this._pInst.width=s,this._pInst.height=i)}return this}}style(t,n){const s=this;if(n instanceof _n&&(n=n.toString()),typeof n>"u"){if(t.indexOf(":")===-1)return window.getComputedStyle(s.elt).getPropertyValue(t);{const i=t.split(";");for(let a=0;a<i.length;a++){const o=i[a].split(":");o[0]&&o[1]&&(this.elt.style[o[0].trim()]=o[1].trim())}}}else if(this.elt.style[t]=n,t==="width"||t==="height"||t==="left"||t==="top"){let o=window.getComputedStyle(s.elt).getPropertyValue(t).replace(/[^\d.]/g,"");this[t]=Math.round(parseFloat(o,10))}return this}_translate(...t){this.elt.style.position="absolute";let n="";return this.elt.style.transform&&(n=this.elt.style.transform.replace(/translate3d\(.*\)/g,""),n=n.replace(/translate[X-Z]?\(.*\)/g,"")),t.length===2?this.elt.style.transform="translate("+t[0]+"px, "+t[1]+"px)":t.length>2&&(this.elt.style.transform="translate3d("+t[0]+"px,"+t[1]+"px,"+t[2]+"px)",t.length===3?this.elt.parentElement.style.perspective="1000px":this.elt.parentElement.style.perspective=t[3]+"px"),this.elt.style.transform+=n,this}_rotate(...t){let n="";return this.elt.style.transform&&(n=this.elt.style.transform.replace(/rotate3d\(.*\)/g,""),n=n.replace(/rotate[X-Z]?\(.*\)/g,"")),t.length===1?this.elt.style.transform="rotate("+t[0]+"deg)":t.length===2?this.elt.style.transform="rotate("+t[0]+"deg, "+t[1]+"deg)":t.length===3&&(this.elt.style.transform="rotateX("+t[0]+"deg)",this.elt.style.transform+="rotateY("+t[1]+"deg)",this.elt.style.transform+="rotateZ("+t[2]+"deg)"),this.elt.style.transform+=n,this}attribute(t,n){if(this.elt.firstChild!=null&&(this.elt.firstChild.type==="checkbox"||this.elt.firstChild.type==="radio")){if(typeof n>"u")return this.elt.firstChild.getAttribute(t);for(let s=0;s<this.elt.childNodes.length;s++)this.elt.childNodes[s].setAttribute(t,n)}else return typeof n>"u"?this.elt.getAttribute(t):(this.elt.setAttribute(t,n),this)}removeAttribute(t){if(this.elt.firstChild!=null&&(this.elt.firstChild.type==="checkbox"||this.elt.firstChild.type==="radio"))for(let n=0;n<this.elt.childNodes.length;n++)this.elt.childNodes[n].removeAttribute(t);return this.elt.removeAttribute(t),this}value(...t){return t.length>0?(this.elt.value=t[0],this):this.elt.type==="range"?parseFloat(this.elt.value):this.elt.value}mousePressed(t){const n=function(s){return this._pInst.mouseIsPressed=!0,this._pInst._activePointers.set(s.pointerId,s),this._pInst._setMouseButton(s),this._pInst._updatePointerCoords(s),t.call(this,s)};return Sr._adjustListener("pointerdown",n,this),this}doubleClicked(t){return Sr._adjustListener("dblclick",t,this),this}mouseWheel(t){return Sr._adjustListener("wheel",t,this),this}mouseReleased(t){return Sr._adjustListener("pointerup",t,this),this}mouseClicked(t){return Sr._adjustListener("click",t,this),this}mouseMoved(t){return Sr._adjustListener("pointermove",t,this),this}mouseOver(t){return Sr._adjustListener("pointerover",t,this),this}mouseOut(t){return Sr._adjustListener("pointerout",t,this),this}dragOver(t){return Sr._adjustListener("dragover",t,this),this}dragLeave(t){return Sr._adjustListener("dragleave",t,this),this}changed(t){return Sr._adjustListener("change",t,this),this}input(t){return Sr._adjustListener("input",t,this),this}drop(t,n){if(window.File&&window.FileReader&&window.FileList&&window.Blob){if(!this._dragDisabled){this._dragDisabled=!0;const s=function(i){i.preventDefault()};this.elt.addEventListener("dragover",s),this.elt.addEventListener("dragleave",s)}Sr._attachListener("drop",function(s){s.preventDefault(),typeof n=="function"&&n.call(this,s);const i=s.dataTransfer.files;for(const a of i)NT._load(a,t)},this)}else console.log("The File APIs are not fully supported in this browser.");return this}draggable(t){let n="ontouchstart"in window,s=0,i=0,a=0,o=0,u,l=n?"touchstart":"mousedown",c=n?"touchend":"mouseup",h=n?"touchmove":"mousemove";t===void 0?(t=this.elt,u=t):t!==this.elt&&t.elt!==this.elt&&(t=t.elt,u=this.elt),u.addEventListener(l,d,!1),u.style.cursor="move";function d(m){if(m=m||window.event,n){const g=m.changedTouches;a=parseInt(g[0].clientX),o=parseInt(g[0].clientY)}else a=parseInt(m.clientX),o=parseInt(m.clientY);return document.addEventListener(c,f,!1),document.addEventListener(h,p,!1),!1}function p(m){if(m=m||window.event,n){const g=m.changedTouches;s=a-parseInt(g[0].clientX),i=o-parseInt(g[0].clientY),a=parseInt(g[0].clientX),o=parseInt(g[0].clientY)}else s=a-parseInt(m.clientX),i=o-parseInt(m.clientY),a=parseInt(m.clientX),o=parseInt(m.clientY);t.style.left=t.offsetLeft-s+"px",t.style.top=t.offsetTop-i+"px"}function f(){document.removeEventListener(c,f,!1),document.removeEventListener(h,p,!1)}return this}static _adjustListener(t,n,s){return n===!1?Sr._detachListener(t,s):Sr._attachListener(t,n,s),this}static _attachListener(t,n,s){s._events[t]&&Sr._detachListener(t,s);const i=n.bind(s);s.elt.addEventListener(t,i,!1),s._events[t]=i}static _detachListener(t,n){const s=n._events[t];n.elt.removeEventListener(t,s,!1),n._events[t]=null}}function VU(r,t){r.Element=Sr}typeof p5<"u"&&VU(p5,p5.prototype);const jr={_toPixels(r){if(r instanceof ImageData)return r.data;if(r.getContext("2d"))return r.getContext("2d").getImageData(0,0,r.width,r.height).data;if(r.getContext("webgl")){const t=r.getContext("webgl"),n=t.drawingBufferWidth*t.drawingBufferHeight*4,s=new Uint8Array(n);return t.readPixels(0,0,r.width,r.height,t.RGBA,t.UNSIGNED_BYTE,s),s}},_getARGB(r,t){const n=t*4;return r[n+3]<<24&4278190080|r[n]<<16&16711680|r[n+1]<<8&65280|r[n+2]&255},_setPixels(r,t){let n=0;for(let s=0,i=r.length;s<i;s++)n=s*4,r[n+0]=(t[s]&16711680)>>>16,r[n+1]=(t[s]&65280)>>>8,r[n+2]=t[s]&255,r[n+3]=(t[s]&4278190080)>>>24},_toImageData(r){return r instanceof ImageData?r:r.getContext("2d").getImageData(0,0,r.width,r.height)},_createImageData(r,t){return jr._tmpCanvas=document.createElement("canvas"),jr._tmpCtx=jr._tmpCanvas.getContext("2d"),this._tmpCtx.createImageData(r,t)},apply(r,t,n){const s=r.getContext("2d"),i=s.getImageData(0,0,r.width,r.height),a=t(i,n);a instanceof ImageData?s.putImageData(a,0,0,0,0,r.width,r.height):s.putImageData(i,0,0,0,0,r.width,r.height)},threshold(r,t=.5){const n=jr._toPixels(r),s=Math.floor(t*255);for(let i=0;i<n.length;i+=4){const a=n[i],o=n[i+1],u=n[i+2],l=.2126*a+.7152*o+.0722*u;let c;l>=s?c=255:c=0,n[i]=n[i+1]=n[i+2]=c}},gray(r){const t=jr._toPixels(r);for(let n=0;n<t.length;n+=4){const s=t[n],i=t[n+1],a=t[n+2],o=.2126*s+.7152*i+.0722*a;t[n]=t[n+1]=t[n+2]=o}},opaque(r){const t=jr._toPixels(r);for(let n=0;n<t.length;n+=4)t[n+3]=255;return t},invert(r){const t=jr._toPixels(r);for(let n=0;n<t.length;n+=4)t[n]=255-t[n],t[n+1]=255-t[n+1],t[n+2]=255-t[n+2]},posterize(r,t=4){const n=jr._toPixels(r);if(t<2||t>255)throw new Error("Level must be greater than 2 and less than 255 for posterize");const s=t-1;for(let i=0;i<n.length;i+=4){const a=n[i],o=n[i+1],u=n[i+2];n[i]=(a*t>>8)*255/s,n[i+1]=(o*t>>8)*255/s,n[i+2]=(u*t>>8)*255/s}},dilate(r){const t=jr._toPixels(r);let n=0;const s=t.length?t.length/4:0,i=new Int32Array(s);let a,o,u,l,c,h,d,p,f,m,g,y,b,x,w,v,S;for(;n<s;)for(a=n,o=n+r.width;n<o;)u=l=jr._getARGB(t,n),d=n-1,h=n+1,p=n-r.width,f=n+r.width,d<a&&(d=n),h>=o&&(h=n),p<0&&(p=0),f>=s&&(f=n),y=jr._getARGB(t,p),g=jr._getARGB(t,d),b=jr._getARGB(t,f),m=jr._getARGB(t,h),c=77*(u>>16&255)+151*(u>>8&255)+28*(u&255),w=77*(g>>16&255)+151*(g>>8&255)+28*(g&255),x=77*(m>>16&255)+151*(m>>8&255)+28*(m&255),v=77*(y>>16&255)+151*(y>>8&255)+28*(y&255),S=77*(b>>16&255)+151*(b>>8&255)+28*(b&255),w>c&&(l=g,c=w),x>c&&(l=m,c=x),v>c&&(l=y,c=v),S>c&&(l=b,c=S),i[n++]=l;jr._setPixels(t,i)},erode(r){const t=jr._toPixels(r);let n=0;const s=t.length?t.length/4:0,i=new Int32Array(s);let a,o,u,l,c,h,d,p,f,m,g,y,b,x,w,v,S;for(;n<s;)for(a=n,o=n+r.width;n<o;)u=l=jr._getARGB(t,n),d=n-1,h=n+1,p=n-r.width,f=n+r.width,d<a&&(d=n),h>=o&&(h=n),p<0&&(p=0),f>=s&&(f=n),y=jr._getARGB(t,p),g=jr._getARGB(t,d),b=jr._getARGB(t,f),m=jr._getARGB(t,h),c=77*(u>>16&255)+151*(u>>8&255)+28*(u&255),w=77*(g>>16&255)+151*(g>>8&255)+28*(g&255),x=77*(m>>16&255)+151*(m>>8&255)+28*(m&255),v=77*(y>>16&255)+151*(y>>8&255)+28*(y&255),S=77*(b>>16&255)+151*(b>>8&255)+28*(b&255),w<c&&(l=g,c=w),x<c&&(l=m,c=x),v<c&&(l=y,c=v),S<c&&(l=b,c=S),i[n++]=l;jr._setPixels(t,i)},blur(r,t){rae(r,t)}};let Gy,Yf,Zf,yh;function tae(r){let t=r*3.5|0;if(t=t<1?1:t<248?t:248,Gy!==t){Gy=t,Yf=1+Gy<<1,Zf=new Int32Array(Yf),yh=new Array(Yf);for(let o=0;o<Yf;o++)yh[o]=new Int32Array(256);let n,s,i,a;for(let o=1,u=t-1;o<t;o++){Zf[t+o]=Zf[u]=s=u*u,i=yh[t+o],a=yh[u--];for(let l=0;l<256;l++)i[l]=a[l]=s*l}n=Zf[t]=t*t,i=yh[t];for(let o=0;o<256;o++)i[o]=n*o}}function rae(r,t){const n=jr._toPixels(r),s=r.width,i=r.height,a=s*i,o=new Int32Array(a);for(let A=0;A<a;A++)o[A]=jr._getARGB(n,A);let u,l,c,h,d,p,f,m,g,y;const b=new Int32Array(a),x=new Int32Array(a),w=new Int32Array(a),v=new Int32Array(a);let S=0;tae(t);let E,C,I,_;for(C=0;C<i;C++){for(E=0;E<s;E++){if(h=c=l=d=u=0,p=E-Gy,p<0)y=-p,p=0;else{if(p>=s)break;y=0}for(I=y;I<Yf&&!(p>=s);I++){const A=o[p+S];_=yh[I],d+=_[(A&-16777216)>>>24],l+=_[(A&16711680)>>16],c+=_[(A&65280)>>8],h+=_[A&255],u+=Zf[I],p++}f=S+E,b[f]=d/u,x[f]=l/u,w[f]=c/u,v[f]=h/u}S+=s}for(S=0,m=-Gy,g=m*s,C=0;C<i;C++){for(E=0;E<s;E++){if(h=c=l=d=u=0,m<0)y=f=-m,p=E;else{if(m>=i)break;y=0,f=m,p=E+g}for(I=y;I<Yf&&!(f>=i);I++)_=yh[I],d+=_[b[p]],l+=_[x[p]],c+=_[w[p]],h+=_[v[p]],u+=Zf[I],f++,p+=s;o[E+S]=d/u<<24|l/u<<16|c/u<<8|h/u}S+=s,g+=s,m++}jr._setPixels(n,o)}function zU(r){let t=0;for(let n=1;n<r.length;n++)t+=r[n-1].position.dist(r[n].position);return t}class UU{constructor(t){for(const[n,s]of Object.entries(t))this[n]=s}}class Ja{constructor(...t){Ar(this,"vertices");Ar(this,"_shape",null);Ar(this,"_primitivesIndex",null);Ar(this,"_contoursIndex",null);Ar(this,"isClosing",!1);if(this.constructor===Ja)throw new Error("ShapePrimitive is an abstract class: it cannot be instantiated.");if(t.length>0)this.vertices=t;else throw new Error("At least one vertex must be passed to the constructor.")}get vertexCount(){return this.vertices.length}get vertexCapacity(){throw new Error("Getter vertexCapacity must be implemented.")}get _firstInterpolatedVertex(){return this.startVertex()}get canOverrideAnchor(){return!1}accept(t){throw new Error("Method accept() must be implemented.")}addToShape(t){let n=t.at(-1);if(n.primitives.length===0)n.primitives.push(this);else{let i=t.at(-1,-1),a=i instanceof this.constructor,o=i.vertexCapacity-i.vertexCount,u,l;a&&o>0?(u=this.vertices.splice(0,o),l=this.vertices,i.vertices.push(...u),l.length>0&&n.primitives.push(this)):n.primitives.push(this)}if(this.vertices.length>0){let i=t.at(-1);this._primitivesIndex=i.primitives.length-1,this._contoursIndex=t.contours.length-1,this._shape=t}return t.at(-1,-1)}get _nextPrimitive(){return this._belongsToShape?this._shape.at(this._contoursIndex,this._primitivesIndex+1):null}get _belongsToShape(){return this._shape!==null}handlesClose(){return!1}close(t){throw new Error("Unimplemented!")}}var xm;class WU{constructor(t=Eo){cn(this,xm);Ar(this,"primitives");Xs(this,xm,t),this.primitives=[]}get kind(){const t=this.primitives.length===0,n=ut(this,xm)===Eo;return t&&n?tm:ut(this,xm)}accept(t){for(const n of this.primitives)n.accept(t)}}xm=new WeakMap;var pS;class uw extends Ja{constructor(){super(...arguments);cn(this,pS,1)}get vertexCapacity(){return ut(this,pS)}accept(n){n.visitAnchor(this)}getEndVertex(){return this.vertices[0]}}pS=new WeakMap;class qh extends Ja{constructor(...t){if(super(...t),this.constructor===qh)throw new Error("Segment is an abstract class: it cannot be instantiated.")}get _previousPrimitive(){return this._belongsToShape?this._shape.at(this._contoursIndex,this._primitivesIndex-1):null}getStartVertex(){return this._previousPrimitive.getEndVertex()}getEndVertex(){return this.vertices.at(-1)}}var fS;class GU extends qh{constructor(){super(...arguments);cn(this,fS,1)}get vertexCapacity(){return ut(this,fS)}accept(n){n.visitLineSegment(this)}}fS=new WeakMap;var lx,cx,vm;class HU extends qh{constructor(n,...s){super(...s);cn(this,lx);cn(this,cx);cn(this,vm);let i=Array.isArray(n)?n[0]:n;Xs(this,lx,i),Xs(this,cx,i)}get order(){return ut(this,lx)}get vertexCapacity(){return ut(this,cx)}hullLength(){return ut(this,vm)===void 0&&Xs(this,vm,zU([this.getStartVertex(),...this.vertices])),ut(this,vm)}accept(n){n.visitBezierSegment(this)}}lx=new WeakMap,cx=new WeakMap,vm=new WeakMap;var mS;class jU extends qh{constructor(){super(...arguments);cn(this,mS,1/0);Ar(this,"_splineProperties",{ends:rm,tightness:0})}get vertexCapacity(){return ut(this,mS)}accept(n){n.visitSplineSegment(this)}get _comesAfterSegment(){return this._previousPrimitive instanceof qh}get canOverrideAnchor(){return this._splineProperties.ends===Xf}get _firstInterpolatedVertex(){return this._splineProperties.ends===Xf?this._comesAfterSegment?this.vertices[1]:this.vertices[0]:this.getStartVertex()}get _chainedToSegment(){if(this._belongsToShape&&this._comesAfterSegment){let n=this._firstInterpolatedVertex.position;return this.getStartVertex().position.equals(n)}else return!1}addToShape(n){const s=super.addToShape(n);if(this._splineProperties.ends=n._splineProperties.ends,this._splineProperties.tightness=n._splineProperties.tightness,this._splineProperties.ends!==Xf)return s;let i=!this._belongsToShape,a=n.at(-1,-1),o=(u,l)=>`Spline does not start where previous path segment ends:
      second spline vertex at (${u})
      expected to be at (${l}).`;if(i&&a.vertices.length===2&&a._comesAfterSegment&&!a._chainedToSegment){let u=a._firstInterpolatedVertex.position,l=a.getStartVertex().position;console.warn(o(u.array(),l.array()))}return s}getEndVertex(){return this._splineProperties.ends===rm?super.getEndVertex():this._splineProperties.ends===Xf?this.vertices.at(-2):this.getStartVertex()}getControlPoints(){let n=[];this._comesAfterSegment&&n.push(this.getStartVertex()),n.push(this.getStartVertex());for(const i of this.vertices)n.push(i);const s=this.getStartVertex();return this._splineProperties.ends===rm?(n.unshift(s),n.push(this.vertices.at(-1))):this._splineProperties.ends===PI&&(n.unshift(this.vertices.at(-1)),n.push(s,this.vertices.at(0))),n}handlesClose(){return this._belongsToShape?this._shape.at(this._contoursIndex).primitives.length===2&&this._primitivesIndex===1:!1}close(){this._splineProperties.ends=PI}}mS=new WeakMap;var gS;class qU extends Ja{constructor(){super(...arguments);cn(this,gS,1)}get vertexCapacity(){return ut(this,gS)}accept(n){n.visitPoint(this)}}gS=new WeakMap;var yS;class KU extends Ja{constructor(){super(...arguments);cn(this,yS,2)}get vertexCapacity(){return ut(this,yS)}accept(n){n.visitLine(this)}}yS=new WeakMap;var bS;class XU extends Ja{constructor(){super(...arguments);cn(this,bS,3)}get vertexCapacity(){return ut(this,bS)}accept(n){n.visitTriangle(this)}}bS=new WeakMap;var xS;class YU extends Ja{constructor(){super(...arguments);cn(this,xS,4)}get vertexCapacity(){return ut(this,xS)}accept(n){n.visitQuad(this)}}xS=new WeakMap;var vS;class ZU extends Ja{constructor(){super(...arguments);cn(this,vS,1/0)}get vertexCapacity(){return ut(this,vS)}accept(n){n.visitTriangleFan(this)}}vS=new WeakMap;var wS;class JU extends Ja{constructor(){super(...arguments);cn(this,wS,1/0)}get vertexCapacity(){return ut(this,wS)}accept(n){n.visitTriangleStrip(this)}}wS=new WeakMap;var SS;class QU extends Ja{constructor(){super(...arguments);cn(this,SS,1/0)}get vertexCapacity(){return ut(this,SS)}accept(n){n.visitQuadStrip(this)}}SS=new WeakMap;class nae{constructor(){Ar(this,"creators");let t=new Map;t.set(`vertex-${tm}`,(...n)=>new uw(...n)),t.set(`vertex-${Eo}`,(...n)=>new GU(...n)),t.set(`vertex-${Mw}`,(...n)=>new qU(...n)),t.set(`vertex-${wm}`,(...n)=>new KU(...n)),t.set(`vertex-${em}`,(...n)=>new XU(...n)),t.set(`vertex-${Uy}`,(...n)=>new YU(...n)),t.set(`vertex-${_S}`,(...n)=>new ZU(...n)),t.set(`vertex-${nb}`,(...n)=>new JU(...n)),t.set(`vertex-${sb}`,(...n)=>new QU(...n)),t.set(`bezierVertex-${tm}`,(n,...s)=>new uw(...s)),t.set(`bezierVertex-${Eo}`,(n,...s)=>new HU(n,...s)),t.set(`splineVertex-${tm}`,(...n)=>new uw(...n)),t.set(`splineVertex-${Eo}`,(...n)=>new jU(...n)),this.creators=t}get(t,n){const s=`${t}-${n}`;return this.creators.get(s)}set(t,n,s){const i=`${t}-${n}`;this.creators.set(i,s)}clear(){this.creators.clear()}}var ds,hx,dx,px,_o,t6,r6,wy;class e6{constructor(t,n=new nae){cn(this,_o);cn(this,ds);cn(this,hx);cn(this,dx);cn(this,px,3);Ar(this,"kind",null);Ar(this,"contours",[]);Ar(this,"_splineProperties",{tightness:0,ends:rm});Ar(this,"userVertexProperties",null);Xs(this,hx,t),Xs(this,ds,t),Xs(this,dx,n);for(const s in ut(this,ds))s!=="position"&&s!=="textureCoordinates"&&(this[s]=function(i){ut(this,ds)[s]=i})}serializeToArray(t){if(t==null)return[];if(t instanceof Number)return[t];if(t instanceof Array)return t;if(t.array instanceof Function)return t.array();throw new Error(`Can't convert ${t} to array!`)}vertexToArray(t){const n=[];for(const s in ut(this,ds)){if(this.userVertexProperties&&s in this.userVertexProperties)continue;const i=t[s];n.push(...this.serializeToArray(i))}for(const s in this.userVertexProperties)s in t?n.push(...this.serializeToArray(t[s])):n.push(...new Array(this.userVertexProperties[s]).fill(0));return n}hydrateValue(t,n){if(n===null)return null;if(n instanceof Number)return t.shift();if(n instanceof Array){const s=[];for(let i=0;i<n.length;i++)s.push(t.shift());return s}else{if(n instanceof De)return new De(t.shift(),t.shift(),t.shift());if(n instanceof _n){const s=[t.shift(),t.shift(),t.shift(),t.shift()];return new _n(s)}}}arrayToVertex(t){const n={},s=[...t];for(const i in ut(this,ds)){if(this.userVertexProperties&&i in this.userVertexProperties)continue;const a=ut(this,ds)[i];n[i]=this.hydrateValue(s,a)}for(const i in this.userVertexProperties){const a=ut(this,ds)[i];n[i]=this.hydrateValue(s,a)}return n}arrayScale(t,n){return t.map(s=>s*n)}arraySum(t,...n){return t.map((s,i)=>{let a=s;for(let o=0;o<n.length;o++)a+=n[o][i];return a})}arrayMinus(t,n){return t.map((s,i)=>s-n[i])}evaluateCubicBezier([t,n,s,i],a){return this.arraySum(this.arrayScale(t,Math.pow(1-a,3)),this.arrayScale(n,3*Math.pow(1-a,2)*a),this.arrayScale(s,3*(1-a)*Math.pow(a,2)),this.arrayScale(i,Math.pow(a,3)))}evaluateQuadraticBezier([t,n,s],i){return this.arraySum(this.arrayScale(t,Math.pow(1-i,2)),this.arrayScale(n,2*(1-i)*i),this.arrayScale(s,i*i))}catmullRomToBezier(t,n){let s=1-n,i=[];for(let a=0;a+3<t.length;a++){const[o,u,l,c]=t.slice(a,a+4),h=this.arraySum(u,this.arrayScale(this.arrayMinus(l,o),s/6)),d=this.arraySum(l,this.arrayScale(this.arrayMinus(u,c),s/6)),p=l;i.push([h,d,p])}return i}at(t,n,s){let i,a;switch(i=this.contours.at(t),arguments.length){case 1:return i;case 2:return i.primitives.at(n);case 3:return a=i.primitives.at(n),a.vertices.at(s)}}reset(){Xs(this,ds,{...ut(this,hx)}),this.kind=null,this.contours=[],this.userVertexProperties=null}vertexProperty(t,n){this.userVertexProperties=this.userVertexProperties||{};const s=this.vertexPropertyKey(t),i=Array.isArray(n)?n:[n];this.userVertexProperties[s]||(this.userVertexProperties[s]=i.length),ut(this,ds)[s]=i}vertexPropertyName(t){return t.replace(/Src$/,"")}vertexPropertyKey(t){return t+"Src"}bezierOrder(...t){Xs(this,px,t)}splineProperty(t,n){this._splineProperties[t]=n}splineProperties(t){if(t)for(const n in t)this.splineProperty(n,t[n]);else return this._splineProperties}vertex(t,n,{isClosing:s=!1}={}){const i=es(this,_o,wy).call(this,"vertex",t,n);i.isClosing=s}bezierVertex(t,n){es(this,_o,wy).call(this,"bezierVertex",t,n)}splineVertex(t,n){es(this,_o,wy).call(this,"splineVertex",t,n)}arcVertex(t,n){es(this,_o,wy).call(this,"arcVertex",t,n)}beginContour(t=Eo){var n;((n=this.at(-1))==null?void 0:n.kind)===tm&&this.contours.pop(),this.contours.push(new WU(t))}endContour(t=zh,n=this.contours.length-1){const s=this.at(n);if(t===ib){const i=s.kind===Eo,a=this.at(n,0,0),o=Object.hasOwn(a,"position"),u=this.at(n,-1);if(i&&o)if(u.handlesClose())u.close(a);else{const l=this.contours.splice(n+1,this.contours.length-n-1),c=ut(this,ds);Xs(this,ds,{...c});for(const h in a)["position","textureCoordinates"].includes(h)||(ut(this,ds)[h]=a[h]);this.vertex(a.position,a.textureCoordinates,{isClosing:!0}),Xs(this,ds,c),this.contours.push(...l)}}}beginShape(t=Eo){this.kind=t,this.beginContour(t)}endShape(t=zh){t===ib&&this.endContour(t,0)}accept(t){for(const n of this.contours)n.accept(t)}}ds=new WeakMap,hx=new WeakMap,dx=new WeakMap,px=new WeakMap,_o=new WeakSet,t6=function(t,n){return ut(this,ds).position=t,n!==void 0&&(ut(this,ds).textureCoordinates=n),new UU(ut(this,ds))},r6=function(t,n,...s){let i=ut(this,dx).get(t,n);return t==="bezierVertex"?i(ut(this,px),...s):i(...s)},wy=function(t,n,s){let i=t,a=this.at(-1).kind,o=es(this,_o,t6).call(this,n,s);return es(this,_o,r6).call(this,i,a,o).addToShape(this)};class ig{constructor(){if(this.constructor===ig)throw new Error("PrimitiveVisitor is an abstract class: it cannot be instantiated.")}visitAnchor(t){throw new Error("Method visitAnchor() has not been implemented.")}visitLineSegment(t){throw new Error("Method visitLineSegment() has not been implemented.")}visitBezierSegment(t){throw new Error("Method visitBezierSegment() has not been implemented.")}visitSplineSegment(t){throw new Error("Method visitSplineSegment() has not been implemented.")}visitArcSegment(t){throw new Error("Method visitArcSegment() has not been implemented.")}visitPoint(t){throw new Error("Method visitPoint() has not been implemented.")}visitLine(t){throw new Error("Method visitLine() has not been implemented.")}visitTriangle(t){throw new Error("Method visitTriangle() has not been implemented.")}visitQuad(t){throw new Error("Method visitQuad() has not been implemented.")}visitTriangleFan(t){throw new Error("Method visitTriangleFan() has not been implemented.")}visitTriangleStrip(t){throw new Error("Method visitTriangleStrip() has not been implemented.")}visitQuadStrip(t){throw new Error("Method visitQuadStrip() has not been implemented.")}}class n6 extends ig{constructor({strokeWeight:n}){super();Ar(this,"path",new Path2D);Ar(this,"strokeWeight");this.strokeWeight=n}visitAnchor(n){let s=n.getEndVertex();this.path.moveTo(s.position.x,s.position.y)}visitLineSegment(n){if(n.isClosing)this.path.closePath();else{let s=n.getEndVertex();this.path.lineTo(s.position.x,s.position.y)}}visitBezierSegment(n){let[s,i,a]=n.vertices;switch(n.order){case 2:this.path.quadraticCurveTo(s.position.x,s.position.y,i.position.x,i.position.y);break;case 3:this.path.bezierCurveTo(s.position.x,s.position.y,i.position.x,i.position.y,a.position.x,a.position.y);break}}visitSplineSegment(n){const s=n._shape;if(n._splineProperties.ends===Xf&&!n._comesAfterSegment){let o=n._firstInterpolatedVertex;this.path.moveTo(o.position.x,o.position.y)}const i=n.getControlPoints().map(o=>s.vertexToArray(o));let a=s.catmullRomToBezier(i,n._splineProperties.tightness).map(o=>o.map(u=>s.arrayToVertex(u)));for(const o of a){const u=o.flatMap(l=>[l.position.x,l.position.y]);this.path.bezierCurveTo(...u)}}visitPoint(n){const{x:s,y:i}=n.vertices[0].position;this.path.moveTo(s,i),this.path.lineTo(s+1e-5,i)}visitLine(n){const{x:s,y:i}=n.vertices[0].position,{x:a,y:o}=n.vertices[1].position;this.path.moveTo(s,i),this.path.lineTo(a,o)}visitTriangle(n){const[s,i,a]=n.vertices;this.path.moveTo(s.position.x,s.position.y),this.path.lineTo(i.position.x,i.position.y),this.path.lineTo(a.position.x,a.position.y),this.path.closePath()}visitQuad(n){const[s,i,a,o]=n.vertices;this.path.moveTo(s.position.x,s.position.y),this.path.lineTo(i.position.x,i.position.y),this.path.lineTo(a.position.x,a.position.y),this.path.lineTo(o.position.x,o.position.y),this.path.closePath()}visitTriangleFan(n){const[s,...i]=n.vertices;for(let a=0;a<i.length-1;a++){const o=i[a],u=i[a+1];this.path.moveTo(s.position.x,s.position.y),this.path.lineTo(o.position.x,o.position.y),this.path.lineTo(u.position.x,u.position.y),this.path.closePath()}}visitTriangleStrip(n){for(let s=0;s<n.vertices.length-2;s++){const i=n.vertices[s],a=n.vertices[s+1],o=n.vertices[s+2];this.path.moveTo(i.position.x,i.position.y),this.path.lineTo(a.position.x,a.position.y),this.path.lineTo(o.position.x,o.position.y),this.path.closePath()}}visitQuadStrip(n){for(let s=0;s<n.vertices.length-3;s+=2){const i=n.vertices[s],a=n.vertices[s+1],o=n.vertices[s+2],u=n.vertices[s+3];this.path.moveTo(i.position.x,i.position.y),this.path.lineTo(a.position.x,a.position.y),this.path.lineTo(u.position.x,u.position.y),this.path.lineTo(o.position.x,o.position.y),this.path.closePath()}}}class s6 extends ig{constructor({curveDetail:n=1}={}){super();Ar(this,"contours",[]);Ar(this,"curveDetail");this.curveDetail=n}lastContour(){return this.contours[this.contours.length-1]}visitAnchor(n){this.contours.push([]);const s=n._nextPrimitive;s!=null&&s.canOverrideAnchor?this.lastContour().push(s._firstInterpolatedVertex):this.lastContour().push(n.getEndVertex())}visitLineSegment(n){this.lastContour().push(n.getEndVertex())}visitBezierSegment(n){const s=this.lastContour(),i=Math.max(1,Math.ceil(n.hullLength()*this.curveDetail)),a=[n.getStartVertex(),...n.vertices].map(o=>n._shape.vertexToArray(o));for(let o=0;o<i;o++){const u=(o+1)/i;s.push(n._shape.arrayToVertex(n.order===3?n._shape.evaluateCubicBezier(a,u):n._shape.evaluateQuadraticBezier(a,u)))}}visitSplineSegment(n){const s=n._shape,i=this.lastContour(),a=n.getControlPoints().map(l=>s.vertexToArray(l));let o=s.catmullRomToBezier(a,n._splineProperties.tightness),u=s.vertexToArray(n._firstInterpolatedVertex);for(const l of o){const c=[u,...l],h=Math.max(1,Math.ceil(zU(c.map(d=>s.arrayToVertex(d)))*this.curveDetail));for(let d=0;d<h;d++){const p=(d+1)/h;i.push(s.arrayToVertex(s.evaluateCubicBezier(c,p)))}u=l[2]}}visitPoint(n){this.contours.push(n.vertices.slice())}visitLine(n){this.contours.push(n.vertices.slice())}visitTriangle(n){this.contours.push(n.vertices.slice())}visitQuad(n){this.contours.push(n.vertices.slice())}visitTriangleFan(n){this.contours.push(n.vertices.slice())}visitTriangleStrip(n){this.contours.push(n.vertices.slice())}visitQuadStrip(n){this.contours.push(n.vertices.slice())}}class sae extends ig{constructor(){super()}}function TT(r,t){r.Shape=e6,r.Contour=WU,r.ShapePrimitive=Ja,r.Vertex=UU,r.Anchor=uw,r.Segment=qh,r.LineSegment=GU,r.BezierSegment=HU,r.SplineSegment=jU,r.Point=qU,r.Line=KU,r.Triangle=XU,r.Quad=YU,r.TriangleFan=ZU,r.TriangleStrip=JU,r.QuadStrip=QU,r.PrimitiveVisitor=ig,r.PrimitiveToPath2DConverter=n6,r.PrimitiveToVerticesConverter=s6,r.PointAtLengthGetter=sae,t.bezierOrder=function(n){return this._renderer.bezierOrder(n)},t.splineVertex=function(...n){let s=0,i=0,a=0,o=0,u=0;n.length===2?[s,i]=n:n.length===4?[s,i,o,u]=n:n.length===3?[s,i,a]=n:n.length===5&&([s,i,a,o,u]=n),this._renderer.splineVertex(s,i,a,o,u)},t.splineProperty=function(n,s){return this._renderer.splineProperty(n,s)},t.splineProperties=function(n){return this._renderer.splineProperties(n)},t.vertex=function(n,s){let i,a,o;i=a=o=0,arguments.length===3?i=arguments[2]:arguments.length===4?(a=arguments[2],o=arguments[3]):arguments.length===5&&(i=arguments[2],a=arguments[3],o=arguments[4]),this._renderer.vertex(n,s,i,a,o)},t.beginContour=function(n){this._renderer.beginContour(n)},t.endContour=function(n=zh){this._renderer.endContour(n)}}typeof p5<"u"&&TT(p5,p5.prototype);var go;class iae{constructor(t){cn(this,go,{});for(const n in t)this[n]=t[n]}setValue(t,n){t in ut(this,go)||(ut(this,go)[t]=this[t]),this[t]=n}getDiff(){const t=ut(this,go);return Xs(this,go,{}),t}getModified(){return ut(this,go)}applyDiff(t){for(const n in ut(this,go))this[n]=ut(this,go)[n];Xs(this,go,t)}}go=new WeakMap;var jI=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function AT(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}function aae(r){if(Object.prototype.hasOwnProperty.call(r,"__esModule"))return r;var t=r.default;if(typeof t=="function"){var n=function s(){return this instanceof s?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};n.prototype=t.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(r).forEach(function(s){var i=Object.getOwnPropertyDescriptor(r,s);Object.defineProperty(n,s,i.get?i:{enumerable:!0,get:function(){return r[s]}})}),n}var lw={exports:{}},oae=lw.exports,GP;function uae(){return GP||(GP=1,function(r){/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */var t=t||function(n){if(!(typeof n>"u"||typeof navigator<"u"&&/MSIE [1-9]\./.test(navigator.userAgent))){var s=n.document,i=function(){return n.URL||n.webkitURL||n},a=s.createElementNS("http://www.w3.org/1999/xhtml","a"),o="download"in a,u=function(w){var v=new MouseEvent("click");w.dispatchEvent(v)},l=/constructor/i.test(n.HTMLElement)||n.safari,c=/CriOS\/[\d]+/.test(navigator.userAgent),h=function(w){(n.setImmediate||n.setTimeout)(function(){throw w},0)},d="application/octet-stream",p=1e3*40,f=function(w){var v=function(){typeof w=="string"?i().revokeObjectURL(w):w.remove()};setTimeout(v,p)},m=function(w,v,S){v=[].concat(v);for(var E=v.length;E--;){var C=w["on"+v[E]];if(typeof C=="function")try{C.call(w,S||w)}catch(I){h(I)}}},g=function(w){return/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(w.type)?new Blob(["\uFEFF",w],{type:w.type}):w},y=function(w,v,S){S||(w=g(w));var E=this,C=w.type,I=C===d,_,A=function(){m(E,"writestart progress write writeend".split(" "))},k=function(){if((c||I&&l)&&n.FileReader){var N=new FileReader;N.onloadend=function(){var F=c?N.result:N.result.replace(/^data:[^;]*;/,"data:attachment/file;"),P=n.open(F,"_blank");P||(n.location.href=F),F=void 0,E.readyState=E.DONE,A()},N.readAsDataURL(w),E.readyState=E.INIT;return}if(_||(_=i().createObjectURL(w)),I)n.location.href=_;else{var D=n.open(_,"_blank");D||(n.location.href=_)}E.readyState=E.DONE,A(),f(_)};if(E.readyState=E.INIT,o){_=i().createObjectURL(w),setTimeout(function(){a.href=_,a.download=v,u(a),A(),f(_),E.readyState=E.DONE});return}k()},b=y.prototype,x=function(w,v,S){return new y(w,v||w.name||"download",S)};return typeof navigator<"u"&&navigator.msSaveOrOpenBlob?function(w,v,S){return v=v||w.name||"download",S||(w=g(w)),navigator.msSaveOrOpenBlob(w,v)}:(b.abort=function(){},b.readyState=b.INIT=0,b.WRITING=1,b.DONE=2,b.error=b.onwritestart=b.onprogress=b.onwrite=b.onabort=b.onerror=b.onwriteend=null,x)}}(typeof self<"u"&&self||typeof window<"u"&&window||oae.content);r.exports&&(r.exports.saveAs=t)}(lw)),lw.exports}var lae=uae();function DT(r,t,n){const i=Hw(t,n)[0];let a=r;a instanceof Blob||(a=new Blob([r])),lae.saveAs(a,i)}function Hw(r,t){(!t||t===!0||t==="true")&&(t=""),r||(r="untitled");let n="";return r&&r.includes(".")&&(n=r.split(".").pop()),t&&n!==t&&(n=t,r=`${r}.${n}`),[r,n]}class Do{constructor(t,n){this.width=t,this.height=n,this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.height,this.drawingContext=this.canvas.getContext("2d"),this._pixelsState=this,this._pixelDensity=1,this.gifProperties=null,this._modified=!1,this.pixels=[]}pixelDensity(t){return typeof t<"u"?(t<=0&&(t=1),this._pixelDensity=t,this.width/=t,this.height/=t,this):this._pixelDensity}_animateGif(t){const n=this.gifProperties,s=t._lastRealFrameTime||window.performance.now();if(n.lastChangeTime===0&&(n.lastChangeTime=s),n.playing){n.timeDisplayed=s-n.lastChangeTime;const i=n.frames[n.displayIndex].delay;if(n.timeDisplayed>=i){const a=Math.floor(n.timeDisplayed/i);if(n.timeDisplayed=0,n.lastChangeTime=s,n.displayIndex+=a,n.loopCount=Math.floor(n.displayIndex/n.numFrames),n.loopLimit!==null&&n.loopCount>=n.loopLimit)n.playing=!1;else{const o=n.displayIndex%n.numFrames;this.drawingContext.putImageData(n.frames[o].image,0,0),n.displayIndex=o,this.setModified(!0)}}}}loadPixels(){const t=this._pixelsState,n=this._pixelDensity,s=this.width*n,i=this.height*n,a=this.drawingContext.getImageData(0,0,s,i);t.imageData=a,this.pixels=t.pixels=a.data,this.setModified(!0)}updatePixels(t,n,s,i){const a=this._pixelsState,o=this._pixelDensity;t===void 0&&n===void 0&&s===void 0&&i===void 0&&(t=0,n=0,s=this.width,i=this.height),t*=o,n*=o,s*=o,i*=o,this.gifProperties&&(this.gifProperties.frames[this.gifProperties.displayIndex].image=a.imageData),this.drawingContext.putImageData(a.imageData,t,n,0,0,s,i),this.setModified(!0)}get(t,n,s,i){const a=this._pixelsState,o=this._pixelDensity,u=this.canvas;if(typeof t>"u"&&typeof n>"u")t=n=0,s=a.width,i=a.height;else if(t*=o,n*=o,typeof s>"u"&&typeof i>"u")return t<0||n<0||t>=u.width||n>=u.height?[0,0,0,0]:this._getPixel(t,n);const l=new Do(s*o,i*o);return l.pixelDensity(o),l.canvas.getContext("2d").drawImage(u,t,n,s*o,i*o,0,0,s*o,i*o),l}_getPixel(t,n){let s,i;return s=this.drawingContext.getImageData(t,n,1,1).data,i=0,[s[i+0],s[i+1],s[i+2],s[i+3]]}set(t,n,s){t=Math.floor(t),n=Math.floor(n);const i=this._pixelsState;if(s instanceof Do)this.drawingContext.save(),this.drawingContext.setTransform(1,0,0,1,0,0),this.drawingContext.scale(this._pixelDensity,this._pixelDensity),this.drawingContext.clearRect(t,n,s.width,s.height),this.drawingContext.drawImage(s.canvas,t,n),this.drawingContext.restore();else{let a=0,o=0,u=0,l=0,c=4*(n*this._pixelDensity*(this.width*this._pixelDensity)+t*this._pixelDensity);if(i.imageData||i.loadPixels(),typeof s=="number")c<i.pixels.length&&(a=s,o=s,u=s,l=255);else if(Array.isArray(s)){if(s.length<4)throw new Error("pixel array must be of the form [R, G, B, A]");c<i.pixels.length&&(a=s[0],o=s[1],u=s[2],l=s[3])}else s instanceof p5.Color&&c<i.pixels.length&&([a,o,u,l]=s._getRGBA([255,255,255,255]));for(let h=0;h<this._pixelDensity;h++)for(let d=0;d<this._pixelDensity;d++)c=4*((n*this._pixelDensity+d)*this.width*this._pixelDensity+(t*this._pixelDensity+h)),i.pixels[c]=a,i.pixels[c+1]=o,i.pixels[c+2]=u,i.pixels[c+3]=l}this.setModified(!0)}resize(t,n){t===0&&n===0?(t=this.canvas.width,n=this.canvas.height):t===0?t=this.canvas.width*n/this.canvas.height:n===0&&(n=this.canvas.height*t/this.canvas.width),t=Math.floor(t),n=Math.floor(n);const s=document.createElement("canvas");if(s.width=t,s.height=n,this.gifProperties){const i=this.gifProperties,a=(o,u)=>{let l=0;for(let c=0;c<u.height;c++)for(let h=0;h<u.width;h++){const d=Math.floor(h*o.width/u.width);let f=(Math.floor(c*o.height/u.height)*o.width+d)*4;u.data[l++]=o.data[f++],u.data[l++]=o.data[f++],u.data[l++]=o.data[f++],u.data[l++]=o.data[f++]}};for(let o=0;o<i.numFrames;o++){const u=this.drawingContext.createImageData(t,n);a(i.frames[o].image,u),i.frames[o].image=u}}s.getContext("2d").drawImage(this.canvas,0,0,this.canvas.width,this.canvas.height,0,0,s.width,s.height),this.canvas.width=this.width=t,this.canvas.height=this.height=n,this.drawingContext.drawImage(s,0,0,t,n,0,0,t,n),this.pixels.length>0&&this.loadPixels(),this.setModified(!0)}copy(...t){let n,s,i,a,o,u,l,c,h;if(t.length===9)n=t[0],s=t[1],i=t[2],a=t[3],o=t[4],u=t[5],l=t[6],c=t[7],h=t[8];else if(t.length===8)n=this,s=t[0],i=t[1],a=t[2],o=t[3],u=t[4],l=t[5],c=t[6],h=t[7];else throw new Error("Signature not supported");this._copyHelper(this,n,s,i,a,o,u,l,c,h)}_copyHelper(t,n,s,i,a,o,u,l,c,h){const d=n.canvas.width/n.width;let p=0,f=0;n._renderer&&n._renderer.isP3D&&(p=n.width/2,f=n.height/2),t._renderer&&t._renderer.isP3D?(t.push(),t.resetMatrix(),t.noLights(),t.blendMode(t.BLEND),t.imageMode(t.CORNER),t._renderer.image(n,s+p,i+f,a,o,u,l,c,h),t.pop()):t.drawingContext.drawImage(n.canvas,d*(s+p),d*(i+f),d*a,d*o,u,l,c,h)}mask(t){t===void 0&&(t=this);const n=this.drawingContext.globalCompositeOperation;let s=this._pixelDensity,i=1;t instanceof Gt&&(i=t._pInst._renderer._pixelDensity);const a=[t,0,0,i*t.width,i*t.height,0,0,s*this.width,s*this.height];if(this.drawingContext.globalCompositeOperation="destination-in",this.gifProperties){for(let o=0;o<this.gifProperties.frames.length;o++)this.drawingContext.putImageData(this.gifProperties.frames[o].image,0,0),this.copy(...a),this.gifProperties.frames[o].image=this.drawingContext.getImageData(0,0,s*this.width,s*this.height);this.drawingContext.putImageData(this.gifProperties.frames[this.gifProperties.displayIndex].image,0,0)}else this.copy(...a);this.drawingContext.globalCompositeOperation=n,this.setModified(!0)}filter(t,n){jr.apply(this.canvas,jr[t],n),this.setModified(!0)}blend(...t){const n=this.drawingContext.globalCompositeOperation,s=t[t.length-1],i=Array.prototype.slice.call(t,0,t.length-1);this.drawingContext.globalCompositeOperation=s,this.copy(...i),this.drawingContext.globalCompositeOperation=n,this.setModified(!0)}setModified(t){this._modified=t}isModified(){return this._modified}save(t,n){if(this.gifProperties)cae(this,t);else{let s=this.canvas;n=n||Hw(t,n)[1]||"png";let i;switch(n){default:i="image/png";break;case"webp":i="image/webp";break;case"jpeg":case"jpg":i="image/jpeg";break}s.toBlob(a=>{DT(a,t,n)},i)}}async toBlob(){return new Promise(t=>{this.canvas.toBlob(t)})}reset(){if(this.gifProperties){const t=this.gifProperties;t.playing=!0,t.timeSinceStart=0,t.timeDisplayed=0,t.lastChangeTime=0,t.loopCount=0,t.displayIndex=0,this.drawingContext.putImageData(t.frames[0].image,0,0)}}getCurrentFrame(){if(this.gifProperties){const t=this.gifProperties;return t.displayIndex%t.numFrames}}setFrame(t){if(this.gifProperties){const n=this.gifProperties;t<n.numFrames&&t>=0?(n.timeDisplayed=0,n.lastChangeTime=0,n.displayIndex=t,this.drawingContext.putImageData(n.frames[t].image,0,0)):console.log("Cannot set GIF to a frame number that is higher than total number of frames or below zero.")}}numFrames(){if(this.gifProperties)return this.gifProperties.numFrames}play(){this.gifProperties&&(this.gifProperties.playing=!0)}pause(){this.gifProperties&&(this.gifProperties.playing=!1)}delay(t,n){if(this.gifProperties){const s=this.gifProperties;if(n<s.numFrames&&n>=0)s.frames[n].delay=t;else for(const i of s.frames)i.delay=t}}}function cae(r,t){const n=r.gifProperties;let s=n.loopLimit;s===1?s=null:s===null&&(s=0);const i=new Uint8Array(r.width*r.height*n.numFrames),a=[],o={};for(let x=0;x<n.numFrames;x++){const w=new Set,v=n.frames[x].image.data,S=v.length,E=new Uint32Array(r.width*r.height);for(let I=0,_=0;I<S;I+=4,_++){const A=v[I+0],k=v[I+1],N=v[I+2],D=A<<16|k<<8|N<<0;w.add(D),E[_]=D}const C=[...w].sort().toString();o[C]===void 0?o[C]={freq:1,frames:[x]}:(o[C].freq+=1,o[C].frames.push(x)),a.push(E)}let u=[];const l=Object.keys(o).sort(function(x,w){return o[w].freq-o[x].freq}),c=l[0].split(",").map(x=>parseInt(x));u=u.concat(o[c].frames);const h=new Set(c);for(let x=1;x<l.length;x++){const v=l[x].split(",").map(S=>parseInt(S)).filter(S=>!h.has(S));if(c.length+v.length<=256){for(let S=0;S<v.length;S++)c.push(v[S]),h.add(v[S]);u=u.concat(o[l[x]].frames)}}u=new Set(u);const d={};for(let x=0;x<c.length;x++)d[c[x]]||(d[c[x]]=x);let p=1;for(;p<c.length;)p<<=1;c.length=p;const f={loop:s,palette:new Uint32Array(c)},m=new omggif.GifWriter(i,r.width,r.height,f);let g={};for(let x=0;x<n.numFrames;x++){const w=!u.has(x),v=w?[]:c,S=new Uint8Array(r.width*r.height),E={},C=new Set;a[x].forEach((A,k)=>{w?(E[A]===void 0&&(E[A]=v.length,v.push(A)),S[k]=E[A]):S[k]=d[A],x>0&&a[x-1][k]!==A&&C.add(A)});const I={},_=v.filter(A=>!C.has(A));if(_.length>0){const A=_[0],k=w?E[A]:d[A];if(x>0){for(let N=0;N<a[x].length;N++)a[x-1][N]===a[x][N]&&(S[N]=k);I.transparent=k,g.frameOpts.disposal=1}}if(I.delay=n.frames[x].delay/10,w){let A=1;for(;A<v.length;)A<<=1;v.length=A,I.palette=new Uint32Array(v)}x>0&&m.addFrame(0,0,r.width,r.height,g.pixelPaletteIndex,g.frameOpts),g={pixelPaletteIndex:S,frameOpts:I}}g.frameOpts.disposal=1,m.addFrame(0,0,r.width,r.height,g.pixelPaletteIndex,g.frameOpts);const y="gif",b=new Blob([i.slice(0,m.end())],{type:"image/gif"});DT(b,t,y)}function i6(r,t){r.Image=Do}typeof p5<"u"&&i6(p5,p5.prototype);class FT{constructor(t={}){for(const n in t)this[n]=t[n]}clone(){return new FT(this)}}const CS=class CS{constructor(t,n,s,i){this._pInst=t,this._isMainCanvas=i,this.pixels=[],this._pixelDensity=Math.ceil(window.devicePixelRatio)||1,this.width=n,this.height=s,this._events={},i&&(this._isMainCanvas=!0),this.states=new iae(CS.states),this.states.strokeColor=new _n([0,0,0]),this.states.fillColor=new _n([1,1,1]),this._pushPopStack=[],this._pushPopDepth=0,this._clipping=!1,this._clipInvert=!1,this._currentShape=void 0}get currentShape(){return this._currentShape||(this._currentShape=new e6(this.getCommonVertexProperties())),this._currentShape}remove(){}pixelDensity(t){let n;return typeof t=="number"?(t!==this._pixelDensity&&(this._pixelDensity=t),n=this,this.resize(this.width,this.height)):n=this._pixelDensity,n}push(){this._pushPopDepth++,this._pushPopStack.push(this.states.getDiff())}pop(){this._pushPopDepth--;const t=this._pushPopStack.pop()||{},n=this.states.getModified();this.states.applyDiff(t),this.updateShapeVertexProperties(n),this.updateShapeProperties(n)}bezierOrder(t){if(t===void 0)return this.states.bezierOrder;this.states.setValue("bezierOrder",t),this.updateShapeProperties()}bezierVertex(t,n,s=0,i=0,a=0){const o=new De(t,n,s),u=this.getSupportedIndividualVertexProperties().textureCoordinates?new De(i,a):void 0;this.currentShape.bezierVertex(o,u)}splineProperty(t,n){if(n===void 0)return this.states.splineProperties[t];this.states.setValue("splineProperties",this.states.splineProperties.clone()),this.states.splineProperties[t]=n,this.updateShapeProperties()}splineProperties(t){if(t)for(const n in t)this.splineProperty(n,t[n]);else return{...this.states.splineProperties}}splineVertex(t,n,s=0,i=0,a=0){const o=new De(t,n,s),u=this.getSupportedIndividualVertexProperties().textureCoordinates?new De(i,a):void 0;this.currentShape.splineVertex(o,u)}curveDetail(t){if(t===void 0)return this.states.curveDetail;this.states.setValue("curveDetail",t)}beginShape(...t){this.currentShape.reset(),this.updateShapeVertexProperties(),this.currentShape.beginShape(...t)}endShape(...t){this.currentShape.endShape(...t),this.drawShape(this.currentShape)}beginContour(t){this.currentShape.beginContour(t)}endContour(t){this.currentShape.endContour(t)}drawShape(t,n){throw new Error("Unimplemented")}vertex(t,n,s=0,i=0,a=0){const o=new De(t,n,s),u=this.getSupportedIndividualVertexProperties().textureCoordinates?new De(i,a):void 0;this.currentShape.vertex(o,u)}bezier(t,n,s,i,a,o,u,l){const c=this._pInst.bezierOrder();return this._pInst.bezierOrder(c),this._pInst.beginShape(),this._pInst.bezierVertex(t,n),this._pInst.bezierVertex(s,i),this._pInst.bezierVertex(a,o),this._pInst.bezierVertex(u,l),this._pInst.endShape(),this}spline(...t){if(t.length===2*4){const[n,s,i,a,o,u,l,c]=t;this._pInst.beginShape(),this._pInst.splineVertex(n,s),this._pInst.splineVertex(i,a),this._pInst.splineVertex(o,u),this._pInst.splineVertex(l,c),this._pInst.endShape()}else if(t.length===3*4){const[n,s,i,a,o,u,l,c,h,d,p,f]=t;this._pInst.beginShape(),this._pInst.splineVertex(n,s,i),this._pInst.splineVertex(a,o,u),this._pInst.splineVertex(l,c,h),this._pInst.splineVertex(d,p,f),this._pInst.endShape()}return this}beginClip(t={}){if(this._clipping)throw new Error("It looks like you're trying to clip while already in the middle of clipping. Did you forget to endClip()?");this._clipping=!0,this._clipInvert=t.invert}endClip(){if(!this._clipping)throw new Error("It looks like you've called endClip() without beginClip(). Did you forget to call beginClip() first?");this._clipping=!1}resize(t,n){this.width=t,this.height=n}get(t,n,s,i){const a=this._pixelDensity,o=this.canvas;if(typeof t>"u"&&typeof n>"u")t=n=0,s=this.width,i=this.height;else if(t*=a,n*=a,typeof s>"u"&&typeof i>"u")return t<0||n<0||t>=o.width||n>=o.height?[0,0,0,0]:this._getPixel(t,n);const u=new Do(s*a,i*a);return u.pixelDensity(a),u.canvas.getContext("2d").drawImage(o,t,n,s*a,i*a,0,0,s*a,i*a),u}scale(t,n){}fill(...t){this.states.setValue("fillSet",!0),this.states.setValue("fillColor",this._pInst.color(...t)),this.updateShapeVertexProperties()}noFill(){this.states.setValue("fillColor",null)}strokeWeight(t){if(t===void 0)return this.states.strokeWeight;this.states.setValue("strokeWeight",t)}stroke(...t){this.states.setValue("strokeSet",!0),this.states.setValue("strokeColor",this._pInst.color(...t)),this.updateShapeVertexProperties()}noStroke(){this.states.setValue("strokeColor",null)}getCommonVertexProperties(){return{}}getSupportedIndividualVertexProperties(){return{textureCoordinates:!1}}updateShapeProperties(t){if(!t||t.bezierOrder||t.splineProperties){const n=this.currentShape;n.bezierOrder(this.states.bezierOrder),n.splineProperty("ends",this.states.splineProperties.ends),n.splineProperty("tightness",this.states.splineProperties.tightness)}}updateShapeVertexProperties(t){const n=this.getCommonVertexProperties();if(!t||Object.keys(t).some(s=>s in n)){const s=this.currentShape;for(const i in n)s[i](n[i])}}_applyDefaults(){return this}};Ar(CS,"states",{strokeColor:null,strokeSet:!1,fillColor:null,fillSet:!1,tint:null,imageMode:xa,rectMode:xa,ellipseMode:Ki,strokeWeight:1,textFont:{family:"sans-serif"},textLeading:15,leadingSet:!1,textSize:12,textAlign:rU,textBaseline:nU,bezierOrder:3,splineProperties:new FT({ends:rm,tightness:0}),textWrap:aU,fontStyle:eu,fontStretch:eu,fontWeight:eu,lineHeight:eu,fontVariant:eu,direction:"inherit"});let Gt=CS;function hae(r,t){r.Renderer=Gt}class db extends Sr{constructor(t,n){super(t,n);const s=this;this.elt.crossOrigin="anonymous",this._prevTime=0,this._cueIDCounter=0,this._cues=[],this.pixels=[],this._pixelsState=this,this._pixelDensity=1,this._modified=!1,this._frameOnCanvas=-1,Object.defineProperty(s,"src",{get(){const i=s.elt.children[0].src,a=s.elt.src===window.location.href?"":s.elt.src;return i===window.location.href?a:i},set(i){for(let o=0;o<s.elt.children.length;o++)s.elt.removeChild(s.elt.children[o]);const a=document.createElement("source");a.src=i,t.appendChild(a),s.elt.src=i,s.modified=!0}}),s._onended=function(){},s.elt.onended=function(){s._onended(s)}}play(){this.elt.currentTime===this.elt.duration&&(this.elt.currentTime=0);let t;return this.elt.readyState>1?t=this.elt.play():(this.elt.load(),t=this.elt.play()),t&&t.catch&&t.catch(n=>{n.name==="NotAllowedError"?typeof IS_MINIFIED>"u"?p5._friendlyAutoplayError(this.src):console.error(n):console.error("Media play method encountered an unexpected error",n)}),this}stop(){return this.elt.pause(),this.elt.currentTime=0,this}pause(){return this.elt.pause(),this}loop(){return this.elt.setAttribute("loop",!0),this.play(),this}noLoop(){return this.elt.removeAttribute("loop"),this}_setupAutoplayFailDetection(){const t=setTimeout(()=>{typeof IS_MINIFIED>"u"?p5._friendlyAutoplayError(this.src):console.error(e)},500);this.elt.addEventListener("play",()=>clearTimeout(t),{passive:!0,once:!0})}autoplay(t){const n=this.elt.getAttribute("autoplay");if(this.elt.setAttribute("autoplay",t),t&&!n){const s=()=>this._setupAutoplayFailDetection();this.elt.readyState===4?s():this.elt.addEventListener("canplay",s,{passive:!0,once:!0})}return this}volume(t){if(typeof t>"u")return this.elt.volume;this.elt.volume=t}speed(t){if(typeof t>"u")return this.presetPlaybackRate||this.elt.playbackRate;this.loadedmetadata?this.elt.playbackRate=t:this.presetPlaybackRate=t}time(t){return typeof t>"u"?this.elt.currentTime:(this.elt.currentTime=t,this)}duration(){return this.elt.duration}_ensureCanvas(){this.canvas||(this.canvas=document.createElement("canvas"),this.drawingContext=this.canvas.getContext("2d"),this.setModified(!0));const t=this._frameOnCanvas!==this._pInst.frameCount;this.loadedmetadata&&t&&(this.canvas.width!==this.elt.width&&(this.canvas.width=this.elt.width,this.canvas.height=this.elt.height,this.width=this.canvas.width,this.height=this.canvas.height),this.drawingContext.clearRect(0,0,this.canvas.width,this.canvas.height),this.flipped===!0&&(this.drawingContext.save(),this.drawingContext.scale(-1,1),this.drawingContext.translate(-this.canvas.width,0)),this.drawingContext.drawImage(this.elt,0,0,this.canvas.width,this.canvas.height),this.flipped===!0&&this.drawingContext.restore(),this.setModified(!0),this._frameOnCanvas=this._pInst.frameCount)}loadPixels(...t){return this._ensureCanvas(),p5.Renderer2D.prototype.loadPixels.apply(this,t)}updatePixels(t,n,s,i){return this.loadedmetadata&&(this._ensureCanvas(),p5.Renderer2D.prototype.updatePixels.call(this,t,n,s,i)),this.setModified(!0),this}get(...t){return this._ensureCanvas(),p5.Renderer2D.prototype.get.apply(this,t)}_getPixel(...t){return this.loadPixels(),p5.Renderer2D.prototype._getPixel.apply(this,t)}set(t,n,s){this.loadedmetadata&&(this._ensureCanvas(),p5.Renderer2D.prototype.set.call(this,t,n,s),this.setModified(!0))}copy(...t){this._ensureCanvas(),fn.copy.apply(this,t)}mask(...t){this.loadPixels(),this.setModified(!0),p5.Image.prototype.mask.apply(this,t)}isModified(){return this._modified}setModified(t){this._modified=t}onended(t){return this._onended=t,this}connect(t){let n,s;if(typeof fn.getAudioContext=="function")n=fn.getAudioContext(),s=p5.soundOut.input;else try{n=t.context,s=n.destination}catch{throw"connect() is meant to be used with Web Audio API or p5.sound.js"}this.audioSourceNode||(this.audioSourceNode=n.createMediaElementSource(this.elt),this.audioSourceNode.connect(s)),t?t.input?this.audioSourceNode.connect(t.input):this.audioSourceNode.connect(t):this.audioSourceNode.connect(s)}disconnect(){if(this.audioSourceNode)this.audioSourceNode.disconnect();else throw"nothing to disconnect"}showControls(){this.elt.style["text-align"]="inherit",this.elt.controls=!0}hideControls(){this.elt.controls=!1}addCue(t,n,s){const i=this._cueIDCounter++,a=new dae(n,t,i,s);return this._cues.push(a),this.elt.ontimeupdate||(this.elt.ontimeupdate=this._onTimeUpdate.bind(this)),i}removeCue(t){for(let n=0;n<this._cues.length;n++)this._cues[n].id===t&&(console.log(t),this._cues.splice(n,1));this._cues.length===0&&(this.elt.ontimeupdate=null)}clearCues(){this._cues=[],this.elt.ontimeupdate=null}_onTimeUpdate(){const t=this.time();for(let n=0;n<this._cues.length;n++){const s=this._cues[n].time,i=this._cues[n].val;this._prevTime<s&&s<=t&&this._cues[n].callback(i)}this._prevTime=t}}let dae=class{constructor(t,n,s,i){this.callback=t,this.time=n,this.id=s,this.val=i}};function a6(r,t){function n(i,a,o){(a._userNode?a._userNode:document.body).appendChild(i);const l=o?new db(i,a):new Sr(i,a);return a._elements.push(l),l}function s(i,a,o,u){const l=document.createElement(a);o=o||"",typeof o=="string"&&(o=[o]);for(const h of o){const d=document.createElement("source");d.setAttribute("src",h),l.appendChild(d)}if(typeof u=="function"){const h=()=>{u(),l.removeEventListener("canplaythrough",h)};l.addEventListener("canplaythrough",h)}const c=n(l,i,!0);return c.loadedmetadata=!1,l.addEventListener("loadedmetadata",()=>{c.width=l.videoWidth,c.height=l.videoHeight,c.elt.width===0&&(c.elt.width=l.videoWidth),c.elt.height===0&&(c.elt.height=l.videoHeight),c.presetPlaybackRate&&(c.elt.playbackRate=c.presetPlaybackRate,delete c.presetPlaybackRate),c.loadedmetadata=!0}),c}t.createVideo=function(i,a){return s(this,"video",i,a)},t.createAudio=function(i,a){return s(this,"audio",i,a)},t.VIDEO="video",t.AUDIO="audio",navigator.mediaDevices===void 0&&(navigator.mediaDevices={}),navigator.mediaDevices.getUserMedia===void 0&&(navigator.mediaDevices.getUserMedia=function(i){const a=navigator.webkitGetUserMedia||navigator.mozGetUserMedia;return a?new Promise(function(o,u){a.call(navigator,i,o,u)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}),t.createCapture=function(...i){if(!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia))throw new DOMException("getUserMedia not supported in this browser");let a=!0,o=!0,u,l,c=!1;for(const f of i)f===t.VIDEO?o=!1:f===t.AUDIO?a=!1:typeof f=="object"?(f.flipped!==void 0&&(c=f.flipped,delete f.flipped),u=Object.assign({},u,f)):typeof f=="function"&&(l=f);u=Object.assign({},{video:a,audio:o},u);const d=document.createElement("video");d.setAttribute("playsinline",""),navigator.mediaDevices.getUserMedia(u).then(function(f){try{"srcObject"in d?d.srcObject=f:d.src=window.URL.createObjectURL(f)}catch{d.src=f}}).catch(f=>{f.name==="NotFoundError"&&r._friendlyError("No webcam found on this device","createCapture"),f.name==="NotAllowedError"&&r._friendlyError("Access to the camera was denied","createCapture"),console.error(f)});const p=n(d,this,!0);return p.loadedmetadata=!1,d.addEventListener("loadedmetadata",function(){d.play(),d.width?(p.width=d.width,p.height=d.height,c&&(p.elt.style.transform="scaleX(-1)")):(p.width=p.elt.width=d.videoWidth,p.height=p.elt.height=d.videoHeight),p.loadedmetadata=!0,l&&l(d.srcObject)}),p.flipped=c,p},r.MediaElement=db}typeof p5<"u"&&a6(p5,p5.prototype);function pae(r,t,n,s,i){let a;return i===xa?a={x:r,y:t,w:Math.abs(n),h:Math.abs(s)}:i===tb?a={x:Math.min(r,n),y:Math.min(t,s),w:Math.abs(n-r),h:Math.abs(s-t)}:i===rb?(n=Math.abs(n),s=Math.abs(s),a={x:r-n,y:t-s,w:2*n,h:2*s}):i===Ki&&(n=Math.abs(n),s=Math.abs(s),a={x:r-n*.5,y:t-s*.5,w:n,h:s}),a}var cw={modeAdjust:pae};function $T(r,t){t._normalizeArcAngles=(n,s,i,a,o)=>{let l;return n=n-bi*Math.floor(n/bi),s=s-bi*Math.floor(s/bi),l=Math.min(Math.abs(n-s),bi-Math.abs(n-s)),o&&(n<=uh?n=Math.atan(i/a*Math.tan(n)):n>uh&&n<=3*uh?n=Math.atan(i/a*Math.tan(n))+FI:n=Math.atan(i/a*Math.tan(n))+bi,s<=uh?s=Math.atan(i/a*Math.tan(s)):s>uh&&s<=3*uh?s=Math.atan(i/a*Math.tan(s))+FI:s=Math.atan(i/a*Math.tan(s))+bi),n>s&&(s+=bi),{start:n,stop:s,correspondToSamePoint:l<1e-5}},t.arc=function(n,s,i,a,o,u,l,c){if(!this._renderer.states.strokeColor&&!this._renderer.states.fillColor)return this;if(o===u)return this;o=this._toRadians(o),u=this._toRadians(u);const h=cw.modeAdjust(n,s,i,a,this._renderer.states.ellipseMode),d=this._normalizeArcAngles(o,u,h.w,h.h,!0);return d.correspondToSamePoint?this._renderer.ellipse([h.x,h.y,h.w,h.h,c]):(this._renderer.arc(h.x,h.y,h.w,h.h,d.start,d.stop,l,c),(this._accessibleOutputs.grid||this._accessibleOutputs.text)&&this._accsOutput("arc",[h.x,h.y,h.w,h.h,d.start,d.stop,l])),this},t.ellipse=function(n,s,i,a,o){return this._renderEllipse(...arguments)},t.circle=function(...n){const s=n.slice(0,2);return s.push(n[2],n[2]),this._renderEllipse(...s)},t._renderEllipse=function(n,s,i,a,o){if(!this._renderer.states.strokeColor&&!this._renderer.states.fillColor)return this;typeof a>"u"&&(a=i);const u=cw.modeAdjust(n,s,i,a,this._renderer.states.ellipseMode);return this._renderer.ellipse([u.x,u.y,u.w,u.h,o]),(this._accessibleOutputs.grid||this._accessibleOutputs.text)&&this._accsOutput("ellipse",[u.x,u.y,u.w,u.h]),this},t.line=function(...n){return this._renderer.states.strokeColor&&this._renderer.line(...n),(this._accessibleOutputs.grid||this._accessibleOutputs.text)&&this._accsOutput("line",n),this},t.point=function(...n){return this._renderer.states.strokeColor&&(n.length===1&&n[0]instanceof r.Vector?this._renderer.point.call(this._renderer,n[0].x,n[0].y,n[0].z):(this._renderer.point(...n),(this._accessibleOutputs.grid||this._accessibleOutputs.text)&&this._accsOutput("point",n))),this},t.quad=function(...n){return(this._renderer.states.strokeColor||this._renderer.states.fillColor)&&(this._renderer.isP3D&&n.length<12?this._renderer.quad.call(this._renderer,n[0],n[1],0,n[2],n[3],0,n[4],n[5],0,n[6],n[7],0,n[8],n[9]):(this._renderer.quad(...n),(this._accessibleOutputs.grid||this._accessibleOutputs.text)&&this._accsOutput("quadrilateral",n))),this},t.rect=function(...n){return this._renderRect(...n)},t.square=function(n,s,i,a,o,u,l){return this._renderRect.call(this,n,s,i,i,a,o,u,l)},t._renderRect=function(){if(this._renderer.states.strokeColor||this._renderer.states.fillColor){arguments.length===3&&(arguments[3]=arguments[2]);const n=cw.modeAdjust(arguments[0],arguments[1],arguments[2],arguments[3],this._renderer.states.rectMode);this._renderer.states.rectMode===xa&&(n.w=arguments[2],n.h=arguments[3]);const s=[n.x,n.y,n.w,n.h];for(let i=4;i<arguments.length;i++)s[i]=arguments[i];this._renderer.rect(s),(this._accessibleOutputs.grid||this._accessibleOutputs.text)&&this._accsOutput("rectangle",[n.x,n.y,n.w,n.h])}return this},t.triangle=function(...n){return(this._renderer.states.strokeColor||this._renderer.states.fillColor)&&this._renderer.triangle(n),(this._accessibleOutputs.grid||this._accessibleOutputs.text)&&this._accsOutput("triangle",n),this}}typeof p5<"u"&&$T(p5,p5.prototype);function RT(r,t){t.ellipseMode=function(n){return(n===xa||n===tb||n===rb||n===Ki)&&this._renderer.states.setValue("ellipseMode",n),this},t.noSmooth=function(){return this._renderer.isP3D?this.setAttributes("antialias",!1):"imageSmoothingEnabled"in this.drawingContext&&(this.drawingContext.imageSmoothingEnabled=!1),this},t.rectMode=function(n){return(n===xa||n===tb||n===rb||n===Ki)&&this._renderer.states.setValue("rectMode",n),this},t.smooth=function(){return this._renderer.isP3D?this.setAttributes("antialias",!0):"imageSmoothingEnabled"in this.drawingContext&&(this.drawingContext.imageSmoothingEnabled=!0),this},t.strokeCap=function(n){return(n===Ql||n===hT||n===cT)&&this._renderer.strokeCap(n),this},t.strokeJoin=function(n){return(n===Ql||n===dT||n===pT)&&this._renderer.strokeJoin(n),this},t.strokeWeight=function(n){return this._renderer.strokeWeight(n),this}}typeof p5<"u"&&RT(p5,p5.prototype);function OT(r,t){t.bezier=function(...n){return!this._renderer.states.strokeColor&&!this._renderer.states.fillColor?this:(this._renderer.bezier(...n),this)},t.bezierPoint=function(n,s,i,a,o){const u=1-o;return Math.pow(u,3)*n+3*Math.pow(u,2)*o*s+3*u*Math.pow(o,2)*i+Math.pow(o,3)*a},t.bezierTangent=function(n,s,i,a,o){const u=1-o;return 3*a*Math.pow(o,2)-3*i*Math.pow(o,2)+6*i*u*o-6*s*u*o+3*s*Math.pow(u,2)-3*n*Math.pow(u,2)},t.spline=function(...n){return!this._renderer.states.strokeColor&&!this._renderer.states.fillColor?this:(this._renderer.spline(...n),this)},t.splinePoint=function(n,s,i,a,o){const u=this._renderer.states.splineProperties.tightness,l=o*o*o,c=o*o,h=(u-1)/2*l+(1-u)*c+(u-1)/2*o,d=(u+3)/2*l+(-5-u)/2*c+1,p=(-3-u)/2*l+(u+2)*c+(1-u)/2*o,f=(1-u)/2*l+(u-1)/2*c;return n*h+s*d+i*p+a*f},t.splineTangent=function(n,s,i,a,o){const u=this._renderer.states.splineProperties.tightness,l=o*o*3,c=o*2,h=(u-1)/2*l+(1-u)*c+(u-1)/2,d=(u+3)/2*l+(-5-u)/2*c,p=(-3-u)/2*l+(u+2)*c+(1-u)/2,f=(1-u)/2*l+(u-1)/2*c;return n*h+s*d+i*p+a*f}}typeof p5<"u"&&OT(p5,p5.prototype);function MT(r,t){t.beginShape=function(n){this._renderer.beginShape(...arguments)},t.bezierVertex=function(...n){this._renderer.bezierVertex(...n)},t.endShape=function(n,s=1){s<1&&(console.log(" p5.js says: You can not have less than one instance"),s=1),this._renderer.endShape(n,s)},t.normal=function(n,s,i){return this._assert3d("normal"),this._renderer.normal(...arguments),this},t.vertexProperty=function(n,s){this._renderer.vertexProperty(n,s)}}typeof p5<"u"&&MT(p5,p5.prototype);function LT(r,t){t.beginClip=function(n={}){this._renderer.beginClip(n)},t.endClip=function(){this._renderer.endClip()},t.clip=function(n,s){this._renderer.beginClip(s),n(),this._renderer.endClip(s)},t.background=function(...n){return this._renderer.background(...n),this},t.clear=function(...n){const s=n[0]||0,i=n[1]||0,a=n[2]||0,o=n[3]||0;return this._renderer.clear(s,i,a,o),this},t.colorMode=function(n,s,i,a,o){if([Cn,xi,za,Xi,im,cb,am,hb,om].includes(n)){this._renderer.states.setValue("colorMode",n),this._renderer.states.setValue("colorMaxes",this._renderer.states.colorMaxes.clone());const u=this._renderer.states.colorMaxes[n];arguments.length===2?(u[0]=s,u[1]=s,u[2]=s,u[3]=s):arguments.length===4?(u[0]=s,u[1]=i,u[2]=a):arguments.length===5&&(u[0]=s,u[1]=i,u[2]=a,u[3]=o)}return this._renderer.states.colorMode},t.fill=function(...n){return this._renderer.fill(...n),this},t.noFill=function(){return this._renderer.noFill(),this},t.noStroke=function(){return this._renderer.states.setValue("strokeColor",null),this},t.stroke=function(...n){return this._renderer.stroke(...n),this},t.erase=function(n=255,s=255){return this._renderer.erase(n,s),this},t.noErase=function(){return this._renderer.noErase(),this},t.blendMode=function(n){n===eu&&(console.warn("NORMAL has been deprecated for use in blendMode. defaulting to BLEND instead."),n=Si),this._renderer.blendMode(n)}}typeof p5<"u"&&LT(p5,p5.prototype);var o1={},HP;function fae(){if(HP)return o1;HP=1;function r(i,a,o,c){var l=0,c=c===void 0?{}:c,h=c.loop===void 0?null:c.loop,d=c.palette===void 0?null:c.palette;if(a<=0||o<=0||a>65535||o>65535)throw new Error("Width/Height invalid.");function p(v){var S=v.length;if(S<2||S>256||S&S-1)throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");return S}i[l++]=71,i[l++]=73,i[l++]=70,i[l++]=56,i[l++]=57,i[l++]=97;var f=0,m=0;if(d!==null){for(var g=p(d);g>>=1;)++f;if(g=1<<f,--f,c.background!==void 0){if(m=c.background,m>=g)throw new Error("Background index out of range.");if(m===0)throw new Error("Background index explicitly passed as 0.")}}if(i[l++]=a&255,i[l++]=a>>8&255,i[l++]=o&255,i[l++]=o>>8&255,i[l++]=(d!==null?128:0)|f,i[l++]=m,i[l++]=0,d!==null)for(var y=0,b=d.length;y<b;++y){var x=d[y];i[l++]=x>>16&255,i[l++]=x>>8&255,i[l++]=x&255}if(h!==null){if(h<0||h>65535)throw new Error("Loop count invalid.");i[l++]=33,i[l++]=255,i[l++]=11,i[l++]=78,i[l++]=69,i[l++]=84,i[l++]=83,i[l++]=67,i[l++]=65,i[l++]=80,i[l++]=69,i[l++]=50,i[l++]=46,i[l++]=48,i[l++]=3,i[l++]=1,i[l++]=h&255,i[l++]=h>>8&255,i[l++]=0}var w=!1;this.addFrame=function(v,S,E,C,I,_){if(w===!0&&(--l,w=!1),_=_===void 0?{}:_,v<0||S<0||v>65535||S>65535)throw new Error("x/y invalid.");if(E<=0||C<=0||E>65535||C>65535)throw new Error("Width/Height invalid.");if(I.length<E*C)throw new Error("Not enough pixels for the frame size.");var A=!0,k=_.palette;if(k==null&&(A=!1,k=d),k==null)throw new Error("Must supply either a local or global palette.");for(var N=p(k),D=0;N>>=1;)++D;N=1<<D;var F=_.delay===void 0?0:_.delay,P=_.disposal===void 0?0:_.disposal;if(P<0||P>3)throw new Error("Disposal out of range.");var G=!1,Y=0;if(_.transparent!==void 0&&_.transparent!==null&&(G=!0,Y=_.transparent,Y<0||Y>=N))throw new Error("Transparent color index.");if((P!==0||G||F!==0)&&(i[l++]=33,i[l++]=249,i[l++]=4,i[l++]=P<<2|(G===!0?1:0),i[l++]=F&255,i[l++]=F>>8&255,i[l++]=Y,i[l++]=0),i[l++]=44,i[l++]=v&255,i[l++]=v>>8&255,i[l++]=S&255,i[l++]=S>>8&255,i[l++]=E&255,i[l++]=E>>8&255,i[l++]=C&255,i[l++]=C>>8&255,i[l++]=A===!0?128|D-1:0,A===!0)for(var Z=0,ee=k.length;Z<ee;++Z){var se=k[Z];i[l++]=se>>16&255,i[l++]=se>>8&255,i[l++]=se&255}return l=t(i,l,D<2?2:D,I),l},this.end=function(){return w===!1&&(i[l++]=59,w=!0),l},this.getOutputBuffer=function(){return i},this.setOutputBuffer=function(v){i=v},this.getOutputBufferPosition=function(){return l},this.setOutputBufferPosition=function(v){l=v}}function t(i,a,o,u){i[a++]=o;var l=a++,c=1<<o,h=c-1,d=c+1,p=d+1,f=o+1,m=0,g=0;function y(_){for(;m>=_;)i[a++]=g&255,g>>=8,m-=8,a===l+256&&(i[l]=255,l=a++)}function b(_){g|=_<<m,m+=f,y(8)}var x=u[0]&h,w={};b(c);for(var v=1,S=u.length;v<S;++v){var E=u[v]&h,C=x<<8|E,I=w[C];if(I===void 0){for(g|=x<<m,m+=f;m>=8;)i[a++]=g&255,g>>=8,m-=8,a===l+256&&(i[l]=255,l=a++);p===4096?(b(c),p=d+1,f=o+1,w={}):(p>=1<<f&&++f,w[C]=p++),x=E}else x=I}return b(x),b(d),y(1),l+1===a?i[l]=0:(i[l]=a-l-1,i[a++]=0),a}function n(i){var a=0;if(i[a++]!==71||i[a++]!==73||i[a++]!==70||i[a++]!==56||(i[a++]+1&253)!==56||i[a++]!==97)throw new Error("Invalid GIF 87a/89a header.");var o=i[a++]|i[a++]<<8,u=i[a++]|i[a++]<<8,l=i[a++],c=l>>7,h=l&7,d=1<<h+1;i[a++],i[a++];var p=null,f=null;c&&(p=a,f=d,a+=d*3);var m=!0,g=[],y=0,b=null,x=0,w=null;for(this.width=o,this.height=u;m&&a<i.length;)switch(i[a++]){case 33:switch(i[a++]){case 255:if(i[a]!==11||i[a+1]==78&&i[a+2]==69&&i[a+3]==84&&i[a+4]==83&&i[a+5]==67&&i[a+6]==65&&i[a+7]==80&&i[a+8]==69&&i[a+9]==50&&i[a+10]==46&&i[a+11]==48&&i[a+12]==3&&i[a+13]==1&&i[a+16]==0)a+=14,w=i[a++]|i[a++]<<8,a++;else for(a+=12;;){var v=i[a++];if(!(v>=0))throw Error("Invalid block size");if(v===0)break;a+=v}break;case 249:if(i[a++]!==4||i[a+4]!==0)throw new Error("Invalid graphics extension block.");var S=i[a++];y=i[a++]|i[a++]<<8,b=i[a++],(S&1)===0&&(b=null),x=S>>2&7,a++;break;case 254:for(;;){var v=i[a++];if(!(v>=0))throw Error("Invalid block size");if(v===0)break;a+=v}break;default:throw new Error("Unknown graphic control label: 0x"+i[a-1].toString(16))}break;case 44:var E=i[a++]|i[a++]<<8,C=i[a++]|i[a++]<<8,I=i[a++]|i[a++]<<8,_=i[a++]|i[a++]<<8,A=i[a++],k=A>>7,N=A>>6&1,D=A&7,F=1<<D+1,P=p,G=f,Y=!1;if(k){var Y=!0;P=a,G=F,a+=F*3}var Z=a;for(a++;;){var v=i[a++];if(!(v>=0))throw Error("Invalid block size");if(v===0)break;a+=v}g.push({x:E,y:C,width:I,height:_,has_local_palette:Y,palette_offset:P,palette_size:G,data_offset:Z,data_length:a-Z,transparent_index:b,interlaced:!!N,delay:y,disposal:x});break;case 59:m=!1;break;default:throw new Error("Unknown gif block: 0x"+i[a-1].toString(16))}this.numFrames=function(){return g.length},this.loopCount=function(){return w},this.frameInfo=function(ee){if(ee<0||ee>=g.length)throw new Error("Frame index out of range.");return g[ee]},this.decodeAndBlitFrameBGRA=function(ee,se){var re=this.frameInfo(ee),J=re.width*re.height,le=new Uint8Array(J);s(i,re.data_offset,le,J);var he=re.palette_offset,xe=re.transparent_index;xe===null&&(xe=256);var Fe=re.width,Le=o-Fe,Ve=Fe,$e=(re.y*o+re.x)*4,Ae=((re.y+re.height)*o+re.x)*4,Te=$e,Ue=Le*4;re.interlaced===!0&&(Ue+=o*4*7);for(var qe=8,Me=0,ie=le.length;Me<ie;++Me){var K=le[Me];if(Ve===0&&(Te+=Ue,Ve=Fe,Te>=Ae&&(Ue=Le*4+o*4*(qe-1),Te=$e+(Fe+Le)*(qe<<1),qe>>=1)),K===xe)Te+=4;else{var pe=i[he+K*3],_e=i[he+K*3+1],We=i[he+K*3+2];se[Te++]=We,se[Te++]=_e,se[Te++]=pe,se[Te++]=255}--Ve}},this.decodeAndBlitFrameRGBA=function(ee,se){var re=this.frameInfo(ee),J=re.width*re.height,le=new Uint8Array(J);s(i,re.data_offset,le,J);var he=re.palette_offset,xe=re.transparent_index;xe===null&&(xe=256);var Fe=re.width,Le=o-Fe,Ve=Fe,$e=(re.y*o+re.x)*4,Ae=((re.y+re.height)*o+re.x)*4,Te=$e,Ue=Le*4;re.interlaced===!0&&(Ue+=o*4*7);for(var qe=8,Me=0,ie=le.length;Me<ie;++Me){var K=le[Me];if(Ve===0&&(Te+=Ue,Ve=Fe,Te>=Ae&&(Ue=Le*4+o*4*(qe-1),Te=$e+(Fe+Le)*(qe<<1),qe>>=1)),K===xe)Te+=4;else{var pe=i[he+K*3],_e=i[he+K*3+1],We=i[he+K*3+2];se[Te++]=pe,se[Te++]=_e,se[Te++]=We,se[Te++]=255}--Ve}}}function s(i,a,o,u){for(var l=i[a++],c=1<<l,h=c+1,d=h+1,p=l+1,f=(1<<p)-1,m=0,g=0,y=0,b=i[a++],x=new Int32Array(4096),w=null;;){for(;m<16&&b!==0;)g|=i[a++]<<m,m+=8,b===1?b=i[a++]:--b;if(m<p)break;var v=g&f;if(g>>=p,m-=p,v===c){d=h+1,p=l+1,f=(1<<p)-1,w=null;continue}else if(v===h)break;for(var S=v<d?v:w,E=0,C=S;C>c;)C=x[C]>>8,++E;var I=C,_=y+E+(S!==v?1:0);if(_>u){console.log("Warning, gif stream longer than expected.");return}o[y++]=I,y+=E;var A=y;for(S!==v&&(o[y++]=I),C=S;E--;)C=x[C],o[--A]=C&255,C>>=8;w!==null&&d<4096&&(x[d++]=w<<8|I,d>=f+1&&p<12&&(++p,f=f<<1|1)),w=v}return y!==u&&console.log("Warning, gif stream shorter than expected."),o}try{o1.GifWriter=r,o1.GifReader=n}catch{}return o1}var o6=fae();function mae(r,t,n=s=>s){const s=Object.create(null);if(s.options=t||{},s.reviver=n,s.value="",s.entry=[],s.output=[],s.col=1,s.row=1,s.options.delimiter=s.options.delimiter===void 0?'"':t.delimiter,s.options.delimiter.length>1||s.options.delimiter.length===0)throw Error(`CSVError: delimiter must be one character [${s.options.separator}]`);if(s.options.separator=s.options.separator===void 0?",":t.separator,s.options.separator.length>1||s.options.separator.length===0)throw Error(`CSVError: separator must be one character [${s.options.separator}]`);const i=new RegExp(`${Jf(s.options.delimiter)}|${Jf(s.options.separator)}|\r
|
|\r|[^${Jf(s.options.delimiter)}${Jf(s.options.separator)}\r
]+`,"y"),a=/^(\r\n|\n|\r)$/;let o=[],u="",l=0;for(;(o=i.exec(r))!==null;)switch(u=o[0],l){case 0:switch(!0){case u===s.options.delimiter:l=3;break;case u===s.options.separator:l=0,nh(s);break;case a.test(u):l=0,nh(s),u1(s);break;default:s.value+=u,l=2;break}break;case 2:switch(!0){case u===s.options.separator:l=0,nh(s);break;case a.test(u):l=0,nh(s),u1(s);break;default:throw l=4,Error(`CSVError: Illegal state [row:${s.row}, col:${s.col}]`)}break;case 3:switch(!0){case u===s.options.delimiter:l=4;break;default:l=3,s.value+=u;break}break;case 4:switch(!0){case u===s.options.delimiter:l=3,s.value+=u;break;case u===s.options.separator:l=0,nh(s);break;case a.test(u):l=0,nh(s),u1(s);break;default:throw Error(`CSVError: Illegal state [row:${s.row}, col:${s.col}]`)}break}return s.entry.length!==0&&(nh(s),u1(s)),s.output}function gae(r,t={},n=s=>s){const s=Object.create(null);if(s.options=t,s.options.eof=s.options.eof!==void 0?s.options.eof:!0,s.row=1,s.col=1,s.output="",s.options.delimiter=s.options.delimiter===void 0?'"':t.delimiter,s.options.delimiter.length>1||s.options.delimiter.length===0)throw Error(`CSVError: delimiter must be one character [${s.options.separator}]`);if(s.options.separator=s.options.separator===void 0?",":t.separator,s.options.separator.length>1||s.options.separator.length===0)throw Error(`CSVError: separator must be one character [${s.options.separator}]`);const i=new RegExp(`${Jf(s.options.delimiter)}|${Jf(s.options.separator)}|\r
|
|\r`);return r.forEach((a,o)=>{let u="";switch(s.col=1,a.forEach((l,c)=>{typeof l=="string"&&(l=l.replace(new RegExp(s.options.delimiter,"g"),`${s.options.delimiter}${s.options.delimiter}`),l=i.test(l)?`${s.options.delimiter}${l}${s.options.delimiter}`:l),u+=n(l,s.row,s.col),c!==a.length-1&&(u+=s.options.separator),s.col++}),!0){case s.options.eof:case(!s.options.eof&&o!==r.length-1):s.output+=`${u}
`;break;default:s.output+=`${u}`;break}s.row++}),s.output}function nh(r){const t=r.options.typed?yae(r.value):r.value;r.entry.push(r.reviver(t,r.row,r.col)),r.value="",r.col++}function u1(r){r.output.push(r.entry),r.entry=[],r.row++,r.col=1}function yae(r){const t=/.\./;switch(!0){case r==="true":case r==="false":return r==="true";case t.test(r):return parseFloat(r);case isFinite(r):return parseInt(r);default:return r}}function Jf(r){return r.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}var bae={trailer:59};function u6(r=256){let t=0,n=new Uint8Array(r);return{get buffer(){return n.buffer},reset(){t=0},bytesView(){return n.subarray(0,t)},bytes(){return n.slice(0,t)},writeByte(i){s(t+1),n[t]=i,t++},writeBytes(i,a=0,o=i.length){s(t+o);for(let u=0;u<o;u++)n[t++]=i[u+a]},writeBytesView(i,a=0,o=i.byteLength){s(t+o),n.set(i.subarray(a,a+o),t),t+=o}};function s(i){var a=n.length;if(a>=i)return;var o=1024*1024;i=Math.max(i,a*(a<o?2:1.125)>>>0),a!=0&&(i=Math.max(i,256));let u=n;n=new Uint8Array(i),t>0&&n.set(u.subarray(0,t),0)}}var lE=12,jP=5003,xae=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];function vae(r,t,n,s,i=u6(512),a=new Uint8Array(256),o=new Int32Array(jP),u=new Int32Array(jP)){let l=o.length,c=Math.max(2,s);a.fill(0),u.fill(0),o.fill(-1);let h=0,d=0,p=c+1,f=p,m=!1,g=f,y=(1<<g)-1,b=1<<p-1,x=b+1,w=b+2,v=0,S=n[0],E=0;for(let _=l;_<65536;_*=2)++E;E=8-E,i.writeByte(c),I(b);let C=n.length;for(let _=1;_<C;_++)e:{let A=n[_],k=(A<<lE)+S,N=A<<E^S;if(o[N]===k){S=u[N];break e}let D=N===0?1:l-N;for(;o[N]>=0;)if(N-=D,N<0&&(N+=l),o[N]===k){S=u[N];break e}I(S),S=A,w<1<<lE?(u[N]=w++,o[N]=k):(o.fill(-1),w=b+2,m=!0,I(b))}return I(S),I(x),i.writeByte(0),i.bytesView();function I(_){for(h&=xae[d],d>0?h|=_<<d:h=_,d+=g;d>=8;)a[v++]=h&255,v>=254&&(i.writeByte(v),i.writeBytesView(a,0,v),v=0),h>>=8,d-=8;if((w>y||m)&&(m?(g=f,y=(1<<g)-1,m=!1):(++g,y=g===lE?1<<g:(1<<g)-1)),_==x){for(;d>0;)a[v++]=h&255,v>=254&&(i.writeByte(v),i.writeBytesView(a,0,v),v=0),h>>=8,d-=8;v>0&&(i.writeByte(v),i.writeBytesView(a,0,v),v=0)}}}var wae=vae;function Sae(r,t,n){return r<<8&63488|t<<2&992|n>>3}function Cae(r,t,n,s){return r>>4|t&240|(n&240)<<4|(s&240)<<8}function _ae(r,t,n){return r>>4<<8|t&240|n>>4}function l1(r,t,n){return r<t?t:r>n?n:r}function hw(r){return r*r}function qP(r,t,n){var s=0,i=1e100;let a=r[t],o=a.cnt;a.ac;let u=a.rc,l=a.gc,c=a.bc;for(var h=a.fw;h!=0;h=r[h].fw){let p=r[h],f=p.cnt,m=o*f/(o+f);if(!(m>=i)){var d=0;d+=m*hw(p.rc-u),!(d>=i)&&(d+=m*hw(p.gc-l),!(d>=i)&&(d+=m*hw(p.bc-c),!(d>=i)&&(i=d,s=h)))}}a.err=i,a.nn=s}function cE(){return{ac:0,rc:0,gc:0,bc:0,cnt:0,nn:0,fw:0,bk:0,tm:0,mtm:0,err:0}}function Eae(r,t){let n=t==="rgb444"?4096:65536,s=new Array(n),i=r.length;if(t==="rgba4444")for(let a=0;a<i;++a){let o=r[a],u=o>>24&255,l=o>>16&255,c=o>>8&255,h=o&255,d=Cae(h,c,l,u),p=d in s?s[d]:s[d]=cE();p.rc+=h,p.gc+=c,p.bc+=l,p.ac+=u,p.cnt++}else if(t==="rgb444")for(let a=0;a<i;++a){let o=r[a],u=o>>16&255,l=o>>8&255,c=o&255,h=_ae(c,l,u),d=h in s?s[h]:s[h]=cE();d.rc+=c,d.gc+=l,d.bc+=u,d.cnt++}else for(let a=0;a<i;++a){let o=r[a],u=o>>16&255,l=o>>8&255,c=o&255,h=Sae(c,l,u),d=h in s?s[h]:s[h]=cE();d.rc+=c,d.gc+=l,d.bc+=u,d.cnt++}return s}function Iae(r,t,n={}){let{format:s="rgb565",clearAlpha:i=!0,clearAlphaColor:a=0,clearAlphaThreshold:o=0,oneBitAlpha:u=!1}=n;if(!r||!r.buffer)throw new Error("quantize() expected RGBA Uint8Array data");if(!(r instanceof Uint8Array)&&!(r instanceof Uint8ClampedArray))throw new Error("quantize() expected RGBA Uint8Array data");let l=new Uint32Array(r.buffer),c=n.useSqrt!==!1,h=s==="rgba4444",d=Eae(l,s),p=d.length,f=p-1,m=new Uint32Array(p+1);for(var g=0,y=0;y<p;++y){let F=d[y];if(F!=null){var b=1/F.cnt;h&&(F.ac*=b),F.rc*=b,F.gc*=b,F.bc*=b,d[g++]=F}}hw(t)/g<.022&&(c=!1);for(var y=0;y<g-1;++y)d[y].fw=y+1,d[y+1].bk=y,c&&(d[y].cnt=Math.sqrt(d[y].cnt));c&&(d[y].cnt=Math.sqrt(d[y].cnt));var x,w,v;for(y=0;y<g;++y){qP(d,y);var S=d[y].err;for(w=++m[0];w>1&&(v=w>>1,!(d[x=m[v]].err<=S));w=v)m[w]=x;m[w]=y}var E=g-t;for(y=0;y<E;){for(var C;;){var I=m[1];if(C=d[I],C.tm>=C.mtm&&d[C.nn].mtm<=C.tm)break;C.mtm==f?I=m[1]=m[m[0]--]:(qP(d,I),C.tm=y);var S=d[I].err;for(w=1;(v=w+w)<=m[0]&&(v<m[0]&&d[m[v]].err>d[m[v+1]].err&&v++,!(S<=d[x=m[v]].err));w=v)m[w]=x;m[w]=I}var _=d[C.nn],A=C.cnt,k=_.cnt,b=1/(A+k);h&&(C.ac=b*(A*C.ac+k*_.ac)),C.rc=b*(A*C.rc+k*_.rc),C.gc=b*(A*C.gc+k*_.gc),C.bc=b*(A*C.bc+k*_.bc),C.cnt+=_.cnt,C.mtm=++y,d[_.bk].fw=_.fw,d[_.fw].bk=_.bk,_.mtm=f}let N=[];var D=0;for(y=0;;++D){let F=l1(Math.round(d[y].rc),0,255),P=l1(Math.round(d[y].gc),0,255),G=l1(Math.round(d[y].bc),0,255),Y=255;h&&(Y=l1(Math.round(d[y].ac),0,255),u&&(Y=Y<=(typeof u=="number"?u:127)?0:255),i&&Y<=o&&(F=P=G=a,Y=0));let Z=h?[F,P,G,Y]:[F,P,G];if(kae(N,Z)||N.push(Z),(y=d[y].fw)==0)break}return N}function kae(r,t){for(let n=0;n<r.length;n++){let s=r[n],i=s[0]===t[0]&&s[1]===t[1]&&s[2]===t[2],a=s.length>=4&&t.length>=4?s[3]===t[3]:!0;if(i&&a)return!0}return!1}function Nae(r,t){var n=0,s;for(s=0;s<r.length;s++){let i=r[s]-t[s];n+=i*i}return n}function Tae(r,t,n=Nae){let s=1/0,i=-1;for(let a=0;a<r.length;a++){let o=r[a],u=n(t,o);u<s&&(s=u,i=a)}return i}function Aae(r={}){let{initialCapacity:t=4096,auto:n=!0}=r,s=u6(t),i=5003,a=new Uint8Array(256),o=new Int32Array(i),u=new Int32Array(i),l=!1;return{reset(){s.reset(),l=!1},finish(){s.writeByte(bae.trailer)},bytes(){return s.bytes()},bytesView(){return s.bytesView()},get buffer(){return s.buffer},get stream(){return s},writeHeader:c,writeFrame(h,d,p,f={}){let{transparent:m=!1,transparentIndex:g=0,delay:y=0,palette:b=null,repeat:x=0,colorDepth:w=8,dispose:v=-1}=f,S=!1;if(n?l||(S=!0,c(),l=!0):S=!!f.first,d=Math.max(0,Math.floor(d)),p=Math.max(0,Math.floor(p)),S){if(!b)throw new Error("First frame must include a { palette } option");Fae(s,d,p,b,w),KP(s,b),x>=0&&$ae(s,x)}let E=Math.round(y/10);Dae(s,v,E,m,g);let C=!!b&&!S;Rae(s,d,p,C?b:null),C&&KP(s,b),Oae(s,h,d,p,w,a,o,u)}};function c(){l6(s,"GIF89a")}}function Dae(r,t,n,s,i){r.writeByte(33),r.writeByte(249),r.writeByte(4),i<0&&(i=0,s=!1);var a,o;s?(a=1,o=2):(a=0,o=0),t>=0&&(o=t&7),o<<=2,r.writeByte(0|o|0|a),Gl(r,n),r.writeByte(i||0),r.writeByte(0)}function Fae(r,t,n,s,i=8){let a=1,o=0,u=PT(s.length)-1,l=a<<7|i-1<<4|o<<3|u;Gl(r,t),Gl(r,n),r.writeBytes([l,0,0])}function $ae(r,t){r.writeByte(33),r.writeByte(255),r.writeByte(11),l6(r,"NETSCAPE2.0"),r.writeByte(3),r.writeByte(1),Gl(r,t),r.writeByte(0)}function KP(r,t){let n=1<<PT(t.length);for(let s=0;s<n;s++){let i=[0,0,0];s<t.length&&(i=t[s]),r.writeByte(i[0]),r.writeByte(i[1]),r.writeByte(i[2])}}function Rae(r,t,n,s){if(r.writeByte(44),Gl(r,0),Gl(r,0),Gl(r,t),Gl(r,n),s){let i=0,a=0,o=PT(s.length)-1;r.writeByte(128|i|a|0|o)}else r.writeByte(0)}function Oae(r,t,n,s,i=8,a,o,u){wae(n,s,t,i,r,a,o,u)}function Gl(r,t){r.writeByte(t&255),r.writeByte(t>>8&255)}function l6(r,t){for(var n=0;n<t.length;n++)r.writeByte(t.charCodeAt(n))}function PT(r){return Math.max(Math.ceil(Math.log2(r)),1)}function BT(r,t){t.blend=function(...s){this._renderer?this._renderer.blend(...s):r.Renderer2D.prototype.blend.apply(this,s)},t.copy=function(...s){let i,a,o,u,l,c,h,d,p;if(s.length===9)i=s[0],a=s[1],o=s[2],u=s[3],l=s[4],c=s[5],h=s[6],d=s[7],p=s[8];else if(s.length===8)i=this,a=s[0],o=s[1],u=s[2],l=s[3],c=s[4],h=s[5],d=s[6],p=s[7];else throw new Error("Signature not supported");t._copyHelper(this,i,a,o,u,l,c,h,d,p)},t._copyHelper=(s,i,a,o,u,l,c,h,d,p)=>{const f=i.canvas.width/i.width;let m=0,g=0;i._renderer&&i._renderer.isP3D&&(m=i.width/2,g=i.height/2),s._renderer&&s._renderer.isP3D?(s.push(),s.resetMatrix(),s.noLights(),s.blendMode(s.BLEND),s.imageMode(s.CORNER),s._renderer.image(i,a+m,o+g,u,l,c,h,d,p),s.pop()):s.drawingContext.drawImage(i.canvas,f*(a+m),f*(o+g),f*u,f*l,c,h,d,p)},t.getFilterGraphicsLayer=function(){return this._renderer.getFilterGraphicsLayer()},t.filter=function(...s){let{shader:i,operation:a,value:o,useWebGL:u}=n(...s);if(this._renderer.isP3D&&i){this._renderer.filter(i);return}if(!u&&!this._renderer.isP3D){this.canvas!==void 0?jr.apply(this.canvas,jr[a],o):jr.apply(this.elt,jr[a],o);return}!u&&this._renderer.isP3D&&console.warn("filter() with useWebGL=false is not supported in WEBGL"),this._renderer.isP3D?this._renderer.filter(a,o):(i?this._renderer.filterRenderer.setOperation(a,o,i):this._renderer.filterRenderer.setOperation(a,o),this._renderer.filterRenderer.applyFilter())};function n(...s){let i={shader:void 0,operation:void 0,value:void 0,useWebGL:!0};return s[0]instanceof r.Shader?(i.shader=s[0],i):(i.operation=s[0],s.length>1&&typeof s[1]=="number"&&(i.value=s[1]),s[s.length-1]===!1&&(i.useWebGL=!1),i)}t.get=function(s,i,a,o){return this._renderer.get(...arguments)},t.loadPixels=function(...s){this._renderer.loadPixels()},t.set=function(s,i,a){this._renderer.set(s,i,a)},t.updatePixels=function(s,i,a,o){this.pixels.length!==0&&this._renderer.updatePixels(s,i,a,o)}}typeof p5<"u"&&BT(p5,p5.prototype);var lT;const JL=class JL{constructor(...t){cn(this,lT,null);if(this.constructor===JL)throw new Error("Class is of abstract type and can't be instantiated");["add","setElement","reset","set","get","copy","clone","diagonal","row","column","transpose","mult","multiplyVec","invert","createSubMatrix3x3","inverseTranspose4x4","apply","scale","rotate4x4","translate","rotateX","rotateY","rotateZ","perspective","ortho","multiplyVec4","multiplyPoint","multiplyAndNormalizePoint","multiplyDirection","multiplyVec3"].forEach(s=>{if(this[s]===void 0)throw new Error(`${s}() method must be implemented`)})}};lT=new WeakMap;let qI=JL;const hE=r=>{if(Math.sqrt(Array.from(r).length)%1!==0)throw new Error("Array length must be a perfect square.");return!0};let $u=Array,hh=r=>Array.isArray(r);typeof Float32Array<"u"&&($u=Float32Array,hh=r=>Array.isArray(r)||r instanceof Float32Array);var Hr,Wn,KI,c6,h6,d6,p6,f6,m6,g6,y6,Mae;const Yo=class Yo extends qI{constructor(...n){super(...n);cn(this,Wn);Ar(this,"matrix");cn(this,Hr);if(hh(n[0])&&hE(n[0])){const s=Math.sqrt(Array.from(n[0]).length);Xs(this,Hr,s),this.matrix=$u.from(n[0])}else typeof n[0]=="number"&&(Xs(this,Hr,Number(n[0])),this.matrix=es(this,Wn,KI).call(this,n[0]));return this}get mat3(){if(ut(this,Hr)===3)return this.matrix}get mat4(){if(ut(this,Hr)===4)return this.matrix}add(n){if(this.matrix.length!==n.matrix.length)throw new Error("Matrices must be of the same dimension to add.");for(let s=0;s<this.matrix.length;s++)this.matrix[s]+=n.matrix[s];return this}setElement(n,s){return n>=0&&n<this.matrix.length&&(this.matrix[n]=s),this}reset(){return this.matrix=es(this,Wn,KI).call(this,ut(this,Hr)),this}set(n){let s=$u.from([...arguments]);return n instanceof Yo?s=$u.from(n.matrix):hh(n)&&(s=$u.from(n)),s.length!==this.matrix.length?(p5._friendlyError(`Expected same dimensions values but received different ${s.length}.`,"p5.Matrix.set"),this):(this.matrix=s,this)}get(){return new Yo(this.matrix)}copy(){return new Yo(this.matrix)}clone(){return this.copy()}diagonal(){const n=[];for(let s=0;s<ut(this,Hr);s++)n.push(this.matrix[s*(ut(this,Hr)+1)]);return n}row(n){const s=[];for(let i=0;i<ut(this,Hr);i++)s.push(this.matrix[i*ut(this,Hr)+n]);return new De(...s)}column(n){const s=[];for(let i=0;i<ut(this,Hr);i++)s.push(this.matrix[n*ut(this,Hr)+i]);return new De(...s)}transpose(n){return ut(this,Hr)===4?es(this,Wn,f6).call(this,n):ut(this,Hr)===3?es(this,Wn,m6).call(this,n):es(this,Wn,p6).call(this,n)}mult(n){let s;return n===this||n===this.matrix?s=this.copy().matrix:n instanceof Yo?s=n.matrix:hh(n)&&hE(n)?s=n:hE(arguments)&&(s=Array.from(arguments)),ut(this,Hr)===4&&s.length===16?es(this,Wn,c6).call(this,s):ut(this,Hr)===3&&s.length===9?es(this,Wn,d6).call(this,s):es(this,Wn,h6).call(this,s)}multiplyVec(n,s){s===void 0&&(s=n.copy());for(let i=0;i<ut(this,Hr);i++)s.values[i]=this.row(i).dot(n);return s}invert(n){if(ut(this,Hr)===4)return es(this,Wn,g6).call(this,n);if(ut(this,Hr)===3)return es(this,Wn,y6).call(this,n);throw new Error("Invert is not implemented for N>4 at the moment, we are working on it")}createSubMatrix3x3(){if(ut(this,Hr)===4){const n=new Yo(3);return n.mat3[0]=this.matrix[0],n.mat3[1]=this.matrix[1],n.mat3[2]=this.matrix[2],n.mat3[3]=this.matrix[4],n.mat3[4]=this.matrix[5],n.mat3[5]=this.matrix[6],n.mat3[6]=this.matrix[8],n.mat3[7]=this.matrix[9],n.mat3[8]=this.matrix[10],n}else throw new Error("Matrix dimension must be 4 to create a 3x3 submatrix.")}inverseTranspose4x4({mat4:n}){if(ut(this,Hr)!==3)throw new Error("This function only works with 33 matrices.");this.matrix[0]=n[0],this.matrix[1]=n[1],this.matrix[2]=n[2],this.matrix[3]=n[4],this.matrix[4]=n[5],this.matrix[5]=n[6],this.matrix[6]=n[8],this.matrix[7]=n[9],this.matrix[8]=n[10];const s=this.invert();if(s)s.transpose(this.matrix);else for(let i=0;i<9;i++)this.matrix[i]=0;return this}apply(n){let s;if(n===this||n===this.matrix)s=this.copy().matrix;else if(n instanceof Yo)s=n.matrix;else if(hh(n))s=n;else if(arguments.length===16)s=arguments;else return;const i=this.matrix,a=i[0],o=i[4],u=i[8],l=i[12];i[0]=s[0]*a+s[1]*o+s[2]*u+s[3]*l,i[4]=s[4]*a+s[5]*o+s[6]*u+s[7]*l,i[8]=s[8]*a+s[9]*o+s[10]*u+s[11]*l,i[12]=s[12]*a+s[13]*o+s[14]*u+s[15]*l;const c=i[1],h=i[5],d=i[9],p=i[13];i[1]=s[0]*c+s[1]*h+s[2]*d+s[3]*p,i[5]=s[4]*c+s[5]*h+s[6]*d+s[7]*p,i[9]=s[8]*c+s[9]*h+s[10]*d+s[11]*p,i[13]=s[12]*c+s[13]*h+s[14]*d+s[15]*p;const f=i[2],m=i[6],g=i[10],y=i[14];i[2]=s[0]*f+s[1]*m+s[2]*g+s[3]*y,i[6]=s[4]*f+s[5]*m+s[6]*g+s[7]*y,i[10]=s[8]*f+s[9]*m+s[10]*g+s[11]*y,i[14]=s[12]*f+s[13]*m+s[14]*g+s[15]*y;const b=i[3],x=i[7],w=i[11],v=i[15];return i[3]=s[0]*b+s[1]*x+s[2]*w+s[3]*v,i[7]=s[4]*b+s[5]*x+s[6]*w+s[7]*v,i[11]=s[8]*b+s[9]*x+s[10]*w+s[11]*v,i[15]=s[12]*b+s[13]*x+s[14]*w+s[15]*v,this}scale(n,s,i){return n instanceof De?(s=n.y,i=n.z,n=n.x):n instanceof Array&&(s=n[1],i=n[2],n=n[0]),this.matrix[0]*=n,this.matrix[1]*=n,this.matrix[2]*=n,this.matrix[3]*=n,this.matrix[4]*=s,this.matrix[5]*=s,this.matrix[6]*=s,this.matrix[7]*=s,this.matrix[8]*=i,this.matrix[9]*=i,this.matrix[10]*=i,this.matrix[11]*=i,this}rotate4x4(n,s,i,a){s instanceof De?(i=s.y,a=s.z,s=s.x):s instanceof Array&&(i=s[1],a=s[2],s=s[0]);const o=Math.sqrt(s*s+i*i+a*a);s*=1/o,i*=1/o,a*=1/o;const u=this.matrix[0],l=this.matrix[1],c=this.matrix[2],h=this.matrix[3],d=this.matrix[4],p=this.matrix[5],f=this.matrix[6],m=this.matrix[7],g=this.matrix[8],y=this.matrix[9],b=this.matrix[10],x=this.matrix[11],w=Math.sin(n),v=Math.cos(n),S=1-v,E=s*s*S+v,C=i*s*S+a*w,I=a*s*S-i*w,_=s*i*S-a*w,A=i*i*S+v,k=a*i*S+s*w,N=s*a*S+i*w,D=i*a*S-s*w,F=a*a*S+v;return this.matrix[0]=u*E+d*C+g*I,this.matrix[1]=l*E+p*C+y*I,this.matrix[2]=c*E+f*C+b*I,this.matrix[3]=h*E+m*C+x*I,this.matrix[4]=u*_+d*A+g*k,this.matrix[5]=l*_+p*A+y*k,this.matrix[6]=c*_+f*A+b*k,this.matrix[7]=h*_+m*A+x*k,this.matrix[8]=u*N+d*D+g*F,this.matrix[9]=l*N+p*D+y*F,this.matrix[10]=c*N+f*D+b*F,this.matrix[11]=h*N+m*D+x*F,this}translate(n){const s=n[0],i=n[1],a=n[2]||0;return this.matrix[12]+=this.matrix[0]*s+this.matrix[4]*i+this.matrix[8]*a,this.matrix[13]+=this.matrix[1]*s+this.matrix[5]*i+this.matrix[9]*a,this.matrix[14]+=this.matrix[2]*s+this.matrix[6]*i+this.matrix[10]*a,this.matrix[15]+=this.matrix[3]*s+this.matrix[7]*i+this.matrix[11]*a,this}rotateX(n){this.rotate4x4(n,1,0,0)}rotateY(n){this.rotate4x4(n,0,1,0)}rotateZ(n){this.rotate4x4(n,0,0,1)}perspective(n,s,i,a){const o=1/Math.tan(n/2),u=1/(i-a);return this.matrix[0]=o/s,this.matrix[1]=0,this.matrix[2]=0,this.matrix[3]=0,this.matrix[4]=0,this.matrix[5]=o,this.matrix[6]=0,this.matrix[7]=0,this.matrix[8]=0,this.matrix[9]=0,this.matrix[10]=(a+i)*u,this.matrix[11]=-1,this.matrix[12]=0,this.matrix[13]=0,this.matrix[14]=2*a*i*u,this.matrix[15]=0,this}ortho(n,s,i,a,o,u){const l=1/(n-s),c=1/(i-a),h=1/(o-u);return this.matrix[0]=-2*l,this.matrix[1]=0,this.matrix[2]=0,this.matrix[3]=0,this.matrix[4]=0,this.matrix[5]=-2*c,this.matrix[6]=0,this.matrix[7]=0,this.matrix[8]=0,this.matrix[9]=0,this.matrix[10]=2*h,this.matrix[11]=0,this.matrix[12]=(n+s)*l,this.matrix[13]=(a+i)*c,this.matrix[14]=(u+o)*h,this.matrix[15]=1,this}multiplyVec4(n,s,i,a){const o=new Array(4),u=this.matrix;return o[0]=u[0]*n+u[4]*s+u[8]*i+u[12]*a,o[1]=u[1]*n+u[5]*s+u[9]*i+u[13]*a,o[2]=u[2]*n+u[6]*s+u[10]*i+u[14]*a,o[3]=u[3]*n+u[7]*s+u[11]*i+u[15]*a,o}multiplyPoint({x:n,y:s,z:i}){const a=this.multiplyVec4(n,s,i,1);return new De(a[0],a[1],a[2])}multiplyAndNormalizePoint({x:n,y:s,z:i}){const a=this.multiplyVec4(n,s,i,1);return a[0]/=a[3],a[1]/=a[3],a[2]/=a[3],new De(a[0],a[1],a[2])}multiplyDirection({x:n,y:s,z:i}){const a=this.multiplyVec4(n,s,i,0);return new De(a[0],a[1],a[2])}multiplyVec3(n,s){return s===void 0&&(s=n.copy()),s.x=this.row(0).dot(n),s.y=this.row(1).dot(n),s.z=this.row(2).dot(n),s}};Hr=new WeakMap,Wn=new WeakSet,KI=function(n){if(n===3)return new $u([1,0,0,0,1,0,0,0,1]);if(n===4)return new $u([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);const s=new $u(n*n).fill(0);for(let i=0;i<n;i++)s[i*n+i]=1;return s},c6=function(n){let s=this.matrix[0],i=this.matrix[1],a=this.matrix[2],o=this.matrix[3];return this.matrix[0]=s*n[0]+i*n[4]+a*n[8]+o*n[12],this.matrix[1]=s*n[1]+i*n[5]+a*n[9]+o*n[13],this.matrix[2]=s*n[2]+i*n[6]+a*n[10]+o*n[14],this.matrix[3]=s*n[3]+i*n[7]+a*n[11]+o*n[15],s=this.matrix[4],i=this.matrix[5],a=this.matrix[6],o=this.matrix[7],this.matrix[4]=s*n[0]+i*n[4]+a*n[8]+o*n[12],this.matrix[5]=s*n[1]+i*n[5]+a*n[9]+o*n[13],this.matrix[6]=s*n[2]+i*n[6]+a*n[10]+o*n[14],this.matrix[7]=s*n[3]+i*n[7]+a*n[11]+o*n[15],s=this.matrix[8],i=this.matrix[9],a=this.matrix[10],o=this.matrix[11],this.matrix[8]=s*n[0]+i*n[4]+a*n[8]+o*n[12],this.matrix[9]=s*n[1]+i*n[5]+a*n[9]+o*n[13],this.matrix[10]=s*n[2]+i*n[6]+a*n[10]+o*n[14],this.matrix[11]=s*n[3]+i*n[7]+a*n[11]+o*n[15],s=this.matrix[12],i=this.matrix[13],a=this.matrix[14],o=this.matrix[15],this.matrix[12]=s*n[0]+i*n[4]+a*n[8]+o*n[12],this.matrix[13]=s*n[1]+i*n[5]+a*n[9]+o*n[13],this.matrix[14]=s*n[2]+i*n[6]+a*n[10]+o*n[14],this.matrix[15]=s*n[3]+i*n[7]+a*n[11]+o*n[15],this},h6=function(n){if(n.length!==this.matrix.length)throw new Error("Matrices must be of the same dimension to multiply.");const s=new $u(this.matrix.length).fill(0);for(let i=0;i<ut(this,Hr);i++)for(let a=0;a<ut(this,Hr);a++)for(let o=0;o<ut(this,Hr);o++)s[i*ut(this,Hr)+a]+=this.matrix[i*ut(this,Hr)+o]*n[o*ut(this,Hr)+a];return this.matrix=s,this},d6=function(n){let s=this.mat3[0],i=this.mat3[1],a=this.mat3[2];return this.mat3[0]=s*n[0]+i*n[3]+a*n[6],this.mat3[1]=s*n[1]+i*n[4]+a*n[7],this.mat3[2]=s*n[2]+i*n[5]+a*n[8],s=this.mat3[3],i=this.mat3[4],a=this.mat3[5],this.mat3[3]=s*n[0]+i*n[3]+a*n[6],this.mat3[4]=s*n[1]+i*n[4]+a*n[7],this.mat3[5]=s*n[2]+i*n[5]+a*n[8],s=this.mat3[6],i=this.mat3[7],a=this.mat3[8],this.mat3[6]=s*n[0]+i*n[3]+a*n[6],this.mat3[7]=s*n[1]+i*n[4]+a*n[7],this.mat3[8]=s*n[2]+i*n[5]+a*n[8],this},p6=function(){const n=ut(this,Hr);for(let s=0;s<n;s++)for(let i=0;i<n;i++)this.matrix[s*n+i]=this.matrix[i*n+s];return this},f6=function(n){console.log("====> 4x4");let s,i,a,o,u,l;return n instanceof Yo?(s=n.matrix[1],i=n.matrix[2],a=n.matrix[3],o=n.matrix[6],u=n.matrix[7],l=n.matrix[11],this.matrix[0]=n.matrix[0],this.matrix[1]=n.matrix[4],this.matrix[2]=n.matrix[8],this.matrix[3]=n.matrix[12],this.matrix[4]=s,this.matrix[5]=n.matrix[5],this.matrix[6]=n.matrix[9],this.matrix[7]=n.matrix[13],this.matrix[8]=i,this.matrix[9]=o,this.matrix[10]=n.matrix[10],this.matrix[11]=n.matrix[14],this.matrix[12]=a,this.matrix[13]=u,this.matrix[14]=l,this.matrix[15]=n.matrix[15]):hh(n)&&(s=n[1],i=n[2],a=n[3],o=n[6],u=n[7],l=n[11],this.matrix[0]=n[0],this.matrix[1]=n[4],this.matrix[2]=n[8],this.matrix[3]=n[12],this.matrix[4]=s,this.matrix[5]=n[5],this.matrix[6]=n[9],this.matrix[7]=n[13],this.matrix[8]=i,this.matrix[9]=o,this.matrix[10]=n[10],this.matrix[11]=n[14],this.matrix[12]=a,this.matrix[13]=u,this.matrix[14]=l,this.matrix[15]=n[15]),this},m6=function(n){n===void 0&&(n=this.mat3);const s=n[1],i=n[2],a=n[5];return this.mat3[0]=n[0],this.mat3[1]=n[3],this.mat3[2]=n[6],this.mat3[3]=s,this.mat3[4]=n[4],this.mat3[5]=n[7],this.mat3[6]=i,this.mat3[7]=a,this.mat3[8]=n[8],this},g6=function(n){let s,i,a,o,u,l,c,h,d,p,f,m,g,y,b,x;n instanceof Yo?(s=n.matrix[0],i=n.matrix[1],a=n.matrix[2],o=n.matrix[3],u=n.matrix[4],l=n.matrix[5],c=n.matrix[6],h=n.matrix[7],d=n.matrix[8],p=n.matrix[9],f=n.matrix[10],m=n.matrix[11],g=n.matrix[12],y=n.matrix[13],b=n.matrix[14],x=n.matrix[15]):hh(n)&&(s=n[0],i=n[1],a=n[2],o=n[3],u=n[4],l=n[5],c=n[6],h=n[7],d=n[8],p=n[9],f=n[10],m=n[11],g=n[12],y=n[13],b=n[14],x=n[15]);const w=s*l-i*u,v=s*c-a*u,S=s*h-o*u,E=i*c-a*l,C=i*h-o*l,I=a*h-o*c,_=d*y-p*g,A=d*b-f*g,k=d*x-m*g,N=p*b-f*y,D=p*x-m*y,F=f*x-m*b;let P=w*F-v*D+S*N+E*k-C*A+I*_;return P?(P=1/P,this.matrix[0]=(l*F-c*D+h*N)*P,this.matrix[1]=(a*D-i*F-o*N)*P,this.matrix[2]=(y*I-b*C+x*E)*P,this.matrix[3]=(f*C-p*I-m*E)*P,this.matrix[4]=(c*k-u*F-h*A)*P,this.matrix[5]=(s*F-a*k+o*A)*P,this.matrix[6]=(b*S-g*I-x*v)*P,this.matrix[7]=(d*I-f*S+m*v)*P,this.matrix[8]=(u*D-l*k+h*_)*P,this.matrix[9]=(i*k-s*D-o*_)*P,this.matrix[10]=(g*C-y*S+x*w)*P,this.matrix[11]=(p*S-d*C-m*w)*P,this.matrix[12]=(l*A-u*N-c*_)*P,this.matrix[13]=(s*N-i*A+a*_)*P,this.matrix[14]=(y*v-g*E-b*w)*P,this.matrix[15]=(d*E-p*v+f*w)*P,this):null},y6=function(){const n=this.mat3[0],s=this.mat3[1],i=this.mat3[2],a=this.mat3[3],o=this.mat3[4],u=this.mat3[5],l=this.mat3[6],c=this.mat3[7],h=this.mat3[8],d=h*o-u*c,p=-h*a+u*l,f=c*a-o*l;let m=n*d+s*p+i*f;return m?(m=1/m,this.mat3[0]=d*m,this.mat3[1]=(-h*s+i*c)*m,this.mat3[2]=(u*s-i*o)*m,this.mat3[3]=p*m,this.mat3[4]=(h*n-i*l)*m,this.mat3[5]=(-u*n+i*a)*m,this.mat3[6]=f*m,this.mat3[7]=(-c*n+s*l)*m,this.mat3[8]=(o*n-s*a)*m,this):null},Mae=function(){if(ut(this,Hr)!==4)throw new Error("Determinant is only implemented for 4x4 matrices. We are working on it.");const n=this.matrix[0]*this.matrix[5]-this.matrix[1]*this.matrix[4],s=this.matrix[0]*this.matrix[6]-this.matrix[2]*this.matrix[4],i=this.matrix[0]*this.matrix[7]-this.matrix[3]*this.matrix[4],a=this.matrix[1]*this.matrix[6]-this.matrix[2]*this.matrix[5],o=this.matrix[1]*this.matrix[7]-this.matrix[3]*this.matrix[5],u=this.matrix[2]*this.matrix[7]-this.matrix[3]*this.matrix[6],l=this.matrix[8]*this.matrix[13]-this.matrix[9]*this.matrix[12],c=this.matrix[8]*this.matrix[14]-this.matrix[10]*this.matrix[12],h=this.matrix[8]*this.matrix[15]-this.matrix[11]*this.matrix[12],d=this.matrix[9]*this.matrix[14]-this.matrix[10]*this.matrix[13],p=this.matrix[9]*this.matrix[15]-this.matrix[11]*this.matrix[13],f=this.matrix[10]*this.matrix[15]-this.matrix[11]*this.matrix[14];return n*f-s*p+i*d+a*h-o*c+u*l};let qn=Yo;function b6(r,t){r.Matrix=qn}typeof p5<"u"&&b6(p5,p5.prototype);class bh{constructor(t=128){this.length=0,this.data=new Float32Array(t),this.initialLength=t}dataArray(){return this.subArray(0,this.length)}clear(){this.length=0}rescale(){if(this.length<this.data.length/2){const t=1<<Math.ceil(Math.log2(this.length)),n=new Float32Array(t);n.set(this.data.subarray(0,this.length),0),this.data=n}}reset(){this.clear(),this.data=new Float32Array(this.initialLength)}push(...t){this.ensureLength(this.length+t.length),this.data.set(t,this.length),this.length+=t.length}slice(t,n){return this.data.slice(t,Math.min(n,this.length))}subArray(t,n){return this.data.subarray(t,Math.min(n,this.length))}ensureLength(t){for(;this.data.length<t;){const n=new Float32Array(this.data.length*2);n.set(this.data,0),this.data=n}}}function x6(r,t){r.DataArray=bh}typeof p5<"u"&&x6(p5,p5.prototype);class ks{constructor(t,n,s,i){this.renderer=i,this.vertices=[],this.boundingBoxCache=null,this.lineVertices=new bh,this.lineTangentsIn=new bh,this.lineTangentsOut=new bh,this.lineSides=new bh,this.vertexNormals=[],this.faces=[],this.uvs=[],this.edges=[],this.vertexColors=[],this.vertexStrokeColors=[],this.userVertexProperties={},this.lineVertexColors=new bh,this.detailX=t!==void 0?t:1,this.detailY=n!==void 0?n:1,this.dirtyFlags={},this._hasFillTransparency=void 0,this._hasStrokeTransparency=void 0,this.gid=`_p5_Geometry_${ks.nextId}`,ks.nextId++,s instanceof Function&&s.call(this)}calculateBoundingBox(){if(this.boundingBoxCache)return this.boundingBoxCache;let t=new De(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),n=new De(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE);for(let a=0;a<this.vertices.length;a++){let o=this.vertices[a];t.x=Math.min(t.x,o.x),t.y=Math.min(t.y,o.y),t.z=Math.min(t.z,o.z),n.x=Math.max(n.x,o.x),n.y=Math.max(n.y,o.y),n.z=Math.max(n.z,o.z)}let s=new De(n.x-t.x,n.y-t.y,n.z-t.z),i=new De((t.x+n.x)/2,(t.y+n.y)/2,(t.z+n.z)/2);return this.boundingBoxCache={min:t,max:n,size:s,offset:i},this.boundingBoxCache}reset(){this._hasFillTransparency=void 0,this._hasStrokeTransparency=void 0,this.lineVertices.clear(),this.lineTangentsIn.clear(),this.lineTangentsOut.clear(),this.lineSides.clear(),this.vertices.length=0,this.edges.length=0,this.vertexColors.length=0,this.vertexStrokeColors.length=0,this.lineVertexColors.clear(),this.vertexNormals.length=0,this.uvs.length=0;for(const t in this.userVertexProperties)this.userVertexProperties[t].delete();this.userVertexProperties={},this.dirtyFlags={}}hasFillTransparency(){if(this._hasFillTransparency===void 0){this._hasFillTransparency=!1;for(let t=0;t<this.vertexColors.length;t+=4)if(this.vertexColors[t+3]<1){this._hasFillTransparency=!0;break}}return this._hasFillTransparency}hasStrokeTransparency(){if(this._hasStrokeTransparency===void 0){this._hasStrokeTransparency=!1;for(let t=0;t<this.lineVertexColors.length;t+=4)if(this.lineVertexColors[t+3]<1){this._hasStrokeTransparency=!0;break}}return this._hasStrokeTransparency}clearColors(){return this.vertexColors=[],this}saveObj(t="model.obj"){let n="";if(this.vertices.forEach(i=>{n+=`v ${i.x} ${i.y} ${i.z}
`}),this.uvs&&this.uvs.length>0)for(let i=0;i<this.uvs.length;i+=2)n+=`vt ${this.uvs[i]} ${this.uvs[i+1]}
`;this.vertexNormals&&this.vertexNormals.length>0&&this.vertexNormals.forEach(i=>{n+=`vn ${i.x} ${i.y} ${i.z}
`}),this.faces.forEach(i=>{let a="f";i.forEach(o=>{a+=" ",a+=o+1,(this.vertexNormals.length>0||this.uvs.length>0)&&(a+="/",this.uvs.length>0&&(a+=o+1),a+="/",this.vertexNormals.length>0&&(a+=o+1))}),n+=a+`
`});const s=new Blob([n],{type:"text/plain"});fn.downloadFile(s,t,"obj")}saveStl(t="model.stl",{binary:n=!1}={}){let s,i=t.substring(0,t.lastIndexOf(".")),a=[];for(let u of this.faces){const l=De.sub(this.vertices[u[1]],this.vertices[u[0]]),c=De.sub(this.vertices[u[2]],this.vertices[u[0]]),h=l.y*c.z-l.z*c.y,d=l.z*c.x-l.x*c.z,p=l.x*c.y-l.y*c.x;a.push(new De(h,d,p).normalize())}if(n){let u=80;const l=this.faces.length*2+this.faces.length*3*4*4+80+4,c=new ArrayBuffer(l);s=new DataView(c),s.setUint32(u,this.faces.length,!0),u+=4;for(const[h,d]of Object.entries(this.faces)){const p=a[h];s.setFloat32(u,p.x,!0),u+=4,s.setFloat32(u,p.y,!0),u+=4,s.setFloat32(u,p.z,!0),u+=4;for(let f of d){const m=this.vertices[f];s.setFloat32(u,m.x,!0),u+=4,s.setFloat32(u,m.y,!0),u+=4,s.setFloat32(u,m.z,!0),u+=4}s.setUint16(u,0,!0),u+=2}}else{s="solid "+i+`
`;for(const[u,l]of Object.entries(this.faces)){const c=a[u];s+=" facet norm "+c.x+" "+c.y+" "+c.z+`
`,s+=`  outer loop
`;for(let h of l){const d=this.vertices[h];s+="   vertex "+d.x+" "+d.y+" "+d.z+`
`}s+=`  endloop
`,s+=` endfacet
`}s+="endsolid "+i+`
`}const o=new Blob([s],{type:"text/plain"});fn.downloadFile(o,t,"stl")}flipU(){this.uvs=this.uvs.flat().map((t,n)=>n%2===0?1-t:t)}flipV(){this.uvs=this.uvs.flat().map((t,n)=>n%2===0?t:1-t)}computeFaces(){this.faces.length=0;const t=this.detailX+1;let n,s,i,a;for(let o=0;o<this.detailY;o++)for(let u=0;u<this.detailX;u++)n=o*t+u,s=o*t+u+1,i=(o+1)*t+u+1,a=(o+1)*t+u,this.faces.push([n,s,a]),this.faces.push([a,s,i]);return this}_getFaceNormal(t){const n=this.faces[t],s=this.vertices[n[0]],i=this.vertices[n[1]],a=this.vertices[n[2]],o=De.sub(i,s),u=De.sub(a,s),l=De.cross(o,u),c=De.mag(l);let h=c/(De.mag(o)*De.mag(u));return h===0||isNaN(h)?(console.warn("p5.Geometry.prototype._getFaceNormal:","face has colinear sides or a repeated vertex"),l):(h>1&&(h=1),l.mult(Math.asin(h)/c))}computeNormals(t=uU,{roundToPrecision:n=3}={}){const s=this.vertexNormals;let i=this.vertices;const a=this.faces;let o;if(t===lU){const u={},l=[],c=Math.pow(10,n),h=p=>Math.round(p*c)/c,d=p=>`${h(p.x)},${h(p.y)},${h(p.z)}`;for(let p=0;p<i.length;p++){const f=i[p],m=d(f);u[m]===void 0&&(u[m]=l.length,l.push(f))}a.forEach(p=>{for(let f=0;f<3;++f){const m=p[f],g=i[m],y=d(g);p[f]=u[y]}}),this.edges.forEach(p=>{for(let f=0;f<2;++f){const m=p[f],g=i[m],y=d(g);p[f]=u[y]}}),this.vertices=i=l}for(s.length=0,o=0;o<i.length;++o)s.push(new De);for(a.forEach((u,l)=>{const c=this._getFaceNormal(l);for(let h=0;h<3;++h){const d=u[h];s[d].add(c)}}),o=0;o<i.length;++o)s[o].normalize();return this}averageNormals(){for(let t=0;t<=this.detailY;t++){const n=this.detailX+1;let s=De.add(this.vertexNormals[t*n],this.vertexNormals[t*n+this.detailX]);s=De.div(s,2),this.vertexNormals[t*n]=s,this.vertexNormals[t*n+this.detailX]=s}return this}averagePoleNormals(){let t=new De(0,0,0);for(let n=0;n<this.detailX;n++)t.add(this.vertexNormals[n]);t=De.div(t,this.detailX);for(let n=0;n<this.detailX;n++)this.vertexNormals[n]=t;t=new De(0,0,0);for(let n=this.vertices.length-1;n>this.vertices.length-1-this.detailX;n--)t.add(this.vertexNormals[n]);t=De.div(t,this.detailX);for(let n=this.vertices.length-1;n>this.vertices.length-1-this.detailX;n--)this.vertexNormals[n]=t;return this}_makeTriangleEdges(){this.edges.length=0;for(let t=0;t<this.faces.length;t++)this.edges.push([this.faces[t][0],this.faces[t][1]]),this.edges.push([this.faces[t][1],this.faces[t][2]]),this.edges.push([this.faces[t][2],this.faces[t][0]]);return this}makeEdgesFromFaces(){this._makeTriangleEdges()}_edgesToVertices(){var i;this.lineVertices.clear(),this.lineTangentsIn.clear(),this.lineTangentsOut.clear(),this.lineSides.clear();const t=new Map,n=new Set;let s;for(let a=0;a<this.edges.length;a++){const o=this.edges[a-1],u=this.edges[a],l=this.vertices[u[0]],c=this.vertices[u[1]],h=this.vertexStrokeColors.length>0&&o?this.vertexStrokeColors.slice(o[1]*4,(o[1]+1)*4):[0,0,0,0],d=this.vertexStrokeColors.length>0?this.vertexStrokeColors.slice(u[0]*4,(u[0]+1)*4):[0,0,0,0],p=this.vertexStrokeColors.length>0?this.vertexStrokeColors.slice(u[1]*4,(u[1]+1)*4):[0,0,0,0],f=c.copy().sub(l).normalize(),m=f.magSq()>0;if(m&&this._addSegment(l,c,d,p,f),!((i=this.renderer)!=null&&i._simpleLines)){if(a>0&&o[1]===u[0])n.has(u[0])||(n.add(u[0]),t.delete(u[0]),s&&m&&f.dot(s)<1-1e-8&&this._addJoin(l,s,f,d));else{if(m&&!n.has(u[0])){const g=t.get(u[0]);g?(this._addJoin(l,g.dir,f,d),t.delete(u[0]),n.add(u[0])):t.set(u[0],{point:l,dir:f.copy().mult(-1),color:d})}if(s&&!n.has(o[1])){const g=t.get(o[1]);g?(this._addJoin(this.vertices[o[1]],s,g.dir.copy().mult(-1),h),t.delete(o[1]),n.add(o[1])):t.set(o[1],{point:this.vertices[o[1]],dir:s,color:h}),s=void 0}}if(a===this.edges.length-1&&!n.has(u[1])){const g=t.get(u[1]);g?(this._addJoin(c,f,g.dir.copy().mult(-1),p),t.delete(u[1]),n.add(u[1])):t.set(u[1],{point:c,dir:f,color:p})}m&&(s=f)}}for(const{point:a,dir:o,color:u}of t.values())this._addCap(a,o,u);return this}_addSegment(t,n,s,i,a){var c;const o=t.array(),u=n.array(),l=a.array();this.lineSides.push(1,1,-1,1,-1,-1);for(const h of[this.lineTangentsIn,this.lineTangentsOut])for(let d=0;d<6;d++)h.push(...l);return this.lineVertices.push(...o,...u,...o,...u,...u,...o),(c=this.renderer)!=null&&c._simpleLines||this.lineVertexColors.push(...s,...i,...s,...i,...i,...s),this}_addCap(t,n,s){const i=t.array(),a=n.array(),o=[0,0,0];for(let u=0;u<6;u++)this.lineVertices.push(...i),this.lineTangentsIn.push(...a),this.lineTangentsOut.push(...o),this.lineVertexColors.push(...s);return this.lineSides.push(-1,2,-2,1,2,-1),this}_addJoin(t,n,s,i){const a=t.array(),o=n.array(),u=s.array();for(let l=0;l<12;l++)this.lineVertices.push(...a),this.lineTangentsIn.push(...o),this.lineTangentsOut.push(...u),this.lineVertexColors.push(...i);return this.lineSides.push(-1,-3,-2,-1,0,-3),this.lineSides.push(3,1,2,3,0,1),this}normalize(){if(this.vertices.length>0){const t=this.vertices[0].copy(),n=this.vertices[0].copy();for(let u=0;u<this.vertices.length;u++)t.x=Math.max(t.x,this.vertices[u].x),n.x=Math.min(n.x,this.vertices[u].x),t.y=Math.max(t.y,this.vertices[u].y),n.y=Math.min(n.y,this.vertices[u].y),t.z=Math.max(t.z,this.vertices[u].z),n.z=Math.min(n.z,this.vertices[u].z);const s=De.lerp(t,n,.5),i=De.sub(t,n),o=200/Math.max(Math.max(i.x,i.y),i.z);for(let u=0;u<this.vertices.length;u++)this.vertices[u].sub(s),this.vertices[u].mult(o)}return this}vertexProperty(t,n,s){let i;this.userVertexProperties[t]||(i=this.userVertexProperties[t]=this._userVertexPropertyHelper(t,n,s)),i=this.userVertexProperties[t],s?i.pushDirect(n):(i.setCurrentData(n),i.pushCurrentData())}_userVertexPropertyHelper(t,n,s){const i=this,a=this.userVertexProperties[t]={name:t,dataSize:s||(n.length?n.length:1),geometry:i,getName(){return this.name},getCurrentData(){return this.currentData===void 0&&(this.currentData=new Array(this.getDataSize()).fill(0)),this.currentData},getDataSize(){return this.dataSize},getSrcName(){return this.name.concat("Src")},getDstName(){return this.name.concat("Buffer")},getSrcArray(){const o=this.getSrcName();return this.geometry[o]},setCurrentData(o){o.length&&o.length,this.currentData=o},pushCurrentData(){const o=this.getCurrentData();this.pushDirect(o)},pushDirect(o){o.length?this.getSrcArray().push(...o):this.getSrcArray().push(o)},resetSrcArray(){this.geometry[this.getSrcName()]=[]},delete(){const o=this.getSrcName();delete this.geometry[o],delete this}};return this[a.getSrcName()]=[],this.userVertexProperties[t]}}ks.nextId=0;function v6(r,t){r.Geometry=ks}typeof p5<"u"&&v6(p5,p5.prototype);class pb{constructor(t){this.renderer=t,t._pInst.push(),this.identityMatrix=new qn(4),t.states.setValue("uModelMatrix",new qn(4)),this.geometry=new ks(void 0,void 0,void 0,this.renderer),this.geometry.gid=`_p5_GeometryBuilder_${pb.nextGeometryId}`,pb.nextGeometryId++,this.hasTransform=!1}transformVertices(t){return this.hasTransform?t.map(n=>this.renderer.states.uModelMatrix.multiplyPoint(n)):t}transformNormals(t){return this.hasTransform?t.map(n=>this.renderer.scratchMat3.multiplyVec(n)):t}addGeometry(t){this.hasTransform=!this.renderer.states.uModelMatrix.mat4.every((u,l)=>u===this.identityMatrix.mat4[l]),this.hasTransform&&this.renderer.scratchMat3.inverseTranspose4x4(this.renderer.states.uModelMatrix);let n=this.geometry.vertices.length;this.geometry.vertices.push(...this.transformVertices(t.vertices)),this.geometry.vertexNormals.push(...this.transformNormals(t.vertexNormals)),this.geometry.uvs.push(...t.uvs);const s=t.userVertexProperties,i=this.geometry.userVertexProperties,a=this.geometry.vertices.length-t.vertices.length;for(const u in i){if(u in s)continue;const l=i[u],h=l.getDataSize()*t.vertices.length,d=Array(h).fill(0);l.pushDirect(d)}for(const u in s){const l=s[u],c=l.getSrcArray(),h=l.getDataSize();if(a>0&&!(u in i)){const d=h*a,p=Array(d).fill(0);this.geometry.vertexProperty(u,p,h)}this.geometry.vertexProperty(u,c,h)}this.renderer.states.fillColor&&this.geometry.faces.push(...t.faces.map(u=>u.map(l=>l+n))),this.renderer.states.strokeColor&&this.geometry.edges.push(...t.edges.map(u=>u.map(l=>l+n)));const o=[...t.vertexColors];for(;o.length<t.vertices.length*4;)o.push(...this.renderer.states.curFillColor);this.geometry.vertexColors.push(...o)}addImmediate(t,n){const s=[];if(this.renderer.states.fillColor)if(n===nb||n===sb)for(let i=2;i<t.vertices.length;i++)i%2===0?s.push([i,i-1,i-2]):s.push([i,i-2,i-1]);else if(n===_S)for(let i=2;i<t.vertices.length;i++)s.push([0,i-1,i]);else for(let i=0;i<t.vertices.length;i+=3)s.push([i,i+1,i+2]);this.addGeometry(Object.assign({},t,{faces:s}))}addRetained(t){this.addGeometry(t)}finish(){return this.renderer._pInst.pop(),this.geometry}}pb.nextGeometryId=0;class um{constructor(t,n,s,i){this.w=t,this.vec=new De(n,s,i)}static fromAxisAngle(t,n,s,i){const a=Math.cos(t/2),o=new De(n,s,i).normalize().mult(Math.sin(t/2));return new um(a,o.x,o.y,o.z)}conjugate(){return new um(this.w,-this.vec.x,-this.vec.y,-this.vec.z)}multiply(t){return new um(this.w*t.w-this.vec.x*t.vec.x-this.vec.y*t.vec.y-this.vec.z-t.vec.z,this.w*t.vec.x+this.vec.x*t.w+this.vec.y*t.vec.z-this.vec.z*t.vec.y,this.w*t.vec.y-this.vec.x*t.vec.z+this.vec.y*t.w+this.vec.z*t.vec.x,this.w*t.vec.z+this.vec.x*t.vec.y-this.vec.y*t.vec.x+this.vec.z*t.w)}rotateVector(t){return De.mult(t,this.w*this.w-this.vec.dot(this.vec)).add(De.mult(this.vec,2*t.dot(this.vec))).add(De.mult(this.vec,2*this.w).cross(t)).clampToZero()}rotateBy(t){return t.multiply(this).multiply(t.conjugate()).vec.clampToZero()}}function w6(r,t){r.Quat=um}typeof p5<"u"&&w6(p5,p5.prototype);class yi{constructor(t,n,s,i,a,o){this.size=t,this.src=n,this.dst=s,this.attr=i,this._renderer=a,this.map=o}_prepareBuffer(t,n){const s=n.attributes,i=this._renderer.GL,a=this._renderer._getOrMakeCachedBuffers(t),o=s[this.attr];if(!o)return;let u=a[this.dst];const l=t[this.src];if(l&&l.length>0){const c=!u;if(c&&(a[this.dst]=u=i.createBuffer()),i.bindBuffer(i.ARRAY_BUFFER,u),c||t.dirtyFlags[this.src]!==!1){const h=this.map,d=h?h(l):l;this._renderer._bindBuffer(u,i.ARRAY_BUFFER,d),t.dirtyFlags[this.src]=!1}n.enableAttrib(o,this.size)}else{const c=o.location;if(c===-1||!this._renderer.registerEnabled.has(c))return;i.disableVertexAttribArray(c),this._renderer.registerEnabled.delete(c)}}}function S6(r,t){r.RenderBuffer=yi}typeof p5<"u"&&S6(p5,p5.prototype);var dw={exports:{}},XP=dw.exports,YP;function Lae(){return YP||(YP=1,function(r){var t;function n(V,H){return V.b===H.b&&V.a===H.a}function s(V,H){return V.b<H.b||V.b===H.b&&V.a<=H.a}function i(V,H,ae){var ce=H.b-V.b,ve=ae.b-H.b;return 0<ce+ve?ce<ve?H.a-V.a+ce/(ce+ve)*(V.a-ae.a):H.a-ae.a+ve/(ce+ve)*(ae.a-V.a):0}function a(V,H,ae){var ce=H.b-V.b,ve=ae.b-H.b;return 0<ce+ve?(H.a-ae.a)*ce+(H.a-V.a)*ve:0}function o(V,H){return V.a<H.a||V.a===H.a&&V.b<=H.b}function u(V,H,ae){var ce=H.a-V.a,ve=ae.a-H.a;return 0<ce+ve?ce<ve?H.b-V.b+ce/(ce+ve)*(V.b-ae.b):H.b-ae.b+ve/(ce+ve)*(ae.b-V.b):0}function l(V,H,ae){var ce=H.a-V.a,ve=ae.a-H.a;return 0<ce+ve?(H.b-ae.b)*ce+(H.b-V.b)*ve:0}function c(V){return s(V.b.a,V.a)}function h(V){return s(V.a,V.b.a)}function d(V,H,ae,ce){return V=0>V?0:V,ae=0>ae?0:ae,V<=ae?ae===0?(H+ce)/2:H+V/(V+ae)*(ce-H):ce+ae/(V+ae)*(H-ce)}function p(V){var H=b(V.b);return w(H,V.c),w(H.b,V.c),v(H,V.a),H}function f(V,H){var ae=!1,ce=!1;V!==H&&(H.a!==V.a&&(ce=!0,E(H.a,V.a)),H.d!==V.d&&(ae=!0,C(H.d,V.d)),x(H,V),ce||(w(H,V.a),V.a.c=V),ae||(v(H,V.d),V.d.a=V))}function m(V){var H=V.b,ae=!1;V.d!==V.b.d&&(ae=!0,C(V.d,V.b.d)),V.c===V?E(V.a,null):(V.b.d.a=pe(V),V.a.c=V.c,x(V,pe(V)),ae||v(V,V.d)),H.c===H?(E(H.a,null),C(H.d,null)):(V.d.a=pe(H),H.a.c=H.c,x(H,pe(H))),S(V)}function g(V){var H=b(V),ae=H.b;return x(H,V.e),H.a=V.b.a,w(ae,H.a),H.d=ae.d=V.d,H=H.b,x(V.b,pe(V.b)),x(V.b,H),V.b.a=H.a,H.b.a.c=H.b,H.b.d=V.b.d,H.f=V.f,H.b.f=V.b.f,H}function y(V,H){var ae=!1,ce=b(V),ve=ce.b;return H.d!==V.d&&(ae=!0,C(H.d,V.d)),x(ce,V.e),x(ve,H),ce.a=V.b.a,ve.a=H.a,ce.d=ve.d=V.d,V.d.a=ve,ae||v(ce,V.d),ce}function b(V){var H=new K,ae=new K,ce=V.b.h;return ae.h=ce,ce.b.h=H,H.h=V,V.b.h=ae,H.b=ae,H.c=H,H.e=ae,ae.b=H,ae.c=ae,ae.e=H}function x(V,H){var ae=V.c,ce=H.c;ae.b.e=H,ce.b.e=V,V.c=ce,H.c=ae}function w(V,H){var ae=H.f,ce=new We(H,ae);ae.e=ce,H.f=ce,ae=ce.c=V;do ae.a=ce,ae=ae.c;while(ae!==V)}function v(V,H){var ae=H.d,ce=new ie(H,ae);ae.b=ce,H.d=ce,ce.a=V,ce.c=H.c,ae=V;do ae.d=ce,ae=ae.e;while(ae!==V)}function S(V){var H=V.h;V=V.b.h,H.b.h=V,V.b.h=H}function E(V,H){var ae=V.c,ce=ae;do ce.a=H,ce=ce.c;while(ce!==ae);ae=V.f,ce=V.e,ce.f=ae,ae.e=ce}function C(V,H){var ae=V.a,ce=ae;do ce.d=H,ce=ce.e;while(ce!==ae);ae=V.d,ce=V.b,ce.d=ae,ae.b=ce}function I(V){var H=0;return Math.abs(V[1])>Math.abs(V[0])&&(H=1),Math.abs(V[2])>Math.abs(V[H])&&(H=2),H}var _=4*1e150;function A(V,H){V.f+=H.f,V.b.f+=H.b.f}function k(V,H,ae){return V=V.a,H=H.a,ae=ae.a,H.b.a===V?ae.b.a===V?s(H.a,ae.a)?0>=a(ae.b.a,H.a,ae.a):0<=a(H.b.a,ae.a,H.a):0>=a(ae.b.a,V,ae.a):ae.b.a===V?0<=a(H.b.a,V,H.a):(H=i(H.b.a,V,H.a),V=i(ae.b.a,V,ae.a),H>=V)}function N(V){V.a.i=null;var H=V.e;H.a.c=H.c,H.c.a=H.a,V.e=null}function D(V,H){m(V.a),V.c=!1,V.a=H,H.i=V}function F(V){var H=V.a.a;do V=Pr(V);while(V.a.a===H);return V.c&&(H=y(lr(V).a.b,V.a.e),D(V,H),V=Pr(V)),V}function P(V,H,ae){var ce=new Gr;return ce.a=ae,ce.e=$e(V.f,H.e,ce),ae.i=ce}function G(V,H){switch(V.s){case 100130:return(H&1)!==0;case 100131:return H!==0;case 100132:return 0<H;case 100133:return 0>H;case 100134:return 2<=H||-2>=H}return!1}function Y(V){var H=V.a,ae=H.d;ae.c=V.d,ae.a=H,N(V)}function Z(V,H,ae){for(V=H,H=H.a;V!==ae;){V.c=!1;var ce=lr(V),ve=ce.a;if(ve.a!==H.a){if(!ce.c){Y(V);break}ve=y(H.c.b,ve.b),D(ce,ve)}H.c!==ve&&(f(pe(ve),ve),f(H,ve)),Y(V),H=ce.a,V=ce}return H}function ee(V,H,ae,ce,ve,He){var Ze=!0;do P(V,H,ae.b),ae=ae.c;while(ae!==ce);for(ve===null&&(ve=lr(H).a.b.c);ce=lr(H),ae=ce.a.b,ae.a===ve.a;)ae.c!==ve&&(f(pe(ae),ae),f(pe(ve),ae)),ce.f=H.f-ae.f,ce.d=G(V,ce.f),H.b=!0,!Ze&&le(V,H)&&(A(ae,ve),N(H),m(ve)),Ze=!1,H=ce,ve=ae;H.b=!0,He&&xe(V,H)}function se(V,H,ae,ce,ve){var He=[H.g[0],H.g[1],H.g[2]];H.d=null,H.d=V.o&&V.o(He,ae,ce,V.c)||null,H.d===null&&(ve?V.n||(Me(V,100156),V.n=!0):H.d=ae[0])}function re(V,H,ae){var ce=[null,null,null,null];ce[0]=H.a.d,ce[1]=ae.a.d,se(V,H.a,ce,[.5,.5,0,0],!1),f(H,ae)}function J(V,H,ae,ce,ve){var He=Math.abs(H.b-V.b)+Math.abs(H.a-V.a),Ze=Math.abs(ae.b-V.b)+Math.abs(ae.a-V.a),dt=ve+1;ce[ve]=.5*Ze/(He+Ze),ce[dt]=.5*He/(He+Ze),V.g[0]+=ce[ve]*H.g[0]+ce[dt]*ae.g[0],V.g[1]+=ce[ve]*H.g[1]+ce[dt]*ae.g[1],V.g[2]+=ce[ve]*H.g[2]+ce[dt]*ae.g[2]}function le(V,H){var ae=lr(H),ce=H.a,ve=ae.a;if(s(ce.a,ve.a)){if(0<a(ve.b.a,ce.a,ve.a))return!1;if(!n(ce.a,ve.a))g(ve.b),f(ce,pe(ve)),H.b=ae.b=!0;else if(ce.a!==ve.a){var ae=V.e,He=ce.a.h;if(0<=He){var ae=ae.b,Ze=ae.d,dt=ae.e,Bt=ae.c,Ut=Bt[He];Ze[Ut]=Ze[ae.a],Bt[Ze[Ut]]=Ut,Ut<=--ae.a&&(1>=Ut||s(dt[Ze[Ut>>1]],dt[Ze[Ut]])?Lt(ae,Ut):wn(ae,Ut)),dt[He]=null,Bt[He]=ae.b,ae.b=He}else for(ae.c[-(He+1)]=null;0<ae.a&&ae.c[ae.d[ae.a-1]]===null;)--ae.a;re(V,pe(ve),ce)}}else{if(0>a(ce.b.a,ve.a,ce.a))return!1;Pr(H).b=H.b=!0,g(ce.b),f(pe(ve),ce)}return!0}function he(V,H){var ae=lr(H),ce=H.a,ve=ae.a,He=ce.a,Ze=ve.a,dt=ce.b.a,Bt=ve.b.a,Ut=new We;if(a(dt,V.a,He),a(Bt,V.a,Ze),He===Ze||Math.min(He.a,dt.a)>Math.max(Ze.a,Bt.a))return!1;if(s(He,Ze)){if(0<a(Bt,He,Ze))return!1}else if(0>a(dt,Ze,He))return!1;var Tr=dt,$=He,B=Bt,z=Ze,W,X;if(s(Tr,$)||(W=Tr,Tr=$,$=W),s(B,z)||(W=B,B=z,z=W),s(Tr,B)||(W=Tr,Tr=B,B=W,W=$,$=z,z=W),s(B,$)?s($,z)?(W=i(Tr,B,$),X=i(B,$,z),0>W+X&&(W=-W,X=-X),Ut.b=d(W,B.b,X,$.b)):(W=a(Tr,B,$),X=-a(Tr,z,$),0>W+X&&(W=-W,X=-X),Ut.b=d(W,B.b,X,z.b)):Ut.b=(B.b+$.b)/2,o(Tr,$)||(W=Tr,Tr=$,$=W),o(B,z)||(W=B,B=z,z=W),o(Tr,B)||(W=Tr,Tr=B,B=W,W=$,$=z,z=W),o(B,$)?o($,z)?(W=u(Tr,B,$),X=u(B,$,z),0>W+X&&(W=-W,X=-X),Ut.a=d(W,B.a,X,$.a)):(W=l(Tr,B,$),X=-l(Tr,z,$),0>W+X&&(W=-W,X=-X),Ut.a=d(W,B.a,X,z.a)):Ut.a=(B.a+$.a)/2,s(Ut,V.a)&&(Ut.b=V.a.b,Ut.a=V.a.a),Tr=s(He,Ze)?He:Ze,s(Tr,Ut)&&(Ut.b=Tr.b,Ut.a=Tr.a),n(Ut,He)||n(Ut,Ze))return le(V,H),!1;if(!n(dt,V.a)&&0<=a(dt,V.a,Ut)||!n(Bt,V.a)&&0>=a(Bt,V.a,Ut)){if(Bt===V.a)return g(ce.b),f(ve.b,ce),H=F(H),ce=lr(H).a,Z(V,lr(H),ae),ee(V,H,pe(ce),ce,ce,!0),!0;if(dt===V.a){g(ve.b),f(ce.e,pe(ve)),He=ae=H,Ze=He.a.b.a;do He=Pr(He);while(He.a.b.a===Ze);return H=He,He=lr(H).a.b.c,ae.a=pe(ve),ve=Z(V,ae,null),ee(V,H,ve.c,ce.b.c,He,!0),!0}return 0<=a(dt,V.a,Ut)&&(Pr(H).b=H.b=!0,g(ce.b),ce.a.b=V.a.b,ce.a.a=V.a.a),0>=a(Bt,V.a,Ut)&&(H.b=ae.b=!0,g(ve.b),ve.a.b=V.a.b,ve.a.a=V.a.a),!1}return g(ce.b),g(ve.b),f(pe(ve),ce),ce.a.b=Ut.b,ce.a.a=Ut.a,ce.a.h=rt(V.e,ce.a),ce=ce.a,ve=[0,0,0,0],Ut=[He.d,dt.d,Ze.d,Bt.d],ce.g[0]=ce.g[1]=ce.g[2]=0,J(ce,He,dt,ve,0),J(ce,Ze,Bt,ve,2),se(V,ce,Ut,ve,!0),Pr(H).b=H.b=ae.b=!0,!1}function xe(V,H){for(var ae=lr(H);;){for(;ae.b;)H=ae,ae=lr(ae);if(!H.b&&(ae=H,H=Pr(H),H===null||!H.b))break;H.b=!1;var ce=H.a,ve=ae.a,He;if(He=ce.b.a!==ve.b.a)e:{He=H;var Ze=lr(He),dt=He.a,Bt=Ze.a,Ut=void 0;if(s(dt.b.a,Bt.b.a)){if(0>a(dt.b.a,Bt.b.a,dt.a)){He=!1;break e}Pr(He).b=He.b=!0,Ut=g(dt),f(Bt.b,Ut),Ut.d.c=He.d}else{if(0<a(Bt.b.a,dt.b.a,Bt.a)){He=!1;break e}He.b=Ze.b=!0,Ut=g(Bt),f(dt.e,Bt.b),Ut.b.d.c=He.d}He=!0}if(He&&(ae.c?(N(ae),m(ve),ae=lr(H),ve=ae.a):H.c&&(N(H),m(ce),H=Pr(ae),ce=H.a)),ce.a!==ve.a){if(ce.b.a===ve.b.a||H.c||ae.c||ce.b.a!==V.a&&ve.b.a!==V.a)le(V,H);else if(he(V,H))break}ce.a===ve.a&&ce.b.a===ve.b.a&&(A(ve,ce),N(H),m(ce),H=Pr(ae))}}function Fe(V,H){V.a=H;for(var ae=H.c;ae.i===null;)if(ae=ae.c,ae===H.c){var ae=V,ce=H,Ze=new Gr;Ze.a=ce.c.b;var ve=ae.f,dt=ve.a;do dt=dt.a;while(dt.b!==null&&!ve.c(ve.b,Ze,dt.b));var ve=dt.b,He=lr(ve),Ze=ve.a,dt=He.a;if(a(Ze.b.a,ce,Ze.a)===0)Ze=ve.a,n(Ze.a,ce)||n(Ze.b.a,ce)||(g(Ze.b),ve.c&&(m(Ze.c),ve.c=!1),f(ce.c,Ze),Fe(ae,ce));else{var Bt=s(dt.b.a,Ze.b.a)?ve:He,He=void 0;ve.d||Bt.c?(Bt===ve?He=y(ce.c.b,Ze.e):He=y(dt.b.c.b,ce.c).b,Bt.c?D(Bt,He):(Ze=ae,ve=P(ae,ve,He),ve.f=Pr(ve).f+ve.a.f,ve.d=G(Ze,ve.f)),Fe(ae,ce)):ee(ae,ve,ce.c,ce.c,null,!0)}return}if(ae=F(ae.i),Ze=lr(ae),ve=Ze.a,Ze=Z(V,Ze,null),Ze.c===ve){var ve=Ze,Ze=ve.c,dt=lr(ae),He=ae.a,Bt=dt.a,Ut=!1;He.b.a!==Bt.b.a&&he(V,ae),n(He.a,V.a)&&(f(pe(Ze),He),ae=F(ae),Ze=lr(ae).a,Z(V,lr(ae),dt),Ut=!0),n(Bt.a,V.a)&&(f(ve,pe(Bt)),ve=Z(V,dt,null),Ut=!0),Ut?ee(V,ae,ve.c,Ze,Ze,!0):(s(Bt.a,He.a)?ce=pe(Bt):ce=He,ce=y(ve.c.b,ce),ee(V,ae,ce,ce.c,ce.c,!1),ce.b.i.c=!0,xe(V,ae))}else ee(V,ae,Ze.c,ve,ve,!0)}function Le(V,H){var ae=new Gr,ce=p(V.b);ce.a.b=_,ce.a.a=H,ce.b.a.b=-4e150,ce.b.a.a=H,V.a=ce.b.a,ae.a=ce,ae.f=0,ae.d=!1,ae.c=!1,ae.h=!0,ae.b=!1,ce=V.f,ce=$e(ce,ce.a,ae),ae.e=ce}function Ve(V){this.a=new Ae,this.b=V,this.c=k}function $e(V,H,ae){do H=H.c;while(H.b!==null&&!V.c(V.b,H.b,ae));return V=new Ae(ae,H.a,H),H.a.c=V,H.a=V}function Ae(V,H,ae){this.b=V||null,this.a=H||this,this.c=ae||this}function Te(){this.d=Ue,this.p=this.b=this.q=null,this.j=[0,0,0],this.s=100130,this.n=!1,this.o=this.a=this.e=this.f=null,this.m=!1,this.c=this.r=this.i=this.k=this.l=this.h=null}var Ue=0;t=Te.prototype,t.x=function(){qe(this,Ue)},t.B=function(V,H){switch(V){case 100142:return;case 100140:switch(H){case 100130:case 100131:case 100132:case 100133:case 100134:this.s=H;return}break;case 100141:this.m=!!H;return;default:Me(this,100900);return}Me(this,100901)},t.y=function(V){switch(V){case 100142:return 0;case 100140:return this.s;case 100141:return this.m;default:Me(this,100900)}return!1},t.A=function(V,H,ae){this.j[0]=V,this.j[1]=H,this.j[2]=ae},t.z=function(V,H){var ae=H||null;switch(V){case 100100:case 100106:this.h=ae;break;case 100104:case 100110:this.l=ae;break;case 100101:case 100107:this.k=ae;break;case 100102:case 100108:this.i=ae;break;case 100103:case 100109:this.p=ae;break;case 100105:case 100111:this.o=ae;break;case 100112:this.r=ae;break;default:Me(this,100900)}},t.C=function(V,H){var ae=!1,ce=[0,0,0];qe(this,2);for(var ve=0;3>ve;++ve){var He=V[ve];-1e150>He&&(He=-1e150,ae=!0),1e150<He&&(He=1e150,ae=!0),ce[ve]=He}ae&&Me(this,100155),ae=this.q,ae===null?(ae=p(this.b),f(ae,ae.b)):(g(ae),ae=ae.e),ae.a.d=H,ae.a.g[0]=ce[0],ae.a.g[1]=ce[1],ae.a.g[2]=ce[2],ae.f=1,ae.b.f=-1,this.q=ae},t.u=function(V){qe(this,Ue),this.d=1,this.b=new _e,this.c=V},t.t=function(){qe(this,1),this.d=2,this.q=null},t.v=function(){qe(this,2),this.d=1},t.w=function(){qe(this,1),this.d=Ue;var V=this.j[0],H=this.j[1],ae=this.j[2],ce=!1,ve=[V,H,ae];if(V===0&&H===0&&ae===0){for(var H=[-2*1e150,-2*1e150,-2*1e150],He=[2*1e150,2*1e150,2*1e150],ae=[],Ze=[],ce=this.b.c,V=ce.e;V!==ce;V=V.e)for(var dt=0;3>dt;++dt){var Bt=V.g[dt];Bt<He[dt]&&(He[dt]=Bt,Ze[dt]=V),Bt>H[dt]&&(H[dt]=Bt,ae[dt]=V)}if(V=0,H[1]-He[1]>H[0]-He[0]&&(V=1),H[2]-He[2]>H[V]-He[V]&&(V=2),He[V]>=H[V])ve[0]=0,ve[1]=0,ve[2]=1;else{for(H=0,He=Ze[V],ae=ae[V],Ze=[0,0,0],He=[He.g[0]-ae.g[0],He.g[1]-ae.g[1],He.g[2]-ae.g[2]],dt=[0,0,0],V=ce.e;V!==ce;V=V.e)dt[0]=V.g[0]-ae.g[0],dt[1]=V.g[1]-ae.g[1],dt[2]=V.g[2]-ae.g[2],Ze[0]=He[1]*dt[2]-He[2]*dt[1],Ze[1]=He[2]*dt[0]-He[0]*dt[2],Ze[2]=He[0]*dt[1]-He[1]*dt[0],Bt=Ze[0]*Ze[0]+Ze[1]*Ze[1]+Ze[2]*Ze[2],Bt>H&&(H=Bt,ve[0]=Ze[0],ve[1]=Ze[1],ve[2]=Ze[2]);0>=H&&(ve[0]=ve[1]=ve[2]=0,ve[I(He)]=1)}ce=!0}for(Ze=I(ve),V=this.b.c,H=(Ze+1)%3,ae=(Ze+2)%3,Ze=0<ve[Ze]?1:-1,ve=V.e;ve!==V;ve=ve.e)ve.b=ve.g[H],ve.a=Ze*ve.g[ae];if(ce){for(ve=0,ce=this.b.a,V=ce.b;V!==ce;V=V.b)if(H=V.a,!(0>=H.f))do ve+=(H.a.b-H.b.a.b)*(H.a.a+H.b.a.a),H=H.e;while(H!==V.a);if(0>ve)for(ve=this.b.c,ce=ve.e;ce!==ve;ce=ce.e)ce.a=-ce.a}for(this.n=!1,ve=this.b.b,V=ve.h;V!==ve;V=ce)ce=V.h,H=V.e,n(V.a,V.b.a)&&V.e.e!==V&&(re(this,H,V),m(V),V=H,H=V.e),H.e===V&&(H!==V&&((H===ce||H===ce.b)&&(ce=ce.h),m(H)),(V===ce||V===ce.b)&&(ce=ce.h),m(V));for(this.e=ve=new Oe,ce=this.b.c,V=ce.e;V!==ce;V=V.e)V.h=rt(ve,V);for(nt(ve),this.f=new Ve(this),Le(this,-4e150),Le(this,_);(ve=pt(this.e))!==null;){for(;;){e:if(V=this.e,V.a===0)ce=it(V.b);else if(ce=V.c[V.d[V.a-1]],V.b.a!==0&&(V=it(V.b),s(V,ce))){ce=V;break e}if(ce===null||!n(ce,ve))break;ce=pt(this.e),re(this,ve.c,ce.c)}Fe(this,ve)}for(this.a=this.f.a.a.b.a.a,ve=0;(ce=this.f.a.a.b)!==null;)ce.h||++ve,N(ce);for(this.f=null,ve=this.e,ve.b=null,ve.d=null,this.e=ve.c=null,ve=this.b,V=ve.a.b;V!==ve.a;V=ce)ce=V.b,V=V.a,V.e.e===V&&(A(V.c,V),m(V));if(!this.n){if(ve=this.b,this.m)for(V=ve.b.h;V!==ve.b;V=ce)ce=V.h,V.b.d.c!==V.d.c?V.f=V.d.c?1:-1:m(V);else for(V=ve.a.b;V!==ve.a;V=ce)if(ce=V.b,V.c){for(V=V.a;s(V.b.a,V.a);V=V.c.b);for(;s(V.a,V.b.a);V=V.e);for(H=V.c.b,ae=void 0;V.e!==H;)if(s(V.b.a,H.a)){for(;H.e!==V&&(c(H.e)||0>=a(H.a,H.b.a,H.e.b.a));)ae=y(H.e,H),H=ae.b;H=H.c.b}else{for(;H.e!==V&&(h(V.c.b)||0<=a(V.b.a,V.a,V.c.b.a));)ae=y(V,V.c.b),V=ae.b;V=V.e}for(;H.e.e!==V;)ae=y(H.e,H),H=ae.b}if(this.h||this.i||this.k||this.l)if(this.m){for(ve=this.b,ce=ve.a.b;ce!==ve.a;ce=ce.b)if(ce.c){this.h&&this.h(2,this.c),V=ce.a;do this.k&&this.k(V.a.d,this.c),V=V.e;while(V!==ce.a);this.i&&this.i(this.c)}}else{for(ve=this.b,ce=!!this.l,V=!1,H=-1,ae=ve.a.d;ae!==ve.a;ae=ae.d)if(ae.c){V||(this.h&&this.h(4,this.c),V=!0),Ze=ae.a;do ce&&(He=Ze.b.d.c?0:1,H!==He&&(H=He,this.l&&this.l(!!H,this.c))),this.k&&this.k(Ze.a.d,this.c),Ze=Ze.e;while(Ze!==ae.a)}V&&this.i&&this.i(this.c)}if(this.r){for(ve=this.b,V=ve.a.b;V!==ve.a;V=ce)if(ce=V.b,!V.c){H=V.a,ae=H.e,Ze=void 0;do Ze=ae,ae=Ze.e,Ze.d=null,Ze.b.d===null&&(Ze.c===Ze?E(Ze.a,null):(Ze.a.c=Ze.c,x(Ze,pe(Ze))),He=Ze.b,He.c===He?E(He.a,null):(He.a.c=He.c,x(He,pe(He))),S(Ze));while(Ze!==H);H=V.d,V=V.b,V.d=H,H.b=V}this.r(this.b),this.c=this.b=null;return}}this.b=this.c=null};function qe(V,H){if(V.d!==H)for(;V.d!==H;)if(V.d<H)switch(V.d){case Ue:Me(V,100151),V.u(null);break;case 1:Me(V,100152),V.t()}else switch(V.d){case 2:Me(V,100154),V.v();break;case 1:Me(V,100153),V.w()}}function Me(V,H){V.p&&V.p(H,V.c)}function ie(V,H){this.b=V||this,this.d=H||this,this.a=null,this.c=!1}function K(){this.h=this,this.i=this.d=this.a=this.e=this.c=this.b=null,this.f=0}function pe(V){return V.b.e}function _e(){this.c=new We,this.a=new ie,this.b=new K,this.d=new K,this.b.b=this.d,this.d.b=this.b}function We(V,H){this.e=V||this,this.f=H||this,this.d=this.c=null,this.g=[0,0,0],this.h=this.a=this.b=0}function Oe(){this.c=[],this.d=null,this.a=0,this.e=!1,this.b=new Et}function nt(V){V.d=[];for(var H=0;H<V.a;H++)V.d[H]=H;V.d.sort(function(ae){return function(ce,ve){return s(ae[ce],ae[ve])?1:-1}}(V.c)),V.e=!0,Mt(V.b)}function rt(V,H){if(V.e){var ae=V.b,ce=++ae.a;2*ce>ae.f&&(ae.f*=2,ae.c=ht(ae.c,ae.f+1));var ve;return ae.b===0?ve=ce:(ve=ae.b,ae.b=ae.c[ae.b]),ae.e[ve]=H,ae.c[ve]=ce,ae.d[ce]=ve,ae.h&&wn(ae,ce),ve}return ae=V.a++,V.c[ae]=H,-(ae+1)}function pt(V){if(V.a===0)return kt(V.b);var H=V.c[V.d[V.a-1]];if(V.b.a!==0&&s(it(V.b),H))return kt(V.b);do--V.a;while(0<V.a&&V.c[V.d[V.a-1]]===null);return H}function Et(){this.d=ht([0],33),this.e=[null,null],this.c=[0,0],this.a=0,this.f=32,this.b=0,this.h=!1,this.d[1]=1}function ht(V,H){for(var ae=Array(H),ce=0;ce<V.length;ce++)ae[ce]=V[ce];for(;ce<H;ce++)ae[ce]=0;return ae}function Mt(V){for(var H=V.a;1<=H;--H)Lt(V,H);V.h=!0}function it(V){return V.e[V.d[1]]}function kt(V){var H=V.d,ae=V.e,ce=V.c,ve=H[1],He=ae[ve];return 0<V.a&&(H[1]=H[V.a],ce[H[1]]=1,ae[ve]=null,ce[ve]=V.b,V.b=ve,0<--V.a&&Lt(V,1)),He}function Lt(V,H){for(var ae=V.d,ce=V.e,ve=V.c,He=H,Ze=ae[He];;){var dt=He<<1;dt<V.a&&s(ce[ae[dt+1]],ce[ae[dt]])&&(dt+=1);var Bt=ae[dt];if(dt>V.a||s(ce[Ze],ce[Bt])){ae[He]=Ze,ve[Ze]=He;break}ae[He]=Bt,ve[Bt]=He,He=dt}}function wn(V,H){for(var ae=V.d,ce=V.e,ve=V.c,He=H,Ze=ae[He];;){var dt=He>>1,Bt=ae[dt];if(dt===0||s(ce[Bt],ce[Ze])){ae[He]=Ze,ve[Ze]=He;break}ae[He]=Bt,ve[Bt]=He,He=dt}}function Gr(){this.e=this.a=null,this.f=0,this.c=this.b=this.h=this.d=!1}function lr(V){return V.e.c.b}function Pr(V){return V.e.a.b}XP.libtess={GluTesselator:Te,windingRule:{GLU_TESS_WINDING_ODD:100130,GLU_TESS_WINDING_NONZERO:100131,GLU_TESS_WINDING_POSITIVE:100132,GLU_TESS_WINDING_NEGATIVE:100133,GLU_TESS_WINDING_ABS_GEQ_TWO:100134},primitiveType:{GL_LINE_LOOP:2,GL_TRIANGLES:4,GL_TRIANGLE_STRIP:5,GL_TRIANGLE_FAN:6},errorType:{GLU_TESS_MISSING_BEGIN_POLYGON:100151,GLU_TESS_MISSING_END_POLYGON:100153,GLU_TESS_MISSING_BEGIN_CONTOUR:100152,GLU_TESS_MISSING_END_CONTOUR:100154,GLU_TESS_COORD_TOO_LARGE:100155,GLU_TESS_NEED_COMBINE_CALLBACK:100156},gluEnum:{GLU_TESS_MESH:100112,GLU_TESS_TOLERANCE:100142,GLU_TESS_WINDING_RULE:100140,GLU_TESS_BOUNDARY_ONLY:100141,GLU_INVALID_ENUM:100900,GLU_INVALID_VALUE:100901,GLU_TESS_BEGIN:100100,GLU_TESS_VERTEX:100101,GLU_TESS_END:100102,GLU_TESS_ERROR:100103,GLU_TESS_EDGE_FLAG:100104,GLU_TESS_COMBINE:100105,GLU_TESS_BEGIN_DATA:100106,GLU_TESS_VERTEX_DATA:100107,GLU_TESS_END_DATA:100108,GLU_TESS_ERROR_DATA:100109,GLU_TESS_EDGE_FLAG_DATA:100110,GLU_TESS_COMBINE_DATA:100111}},Te.prototype.gluDeleteTess=Te.prototype.x,Te.prototype.gluTessProperty=Te.prototype.B,Te.prototype.gluGetTessProperty=Te.prototype.y,Te.prototype.gluTessNormal=Te.prototype.A,Te.prototype.gluTessCallback=Te.prototype.z,Te.prototype.gluTessVertex=Te.prototype.C,Te.prototype.gluTessBeginPolygon=Te.prototype.u,Te.prototype.gluTessBeginContour=Te.prototype.t,Te.prototype.gluTessEndContour=Te.prototype.v,Te.prototype.gluTessEndPolygon=Te.prototype.w,r.exports=XP.libtess}(dw)),dw.exports}var Pae=Lae();const Du=AT(Pae),C6={vertices:1,vertexNormals:1,vertexColors:4,vertexStrokeColors:4,uvs:2},ZP=Object.values(C6).reduce((r,t)=>r+t);class Bae{constructor(t){this.renderer=t,this.shapeMode=Eo,this.geometry=new ks(void 0,void 0,void 0,this.renderer),this.geometry.gid="__IMMEDIATE_MODE_GEOMETRY__",this.contourIndices=[],this._useUserVertexProperties=void 0,this._bezierVertex=[],this._quadraticVertex=[],this._curveVertex=[],this.isProcessingVertices=!1,this._tessy=this._initTessy(),this.tessyVertexSize=ZP,this.bufferStrides={...C6}}constructFromContours(t,n){this._useUserVertexProperties&&this._resetUserVertexProperties(),this.geometry.reset(),this.contourIndices=[],this.shapeMode=t.contours[0].kind;const s=!!this.renderer.states.strokeColor,i={};if(t.userVertexProperties){this._useUserVertexProperties=!0;for(const a in t.userVertexProperties){const o=t.vertexPropertyName(a),u=this.geometry._userVertexPropertyHelper(o,[],t.userVertexProperties[a]);i[a]=u,this.tessyVertexSize+=u.getDataSize(),this.bufferStrides[u.getSrcName()]=u.getDataSize(),this.renderer.buffers.user.push(new yi(u.getDataSize(),u.getSrcName(),u.getDstName(),o,this.renderer))}}else this._useUserVertexProperties=!1;for(const a of n){this.contourIndices.push(this.geometry.vertices.length);for(const o of a){if(this.shapeMode===Uy&&this.geometry.vertices.length%6===3)for(const u in this.bufferStrides){const l=this.bufferStrides[u],c=this.geometry[u];c.push(...c.slice(c.length-3*l,c.length-2*l),...c.slice(c.length-l,c.length))}this.geometry.vertices.push(o.position),this.geometry.vertexNormals.push(o.normal||new De(0,0,0)),this.geometry.uvs.push(o.textureCoordinates.x,o.textureCoordinates.y),this.renderer.states.fillColor?this.geometry.vertexColors.push(...o.fill.array()):this.geometry.vertexColors.push(0,0,0,0),this.renderer.states.strokeColor?this.geometry.vertexStrokeColors.push(...o.stroke.array()):this.geometry.vertexStrokeColors.push(0,0,0,0);for(const u in i){const l=i[u];u in o&&l.setCurrentData(o[u]),l.pushCurrentData()}}}s&&(this.geometry.edges=this._calculateEdges(this.shapeMode,this.geometry.vertices)),s&&!this.renderer.geometryBuilder&&this.geometry._edgesToVertices(),this.shapeMode===Eo?(this.isProcessingVertices=!0,this._tesselateShape(),this.isProcessingVertices=!1):this.shapeMode===sb?this.shapeMode=nb:this.shapeMode===Uy&&(this.shapeMode=em),this.renderer.states.textureMode===RS&&this.renderer.states._tex!==null&&this.renderer.states._tex.width>0&&this.renderer.states._tex.height>0&&(this.geometry.uvs=this.geometry.uvs.map((a,o)=>o%2===0?a/this.renderer.states._tex.width:a/this.renderer.states._tex.height))}_resetUserVertexProperties(){const t=this.geometry.userVertexProperties;for(const n in t){const s=t[n];delete this.bufferStrides[n],s.delete()}this._useUserVertexProperties=!1,this.tessyVertexSize=ZP,this.geometry.userVertexProperties={}}_calculateEdges(t,n){const s=[];let i=0;const a=this.contourIndices.slice();let o=-1;switch(t){case nb:for(i=0;i<n.length-2;i++)s.push([i,i+1]),s.push([i,i+2]);s.push([i,i+1]);break;case _S:for(i=1;i<n.length-1;i++)s.push([0,i]),s.push([i,i+1]);s.push([0,n.length-1]);break;case em:for(i=0;i<n.length-2;i=i+3)s.push([i,i+1]),s.push([i+1,i+2]),s.push([i+2,i]);break;case wm:for(i=0;i<n.length-1;i=i+2)s.push([i,i+1]);break;case Uy:for(i=0;i<n.length-5;i+=6)s.push([i,i+1]),s.push([i+1,i+2]),s.push([i+2,i+5]),s.push([i+5,i]);break;case sb:for(i=0;i<n.length-2;i+=2)s.push([i,i+1]),s.push([i+1,i+3]),s.push([i,i+2]);s.push([i,i+1]);break;default:for(i=0;i<n.length;i++)i===a[0]?o=a.shift():n[o]&&n[i].equals(n[o])?s.push([i-1,o]):s.push([i-1,i]);break}return s}_tesselateShape(){this.shapeMode=em;const t=[];for(let a=0;a<this.geometry.vertices.length;a++){this.contourIndices.length>0&&this.contourIndices[0]===a&&(this.contourIndices.shift(),t.push([])),t[t.length-1].push(this.geometry.vertices[a].x,this.geometry.vertices[a].y,this.geometry.vertices[a].z,this.geometry.uvs[a*2],this.geometry.uvs[a*2+1],this.geometry.vertexColors[a*4],this.geometry.vertexColors[a*4+1],this.geometry.vertexColors[a*4+2],this.geometry.vertexColors[a*4+3],this.geometry.vertexNormals[a].x,this.geometry.vertexNormals[a].y,this.geometry.vertexNormals[a].z);for(const o in this.geometry.userVertexProperties){const u=this.geometry.userVertexProperties[o],l=a*u.getDataSize(),c=l+u.getDataSize(),h=u.getSrcArray().slice(l,c);t[t.length-1].push(...h)}}const n=this._triangulate(t),s=this.geometry.vertices;this.geometry.vertices=[],this.geometry.vertexNormals=[],this.geometry.uvs=[];for(const a in this.geometry.userVertexProperties)this.geometry.userVertexProperties[a].resetSrcArray();const i=[];for(let a=0,o=n.length;a<o;a=a+this.tessyVertexSize){i.push(...n.slice(a+5,a+9)),this.geometry.vertexNormals.push(new De(...n.slice(a+9,a+12)));{let u=12;for(const l in this.geometry.userVertexProperties){const c=this.geometry.userVertexProperties[l],h=c.getDataSize(),d=a+u,p=d+h;c.setCurrentData(n.slice(d,p)),c.pushCurrentData(),u+=h}}this.geometry.vertices.push(new De(...n.slice(a,a+3))),this.geometry.uvs.push(...n.slice(a+3,a+5))}if(this.renderer.geometryBuilder){const a=new Map;this.geometry.edges=this.geometry.edges.map(o=>o.map(u=>{if(!a.has(u)){const l=s[u];let c=this.geometry.vertices.findIndex(h=>l.x===h.x&&l.y===h.y&&l.z===h.z);if(c===-1){let h=1/0,d=0;for(let p=0;p<this.geometry.vertices.length;p++){const f=this.geometry.vertices[p],m=l.x-f.x,g=l.y-f.y,y=l.z-f.z,b=m*m+g*g+y*y;b<h&&(h=b,d=p)}c=d}a.set(u,c)}return a.get(u)}))}this.geometry.vertexColors=i}_initTessy(){function t(u,l){for(const c of u)l.push(c)}function n(u){u!==Du.primitiveType.GL_TRIANGLES&&console.log(`expected TRIANGLES but got type: ${u}`)}function s(u){console.log("error callback"),console.log(`error number: ${u}`)}const i=(u,l,c)=>{const h=new Array(this.tessyVertexSize).fill(0);for(let d=0;d<c.length;d++)for(let p=0;p<h.length;p++)c[d]===0||!l[d]||(h[p]+=l[d][p]*c[d]);return h};function a(u){}const o=new Du.GluTesselator;return o.gluTessCallback(Du.gluEnum.GLU_TESS_VERTEX_DATA,t),o.gluTessCallback(Du.gluEnum.GLU_TESS_BEGIN,n),o.gluTessCallback(Du.gluEnum.GLU_TESS_ERROR,s),o.gluTessCallback(Du.gluEnum.GLU_TESS_COMBINE,i),o.gluTessCallback(Du.gluEnum.GLU_TESS_EDGE_FLAG,a),o.gluTessProperty(Du.gluEnum.GLU_TESS_WINDING_RULE,Du.windingRule.GLU_TESS_WINDING_NONZERO),o}_triangulate(t){const n=t[0]?t[0][2]:void 0;let s=!0;for(const a of t)for(let o=0;o<a.length;o+=this.tessyVertexSize)if(a[o+2]!==n){s=!1;break}s?this._tessy.gluTessNormal(0,0,1):this._tessy.gluTessNormal(0,0,0);const i=[];this._tessy.gluTessBeginPolygon(i);for(const a of t){this._tessy.gluTessBeginContour();for(let o=0;o<a.length;o+=this.tessyVertexSize){const u=a.slice(o,o+this.tessyVertexSize);this._tessy.gluTessVertex(u,u)}this._tessy.gluTessEndContour()}return this._tessy.gluTessEndPolygon(),i}}class Vae{constructor(t){this.renderer=t,this.cache={}}numCached(){return Object.keys(this.cache).length}isCached(t){return this.cache[t]!==void 0}getGeometryByID(t){var n;return(n=this.cache[t])==null?void 0:n.geometry}getCached(t){return this.getCachedID(t.gid)}getCachedID(t){return this.cache[t]}ensureCached(t){const n=t.gid;if(!n)throw new Error("The p5.Geometry you passed in has no gid property!");if(this.isCached(t.gid))return this.getCached(t);const s=this.renderer.GL;if(this.freeBuffers(n),Object.keys(this.cache).length>1e3){const o=Object.keys(this.cache)[0];this.freeBuffers(o)}const i={};this.cache[n]=i,i.geometry=t;let a=i.indexBuffer;if(t.faces.length){a||(a=i.indexBuffer=s.createBuffer());const o=t.faces.flat(),u=o.some(c=>c>65535);let l=u?Uint32Array:Uint16Array;this.renderer._bindBuffer(a,s.ELEMENT_ARRAY_BUFFER,o,l),i.indexBufferType=u?s.UNSIGNED_INT:s.UNSIGNED_SHORT}else a&&(s.deleteBuffer(a),i.indexBuffer=null);return i}freeBuffers(t){const n=this.cache[t];if(!n)return;delete this.cache[t];const s=this.renderer.GL;n.indexBuffer&&s.deleteBuffer(n.indexBuffer);function i(a){for(const o of a)n[o.dst]&&(s.deleteBuffer(n[o.dst]),n[o.dst]=null)}i(this.renderer.buffers.stroke),i(this.renderer.buffers.fill),i(this.renderer.buffers.user)}}const jw={[Sm]:3,[$S]:4,[FS]:.5};function VT(r,t){const n=t.DEGREES="degrees",s=t.RADIANS="radians";t._angleMode=s,t.acos=function(i){return this._fromRadians(Math.acos(i))},t.asin=function(i){return this._fromRadians(Math.asin(i))},t.atan=function(i){return this._fromRadians(Math.atan(i))},t.atan2=function(i,a){return this._fromRadians(Math.atan2(i,a))},t.cos=function(i){return Math.cos(this._toRadians(i))},t.sin=function(i){return Math.sin(this._toRadians(i))},t.tan=function(i){return Math.tan(this._toRadians(i))},t.degrees=i=>i*ch,t.radians=i=>i*lh,t.angleMode=function(i){if(typeof i>"u")return this._angleMode;if(i===n||i===s){const a=this._angleMode;if(i===a)return;i===s?(this.pRotationX=this.pRotationX*lh,this.pRotationY=this.pRotationY*lh,this.pRotationZ=this.pRotationZ*lh):(this.pRotationX=this.pRotationX*ch,this.pRotationY=this.pRotationY*ch,this.pRotationZ=this.pRotationZ*ch),this._angleMode=i}},t._toRadians=function(i){return this._angleMode===n?i*lh:i},t._toDegrees=function(i){return this._angleMode===s?i*ch:i},t._fromRadians=function(i){return this._angleMode===n?i*ch:i},t._fromDegrees=function(i){return this._angleMode===s?i*lh:i}}typeof p5<"u"&&VT(p5,p5.prototype);function zT(r,t){t.createImage=function(n,s){return new r.Image(n,s)},t.saveCanvas=function(...n){let s,i,a,o;if(n[0]instanceof HTMLCanvasElement)s=n[0],n.shift();else if(n[0]instanceof Sr)s=n[0].elt,n.shift();else if(n[0]instanceof yo){const l=n[0];o=this.createGraphics(l.width,l.height),o.pixelDensity(l.pixelDensity()),l.loadPixels(),o.loadPixels(),o.pixels.set(l.pixels),o.updatePixels(),s=o._renderer.canvas,n.shift()}else s=this._curElement&&this._curElement.elt;n.length>=1&&(i=n[0]),n.length>=2&&(a=n[1]),a=a||t._checkFileExtension(i,a)[1]||"png";let u;switch(a){default:u="image/png";break;case"webp":u="image/webp";break;case"jpeg":case"jpg":u="image/jpeg";break}s.toBlob(l=>{t.downloadFile(l,i,a),o&&o.remove()},u)},t.encodeAndDownloadGif=function(n,s){const i=n.gifProperties;let a=i.loopLimit;a===1?a=null:a===null&&(a=0);const o=new Uint8Array(n.width*n.height*i.numFrames),u=[],l={};for(let v=0;v<i.numFrames;v++){const S=new Set,E=i.frames[v].image.data,C=E.length,I=new Uint32Array(n.width*n.height);for(let A=0,k=0;A<C;A+=4,k++){const N=E[A+0],D=E[A+1],F=E[A+2],P=N<<16|D<<8|F<<0;S.add(P),I[k]=P}const _=[...S].sort().toString();l[_]===void 0?l[_]={freq:1,frames:[v]}:(l[_].freq+=1,l[_].frames.push(v)),u.push(I)}let c=[];const h=Object.keys(l).sort(function(v,S){return l[S].freq-l[v].freq}),d=h[0].split(",").map(v=>parseInt(v));c=c.concat(l[d].frames);const p=new Set(d);for(let v=1;v<h.length;v++){const E=h[v].split(",").map(C=>parseInt(C)).filter(C=>!p.has(C));if(d.length+E.length<=256){for(let C=0;C<E.length;C++)d.push(E[C]),p.add(E[C]);c=c.concat(l[h[v]].frames)}}c=new Set(c);const f={};for(let v=0;v<d.length;v++)f[d[v]]||(f[d[v]]=v);let m=1;for(;m<d.length;)m<<=1;d.length=m;const g={loop:a,palette:new Uint32Array(d)},y=new o6.GifWriter(o,n.width,n.height,g);let b={};for(let v=0;v<i.numFrames;v++){const S=!c.has(v),E=S?[]:d,C=new Uint8Array(n.width*n.height),I={},_=new Set;u[v].forEach((N,D)=>{S?(I[N]===void 0&&(I[N]=E.length,E.push(N)),C[D]=I[N]):C[D]=f[N],v>0&&u[v-1][D]!==N&&_.add(N)});const A={},k=E.filter(N=>!_.has(N));if(k.length>0){const N=k[0],D=S?I[N]:f[N];if(v>0){for(let F=0;F<u[v].length;F++)u[v-1][F]===u[v][F]&&(C[F]=D);A.transparent=D,b.frameOpts.disposal=1}}if(A.delay=i.frames[v].delay/10,S){let N=1;for(;N<E.length;)N<<=1;E.length=N,A.palette=new Uint32Array(E)}v>0&&y.addFrame(0,0,n.width,n.height,b.pixelPaletteIndex,b.frameOpts),b={pixelPaletteIndex:C,frameOpts:A}}b.frameOpts.disposal=1,y.addFrame(0,0,n.width,n.height,b.pixelPaletteIndex,b.frameOpts);const x="gif",w=new Blob([o.slice(0,y.end())],{type:"image/gif"});t.downloadFile(w,s,x)},t.saveFrames=function(n,s,i,a,o){let u=i||3;u=Math.max(Math.min(u,15),0),u=u*1e3;let l=a||15;l=Math.max(Math.min(l,22),0);let c=0;const h=t._makeFrame,d=this._curElement.elt;let p=[];const f=setInterval(()=>{p.push(h(n+c,s,d)),c++},1e3/l);setTimeout(()=>{if(clearInterval(f),o)o(p);else for(const m of p)t.downloadFile(m.imageData,m.filename,m.ext);p=[]},u+.01)},t._makeFrame=function(n,s,i){let a;this?a=this._curElement.elt:a=i;let o;if(!s)s="png",o="image/png";else switch(s.toLowerCase()){case"png":o="image/png";break;case"jpeg":o="image/jpeg";break;case"jpg":o="image/jpeg";break;default:o="image/png";break}const u="image/octet-stream";let l=a.toDataURL(o);l=l.replace(o,u);const c={};return c.imageData=l,c.filename=n,c.ext=s,c}}typeof p5<"u"&&zT(p5,p5.prototype);class JP extends Error{constructor(){super(...arguments);Ar(this,"status");Ar(this,"response");Ar(this,"ok")}}async function ca(r,t){try{const n=await fetch(r);if(n.ok){let s;switch(t){case"json":s=await n.json();break;case"text":s=await n.text();break;case"arrayBuffer":s=await n.arrayBuffer();break;case"blob":s=await n.blob();break;case"bytes":if(n.bytes)s=await n.bytes();else{const i=await n.arrayBuffer();s=new Uint8Array(i)}break;default:throw new Error("Unsupported response type")}return{data:s,headers:n.headers}}else{const s=new JP(n.statusText);throw s.status=n.status,s.response=n,s.ok=!1,s}}catch(n){throw n instanceof TypeError?console.log("You may have encountered a CORS error"):n instanceof JP?console.log("You have encountered a HTTP error"):n instanceof SyntaxError&&console.log("There is an error parsing the response to requested data structure"),n}}function _6(r,t){t.loadJSON=async function(s,i,a){try{const{data:o}=await ca(s,"json");return i?i(o):o}catch(o){if(r._friendlyFileLoadError(5,s),a)return a(o);throw o}},t.loadStrings=async function(s,i,a){try{let{data:o}=await ca(s,"text");return o=o.split(/\r?\n/),i?i(o):o}catch(o){if(r._friendlyFileLoadError(3,s),a)return a(o);throw o}},t.loadTable=async function(s,i,a,o,u){typeof arguments[arguments.length-1]=="function"&&(typeof arguments[arguments.length-2]=="function"?(o=arguments[arguments.length-2],u=arguments[arguments.length-1]):o=arguments[arguments.length-1]),typeof i!="string"&&(i=","),typeof a=="function"&&(a=!1);try{let{data:l}=await ca(s,"text"),c=new r.Table;return l=mae(l,{separator:i}),a?c.columns=l.shift():c.columns=Array(l[0].length).fill(null),l.forEach(h=>{const d=new r.TableRow(h);c.addRow(d)}),o?o(c):c}catch(l){if(r._friendlyFileLoadError(2,s),u)return u(l);throw l}},t.loadXML=async function(s,i,a){try{const o=new DOMParser;let{data:u}=await ca(s,"text");const l=o.parseFromString(u,"application/xml");return u=new r.XML(l),i?i(u):u}catch(o){if(r._friendlyFileLoadError(1,s),a)return a(o);throw o}},t.loadBytes=async function(s,i,a){try{let{data:o}=await ca(s,"arrayBuffer");return o=new Uint8Array(o),i?i(o):o}catch(o){if(r._friendlyFileLoadError(6,s),a)return a(o);throw o}},t.loadBlob=async function(s,i,a){try{const{data:o}=await ca(s,"blob");return i?i(o):o}catch(o){if(a)return a(o);throw o}},t.httpGet=async function(s,i="text",a,o){return typeof i=="function"&&(o=a,a=i,i="text"),this.httpDo(s,"GET",i,a,o)},t.httpPost=async function(s,i,a="text",o,u){typeof i=="function"?(o=i,u=a,i=void 0,a="text"):typeof a=="function"&&(u=o,o=a,a="text");let l=i,c="text/plain";i instanceof r.XML?(l=i.serialize(),c="application/xml"):i instanceof r.Image?(l=await i.toBlob(),c="image/png"):typeof i=="object"&&(l=JSON.stringify(i),c="application/json");const h={method:"POST",body:l,headers:{"Content-Type":c}};l&&(h.body=l);const d=new Request(s,h);return this.httpDo(d,"POST",a,o,u)},t.httpDo=async function(s,i,a,o,u){if(typeof a=="function"&&(u=o,o=a,a=void 0),!a)switch(typeof s=="string"?s.split(".").pop():s.url.split(".").pop()){case"json":a="json";break;case"jpg":case"jpeg":case"png":case"webp":case"gif":a="blob";break;case"xml":case"txt":default:a="text"}const l=new Request(s,{method:i});try{const{data:c}=await ca(l,a);return o?o(c):c}catch(c){if(u)return u(c);throw c}},t._pWriters=[],t.createWriter=function(s,i){let a;for(const o in t._pWriters)if(t._pWriters[o].name===s)return a=new r.PrintWriter(s+this.millis(),i),t._pWriters.push(a),a;return a=new r.PrintWriter(s,i),t._pWriters.push(a),a},r.PrintWriter=function(s,i){let a=this;this.name=s,this.content="",this.write=function(o){this.content+=o},this.print=function(o){this.content+=`${o}
`},this.clear=function(){this.content=""},this.close=function(){const o=[];o.push(this.content),t.writeFile(o,s,i);for(const u in t._pWriters)t._pWriters[u].name===this.name&&t._pWriters.splice(u,1);a.clear(),a={}}},t.save=function(s,i,a){const o=arguments,u=this._curElement?this._curElement.elt:this.elt;if(o.length===0){t.saveCanvas(u);return}else if(o[0]instanceof Gt||o[0]instanceof Em){t.saveCanvas(o[0].canvas,o[1],o[2]);return}else if(o.length===1&&typeof o[0]=="string")t.saveCanvas(u,o[0]);else switch(Hw(o[1],o[2])[1]){case"json":t.saveJSON(o[0],o[1],o[2]);return;case"txt":t.saveStrings(o[0],o[1],o[2]);return;default:o[0]instanceof Array?t.saveStrings(o[0],o[1],o[2]):o[0]instanceof r.Table?t.saveTable(o[0],o[1],o[2]):o[0]instanceof r.Image?t.saveCanvas(o[0].canvas,o[1]):o[0]instanceof r.SoundFile&&t.saveSound(o[0],o[1],o[2],o[3])}},t.saveJSON=function(s,i,a){let o;a?o=JSON.stringify(s):o=JSON.stringify(s,void 0,2),this.saveStrings(o.split(`
`),i,"json")},t.saveStrings=function(s,i,a,o){const u=a||"txt",l=new r.PrintWriter(i,u);for(let c of s)o?l.write(c+`\r
`):l.write(c+`
`);l.close(),l.clear()};function n(s){return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;")}t.saveTable=function(s,i,a){let o;a===void 0?(o=i.substring(i.lastIndexOf(".")+1,i.length),o===i&&(o="csv")):o=a;const u=this.createWriter(i,o),l=s.columns;let c=",";if(o==="tsv"&&(c="	"),o!=="html"){const h=s.toString(c);u.write(h)}else{u.print("<html>"),u.print("<head>");let h='  <meta http-equiv="content-type" content';if(h+='="text/html;charset=utf-8" />',u.print(h),u.print("</head>"),u.print("<body>"),u.print("  <table>"),l[0]!=="0"){u.print("    <tr>");for(let d=0;d<l.length;d++){const p=n(l[d]);u.print(`      <td>${p}`),u.print("      </td>")}u.print("    </tr>")}for(let d=0;d<s.rows.length;d++){u.print("    <tr>");for(let p=0;p<s.columns.length;p++){const f=s.rows[d].getString(p),m=n(f);u.print(`      <td>${m}`),u.print("      </td>")}u.print("    </tr>")}u.print("  </table>"),u.print("</body>"),u.print("</html>")}u.close(),u.clear()},t.writeFile=function(s,i,a){let o="application/octet-stream";t._isSafari()&&(o="text/plain");const u=new Blob(s,{type:o});t.downloadFile(u,i,a)},t.downloadFile=DT,t._checkFileExtension=Hw,t._isSafari=function(){return/^((?!chrome|android).)*safari/i.test(navigator.userAgent)}}typeof p5<"u"&&_6(p5,p5.prototype);function UT(r,t){t.loadImage=async function(c,h,d){try{let p=new r.Image(1,1,this);const f=new Request(c,{method:"GET",mode:"cors"}),{data:m,headers:g}=await ca(f,"bytes"),y=g.get("content-type");if(y===null&&console.warn("The image you loaded does not have a Content-Type header. If you are using the online editor consider reuploading the asset."),y&&y.includes("image/gif"))await i(m,p);else{const b=new Blob([m]),x=await createImageBitmap(b);p.width=p.canvas.width=x.width,p.height=p.canvas.height=x.height,p.drawingContext.drawImage(x,0,0)}return p.modified=!0,h?h(p):p}catch(p){if(r._friendlyFileLoadError(0,c),typeof d=="function")return d(p);throw p}},t.saveGif=async function(c,h,d={delay:0,units:"seconds",silent:!1,notificationDuration:0,notificationID:"progressBar"}){if(typeof c!="string")throw TypeError("fileName parameter must be a string");if(typeof h!="number")throw TypeError("Duration parameter must be a number");const p=d&&d.delay||0,f=d&&d.units||"seconds",m=d&&d.silent||!1,g=d&&d.notificationDuration||0,y=d&&d.notificationID||"progressBar";if(typeof p!="number")throw TypeError("Delay parameter must be a number");if(f!=="seconds"&&f!=="frames")throw TypeError('Units parameter must be either "frames" or "seconds"');if(typeof m!="boolean")throw TypeError("Silent parameter must be a boolean");if(typeof g!="number")throw TypeError("Notification duration parameter must be a number");if(typeof y!="string")throw TypeError("Notification ID parameter must be a string");this._recording=!0;let b=this._targetFrameRate;(b===1/0||b===void 0||b===0)&&(b=60);let x=1/b*1e3;x=x<20?20:x;const w=f==="seconds"?h*b:h,v=f==="seconds"?p*b:p,S=w+v;let E=v;this.frameCount=E;const C=this._renderer._pixelDensity;this.pixelDensity(1);let I=[];document.getElementById(y)!==null&&document.getElementById(y).remove();let _;m||(_=this.createP(""),_.id(y),_.style("font-size","16px"),_.style("font-family","Montserrat"),_.style("background-color","#ffffffa0"),_.style("padding","8px"),_.style("border-radius","10px"),_.position(0,0));let A,k;for(this._renderer instanceof r.RendererGL&&(k=this.drawingContext,A=new Uint8Array(k.drawingBufferWidth*k.drawingBufferHeight*4)),this.noLoop(),await Promise.resolve();E<S;){this.redraw();let re;this._renderer instanceof r.RendererGL?(A=new Uint8Array(k.drawingBufferWidth*k.drawingBufferHeight*4),k.readPixels(0,0,k.drawingBufferWidth,k.drawingBufferHeight,k.RGBA,k.UNSIGNED_BYTE,A),re=n(A,this.width,this.height)):re=this.drawingContext.getImageData(0,0,this.width,this.height).data,I.push(re),E++,m||_.html("Saved frame <b>"+I.length.toString()+"</b> out of "+w.toString()),await new Promise(J=>setTimeout(J,0))}m||_.html("Frames processed, generating color palette..."),this.loop(),this.pixelDensity(C);const N=Aae(),D=s(I),F={},P=re=>{const J=re.length/4,le=new Uint8Array(J);for(let he=0;he<J;he++){const xe=re[he*4]<<24|re[he*4+1]<<16|re[he*4+2]<<8|re[he*4+3];F[xe]===void 0&&(F[xe]=Tae(D,re.slice(he*4,(he+1)*4))),le[he]=F[xe]}return le},G=D.length-1;let Y=[];for(let re=0;re<I.length;re++){const J=P(I[re]),le=J.slice();if(re===0)N.writeFrame(J,this.width,this.height,{palette:D,delay:x,dispose:1});else{for(let he=0;he<J.length;he++)J[he]===Y[he]&&(J[he]=G);N.writeFrame(J,this.width,this.height,{delay:x,transparent:!0,transparentIndex:G,dispose:1})}Y=le,m||_.html("Rendered frame <b>"+re.toString()+"</b> out of "+w.toString()),await new Promise(he=>setTimeout(he,0))}N.finish();const Z=N.bytesView(),ee="gif",se=new Blob([Z],{type:"image/gif"});I=[],this._recording=!1,this.loop(),m||(_.html("Done. Downloading your gif!"),g>0&&setTimeout(()=>_.remove(),g*1e3)),t.downloadFile(se,c,ee)};function n(c,h,d){const p=parseInt(d/2),f=h*4,m=new Uint8Array(h*4);for(let g=0;g<p;++g){const y=g*f,b=(d-g-1)*f;m.set(c.subarray(y,y+f)),c.copyWithin(y,b,b+f),c.set(m,b)}return c}function s(c){let h=new Uint8Array(c.length*c[0].length);for(let p=0;p<c.length;p++)h.set(c[p],p*c[0].length);let d=Iae(h,256,{format:"rgba4444",oneBitAlpha:!0});return d.length===256?d[d.length-1]=[Math.random()*255,Math.random()*255,Math.random()*255,0]:d.push([Math.random()*255,Math.random()*255,Math.random()*255,0]),d}async function i(c,h){const d=new o6.GifReader(c);h.width=h.canvas.width=d.width,h.height=h.canvas.height=d.height;const p=[],f=d.numFrames();let m=new Uint8ClampedArray(h.width*h.height*4);const g=(b,x)=>{try{x.decodeAndBlitFrameRGBA(b,m)}catch(w){throw r._friendlyFileLoadError(8,h.src),w}};for(let b=0;b<f;b++){const x=d.frameInfo(b),w=h.drawingContext.getImageData(0,0,h.width,h.height);m=w.data.slice(),g(b,d);const v=new ImageData(m,h.width,h.height);h.drawingContext.putImageData(v,0,0);let S=x.delay;S===0&&(S=10),p.push({image:h.drawingContext.getImageData(0,0,h.width,h.height),delay:S*10}),x.disposal===2?h.drawingContext.clearRect(x.x,x.y,x.width,x.height):x.disposal===3&&h.drawingContext.putImageData(w,0,0,x.x,x.y,x.width,x.height)}let y=d.loopCount();return y===null?y=1:y===0&&(y=null),h.drawingContext.putImageData(p[0].image,0,0),p.length>1&&(h.gifProperties={displayIndex:0,loopLimit:y,loopCount:0,frames:p,numFrames:f,playing:!0,timeDisplayed:0,lastChangeTime:0}),h}function a(c,h,d,p,f,m,g,y){const b=Math.max(g/f,y/m),[x,w]=[g/b,y/b];let v=d,S=p;return c===Ki?v+=(f-x)/2:c===Ow&&(v+=f-x),h===Ki?S+=(m-w)/2:h===$I&&(S+=m-w),{x:v,y:S,w:x,h:w}}function o(c,h,d,p,f,m,g,y){const b=Math.max(d/g,p/y),[x,w]=[d/b,p/b];let v=f,S=m;return c===Ki?v+=(g-x)/2:c===Ow&&(v+=g-x),h===Ki?S+=(y-w)/2:h===$I&&(S+=y-w),{x:v,y:S,w:x,h:w}}function u(c,h,d,p,f,m,g,y,b,x,w){if(c===mU){const{x:v,y:S,w:E,h:C}=o(h,d,m,g,y,b,x,w);y=v,b=S,x=E,w=C}if(c===fU){const{x:v,y:S,w:E,h:C}=a(h,d,p,f,m,g,x,w);p=v,f=S,m=E,g=C}return{sx:y,sy:b,sw:x,sh:w,dx:p,dy:f,dw:m,dh:g}}function l(c,h){return c>0&&c<h?c:h}t.image=function(c,h,d,p,f,m,g,y,b,x,w,v){let S=c.width,E=c.height;v=v||Ki,w=w||Ki,c.elt&&(S=S!==void 0?S:c.elt.width,E=E!==void 0?E:c.elt.height),c.elt&&c.elt.videoWidth&&!c.canvas&&(S=S!==void 0?S:c.elt.videoWidth,E=E!==void 0?E:c.elt.videoHeight);let C=h,I=d,_=p||S,A=f||E,k=m||0,N=g||0,D=y!==void 0?y:S,F=b!==void 0?b:E;D=l(D,S),F=l(F,E);let P=1;c.elt&&!c.canvas&&c.elt.style.width&&(c.elt.videoWidth&&!p?P=c.elt.videoWidth:P=c.elt.width,P/=parseInt(c.elt.style.width,10)),k*=P,N*=P,F*=P,D*=P;let G=cw.modeAdjust(C,I,_,A,this._renderer.states.imageMode);G=u(x,w,v,G.x,G.y,G.w,G.h,k,N,D,F),this._renderer.image(c,G.sx,G.sy,G.sw,G.sh,G.dx,G.dy,G.dw,G.dh)},t.tint=function(...c){const h=this.color(...c);this._renderer.states.setValue("tint",h._getRGBA([255,255,255,255]))},t.noTint=function(){this._renderer.states.setValue("tint",null)},t.imageMode=function(c){(c===xa||c===tb||c===Ki)&&this._renderer.states.setValue("imageMode",c)}}typeof p5<"u"&&UT(p5,p5.prototype);class Kh{constructor(t){this._renderer=t,this.cameraType="default",this.useLinePerspective=!0,this.cameraMatrix=new qn(4),this.projMatrix=new qn(4),this.yScale=1}perspective(t,n,s,i){this.cameraType=arguments.length>0?"custom":"default",typeof t>"u"?(t=this.defaultCameraFOV,this.cameraFOV=t):this.cameraFOV=this._renderer._pInst._toRadians(t),typeof n>"u"&&(n=this.defaultAspectRatio),typeof s>"u"&&(s=this.defaultCameraNear),typeof i>"u"&&(i=this.defaultCameraFar),s<=1e-4&&(s=.01,console.log("Avoid perspective near plane values close to or below 0. Setting value to 0.01.")),i<s&&console.log("Perspective far plane value is less than near plane value. Nothing will be shown."),this.aspectRatio=n,this.cameraNear=s,this.cameraFar=i,this.projMatrix=new qn(4);const a=1/Math.tan(this.cameraFOV/2),o=1/(this.cameraNear-this.cameraFar);this.projMatrix.set(a/n,0,0,0,0,-a*this.yScale,0,0,0,0,(i+s)*o,-1,0,0,2*i*s*o,0),this._isActive()&&(this._renderer.states.setValue("uPMatrix",this._renderer.states.uPMatrix.clone()),this._renderer.states.uPMatrix.set(this.projMatrix))}ortho(t,n,s,i,a,o){const u=this.fbo||this._renderer;t===void 0&&(t=-u.width/2),n===void 0&&(n=+u.width/2),s===void 0&&(s=-u.height/2),i===void 0&&(i=+u.height/2),a===void 0&&(a=0),o===void 0&&(o=Math.max(u.width,u.height)+800),this.cameraNear=a,this.cameraFar=o;const l=n-t,c=i-s,h=o-a,d=2/l,p=2/c*this.yScale,f=-2/h,m=-(n+t)/l,g=-(i+s)/c,y=-(o+a)/h;this.projMatrix=new qn(4),this.projMatrix.set(d,0,0,0,0,-p,0,0,0,0,f,0,m,g,y,1),this._isActive()&&(this._renderer.states.setValue("uPMatrix",this._renderer.states.uPMatrix.clone()),this._renderer.states.uPMatrix.set(this.projMatrix)),this.cameraType="custom"}frustum(t,n,s,i,a,o){t===void 0&&(t=-this._renderer.width*.05),n===void 0&&(n=+this._renderer.width*.05),s===void 0&&(s=+this._renderer.height*.05),i===void 0&&(i=-this._renderer.height*.05),a===void 0&&(a=this.defaultCameraNear),o===void 0&&(o=this.defaultCameraFar),this.cameraNear=a,this.cameraFar=o;const u=n-t,l=i-s,c=o-a,h=+(2*a)/u,d=+(2*a)/l*this.yScale,p=-(2*o*a)/c,f=(n+t)/u,m=(i+s)/l,g=-(o+a)/c;this.projMatrix=new qn(4),this.projMatrix.set(h,0,0,0,0,-d,0,0,f,m,g,-1,0,0,p,0),this._isActive()&&(this._renderer.states.setValue("uPMatrix",this._renderer.states.uPMatrix.clone()),this._renderer.states.uPMatrix.set(this.projMatrix)),this.cameraType="custom"}_rotateView(t,n,s,i){let a=this.centerX,o=this.centerY,u=this.centerZ;a-=this.eyeX,o-=this.eyeY,u-=this.eyeZ;const l=new qn(4);l.rotate4x4(this._renderer._pInst._toRadians(t),n,s,i);const c=[a*l.mat4[0]+o*l.mat4[4]+u*l.mat4[8],a*l.mat4[1]+o*l.mat4[5]+u*l.mat4[9],a*l.mat4[2]+o*l.mat4[6]+u*l.mat4[10]];c[0]+=this.eyeX,c[1]+=this.eyeY,c[2]+=this.eyeZ,this.camera(this.eyeX,this.eyeY,this.eyeZ,c[0],c[1],c[2],this.upX,this.upY,this.upZ)}roll(t){const n=this._getLocalAxes(),i=um.fromAxisAngle(this._renderer._pInst._toRadians(t),n.z[0],n.z[1],n.z[2]).rotateVector(new De(this.upX,this.upY,this.upZ));this.camera(this.eyeX,this.eyeY,this.eyeZ,this.centerX,this.centerY,this.centerZ,i.x,i.y,i.z)}pan(t){const n=this._getLocalAxes();this._rotateView(t,n.y[0],n.y[1],n.y[2])}tilt(t){const n=this._getLocalAxes();this._rotateView(t,n.x[0],n.x[1],n.x[2])}lookAt(t,n,s){this.camera(this.eyeX,this.eyeY,this.eyeZ,t,n,s,this.upX,this.upY,this.upZ)}camera(t,n,s,i,a,o,u,l,c){typeof t>"u"&&(t=this.defaultEyeX,n=this.defaultEyeY,s=this.defaultEyeZ,i=t,a=n,o=0,u=0,l=1,c=0),this.eyeX=t,this.eyeY=n,this.eyeZ=s,typeof i<"u"&&(this.centerX=i,this.centerY=a,this.centerZ=o),typeof u<"u"&&(this.upX=u,this.upY=l,this.upZ=c);const h=this._getLocalAxes();this.cameraMatrix.set(h.x[0],h.y[0],h.z[0],0,h.x[1],h.y[1],h.z[1],0,h.x[2],h.y[2],h.z[2],0,0,0,0,1);const d=-t,p=-n,f=-s;return this.cameraMatrix.translate([d,p,f]),this._isActive()&&(this._renderer.states.setValue("uViewMatrix",this._renderer.states.uViewMatrix.clone()),this._renderer.states.uViewMatrix.set(this.cameraMatrix)),this}move(t,n,s){const i=this._getLocalAxes(),a=[i.x[0]*t,i.x[1]*t,i.x[2]*t],o=[i.y[0]*n,i.y[1]*n,i.y[2]*n],u=[i.z[0]*s,i.z[1]*s,i.z[2]*s];this.camera(this.eyeX+a[0]+o[0]+u[0],this.eyeY+a[1]+o[1]+u[1],this.eyeZ+a[2]+o[2]+u[2],this.centerX+a[0]+o[0]+u[0],this.centerY+a[1]+o[1]+u[1],this.centerZ+a[2]+o[2]+u[2],this.upX,this.upY,this.upZ)}setPosition(t,n,s){const i=t-this.eyeX,a=n-this.eyeY,o=s-this.eyeZ;this.camera(t,n,s,this.centerX+i,this.centerY+a,this.centerZ+o,this.upX,this.upY,this.upZ)}set(t){const n=["eyeX","eyeY","eyeZ","centerX","centerY","centerZ","upX","upY","upZ","cameraFOV","aspectRatio","cameraNear","cameraFar","cameraType","yScale","useLinePerspective"];for(const s of n)this[s]=t[s];this.cameraMatrix=t.cameraMatrix.copy(),this.projMatrix=t.projMatrix.copy(),this._isActive()&&(this._renderer.states.setValue("uModelMatrix",this._renderer.states.uModelMatrix.clone()),this._renderer.states.setValue("uViewMatrix",this._renderer.states.uViewMatrix.clone()),this._renderer.states.setValue("uPMatrix",this._renderer.states.uPMatrix.clone()),this._renderer.states.uModelMatrix.reset(),this._renderer.states.uViewMatrix.set(this.cameraMatrix),this._renderer.states.uPMatrix.set(this.projMatrix))}slerp(t,n,s){if(s===0){this.set(t);return}else if(s===1){this.set(n);return}this.projMatrix.mat4[15]!==0&&(this.projMatrix.setElement(0,t.projMatrix.mat4[0]*Math.pow(n.projMatrix.mat4[0]/t.projMatrix.mat4[0],s)),this.projMatrix.setElement(5,t.projMatrix.mat4[5]*Math.pow(n.projMatrix.mat4[5]/t.projMatrix.mat4[5],s)),this._isActive()&&(this._renderer.states.setValue("uPMatrix",this._renderer.states.uPMatrix.clone()),this._renderer.states.uPMatrix.mat4=this.projMatrix.mat4.slice()));const i=new De(t.eyeX,t.eyeY,t.eyeZ),a=new De(n.eyeX,n.eyeY,n.eyeZ),o=new De(t.centerX,t.centerY,t.centerZ),u=new De(n.centerX,n.centerY,n.centerZ),l=De.dist(i,o),c=De.dist(a,u),h=l*Math.pow(c/l,s),d=De.sub(i,a),p=i.copy().sub(a).sub(o).add(u),f=p.magSq();let m=1;f>1e-6&&(m=De.dot(d,p)/f,m=Math.max(0,Math.min(m,1)));const g=De.lerp(De.lerp(i,o,m),De.lerp(a,u,m),s),y=t.cameraMatrix.createSubMatrix3x3(),b=n.cameraMatrix.createSubMatrix3x3(),x=y.row(2),w=b.row(2),v=y.row(1),S=b.row(1),E=new De,C=new De,I=new De,_=new De,A=b.mult(y.copy().transpose()),k=A.diagonal();let N=.5*(k[0]+k[1]+k[2]-1);if(1-N<1e-7){E.set(De.lerp(x,w,s)).normalize(),I.set(E).mult(m*h).add(g),_.set(E).mult((m-1)*h).add(g),C.set(De.lerp(v,S,s)).normalize(),this.camera(I.x,I.y,I.z,_.x,_.y,_.z,C.x,C.y,C.z);return}let D,F,P,G,Y=1/(1-N);const Z=Math.max(k[0],k[1],k[2]),ee=A.mat3[1]+A.mat3[3],se=A.mat3[2]+A.mat3[6],re=A.mat3[5]+A.mat3[7];Z===k[0]?(D=Math.sqrt((k[0]-N)*Y),Y/=D,F=.5*ee*Y,P=.5*se*Y,G=.5*(A.mat3[7]-A.mat3[5])/D):Z===k[1]?(F=Math.sqrt((k[1]-N)*Y),Y/=F,P=.5*re*Y,D=.5*ee*Y,G=.5*(A.mat3[2]-A.mat3[6])/F):(P=Math.sqrt((k[2]-N)*Y),Y/=P,D=.5*se*Y,F=.5*re*Y,G=.5*(A.mat3[3]-A.mat3[1])/P);const J=s*Math.atan2(G,N),le=Math.cos(J),he=Math.sin(J),xe=1-le,Fe=D*F,Le=F*P,Ve=P*D,$e=new qn([le+xe*D*D,xe*Fe+he*P,xe*Ve-he*F,xe*Fe-he*P,le+xe*F*F,xe*Le+he*D,xe*Ve+he*F,xe*Le-he*D,le+xe*P*P]);$e.multiplyVec(x,E),I.set(E).mult(m*h).add(g),_.set(E).mult((m-1)*h).add(g),$e.multiplyVec(v,C),this.camera(I.x,I.y,I.z,_.x,_.y,_.z,C.x,C.y,C.z)}_computeCameraDefaultSettings(){this.defaultAspectRatio=this._renderer.width/this._renderer.height,this.defaultEyeX=0,this.defaultEyeY=0,this.defaultEyeZ=800,this.defaultCameraFOV=2*Math.atan(this._renderer.height/2/this.defaultEyeZ),this.defaultCenterX=0,this.defaultCenterY=0,this.defaultCenterZ=0,this.defaultCameraNear=this.defaultEyeZ*.1,this.defaultCameraFar=this.defaultEyeZ*10}_setDefaultCamera(){this.cameraFOV=this.defaultCameraFOV,this.aspectRatio=this.defaultAspectRatio,this.eyeX=this.defaultEyeX,this.eyeY=this.defaultEyeY,this.eyeZ=this.defaultEyeZ,this.centerX=this.defaultCenterX,this.centerY=this.defaultCenterY,this.centerZ=this.defaultCenterZ,this.upX=0,this.upY=1,this.upZ=0,this.cameraNear=this.defaultCameraNear,this.cameraFar=this.defaultCameraFar,this.perspective(),this.camera(),this.cameraType="default"}_resize(){this.cameraType==="default"&&(this._computeCameraDefaultSettings(),this.cameraFOV=this.defaultCameraFOV,this.aspectRatio=this.defaultAspectRatio,this.perspective())}copy(){const t=new Kh(this._renderer);return t.cameraFOV=this.cameraFOV,t.aspectRatio=this.aspectRatio,t.eyeX=this.eyeX,t.eyeY=this.eyeY,t.eyeZ=this.eyeZ,t.centerX=this.centerX,t.centerY=this.centerY,t.centerZ=this.centerZ,t.upX=this.upX,t.upY=this.upY,t.upZ=this.upZ,t.cameraNear=this.cameraNear,t.cameraFar=this.cameraFar,t.cameraType=this.cameraType,t.useLinePerspective=this.useLinePerspective,t.cameraMatrix=this.cameraMatrix.copy(),t.projMatrix=this.projMatrix.copy(),t.yScale=this.yScale,t}clone(){return this.copy()}_getLocalAxes(){let t=this.eyeX-this.centerX,n=this.eyeY-this.centerY,s=this.eyeZ-this.centerZ;const i=Math.sqrt(t*t+n*n+s*s);i!==0&&(t/=i,n/=i,s/=i);let a=this.upX,o=this.upY,u=this.upZ,l=o*s-u*n,c=-a*s+u*t,h=a*n-o*t;a=n*h-s*c,o=-t*h+s*l,u=t*c-n*l;const d=Math.sqrt(l*l+c*c+h*h);d!==0&&(l/=d,c/=d,h/=d);const p=Math.sqrt(a*a+o*o+u*u);return p!==0&&(a/=p,o/=p,u/=p),{x:[l,c,h],y:[a,o,u],z:[t,n,s]}}_orbit(t,n,s){const i=this.eyeX-this.centerX,a=this.eyeY-this.centerY,o=this.eyeZ-this.centerZ;let u=Math.hypot(i,a,o);const l=new De(i,a,o).normalize(),c=new De(this.upX,this.upY,this.upZ).normalize(),h=De.cross(c,l).normalize(),d=De.cross(h,c);u*=Math.pow(10,s),u<this.cameraNear&&(u=this.cameraNear),u>this.cameraFar&&(u=this.cameraFar);const p=Math.acos(Math.max(-1,Math.min(1,De.dot(l,c))))+n,f=t;(p<=0||p>=Math.PI)&&(this.upX*=-1,this.upY*=-1,this.upZ*=-1),c.mult(Math.cos(p)),d.mult(Math.cos(f)*Math.sin(p)),h.mult(Math.sin(f)*Math.sin(p)),l.set(c).add(d).add(h),this.eyeX=u*l.x+this.centerX,this.eyeY=u*l.y+this.centerY,this.eyeZ=u*l.z+this.centerZ,this.camera(this.eyeX,this.eyeY,this.eyeZ,this.centerX,this.centerY,this.centerZ,this.upX,this.upY,this.upZ)}_orbitFree(t,n,s){const i=this.eyeX-this.centerX,a=this.eyeY-this.centerY,o=this.eyeZ-this.centerZ;let u=Math.hypot(i,a,o);const l=new De(i,a,o).normalize(),c=new De(this.upX,this.upY,this.upZ),h=De.cross(c,l).normalize(),d=De.cross(l,h),p=Math.atan2(n,t);d.mult(Math.sin(p)),h.mult(Math.cos(p)).add(d);const f=Math.sqrt(t*t+n*n),m=De.cross(l,h);u*=Math.pow(10,s),u<this.cameraNear&&(u=this.cameraNear),u>this.cameraFar&&(u=this.cameraFar);const g=Math.cos(f),y=Math.sin(f),b=c.dot(l),x=c.dot(h),w=b*g+x*y,v=-b*y+x*g,S=c.dot(m);c.x=w*l.x+v*h.x+S*m.x,c.y=w*l.y+v*h.y+S*m.y,c.z=w*l.z+v*h.z+S*m.z,h.mult(-y),l.mult(g).add(h).mult(u),this.camera(l.x+this.centerX,l.y+this.centerY,l.z+this.centerZ,this.centerX,this.centerY,this.centerZ,c.x,c.y,c.z)}_isActive(){return this===this._renderer.states.curCamera}}function E6(r,t){t.camera=function(...n){return this._assert3d("camera"),this._renderer.camera(...n),this},t.perspective=function(...n){return this._assert3d("perspective"),this._renderer.perspective(...n),this},t.linePerspective=function(n){if(!(this._renderer instanceof Kt))throw new Error("linePerspective() must be called in WebGL mode.");return this._renderer.linePerspective(n)},t.ortho=function(...n){return this._assert3d("ortho"),this._renderer.ortho(...n),this},t.frustum=function(...n){return this._assert3d("frustum"),this._renderer.frustum(...n),this},t.createCamera=function(){return this._assert3d("createCamera"),this._renderer.createCamera()},t.setCamera=function(n){this._renderer.setCamera(n)},r.Camera=Kh,Kt.prototype.camera=function(...n){this.states.curCamera.camera(...n)},Kt.prototype.perspective=function(...n){this.states.curCamera.perspective(...n)},Kt.prototype.linePerspective=function(n){if(n!==void 0)this.states.curCamera.useLinePerspective=n;else return this.states.curCamera.useLinePerspective},Kt.prototype.ortho=function(...n){this.states.curCamera.ortho(...n)},Kt.prototype.frustum=function(...n){this.states.curCamera.frustum(...n)},Kt.prototype.createCamera=function(){const n=new Kh(this);return n._computeCameraDefaultSettings(),n._setDefaultCamera(),n},Kt.prototype.setCamera=function(n){this.states.setValue("curCamera",n),this.states.setValue("uPMatrix",this.states.uPMatrix.clone()),this.states.uPMatrix.set(n.projMatrix),this.states.setValue("uViewMatrix",this.states.uViewMatrix.clone()),this.states.uViewMatrix.set(n.cameraMatrix)}}typeof p5<"u"&&E6(p5,p5.prototype);class Ns{constructor(t,n,s,i={}){this._renderer=t,this._vertSrc=n,this._fragSrc=s,this._vertShader=-1,this._fragShader=-1,this._glProgram=0,this._loadedAttributes=!1,this.attributes={},this._loadedUniforms=!1,this.uniforms={},this._bound=!1,this.samplers=[],this.hooks={uniforms:i.uniforms||{},declarations:i.declarations,helpers:i.helpers||{},vertex:i.vertex||{},fragment:i.fragment||{},modified:{vertex:i.modified&&i.modified.vertex||{},fragment:i.modified&&i.modified.fragment||{}}}}hookTypes(t){let n=this._vertSrc,s=this.hooks.vertex[t];if(s||(s=this.hooks.fragment[t],n=this._fragSrc),!s)throw new Error(`Can't find hook ${t}!`);const i=t.split(/\s+/g),a=i.pop(),o=i.pop(),u=[...i],l=/\(([^\)]*)\)/.exec(s);if(!l)throw new Error(`Couldn't find function parameters in hook body:
${s}`);const c=d=>{const p=new RegExp(`struct\\s+${d}\\s*{([^}]*)}`).exec(n);if(!p)return;const f=[];for(const m of p[1].split(";")){const g=m.trim().split(/\s+|,/g),y=g.shift(),b=[...g],x=c(y);for(const w of b)f.push({name:w,type:{typeName:y,qualifiers:[],properties:x}})}return f},h=l[1].split(",").map(d=>{const p=d.trim().split(/\s+/g),f=p.pop(),m=p.pop(),g=[...p],y=c(m);return{name:f,type:{typeName:m,qualifiers:g,properties:y}}});return{name:a,returnType:{typeName:o,qualifiers:u,properties:c(o)},parameters:h}}shaderSrc(t,n){const s="void main";let[i,a]=t.split(s),o="",u="";for(const l in this.hooks.uniforms)o+=`uniform ${l};
`;this.hooks.declarations&&(o+=this.hooks.declarations+`
`),this.hooks[n].declarations&&(o+=this.hooks[n].declarations+`
`);for(const l in this.hooks.helpers)o+=`${l}${this.hooks.helpers[l]}
`;for(const l in this.hooks[n]){if(l==="declarations")continue;const[c,h]=l.split(" ");this.hooks.modified[n][l]&&(u+="#define AUGMENTED_HOOK_"+h+`
`),o+=c+" HOOK_"+h+this.hooks[n][l]+`
`}return i.indexOf("#define HOOK_DEFINES")!==-1&&(i=i.replace("#define HOOK_DEFINES",`
`+u+`
`),u=""),i+`
`+u+o+s+a}version(){const t=/#version (.+)$/.exec(this.vertSrc());return t?t[1]:"100 es"}vertSrc(){return this.shaderSrc(this._vertSrc,"vertex")}fragSrc(){return this.shaderSrc(this._fragSrc,"fragment")}inspectHooks(){console.log("==== Vertex shader hooks: ====");for(const t in this.hooks.vertex)console.log((this.hooks.modified.vertex[t]?"[MODIFIED] ":"")+t+this.hooks.vertex[t]);console.log(""),console.log("==== Fragment shader hooks: ====");for(const t in this.hooks.fragment)console.log((this.hooks.modified.fragment[t]?"[MODIFIED] ":"")+t+this.hooks.fragment[t]);console.log(""),console.log("==== Helper functions: ====");for(const t in this.hooks.helpers)console.log(t+this.hooks.helpers[t])}modify(t){const n={vertex:{},fragment:{},helpers:{}};for(const a in t)a!=="declarations"&&a!=="uniforms"&&(a==="vertexDeclarations"?n.vertex.declarations=(n.vertex.declarations||"")+`
`+t[a]:a==="fragmentDeclarations"?n.fragment.declarations=(n.fragment.declarations||"")+`
`+t[a]:this.hooks.vertex[a]?n.vertex[a]=t[a]:this.hooks.fragment[a]?n.fragment[a]=t[a]:n.helpers[a]=t[a]);const s=Object.assign({},this.hooks.modified.vertex),i=Object.assign({},this.hooks.modified.fragment);for(const a in n.vertex||{})a!=="declarations"&&(s[a]=!0);for(const a in n.fragment||{})a!=="declarations"&&(i[a]=!0);return new Ns(this._renderer,this._vertSrc,this._fragSrc,{declarations:(this.hooks.declarations||"")+`
`+(t.declarations||""),uniforms:Object.assign({},this.hooks.uniforms,t.uniforms||{}),fragment:Object.assign({},this.hooks.fragment,n.fragment||{}),vertex:Object.assign({},this.hooks.vertex,n.vertex||{}),helpers:Object.assign({},this.hooks.helpers,n.helpers||{}),modified:{vertex:s,fragment:i}})}init(){if(this._glProgram===0){const t=this._renderer.GL;if(this._vertShader=t.createShader(t.VERTEX_SHADER),t.shaderSource(this._vertShader,this.vertSrc()),t.compileShader(this._vertShader),!t.getShaderParameter(this._vertShader,t.COMPILE_STATUS)){const n=t.getShaderInfoLog(this._vertShader);if(typeof IS_MINIFIED<"u")console.error(n);else throw n;return null}if(this._fragShader=t.createShader(t.FRAGMENT_SHADER),t.shaderSource(this._fragShader,this.fragSrc()),t.compileShader(this._fragShader),!t.getShaderParameter(this._fragShader,t.COMPILE_STATUS)){const n=t.getShaderInfoLog(this._fragShader);if(typeof IS_MINIFIED<"u")console.error(n);else throw n;return null}this._glProgram=t.createProgram(),t.attachShader(this._glProgram,this._vertShader),t.attachShader(this._glProgram,this._fragShader),t.linkProgram(this._glProgram),t.getProgramParameter(this._glProgram,t.LINK_STATUS)||p5._friendlyError(`Snap! Error linking shader program: ${t.getProgramInfoLog(this._glProgram)}`),this._loadAttributes(),this._loadUniforms()}return this}setDefaultUniforms(){for(const t in this.hooks.uniforms){const[,n]=t.split(" "),s=this.hooks.uniforms[t];let i;s instanceof Function?i=s():i=s,i!=null&&this.setUniform(n,i)}}copyToContext(t){const n=new Ns(t._renderer,this._vertSrc,this._fragSrc);return n.ensureCompiledOnContext(t._renderer),n}ensureCompiledOnContext(t){var n,s;if(this._glProgram!==0&&this._renderer!==t)throw new Error("The shader being run is attached to a different context. Do you need to copy it to this context first with .copyToContext()?");this._glProgram===0&&(this._renderer=((s=(n=t==null?void 0:t._renderer)==null?void 0:n.filterRenderer)==null?void 0:s._renderer)||t,this.init())}_loadAttributes(){if(this._loadedAttributes)return;this.attributes={};const t=this._renderer.GL,n=t.getProgramParameter(this._glProgram,t.ACTIVE_ATTRIBUTES);for(let s=0;s<n;++s){const i=t.getActiveAttrib(this._glProgram,s),a=i.name,o=t.getAttribLocation(this._glProgram,a),u={};u.name=a,u.location=o,u.index=s,u.type=i.type,u.size=i.size,this.attributes[a]=u}this._loadedAttributes=!0}_loadUniforms(){if(this._loadedUniforms)return;const t=this._renderer.GL,n=t.getProgramParameter(this._glProgram,t.ACTIVE_UNIFORMS);let s=0;for(let i=0;i<n;++i){const a=t.getActiveUniform(this._glProgram,i),o={};o.location=t.getUniformLocation(this._glProgram,a.name),o.size=a.size;let u=a.name;a.size>1&&(u=u.substring(0,u.indexOf("[0]"))),o.name=u,o.type=a.type,o._cachedData=void 0,o.type===t.SAMPLER_2D&&(o.samplerIndex=s,s++,this.samplers.push(o)),o.isArray=a.size>1||o.type===t.FLOAT_MAT3||o.type===t.FLOAT_MAT4||o.type===t.FLOAT_VEC2||o.type===t.FLOAT_VEC3||o.type===t.FLOAT_VEC4||o.type===t.INT_VEC2||o.type===t.INT_VEC4||o.type===t.INT_VEC3,this.uniforms[u]=o}this._loadedUniforms=!0}compile(){}bindShader(){this.init(),this._bound||(this.useProgram(),this._bound=!0)}unbindShader(){return this._bound&&(this.unbindTextures(),this._bound=!1),this}bindTextures(){const t=this._renderer.GL,n=this._renderer._getEmptyTexture();for(const s of this.samplers){let i=s.texture;i===void 0&&(s.texture=i=n),t.activeTexture(t.TEXTURE0+s.samplerIndex),i.bindTexture(),i.update(),t.uniform1i(s.location,s.samplerIndex)}}updateTextures(){for(const t of this.samplers){const n=t.texture;n&&n.update()}}unbindTextures(){var s;const t=this._renderer.GL,n=this._renderer._getEmptyTexture();for(const i of this.samplers)(s=i.texture)!=null&&s.isFramebufferTexture&&(t.activeTexture(t.TEXTURE0+i.samplerIndex),n.bindTexture(),t.uniform1i(i.location,i.samplerIndex))}useProgram(){const t=this._renderer.GL;return this._renderer._curShader!==this&&(t.useProgram(this._glProgram),this._renderer._curShader=this),this}setUniform(t,n){this.init();const s=this.uniforms[t];if(!s)return;const i=this._renderer.GL;if(s.isArray){if(s._cachedData&&this._renderer._arraysEqual(s._cachedData,n))return;s._cachedData=n.slice(0)}else{if(s._cachedData&&s._cachedData===n)return;Array.isArray(n)?s._cachedData=n.slice(0):s._cachedData=n}const a=s.location;switch(this.useProgram(),s.type){case i.BOOL:n===!0?i.uniform1i(a,1):i.uniform1i(a,0);break;case i.INT:s.size>1?n.length&&i.uniform1iv(a,n):i.uniform1i(a,n);break;case i.FLOAT:s.size>1?n.length&&i.uniform1fv(a,n):i.uniform1f(a,n);break;case i.FLOAT_MAT3:i.uniformMatrix3fv(a,!1,n);break;case i.FLOAT_MAT4:i.uniformMatrix4fv(a,!1,n);break;case i.FLOAT_VEC2:s.size>1?n.length&&i.uniform2fv(a,n):i.uniform2f(a,n[0],n[1]);break;case i.FLOAT_VEC3:s.size>1?n.length&&i.uniform3fv(a,n):i.uniform3f(a,n[0],n[1],n[2]);break;case i.FLOAT_VEC4:s.size>1?n.length&&i.uniform4fv(a,n):i.uniform4f(a,n[0],n[1],n[2],n[3]);break;case i.INT_VEC2:s.size>1?n.length&&i.uniform2iv(a,n):i.uniform2i(a,n[0],n[1]);break;case i.INT_VEC3:s.size>1?n.length&&i.uniform3iv(a,n):i.uniform3i(a,n[0],n[1],n[2]);break;case i.INT_VEC4:s.size>1?n.length&&i.uniform4iv(a,n):i.uniform4i(a,n[0],n[1],n[2],n[3]);break;case i.SAMPLER_2D:if(typeof n=="number"){if(n<i.TEXTURE0||n>i.TEXTURE31||n!==Math.ceil(n))return console.log(" p5.js says: You're trying to use a number as the data for a texture.Please use a texture."),this;i.activeTexture(n),i.uniform1i(a,n)}else i.activeTexture(i.TEXTURE0+s.samplerIndex),s.texture=n instanceof nl?n:this._renderer.getTexture(n),i.uniform1i(a,s.samplerIndex),s.texture.src.gifProperties&&s.texture.src._animateGif(this._renderer._pInst);break;case i.SAMPLER_CUBE:case i.SAMPLER_3D:case i.SAMPLER_2D_SHADOW:case i.SAMPLER_2D_ARRAY:case i.SAMPLER_2D_ARRAY_SHADOW:case i.SAMPLER_CUBE_SHADOW:case i.INT_SAMPLER_2D:case i.INT_SAMPLER_3D:case i.INT_SAMPLER_CUBE:case i.INT_SAMPLER_2D_ARRAY:case i.UNSIGNED_INT_SAMPLER_2D:case i.UNSIGNED_INT_SAMPLER_3D:case i.UNSIGNED_INT_SAMPLER_CUBE:case i.UNSIGNED_INT_SAMPLER_2D_ARRAY:if(typeof n!="number")break;if(n<i.TEXTURE0||n>i.TEXTURE31||n!==Math.ceil(n)){console.log(" p5.js says: You're trying to use a number as the data for a texture.Please use a texture.");break}i.activeTexture(n),i.uniform1i(a,n);break}return this}enableAttrib(t,n,s,i,a,o){if(t){typeof IS_MINIFIED>"u"&&this.attributes[t.name]!==t&&console.warn(`The attribute "${t.name}"passed to enableAttrib does not belong to this shader.`);const u=t.location;if(u!==-1){const l=this._renderer.GL;this._renderer.registerEnabled.has(u)||(l.enableVertexAttribArray(u),this._renderer.registerEnabled.add(u)),this._renderer.GL.vertexAttribPointer(u,n,s||l.FLOAT,i||!1,a||0,o||0)}}return this}disableRemainingAttributes(){for(const t of this._renderer.registerEnabled.values())Object.keys(this.attributes).some(n=>this.attributes[n].location===t)||(this._renderer.GL.disableVertexAttribArray(t),this._renderer.registerEnabled.delete(t))}}function WT(r,t){r.Shader=Ns}typeof p5<"u"&&WT(p5,p5.prototype);var I6=`precision highp int;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

IN vec3 aPosition;
IN vec2 aTexCoord;
OUT vec2 vTexCoord;

void main() {
  // transferring texcoords for the frag shader
  vTexCoord = aTexCoord;

  // copy position with a fourth coordinate for projection (1.0 is normal)
  vec4 positionVec4 = vec4(aPosition, 1.0);

  // project to 3D space
  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
}
`,QP=`#define PI 3.141592

precision highp float;
precision highp int;

uniform mat4 uViewMatrix;

uniform bool uUseLighting;

uniform int uAmbientLightCount;
uniform vec3 uAmbientColor[5];
uniform mat3 uCameraRotation;
uniform int uDirectionalLightCount;
uniform vec3 uLightingDirection[5];
uniform vec3 uDirectionalDiffuseColors[5];
uniform vec3 uDirectionalSpecularColors[5];

uniform int uPointLightCount;
uniform vec3 uPointLightLocation[5];
uniform vec3 uPointLightDiffuseColors[5];	
uniform vec3 uPointLightSpecularColors[5];

uniform int uSpotLightCount;
uniform float uSpotLightAngle[5];
uniform float uSpotLightConc[5];
uniform vec3 uSpotLightDiffuseColors[5];
uniform vec3 uSpotLightSpecularColors[5];
uniform vec3 uSpotLightLocation[5];
uniform vec3 uSpotLightDirection[5];

uniform bool uSpecular;
uniform float uShininess;
uniform float uMetallic;

uniform float uConstantAttenuation;
uniform float uLinearAttenuation;
uniform float uQuadraticAttenuation;

// setting from  _setImageLightUniforms()
// boolean to initiate the calculateImageDiffuse and calculateImageSpecular
uniform bool uUseImageLight;
// texture for use in calculateImageDiffuse
uniform sampler2D environmentMapDiffused;
// texture for use in calculateImageSpecular
uniform sampler2D environmentMapSpecular;

const float specularFactor = 2.0;
const float diffuseFactor = 0.73;

struct LightResult {
  float specular;
  float diffuse;
};

float _phongSpecular(
  vec3 lightDirection,
  vec3 viewDirection,
  vec3 surfaceNormal,
  float shininess) {

  vec3 R = reflect(lightDirection, surfaceNormal);
  return pow(max(0.0, dot(R, viewDirection)), shininess);
}

float _lambertDiffuse(vec3 lightDirection, vec3 surfaceNormal) {
  return max(0.0, dot(-lightDirection, surfaceNormal));
}

LightResult _light(vec3 viewDirection, vec3 normal, vec3 lightVector, float shininess, float metallic) {

  vec3 lightDir = normalize(lightVector);

  //compute our diffuse & specular terms
  LightResult lr;
  float specularIntensity = mix(1.0, 0.4, metallic);
  float diffuseIntensity = mix(1.0, 0.1, metallic);
  if (uSpecular)
    lr.specular = (_phongSpecular(lightDir, viewDirection, normal, shininess)) * specularIntensity;
    lr.diffuse = _lambertDiffuse(lightDir, normal) * diffuseIntensity;
  return lr;
}

// converts the range of "value" from [min1 to max1] to [min2 to max2]
float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec2 mapTextureToNormal( vec3 v ){
  // x = r sin(phi) cos(theta)   
  // y = r cos(phi)  
  // z = r sin(phi) sin(theta)
  float phi = acos( v.y );
  // if phi is 0, then there are no x, z components
  float theta = 0.0;
  // else 
  theta = acos(v.x / sin(phi));
  float sinTheta = v.z / sin(phi);
  if (sinTheta < 0.0) {
    // Turn it into -theta, but in the 0-2PI range
    theta = 2.0 * PI - theta;
  }
  theta = theta / (2.0 * 3.14159);
  phi = phi / 3.14159 ;
  
  vec2 angles = vec2( fract(theta + 0.25), 1.0 - phi );
  return angles;
}


vec3 calculateImageDiffuse(vec3 vNormal, vec3 vViewPosition, float metallic){
  // make 2 seperate builds 
  vec3 worldCameraPosition =  vec3(0.0, 0.0, 0.0);  // hardcoded world camera position
  vec3 worldNormal = normalize(vNormal * uCameraRotation);
  vec2 newTexCoor = mapTextureToNormal( worldNormal );
  vec4 texture = TEXTURE( environmentMapDiffused, newTexCoor );
  // this is to make the darker sections more dark
  // png and jpg usually flatten the brightness so it is to reverse that
  return mix(smoothstep(vec3(0.0), vec3(1.0), texture.xyz), vec3(0.0), metallic);
}

vec3 calculateImageSpecular(vec3 vNormal, vec3 vViewPosition, float shininess, float metallic){
  vec3 worldCameraPosition =  vec3(0.0, 0.0, 0.0);
  vec3 worldNormal = normalize(vNormal);
  vec3 lightDirection = normalize( vViewPosition - worldCameraPosition );
  vec3 R = reflect(lightDirection, worldNormal) * uCameraRotation;
  vec2 newTexCoor = mapTextureToNormal( R );
#ifdef WEBGL2
  // In p5js the range of shininess is >= 1,
  // Therefore roughness range will be ([0,1]*8)*20 or [0, 160]
  // The factor of 8 is because currently the getSpecularTexture
  // only calculated 8 different levels of roughness
  // The factor of 20 is just to spread up this range so that,
  // [1, max] of shininess is converted to [0,160] of roughness
  float roughness = 20. / shininess;
  vec4 outColor = textureLod(environmentMapSpecular, newTexCoor, roughness * 8.);
#else
  vec4 outColor = TEXTURE(environmentMapSpecular, newTexCoor);
#endif
  // this is to make the darker sections more dark
  // png and jpg usually flatten the brightness so it is to reverse that
  return mix(
    pow(outColor.xyz, vec3(10)),
    pow(outColor.xyz, vec3(1.2)),
    metallic 
  );
}

void totalLight(
  vec3 modelPosition,
  vec3 normal,
  float shininess,
  float metallic,
  out vec3 totalDiffuse,
  out vec3 totalSpecular
) {

  totalSpecular = vec3(0.0);

  if (!uUseLighting) {
    totalDiffuse = vec3(1.0);
    return;
  }

  totalDiffuse = vec3(0.0);

  vec3 viewDirection = normalize(-modelPosition);

  for (int j = 0; j < 5; j++) {
    if (j < uDirectionalLightCount) {
      vec3 lightVector = (uViewMatrix * vec4(uLightingDirection[j], 0.0)).xyz;
      vec3 lightColor = uDirectionalDiffuseColors[j];
      vec3 specularColor = uDirectionalSpecularColors[j];
      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);
      totalDiffuse += result.diffuse * lightColor;
      totalSpecular += result.specular * lightColor * specularColor;
    }

    if (j < uPointLightCount) {
      vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation[j], 1.0)).xyz;
      vec3 lightVector = modelPosition - lightPosition;
      //calculate attenuation
      float lightDistance = length(lightVector);
      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);
      vec3 lightColor = lightFalloff * uPointLightDiffuseColors[j];
      vec3 specularColor = lightFalloff * uPointLightSpecularColors[j];

      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);
      totalDiffuse += result.diffuse * lightColor;
      totalSpecular += result.specular * lightColor * specularColor;
    }

    if(j < uSpotLightCount) {
      vec3 lightPosition = (uViewMatrix * vec4(uSpotLightLocation[j], 1.0)).xyz;
      vec3 lightVector = modelPosition - lightPosition;
    
      float lightDistance = length(lightVector);
      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);

      vec3 lightDirection = (uViewMatrix * vec4(uSpotLightDirection[j], 0.0)).xyz;
      float spotDot = dot(normalize(lightVector), normalize(lightDirection));
      float spotFalloff;
      if(spotDot < uSpotLightAngle[j]) {
        spotFalloff = 0.0;
      }
      else {
        spotFalloff = pow(spotDot, uSpotLightConc[j]);
      }
      lightFalloff *= spotFalloff;

      vec3 lightColor = uSpotLightDiffuseColors[j];
      vec3 specularColor = uSpotLightSpecularColors[j];
     
      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);
      
      totalDiffuse += result.diffuse * lightColor * lightFalloff;
      totalSpecular += result.specular * lightColor * specularColor * lightFalloff;
    }
  }

  if( uUseImageLight ){
    totalDiffuse += calculateImageDiffuse(normal, modelPosition, metallic);
    totalSpecular += calculateImageSpecular(normal, modelPosition, shininess, metallic);
  }

  totalDiffuse *= diffuseFactor;
  totalSpecular *= specularFactor;
}
`,XI=`#ifdef WEBGL2

#define IN in
#define OUT out

#ifdef FRAGMENT_SHADER
out vec4 outColor;
#define OUT_COLOR outColor
#endif
#define TEXTURE texture

#else

#ifdef FRAGMENT_SHADER
#define IN varying
#else
#define IN attribute
#endif
#define OUT varying
#define TEXTURE texture2D

#ifdef FRAGMENT_SHADER
#define OUT_COLOR gl_FragColor
#endif

#endif

#ifdef FRAGMENT_SHADER
vec4 getTexture(in sampler2D content, vec2 coord) {
  vec4 color = TEXTURE(content, coord);
  color.rgb /= color.a;
  return color;
}
#endif
`,zae=`IN vec3 aPosition;
IN vec3 aNormal;
IN vec2 aTexCoord;
IN vec4 aVertexColor;

#define HOOK_DEFINES

#ifdef AUGMENTED_HOOK_getWorldInputs
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat3 uModelNormalMatrix;
uniform mat3 uCameraNormalMatrix;
#else
uniform mat4 uModelViewMatrix;
uniform mat3 uNormalMatrix;
#endif
uniform mat4 uProjectionMatrix;

uniform vec4 uMaterialColor;
uniform bool uUseVertexColor;

OUT vec3 vVertexNormal;
OUT highp vec2 vVertTexCoord;
OUT vec4 vColor;

struct Vertex {
  vec3 position;
  vec3 normal;
  vec2 texCoord;
  vec4 color;
};

void main(void) {
  HOOK_beforeVertex();

  Vertex inputs;
  inputs.position = aPosition;
  inputs.normal = aNormal;
  inputs.texCoord = aTexCoord;
  inputs.color = (uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor;
#ifdef AUGMENTED_HOOK_getObjectInputs
  inputs = HOOK_getObjectInputs(inputs);
#endif

#ifdef AUGMENTED_HOOK_getWorldInputs
  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.normal = uModelNormalMatrix * inputs.normal;
  inputs = HOOK_getWorldInputs(inputs);
#endif

#ifdef AUGMENTED_HOOK_getWorldInputs
  // Already multiplied by the model matrix, just apply view
  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.normal = uCameraNormalMatrix * inputs.normal;
#else
  // Apply both at once
  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.normal = uNormalMatrix * inputs.normal;
#endif
#ifdef AUGMENTED_HOOK_getCameraInputs
  inputs = HOOK_getCameraInputs(inputs);
#endif

  // Pass varyings to fragment shader
  vVertTexCoord = inputs.texCoord;
  vVertexNormal = normalize(inputs.normal);
  vColor = inputs.color;

  gl_Position = uProjectionMatrix * vec4(inputs.position, 1.);

  HOOK_afterVertex();
}
`,Uae=`IN vec3 vVertexNormal;
void main(void) {
  HOOK_beforeFragment();
  OUT_COLOR = HOOK_getFinalColor(vec4(vVertexNormal, 1.0));
  HOOK_afterFragment();
}
`,Wae=`IN vec4 vColor;
void main(void) {
  HOOK_beforeFragment();
  OUT_COLOR = HOOK_getFinalColor(vec4(vColor.rgb, 1.) * vColor.a);
  HOOK_afterFragment();
}
`,Gae=`#define PI 3.141592

precision highp float;
  
uniform sampler2D uEnvMap;
uniform mat3 uNewNormalMatrix;
uniform float uFovY;
uniform float uAspect;

varying vec2 vTexCoord;
  
void main() {
    float uFovX = uFovY * uAspect; 
    float angleY = mix(uFovY/2.0,  -uFovY/2.0, vTexCoord.y);
    float angleX = mix(uFovX/2.0, -uFovX/2.0, vTexCoord.x);
    vec3 rotatedNormal = vec3( angleX, angleY, 1.0 );
    rotatedNormal = uNewNormalMatrix * normalize(rotatedNormal);
    float temp = rotatedNormal.z;
    rotatedNormal.z = rotatedNormal.x;
    rotatedNormal.x = -temp;
    vec2 suv;
    suv.y = 0.5 + 0.5 * (-rotatedNormal.y);
    suv.x = atan(rotatedNormal.z, rotatedNormal.x) / (2.0 * PI) + 0.5;
    vec4 newTexColor = texture2D(uEnvMap, suv.xy);
    gl_FragColor = newTexColor;
}
`,Hae=`// include lighting.glgl

IN vec3 aPosition;
IN vec3 aNormal;
IN vec2 aTexCoord;
IN vec4 aVertexColor;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

uniform bool uUseVertexColor;
uniform vec4 uMaterialColor;

OUT highp vec2 vVertTexCoord;
OUT vec3 vDiffuseColor;
OUT vec3 vSpecularColor;
OUT vec4 vColor;

void main(void) {

  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);
  gl_Position = uProjectionMatrix * viewModelPosition;

  vec3 vertexNormal = normalize(uNormalMatrix * aNormal);
  vVertTexCoord = aTexCoord;

  totalLight(viewModelPosition.xyz, vertexNormal, vDiffuseColor, vSpecularColor);

  for (int i = 0; i < 8; i++) {
    if (i < uAmbientLightCount) {
      vDiffuseColor += uAmbientColor[i];
    }
  }
  
  vColor = ((uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor);
}
`,jae=`uniform vec4 uTint;
uniform sampler2D uSampler;
uniform bool isTexture;
uniform bool uEmissive;

IN highp vec2 vVertTexCoord;
IN vec3 vDiffuseColor;
IN vec3 vSpecularColor;
IN vec4 vColor;

void main(void) {
  if(uEmissive && !isTexture) {
    OUT_COLOR = vColor;
  }
  else {
    vec4 baseColor = isTexture
      // Textures come in with premultiplied alpha. To apply tint and still have
      // premultiplied alpha output, we need to multiply the RGB channels by the
      // tint RGB, and all channels by the tint alpha.
      ? TEXTURE(uSampler, vVertTexCoord) * vec4(uTint.rgb/255., 1.) * (uTint.a/255.)
      // Colors come in with unmultiplied alpha, so we need to multiply the RGB
      // channels by alpha to convert it to premultiplied alpha.
      : vec4(vColor.rgb * vColor.a, vColor.a);
    OUT_COLOR = vec4(baseColor.rgb * vDiffuseColor + vSpecularColor, baseColor.a);
  }
}
`,qae=`precision highp int;

#define HOOK_DEFINES

IN vec3 aPosition;
IN vec3 aNormal;
IN vec2 aTexCoord;
IN vec4 aVertexColor;

uniform vec3 uAmbientColor[5];

#ifdef AUGMENTED_HOOK_getWorldInputs
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat3 uModelNormalMatrix;
uniform mat3 uCameraNormalMatrix;
#else
uniform mat4 uModelViewMatrix;
uniform mat3 uNormalMatrix;
#endif
uniform mat4 uProjectionMatrix;
uniform int uAmbientLightCount;

uniform bool uUseVertexColor;
uniform vec4 uMaterialColor;

OUT vec3 vNormal;
OUT vec2 vTexCoord;
OUT vec3 vViewPosition;
OUT vec3 vAmbientColor;
OUT vec4 vColor;

struct Vertex {
  vec3 position;
  vec3 normal;
  vec2 texCoord;
  vec4 color;
};

void main(void) {
  HOOK_beforeVertex();

  Vertex inputs;
  inputs.position = aPosition;
  inputs.normal = aNormal;
  inputs.texCoord = aTexCoord;
  inputs.color = (uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor;
#ifdef AUGMENTED_HOOK_getObjectInputs
  inputs = HOOK_getObjectInputs(inputs);
#endif

#ifdef AUGMENTED_HOOK_getWorldInputs
  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.normal = uModelNormalMatrix * inputs.normal;
  inputs = HOOK_getWorldInputs(inputs);
#endif

#ifdef AUGMENTED_HOOK_getWorldInputs
  // Already multiplied by the model matrix, just apply view
  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.normal = uCameraNormalMatrix * inputs.normal;
#else
  // Apply both at once
  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.normal = uNormalMatrix * inputs.normal;
#endif
#ifdef AUGMENTED_HOOK_getCameraInputs
  inputs = HOOK_getCameraInputs(inputs);
#endif

  // Pass varyings to fragment shader
  vViewPosition = inputs.position;
  vTexCoord = inputs.texCoord;
  vNormal = inputs.normal;
  vColor = inputs.color;

  // TODO: this should be a uniform
  vAmbientColor = vec3(0.0);
  for (int i = 0; i < 5; i++) {
    if (i < uAmbientLightCount) {
      vAmbientColor += uAmbientColor[i];
    }
  }

  gl_Position = uProjectionMatrix * vec4(inputs.position, 1.);
  HOOK_afterVertex();
}
`,Kae=`// include lighting.glsl
precision highp int;

uniform bool uHasSetAmbient;
uniform vec4 uSpecularMatColor;
uniform vec4 uAmbientMatColor;
uniform vec4 uEmissiveMatColor;

uniform vec4 uTint;
uniform sampler2D uSampler;
uniform bool isTexture;

IN vec3 vNormal;
IN vec2 vTexCoord;
IN vec3 vViewPosition;
IN vec3 vAmbientColor;
IN vec4 vColor;

struct ColorComponents {
  vec3 baseColor;
  float opacity;
  vec3 ambientColor;
  vec3 specularColor;
  vec3 diffuse;
  vec3 ambient;
  vec3 specular;
  vec3 emissive;
};

struct Inputs {
  vec3 normal;
  vec2 texCoord;
  vec3 ambientLight;
  vec3 ambientMaterial;
  vec3 specularMaterial;
  vec3 emissiveMaterial;
  vec4 color;
  float shininess;
  float metalness;
};

void main(void) {
  HOOK_beforeFragment();

  Inputs inputs;
  inputs.normal = normalize(vNormal);
  inputs.texCoord = vTexCoord;
  inputs.ambientLight = vAmbientColor;
  inputs.color = isTexture
      ? TEXTURE(uSampler, vTexCoord) * (vec4(uTint.rgb/255., 1.) * uTint.a/255.)
      : vColor;
  if (isTexture && inputs.color.a > 0.0) {
    // Textures come in with premultiplied alpha. Temporarily unpremultiply it
    // so hooks users don't have to think about premultiplied alpha.
    inputs.color.rgb /= inputs.color.a;
  }
  inputs.shininess = uShininess;
  inputs.metalness = uMetallic;
  inputs.ambientMaterial = uHasSetAmbient ? uAmbientMatColor.rgb : inputs.color.rgb;
  inputs.specularMaterial = uSpecularMatColor.rgb;
  inputs.emissiveMaterial = uEmissiveMatColor.rgb;
  inputs = HOOK_getPixelInputs(inputs);

  vec3 diffuse;
  vec3 specular;
  totalLight(vViewPosition, inputs.normal, inputs.shininess, inputs.metalness, diffuse, specular);

  // Calculating final color as result of all lights (plus emissive term).

  vec2 texCoord = inputs.texCoord;
  vec4 baseColor = inputs.color;
  ColorComponents c;
  c.opacity = baseColor.a;
  c.baseColor = baseColor.rgb;
  c.ambientColor = inputs.ambientMaterial;
  c.specularColor = inputs.specularMaterial;
  c.diffuse = diffuse;
  c.ambient = inputs.ambientLight;
  c.specular = specular;
  c.emissive = inputs.emissiveMaterial;
  OUT_COLOR = HOOK_getFinalColor(HOOK_combineColors(c));
  OUT_COLOR.rgb *= OUT_COLOR.a; // Premultiply alpha before rendering
  HOOK_afterFragment();
}
`,Xae=`IN vec3 aPosition;
IN vec2 aTexCoord;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

uniform vec4 uGlyphRect;
uniform float uGlyphOffset;

OUT vec2 vTexCoord;
OUT float w;

void main() {
  vec4 positionVec4 = vec4(aPosition, 1.0);

  // scale by the size of the glyph's rectangle
  positionVec4.xy *= uGlyphRect.zw - uGlyphRect.xy;

  // Expand glyph bounding boxes by 1px on each side to give a bit of room
  // for antialiasing
  vec3 newOrigin = (uModelViewMatrix * vec4(0., 0., 0., 1.)).xyz;
  vec3 newDX = (uModelViewMatrix * vec4(1., 0., 0., 1.)).xyz;
  vec3 newDY = (uModelViewMatrix * vec4(0., 1., 0., 1.)).xyz;
  vec2 pixelScale = vec2(
    1. / length(newOrigin - newDX),
    1. / length(newOrigin - newDY)
  );
  vec2 offset = pixelScale * normalize(aTexCoord - vec2(0.5, 0.5));
  vec2 textureOffset = offset * (1. / vec2(
    uGlyphRect.z - uGlyphRect.x,
    uGlyphRect.w - uGlyphRect.y
  ));

  // move to the corner of the glyph
  positionVec4.xy += uGlyphRect.xy;

  // move to the letter's line offset
  positionVec4.x += uGlyphOffset;

  positionVec4.xy += offset;
  
  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
  vTexCoord = aTexCoord + textureOffset;
  w = gl_Position.w;
}
`,Yae=`#ifndef WEBGL2
#extension GL_OES_standard_derivatives : enable
#endif

#if 0
  // simulate integer math using floats
	#define int float
	#define ivec2 vec2
	#define INT(x) float(x)

	int ifloor(float v) { return floor(v); }
	ivec2 ifloor(vec2 v) { return floor(v); }

#else
  // use native integer math
	precision highp int;
	#define INT(x) x

	int ifloor(float v) { return int(v); }
	int ifloor(int v) { return v; }
	ivec2 ifloor(vec2 v) { return ivec2(v); }

#endif

uniform sampler2D uSamplerStrokes;
uniform sampler2D uSamplerRowStrokes;
uniform sampler2D uSamplerRows;
uniform sampler2D uSamplerColStrokes;
uniform sampler2D uSamplerCols;

uniform ivec2 uStrokeImageSize;
uniform ivec2 uCellsImageSize;
uniform ivec2 uGridImageSize;

uniform ivec2 uGridOffset;
uniform ivec2 uGridSize;
uniform vec4 uMaterialColor;

IN vec2 vTexCoord;

// some helper functions
int ROUND(float v) { return ifloor(v + 0.5); }
ivec2 ROUND(vec2 v) { return ifloor(v + 0.5); }
float saturate(float v) { return clamp(v, 0.0, 1.0); }
vec2 saturate(vec2 v) { return clamp(v, 0.0, 1.0); }

int mul(float v1, int v2) {
  return ifloor(v1 * float(v2));
}

ivec2 mul(vec2 v1, ivec2 v2) {
  return ifloor(v1 * vec2(v2) + 0.5);
}

// unpack a 16-bit integer from a float vec2
int getInt16(vec2 v) {
  ivec2 iv = ROUND(v * 255.0);
  return iv.x * INT(128) + iv.y;
}

vec2 pixelScale;
vec2 coverage = vec2(0.0);
vec2 weight = vec2(0.5);
const float minDistance = 1.0/8192.0;
const float hardness = 1.05; // amount of antialias

// the maximum number of curves in a glyph
const int N = INT(250);

// retrieves an indexed pixel from a sampler
vec4 getTexel(sampler2D sampler, int pos, ivec2 size) {
  int width = size.x;
  int y = ifloor(pos / width);
  int x = pos - y * width;  // pos % width

  return TEXTURE(sampler, (vec2(x, y) + 0.5) / vec2(size));
}

void calulateCrossings(vec2 p0, vec2 p1, vec2 p2, out vec2 C1, out vec2 C2) {

  // get the coefficients of the quadratic in t
  vec2 a = p0 - p1 * 2.0 + p2;
  vec2 b = p0 - p1;
  vec2 c = p0 - vTexCoord;

  // found out which values of 't' it crosses the axes
  vec2 surd = sqrt(max(vec2(0.0), b * b - a * c));
  vec2 t1 = ((b - surd) / a).yx;
  vec2 t2 = ((b + surd) / a).yx;

  // approximate straight lines to avoid rounding errors
  if (abs(a.y) < 0.001)
    t1.x = t2.x = c.y / (2.0 * b.y);

  if (abs(a.x) < 0.001)
    t1.y = t2.y = c.x / (2.0 * b.x);

  // plug into quadratic formula to find the corrdinates of the crossings
  C1 = ((a * t1 - b * 2.0) * t1 + c) * pixelScale;
  C2 = ((a * t2 - b * 2.0) * t2 + c) * pixelScale;
}

void coverageX(vec2 p0, vec2 p1, vec2 p2) {

  vec2 C1, C2;
  calulateCrossings(p0, p1, p2, C1, C2);

  // determine on which side of the x-axis the points lie
  bool y0 = p0.y > vTexCoord.y;
  bool y1 = p1.y > vTexCoord.y;
  bool y2 = p2.y > vTexCoord.y;

  // could web be under the curve (after t1)?
  if (y1 ? !y2 : y0) {
    // add the coverage for t1
    coverage.x += saturate(C1.x + 0.5);
    // calculate the anti-aliasing for t1
    weight.x = min(weight.x, abs(C1.x));
  }

  // are we outside the curve (after t2)?
  if (y1 ? !y0 : y2) {
    // subtract the coverage for t2
    coverage.x -= saturate(C2.x + 0.5);
    // calculate the anti-aliasing for t2
    weight.x = min(weight.x, abs(C2.x));
  }
}

// this is essentially the same as coverageX, but with the axes swapped
void coverageY(vec2 p0, vec2 p1, vec2 p2) {

  vec2 C1, C2;
  calulateCrossings(p0, p1, p2, C1, C2);

  bool x0 = p0.x > vTexCoord.x;
  bool x1 = p1.x > vTexCoord.x;
  bool x2 = p2.x > vTexCoord.x;

  if (x1 ? !x2 : x0) {
    coverage.y -= saturate(C1.y + 0.5);
    weight.y = min(weight.y, abs(C1.y));
  }

  if (x1 ? !x0 : x2) {
    coverage.y += saturate(C2.y + 0.5);
    weight.y = min(weight.y, abs(C2.y));
  }
}

void main() {

  // calculate the pixel scale based on screen-coordinates
  pixelScale = hardness / fwidth(vTexCoord);

  // which grid cell is this pixel in?
  ivec2 gridCoord = ifloor(vTexCoord * vec2(uGridSize));

  // intersect curves in this row
  {
    // the index into the row info bitmap
    int rowIndex = gridCoord.y + uGridOffset.y;
    // fetch the info texel
    vec4 rowInfo = getTexel(uSamplerRows, rowIndex, uGridImageSize);
    // unpack the rowInfo
    int rowStrokeIndex = getInt16(rowInfo.xy);
    int rowStrokeCount = getInt16(rowInfo.zw);

    for (int iRowStroke = INT(0); iRowStroke < N; iRowStroke++) {
      if (iRowStroke >= rowStrokeCount)
        break;

      // each stroke is made up of 3 points: the start and control point
      // and the start of the next curve.
      // fetch the indices of this pair of strokes:
      vec4 strokeIndices = getTexel(uSamplerRowStrokes, rowStrokeIndex++, uCellsImageSize);

      // unpack the stroke index
      int strokePos = getInt16(strokeIndices.xy);

      // fetch the two strokes
      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);
      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);

      // calculate the coverage
      coverageX(stroke0.xy, stroke0.zw, stroke1.xy);
    }
  }

  // intersect curves in this column
  {
    int colIndex = gridCoord.x + uGridOffset.x;
    vec4 colInfo = getTexel(uSamplerCols, colIndex, uGridImageSize);
    int colStrokeIndex = getInt16(colInfo.xy);
    int colStrokeCount = getInt16(colInfo.zw);
    
    for (int iColStroke = INT(0); iColStroke < N; iColStroke++) {
      if (iColStroke >= colStrokeCount)
        break;

      vec4 strokeIndices = getTexel(uSamplerColStrokes, colStrokeIndex++, uCellsImageSize);

      int strokePos = getInt16(strokeIndices.xy);
      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);
      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);
      coverageY(stroke0.xy, stroke0.zw, stroke1.xy);
    }
  }

  weight = saturate(1.0 - weight * 2.0);
  float distance = max(weight.x + weight.y, minDistance); // manhattan approx.
  float antialias = abs(dot(coverage, weight) / distance);
  float cover = min(abs(coverage.x), abs(coverage.y));
  OUT_COLOR = vec4(uMaterialColor.rgb, 1.) * uMaterialColor.a;
  OUT_COLOR *= saturate(max(antialias, cover));
}
`,Zae=`/*
  Part of the Processing project - http://processing.org
  Copyright (c) 2012-15 The Processing Foundation
  Copyright (c) 2004-12 Ben Fry and Casey Reas
  Copyright (c) 2001-04 Massachusetts Institute of Technology
  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation, version 2.1.
  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.
  You should have received a copy of the GNU Lesser General
  Public License along with this library; if not, write to the
  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
  Boston, MA  02111-1307  USA
*/

#define PROCESSING_LINE_SHADER

#define HOOK_DEFINES

precision highp int;
precision highp float;

#ifdef AUGMENTED_HOOK_getWorldInputs
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
#else
uniform mat4 uModelViewMatrix;
#endif

uniform mat4 uProjectionMatrix;
uniform float uStrokeWeight;

uniform bool uUseLineColor;
uniform bool uSimpleLines;
uniform vec4 uMaterialColor;

uniform vec4 uViewport;
uniform int uPerspective;
uniform int uStrokeJoin;

IN vec3 aPosition;
IN vec3 aTangentIn;
IN vec3 aTangentOut;
IN float aSide;
IN vec4 aVertexColor;

OUT vec4 vColor;
OUT vec2 vTangent;
OUT vec2 vCenter;
OUT vec2 vPosition;
OUT float vMaxDist;
OUT float vCap;
OUT float vJoin;
OUT float vStrokeWeight;

vec2 lineIntersection(vec2 aPoint, vec2 aDir, vec2 bPoint, vec2 bDir) {
  // Rotate and translate so a starts at the origin and goes out to the right
  bPoint -= aPoint;
  vec2 rotatedBFrom = vec2(
    bPoint.x*aDir.x + bPoint.y*aDir.y,
    bPoint.y*aDir.x - bPoint.x*aDir.y
  );
  vec2 bTo = bPoint + bDir;
  vec2 rotatedBTo = vec2(
    bTo.x*aDir.x + bTo.y*aDir.y,
    bTo.y*aDir.x - bTo.x*aDir.y
  );
  float intersectionDistance =
    rotatedBTo.x + (rotatedBFrom.x - rotatedBTo.x) * rotatedBTo.y /
    (rotatedBTo.y - rotatedBFrom.y);
  return aPoint + aDir * intersectionDistance;
}

struct StrokeVertex {
  vec3 position;
  vec3 tangentIn;
  vec3 tangentOut;
  vec4 color;
  float weight;
};

void main() {
  HOOK_beforeVertex();

  if (!uSimpleLines) {
      // Caps have one of either the in or out tangent set to 0
      vCap = (aTangentIn == vec3(0.)) != (aTangentOut == vec3(0.)) ? 1. : 0.;

      // Joins have two unique, defined tangents
      vJoin = (
          aTangentIn != vec3(0.) &&
          aTangentOut != vec3(0.) &&
          aTangentIn != aTangentOut
      ) ? 1. : 0.;
  }

  StrokeVertex inputs;
  inputs.position = aPosition.xyz;
  inputs.color = uUseLineColor ? aVertexColor : uMaterialColor;
  inputs.weight = uStrokeWeight;
  inputs.tangentIn = aTangentIn;
  inputs.tangentOut = aTangentOut;

#ifdef AUGMENTED_HOOK_getObjectInputs
  inputs = HOOK_getObjectInputs(inputs);
#endif

#ifdef AUGMENTED_HOOK_getWorldInputs
  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.tangentIn = (uModelMatrix * vec4(aTangentIn, 0.)).xyz;
  inputs.tangentOut = (uModelMatrix * vec4(aTangentOut, 0.)).xyz;
  inputs = HOOK_getWorldInputs(inputs);
#endif

#ifdef AUGMENTED_HOOK_getWorldInputs
  // Already multiplied by the model matrix, just apply view
  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.tangentIn = (uViewMatrix * vec4(aTangentIn, 0.)).xyz;
  inputs.tangentOut = (uViewMatrix * vec4(aTangentOut, 0.)).xyz;
#else
  // Apply both at once
  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.tangentIn = (uModelViewMatrix * vec4(aTangentIn, 0.)).xyz;
  inputs.tangentOut = (uModelViewMatrix * vec4(aTangentOut, 0.)).xyz;
#endif
#ifdef AUGMENTED_HOOK_getCameraInputs
  inputs = hook_getCameraInputs(inputs);
#endif

  vec4 posp = vec4(inputs.position, 1.);
  vec4 posqIn = vec4(inputs.position + inputs.tangentIn, 1.);
  vec4 posqOut = vec4(inputs.position + inputs.tangentOut, 1.);
  vStrokeWeight = inputs.weight;

  float facingCamera = pow(
    // The word space tangent's z value is 0 if it's facing the camera
    abs(normalize(posqIn-posp).z),

    // Using pow() here to ramp \`facingCamera\` up from 0 to 1 really quickly
    // so most lines get scaled and don't get clipped
    0.25
  );

  // Moving vertices slightly toward the camera
  // to avoid depth-fighting with the fill triangles.
  // A mix of scaling and offsetting is used based on distance
  // Discussion here:
  // https://github.com/processing/p5.js/issues/7200 

  // using a scale <1 moves the lines towards nearby camera
  // in order to prevent popping effects due to half of
  // the line disappearing behind the geometry faces.
  float zDistance = -posp.z; 
  float distanceFactor = smoothstep(0.0, 800.0, zDistance); 
  
  // Discussed here:
  // http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=252848  
  float scale = mix(1., 0.995, facingCamera);
  float dynamicScale = mix(scale, 1.0, distanceFactor); // Closer = more scale, farther = less

  posp.xyz = posp.xyz * dynamicScale;
  posqIn.xyz = posqIn.xyz * dynamicScale;
  posqOut.xyz = posqOut.xyz * dynamicScale;

  // Moving vertices slightly toward camera when far away 
  // https://github.com/processing/p5.js/issues/6956 
  float zOffset = mix(0., -1., facingCamera);
  float dynamicZAdjustment = mix(0.0, zOffset, distanceFactor); // Closer = less zAdjustment, farther = more

  posp.z -= dynamicZAdjustment;
  posqIn.z -= dynamicZAdjustment;
  posqOut.z -= dynamicZAdjustment;
  
  vec4 p = uProjectionMatrix * posp;
  vec4 qIn = uProjectionMatrix * posqIn;
  vec4 qOut = uProjectionMatrix * posqOut;

  // formula to convert from clip space (range -1..1) to screen space (range 0..[width or height])
  // screen_p = (p.xy/p.w + <1,1>) * 0.5 * uViewport.zw

  // prevent division by W by transforming the tangent formula (div by 0 causes
  // the line to disappear, see https://github.com/processing/processing/issues/5183)
  // t = screen_q - screen_p
  //
  // tangent is normalized and we don't care which aDirection it points to (+-)
  // t = +- normalize( screen_q - screen_p )
  // t = +- normalize( (q.xy/q.w+<1,1>)*0.5*uViewport.zw - (p.xy/p.w+<1,1>)*0.5*uViewport.zw )
  //
  // extract common factor, <1,1> - <1,1> cancels out
  // t = +- normalize( (q.xy/q.w - p.xy/p.w) * 0.5 * uViewport.zw )
  //
  // convert to common divisor
  // t = +- normalize( ((q.xy*p.w - p.xy*q.w) / (p.w*q.w)) * 0.5 * uViewport.zw )
  //
  // remove the common scalar divisor/factor, not needed due to normalize and +-
  // (keep uViewport - can't remove because it has different components for x and y
  //  and corrects for aspect ratio, see https://github.com/processing/processing/issues/5181)
  // t = +- normalize( (q.xy*p.w - p.xy*q.w) * uViewport.zw )

  vec2 tangentIn = normalize((qIn.xy*p.w - p.xy*qIn.w) * uViewport.zw);
  vec2 tangentOut = normalize((qOut.xy*p.w - p.xy*qOut.w) * uViewport.zw);

  vec2 curPerspScale;
  if(uPerspective == 1) {
    // Perspective ---
    // convert from world to clip by multiplying with projection scaling factor
    // to get the right thickness (see https://github.com/processing/processing/issues/5182)

    // The y value of the projection matrix may be flipped if rendering to a Framebuffer.
    // Multiplying again by its sign here negates the flip to get just the scale.
    curPerspScale = (uProjectionMatrix * vec4(1, sign(uProjectionMatrix[1][1]), 0, 0)).xy;
  } else {
    // No Perspective ---
    // multiply by W (to cancel out division by W later in the pipeline) and
    // convert from screen to clip (derived from clip to screen above)
    curPerspScale = p.w / (0.5 * uViewport.zw);
  }

  vec2 offset;
  if (vJoin == 1. && !uSimpleLines) {
    vTangent = normalize(tangentIn + tangentOut);
    vec2 normalIn = vec2(-tangentIn.y, tangentIn.x);
    vec2 normalOut = vec2(-tangentOut.y, tangentOut.x);
    float side = sign(aSide);
    float sideEnum = abs(aSide);

    // We generate vertices for joins on either side of the centerline, but
    // the "elbow" side is the only one needing a join. By not setting the
    // offset for the other side, all its vertices will end up in the same
    // spot and not render, effectively discarding it.
    if (sign(dot(tangentOut, vec2(-tangentIn.y, tangentIn.x))) != side) {
      // Side enums:
      //   1: the side going into the join
      //   2: the middle of the join
      //   3: the side going out of the join
      if (sideEnum == 2.) {
        // Calculate the position + tangent on either side of the join, and
        // find where the lines intersect to find the elbow of the join
        vec2 c = (posp.xy/posp.w + vec2(1.,1.)) * 0.5 * uViewport.zw;
        vec2 intersection = lineIntersection(
          c + (side * normalIn * inputs.weight / 2.),
          tangentIn,
          c + (side * normalOut * inputs.weight / 2.),
          tangentOut
        );
        offset = (intersection - c);

        // When lines are thick and the angle of the join approaches 180, the
        // elbow might be really far from the center. We'll apply a limit to
        // the magnitude to avoid lines going across the whole screen when this
        // happens.
        float mag = length(offset);
        float maxMag = 3. * inputs.weight;
        if (mag > maxMag) {
          offset *= maxMag / mag;
        }
      } else if (sideEnum == 1.) {
        offset = side * normalIn * inputs.weight / 2.;
      } else if (sideEnum == 3.) {
        offset = side * normalOut * inputs.weight / 2.;
      }
    }
    if (uStrokeJoin == STROKE_JOIN_BEVEL) {
      vec2 avgNormal = vec2(-vTangent.y, vTangent.x);
      vMaxDist = abs(dot(avgNormal, normalIn * inputs.weight / 2.));
    } else {
      vMaxDist = inputs.weight / 2.;
    }
  } else {
    vec2 tangent = aTangentIn == vec3(0.) ? tangentOut : tangentIn;
    vTangent = tangent;
    vec2 normal = vec2(-tangent.y, tangent.x);

    float normalOffset = sign(aSide);
    // Caps will have side values of -2 or 2 on the edge of the cap that
    // extends out from the line
    float tangentOffset = abs(aSide) - 1.;
    offset = (normal * normalOffset + tangent * tangentOffset) *
      inputs.weight * 0.5;
    vMaxDist = inputs.weight / 2.;
  }

  vCenter = p.xy;
  vPosition = vCenter + offset;
  vColor = inputs.color;

  gl_Position.xy = p.xy + offset.xy * curPerspScale;
  gl_Position.zw = p.zw;
  
  HOOK_afterVertex();
}
`,Jae=`precision highp int;
precision highp float;

uniform vec4 uMaterialColor;
uniform int uStrokeCap;
uniform int uStrokeJoin;

IN vec4 vColor;
IN vec2 vTangent;
IN vec2 vCenter;
IN vec2 vPosition;
IN float vStrokeWeight;
IN float vMaxDist;
IN float vCap;
IN float vJoin;

float distSquared(vec2 a, vec2 b) {
  vec2 aToB = b - a;
  return dot(aToB, aToB);
}

struct Inputs {
  vec4 color;
  vec2 tangent;
  vec2 center;
  vec2 position;
  float strokeWeight;
};

void main() {
  HOOK_beforeFragment();

  Inputs inputs;
  inputs.color = vColor;
  inputs.tangent = vTangent;
  inputs.center = vCenter;
  inputs.position = vPosition;
  inputs.strokeWeight = vStrokeWeight;
  inputs = HOOK_getPixelInputs(inputs);

  if (vCap > 0.) {
    if (
      uStrokeCap == STROKE_CAP_ROUND &&
      HOOK_shouldDiscard(distSquared(inputs.position, inputs.center) > inputs.strokeWeight * inputs.strokeWeight * 0.25)
    ) {
      discard;
    } else if (
      uStrokeCap == STROKE_CAP_SQUARE &&
      HOOK_shouldDiscard(dot(inputs.position - inputs.center, inputs.tangent) > 0.)
    ) {
      discard;
    // Use full area for PROJECT
    } else if (HOOK_shouldDiscard(false)) {
      discard;
    }
  } else if (vJoin > 0.) {
    if (
      uStrokeJoin == STROKE_JOIN_ROUND &&
      HOOK_shouldDiscard(distSquared(inputs.position, inputs.center) > inputs.strokeWeight * inputs.strokeWeight * 0.25)
    ) {
      discard;
    } else if (uStrokeJoin == STROKE_JOIN_BEVEL) {
      vec2 normal = vec2(-inputs.tangent.y, inputs.tangent.x);
      if (HOOK_shouldDiscard(abs(dot(inputs.position - inputs.center, normal)) > vMaxDist)) {
        discard;
      }
    // Use full area for MITER
    } else if (HOOK_shouldDiscard(false)) {
      discard;
    }
  }
  OUT_COLOR = HOOK_getFinalColor(vec4(inputs.color.rgb, 1.) * inputs.color.a);
  HOOK_afterFragment();
}
`,Qae=`IN vec3 aPosition;
uniform float uPointSize;
OUT float vStrokeWeight;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

void main() {
  HOOK_beforeVertex();
  vec4 viewModelPosition = vec4(HOOK_getWorldPosition(
    (uModelViewMatrix * vec4(HOOK_getLocalPosition(aPosition), 1.0)).xyz
  ), 1.);
  gl_Position = uProjectionMatrix * viewModelPosition;  

  float pointSize = HOOK_getPointSize(uPointSize);

	gl_PointSize = pointSize;
	vStrokeWeight = pointSize;
  HOOK_afterVertex();
}
`,eoe=`precision mediump int;
uniform vec4 uMaterialColor;
IN float vStrokeWeight;

void main(){
  HOOK_beforeFragment();
  float mask = 0.0;

  // make a circular mask using the gl_PointCoord (goes from 0 - 1 on a point)
  // might be able to get a nicer edge on big strokeweights with smoothstep but slightly less performant

  mask = step(0.98, length(gl_PointCoord * 2.0 - 1.0));

  // if strokeWeight is 1 or less lets just draw a square
  // this prevents weird artifacting from carving circles when our points are really small
  // if strokeWeight is larger than 1, we just use it as is

  mask = mix(0.0, mask, clamp(floor(vStrokeWeight - 0.5),0.0,1.0));

  // throw away the borders of the mask
  // otherwise we get weird alpha blending issues

  if(HOOK_shouldDiscard(mask > 0.98)){
    discard;
  }

  OUT_COLOR = HOOK_getFinalColor(vec4(uMaterialColor.rgb, 1.) * uMaterialColor.a);
  HOOK_afterFragment();
}
`,toe=`precision highp float;
attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec2 aTexCoord;

varying vec3 localPos;
varying vec3 vWorldNormal;
varying vec3 vWorldPosition;
varying vec2 vTexCoord;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

void main() {
  // Multiply the position by the matrix.
  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);
  gl_Position = uProjectionMatrix * viewModelPosition;  
  
  // orient the normals and pass to the fragment shader
  vWorldNormal = uNormalMatrix * aNormal;
  
  // send the view position to the fragment shader
  vWorldPosition = (uModelViewMatrix * vec4(aPosition, 1.0)).xyz;
  
  localPos = vWorldPosition;
  vTexCoord = aTexCoord;
}


/*
in the vertex shader we'll compute the world position and world oriented normal of the vertices and pass those to the fragment shader as varyings.
*/
`,roe=`precision highp float;
varying vec3 localPos;

// the HDR cubemap converted (can be from an equirectangular environment map.)
uniform sampler2D environmentMap;
varying vec2 vTexCoord;

const float PI = 3.14159265359;

vec2 nTOE( vec3 v ){
  // x = r sin(phi) cos(theta)   
  // y = r cos(phi)  
  // z = r sin(phi) sin(theta)
  float phi = acos( v.y );
  // if phi is 0, then there are no x, z components
  float theta = 0.0;
  // else 
  theta = acos(v.x / sin(phi));
  float sinTheta = v.z / sin(phi);
  if (sinTheta < 0.0) {
    // Turn it into -theta, but in the 0-2PI range
    theta = 2.0 * PI - theta;
  }
  theta = theta / (2.0 * 3.14159);
  phi = phi / 3.14159 ;
  
  vec2 angles = vec2( phi, theta );
  return angles;
}

float random(vec2 p) {
  vec3 p3  = fract(vec3(p.xyx) * .1031);
  p3 += dot(p3, p3.yzx + 33.33);
  return fract((p3.x + p3.y) * p3.z);
}

void main()
{   	 
	// the sample direction equals the hemisphere's orientation
  float phi = vTexCoord.x * 2.0 * PI;
  float theta = vTexCoord.y * PI;
  float x = sin(theta) * cos(phi);
  float y = sin(theta) * sin(phi);
  float z = cos(theta);
  vec3 normal = vec3( x, y, z);

	// Discretely sampling the hemisphere given the integral's
  // spherical coordinates translates to the following fragment code:
	vec3 irradiance = vec3(0.0);  
	vec3 up	= vec3(0.0, 1.0, 0.0);
	vec3 right = normalize(cross(up, normal));
	up = normalize(cross(normal, right));

	//  We specify a fixed sampleDelta delta value to traverse
  // the hemisphere; decreasing or increasing the sample delta
  // will increase or decrease the accuracy respectively.
	const float sampleDelta = 0.100;
	float nrSamples = 0.0;
  float randomOffset = random(gl_FragCoord.xy) * sampleDelta;
	for(float rawPhi = 0.0; rawPhi < 2.0 * PI; rawPhi += sampleDelta)
	{
    float phi = rawPhi + randomOffset;
    for(float rawTheta = 0.0; rawTheta < ( 0.5 ) * PI; rawTheta += sampleDelta)
    {
      float theta = rawTheta + randomOffset;
      // spherical to cartesian (in tangent space) // tangent space to world // add each sample result to irradiance
      float x = sin(theta) * cos(phi);
      float y = sin(theta) * sin(phi);
      float z = cos(theta);
      vec3 tangentSample = vec3( x, y, z);
      
      vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal;
        irradiance += (texture2D(environmentMap, nTOE(sampleVec)).xyz) * cos(theta) * sin(theta);
      nrSamples++;
    }
	}
	// divide by the total number of samples taken, giving us the average sampled irradiance.
	irradiance = PI * irradiance * (1.0 / float(nrSamples )) ;
  
 
	gl_FragColor = vec4(irradiance, 1.0);
}`,noe=`precision highp float;\r
varying vec3 localPos;\r
varying vec2 vTexCoord;\r
\r
// our texture\r
uniform sampler2D environmentMap;\r
uniform float roughness;\r
\r
const float PI = 3.14159265359;\r
\r
float VanDerCorput(int bits);\r
vec2 HammersleyNoBitOps(int i, int N);\r
vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);\r
\r
\r
vec2 nTOE( vec3 v ){\r
  // x = r sin(phi) cos(theta)   \r
  // y = r cos(phi)  \r
  // z = r sin(phi) sin(theta)\r
  float phi = acos( v.y );\r
  // if phi is 0, then there are no x, z components\r
  float theta = 0.0;\r
  // else \r
  theta = acos(v.x / sin(phi));\r
  float sinTheta = v.z / sin(phi);\r
  if (sinTheta < 0.0) {\r
    // Turn it into -theta, but in the 0-2PI range\r
    theta = 2.0 * PI - theta;\r
  }\r
  theta = theta / (2.0 * 3.14159);\r
  phi = phi / 3.14159 ;\r
  \r
  vec2 angles = vec2( phi, theta );\r
  return angles;\r
}\r
\r
\r
void main(){\r
  const int SAMPLE_COUNT = 400; // 4096\r
  int lowRoughnessLimit = int(pow(2.0,(roughness+0.1)*20.0));\r
  float totalWeight = 0.0;\r
  vec3 prefilteredColor = vec3(0.0);\r
  float phi = vTexCoord.x * 2.0 * PI;\r
  float theta = vTexCoord.y * PI;\r
  float x = sin(theta) * cos(phi);\r
  float y = sin(theta) * sin(phi);\r
  float z = cos(theta);\r
  vec3 N = vec3(x,y,z);\r
  vec3 V = N;\r
  for (int i = 0; i < SAMPLE_COUNT; ++i)\r
  {\r
    // break at smaller sample numbers for low roughness levels\r
    if(i == lowRoughnessLimit)\r
    {\r
      break;\r
    }\r
    vec2 Xi = HammersleyNoBitOps(i, SAMPLE_COUNT);\r
    vec3 H = ImportanceSampleGGX(Xi, N, roughness);\r
    vec3 L = normalize(2.0 * dot(V, H) * H - V);\r
\r
    float NdotL = max(dot(N, L), 0.0);\r
    if (NdotL > 0.0)\r
    {\r
      prefilteredColor += texture2D(environmentMap, nTOE(L)).xyz * NdotL;\r
      totalWeight += NdotL;\r
    }\r
  }\r
  prefilteredColor = prefilteredColor / totalWeight;\r
\r
  gl_FragColor = vec4(prefilteredColor, 1.0);\r
}\r
\r
vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness){\r
  float a = roughness * roughness;\r
\r
  float phi = 2.0 * PI * Xi.x;\r
  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\r
  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\r
  // from spherical coordinates to cartesian coordinates\r
  vec3 H;\r
  H.x = cos(phi) * sinTheta;\r
  H.y = sin(phi) * sinTheta;\r
  H.z = cosTheta;\r
\r
  // from tangent-space vector to world-space sample vector\r
  vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r
  vec3 tangent = normalize(cross(up, N));\r
  vec3 bitangent = cross(N, tangent);\r
\r
  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r
  return normalize(sampleVec);\r
}\r
\r
\r
float VanDerCorput(int n, int base)\r
{\r
#ifdef WEBGL2\r
\r
    uint bits = uint(n);\r
    bits = (bits << 16u) | (bits >> 16u);\r
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r
    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r
\r
#else\r
\r
  float invBase = 1.0 / float(base);\r
  float denom = 1.0;\r
  float result = 0.0;\r
\r
\r
  for (int i = 0; i < 32; ++i)\r
  {\r
        if (n > 0)\r
        {\r
        denom = mod(float(n), 2.0);\r
        result += denom * invBase;\r
        invBase = invBase / 2.0;\r
        n = int(float(n) / 2.0);\r
        }\r
  }\r
\r
\r
  return result;\r
\r
#endif\r
}\r
\r
vec2 HammersleyNoBitOps(int i, int N)\r
{\r
  return vec2(float(i) / float(N), VanDerCorput(i, 2));\r
}\r
`,k6=`precision highp float;

uniform sampler2D tex0;
uniform vec2 canvasSize;
uniform vec2 texelSize;

IN vec2 vTexCoord;

struct FilterInputs {
  vec2 texCoord;
  vec2 canvasSize;
  vec2 texelSize;
};

void main(void) {
  FilterInputs inputs;
  inputs.texCoord = vTexCoord;
  inputs.canvasSize = canvasSize;
  inputs.texelSize = texelSize;
  OUT_COLOR = HOOK_getColor(inputs, tex0);
  OUT_COLOR.rgb *= outColor.a;
}
`,N6=`precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;

float luma(vec3 color) {
  // weighted grayscale with luminance values
  return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

void main() {
  vec4 tex = texture2D(tex0, vTexCoord);
  float gray = luma(tex.rgb);
  gl_FragColor = vec4(gray, gray, gray, tex.a);
}
`,T6=`// Reduces the bright areas in an image

precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;
uniform vec2 texelSize;

float luma(vec3 color) {
  // weighted grayscale with luminance values
  // weights 77, 151, 28 taken from src/image/filters.js
  return dot(color, vec3(0.300781, 0.589844, 0.109375));
}

void main() {
  vec4 color = texture2D(tex0, vTexCoord);
  float lum = luma(color.rgb);

  // set current color as the darkest neighbor color

  vec4 neighbors[4];
  neighbors[0] = texture2D(tex0, vTexCoord + vec2( texelSize.x, 0.0));
  neighbors[1] = texture2D(tex0, vTexCoord + vec2(-texelSize.x, 0.0));
  neighbors[2] = texture2D(tex0, vTexCoord + vec2(0.0,  texelSize.y));
  neighbors[3] = texture2D(tex0, vTexCoord + vec2(0.0, -texelSize.y));

  for (int i = 0; i < 4; i++) {
    vec4 neighborColor = neighbors[i];
    float neighborLum = luma(neighborColor.rgb);

    if (neighborLum < lum) {
      color = neighborColor;
      lum = neighborLum;
    }
  }

  gl_FragColor = color;
}
`,A6=`// Increase the bright areas in an image

precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;
uniform vec2 texelSize;

float luma(vec3 color) {
  // weighted grayscale with luminance values
  // weights 77, 151, 28 taken from src/image/filters.js
  return dot(color, vec3(0.300781, 0.589844, 0.109375));
}

void main() {
  vec4 color = texture2D(tex0, vTexCoord);
  float lum = luma(color.rgb);

  // set current color as the brightest neighbor color

  vec4 neighbors[4];
  neighbors[0] = texture2D(tex0, vTexCoord + vec2( texelSize.x, 0.0));
  neighbors[1] = texture2D(tex0, vTexCoord + vec2(-texelSize.x, 0.0));
  neighbors[2] = texture2D(tex0, vTexCoord + vec2(0.0,  texelSize.y));
  neighbors[3] = texture2D(tex0, vTexCoord + vec2(0.0, -texelSize.y));

  for (int i = 0; i < 4; i++) {
    vec4 neighborColor = neighbors[i];
    float neighborLum = luma(neighborColor.rgb);

    if (neighborLum > lum) {
      color = neighborColor;
      lum = neighborLum;
    }
  }

  gl_FragColor = color;
}
`,D6=`precision highp float;

// Two-pass blur filter, unweighted kernel.
// See also a similar blur at Adam Ferriss' repo of shader examples:
// https://github.com/aferriss/p5jsShaderExamples/blob/gh-pages/4_image-effects/4-9_single-pass-blur/effect.frag


uniform sampler2D tex0;
varying vec2 vTexCoord;
uniform vec2 direction;
uniform vec2 canvasSize;
uniform float radius;

float random(vec2 p) {
  vec3 p3  = fract(vec3(p.xyx) * .1031);
  p3 += dot(p3, p3.yzx + 33.33);
  return fract((p3.x + p3.y) * p3.z);
}

// This isn't a real Gaussian weight, it's a quadratic weight. It's what the
// CPU mode's blur uses though, so we also use it here to match.
float quadWeight(float x, float e) {
  return pow(e-abs(x), 2.);
}

void main(){
  vec2 uv = vTexCoord;

  // A reasonable maximum number of samples
  const float maxSamples = 64.0;

  float numSamples = floor(7. * radius);
  if (fract(numSamples / 2.) == 0.) {
    numSamples++;
  }
  vec4 avg = vec4(0.0);
  float total = 0.0;

  // Calculate the spacing to avoid skewing if numSamples > maxSamples
  float spacing = 1.0;
  if (numSamples > maxSamples) {
    spacing = numSamples / maxSamples;
    numSamples = maxSamples;
  }

  float randomOffset = (spacing - 1.0) * mix(-0.5, 0.5, random(gl_FragCoord.xy));
  for (float i = 0.0; i < maxSamples; i++) {
    if (i >= numSamples) break;

    float sample = i * spacing - (numSamples - 1.0) * 0.5 * spacing + randomOffset;
    vec2 sampleCoord = uv + vec2(sample, sample) / canvasSize * direction;
    float weight = quadWeight(sample, (numSamples - 1.0) * 0.5 * spacing);

    avg += weight * texture2D(tex0, sampleCoord);
    total += weight;
  }

  avg /= total;
  gl_FragColor = avg;
}
`,F6=`// Limit color space for a stylized cartoon / poster effect

precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;
uniform float filterParameter;

vec3 quantize(vec3 color, float n) {
  // restrict values to N options/bins
  // and floor each channel to nearest value
  //
  // eg. when N = 5, values = 0.0, 0.25, 0.50, 0.75, 1.0
  // then quantize (0.1, 0.7, 0.9) -> (0.0, 0.5, 1.0)

  color = color * n;
  color = floor(color);
  color = color / (n - 1.0);
  return color;
}

void main() {
  vec4 color = texture2D(tex0, vTexCoord);

  vec3 restrictedColor = quantize(color.rgb / color.a, filterParameter);

  gl_FragColor = vec4(restrictedColor.rgb * color.a, color.a);
}
`,$6=`// Set alpha channel to entirely opaque

precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;

void main() {
  vec4 color = texture2D(tex0, vTexCoord);
  gl_FragColor = vec4(color.rgb / color.a, 1.0);
}
`,R6=`// Set each pixel to inverse value
// Note that original INVERT does not change the opacity, so this follows suit

precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;

void main() {
vec4 color = texture2D(tex0, vTexCoord);
vec3 origColor = color.rgb / color.a;
vec3 invertedColor = vec3(1.0) - origColor;
gl_FragColor = vec4(invertedColor * color.a, color.a);
}
`,O6=`// Convert pixels to either white or black, 
// depending on if their luma is above or below filterParameter

precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;
uniform float filterParameter;

float luma(vec3 color) {
  // weighted grayscale with luminance values
  return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

void main() {
  vec4 color = texture2D(tex0, vTexCoord);
  float gray = luma(color.rgb / color.a);
  // floor() used to match src/image/filters.js
  float threshold = floor(filterParameter * 255.0) / 255.0;
  float blackOrWhite = step(threshold, gray);
  gl_FragColor = vec4(vec3(blackOrWhite) * color.a, color.a);
}
`,M6=`uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

attribute vec3 aPosition;
// texcoords only come from p5 to vertex shader
// so pass texcoords on to the fragment shader in a varying variable
attribute vec2 aTexCoord;
varying vec2 vTexCoord;

void main() {
  // transferring texcoords for the frag shader
  vTexCoord = aTexCoord;

  // copy position with a fourth coordinate for projection (1.0 is normal)
  vec4 positionVec4 = vec4(aPosition, 1.0);

  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
}
`;const L6={},P6={};let qw="";const GT=function(r,t){qw+=`#define STROKE_CAP_${r} ${t}
`,L6[Wh[r]]=t},HT=function(r,t){qw+=`#define STROKE_JOIN_${r} ${t}
`,P6[Wh[r]]=t};GT("ROUND",0);GT("PROJECT",1);GT("SQUARE",2);HT("ROUND",0);HT("MITER",1);HT("BEVEL",2);const Dn={normalVert:zae,normalFrag:Uae,basicFrag:Wae,sphereMappingFrag:Gae,lightVert:QP+Hae,lightTextureFrag:jae,phongVert:qae,phongFrag:QP+Kae,fontVert:Xae,fontFrag:Yae,lineVert:qw+Zae,lineFrag:qw+Jae,pointVert:Qae,pointFrag:eoe,imageLightVert:toe,imageLightDiffusedFrag:roe,imageLightSpecularFrag:noe,filterBaseVert:I6,filterBaseFrag:k6};let soe=Dn.sphereMappingFrag;for(const r in Dn)Dn[r]=XI+Dn[r];const ioe={[xT]:N6,[CT]:T6,[ST]:A6,[Sm]:D6,[$S]:F6,[vT]:$6,[wT]:R6,[FS]:O6};class Kt extends Gt{constructor(t,n,s,i,a,o){super(t,n,s,i),this.canvas=this.elt=a||document.createElement("canvas"),this._setAttributeDefaults(t),this._initContext(),this.GL=this.drawingContext,this._isMainCanvas?(this._pInst._curElement=this,this._pInst.canvas=this.canvas):this.canvas.style.display="none",this.elt.id="defaultCanvas0",this.elt.classList.add("p5Canvas"),this.wrappedElt=new Sr(this.elt,this._pInst);for(const l of Object.getOwnPropertyNames(Sr.prototype))l!=="constructor"&&l[0]!=="_"&&Object.defineProperty(this,l,{get(){return this.wrappedElt[l]}});const u=this._adjustDimensions(n,s);if(n=u.adjustedWidth,s=u.adjustedHeight,this.width=n,this.height=s,this.elt.width=n*this._pixelDensity,this.elt.height=s*this._pixelDensity,this.elt.style.width=`${n}px`,this.elt.style.height=`${s}px`,this._origViewport={width:this.GL.drawingBufferWidth,height:this.GL.drawingBufferHeight},this.viewport(this._origViewport.width,this._origViewport.height),this._pInst._userNode)this._pInst._userNode.appendChild(this.elt);else{if(document.getElementsByTagName("main").length===0){let l=document.createElement("main");document.body.appendChild(l)}document.getElementsByTagName("main")[0].appendChild(this.elt)}this.isP3D=!0,this.geometryBuilder=void 0,this.states.uModelMatrix=new qn(4),this.states.uViewMatrix=new qn(4),this.states.uPMatrix=new qn(4),this.states.curCamera=new Kh(this),this.states.uPMatrix.set(this.states.curCamera.projMatrix),this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix),this.states.enableLighting=!1,this.states.ambientLightColors=[],this.states.specularColors=[1,1,1],this.states.directionalLightDirections=[],this.states.directionalLightDiffuseColors=[],this.states.directionalLightSpecularColors=[],this.states.pointLightPositions=[],this.states.pointLightDiffuseColors=[],this.states.pointLightSpecularColors=[],this.states.spotLightPositions=[],this.states.spotLightDirections=[],this.states.spotLightDiffuseColors=[],this.states.spotLightSpecularColors=[],this.states.spotLightAngle=[],this.states.spotLightConc=[],this.states.activeImageLight=null,this.states.curFillColor=[1,1,1,1],this.states.curAmbientColor=[1,1,1,1],this.states.curSpecularColor=[0,0,0,0],this.states.curEmissiveColor=[0,0,0,0],this.states.curStrokeColor=[0,0,0,1],this.states.curBlendMode=Si,this.states._hasSetAmbient=!1,this.states._useSpecularMaterial=!1,this.states._useEmissiveMaterial=!1,this.states._useNormalMaterial=!1,this.states._useShininess=1,this.states._useMetalness=0,this.states.tint=[255,255,255,255],this.states.constantAttenuation=1,this.states.linearAttenuation=0,this.states.quadraticAttenuation=0,this.states._currentNormal=new De(0,0,1),this.states.drawMode=Pw,this.states._tex=null,this.states.textureMode=RS,this.states.textureWrapX=MI,this.states.textureWrapY=MI,this._isErasing=!1,this._simpleLines=!1,this._clipDepths=[],this._isClipApplied=!1,this._stencilTestOn=!1,this.mixedAmbientLight=[],this.mixedSpecularColor=[],this.diffusedTextures=new Map,this.specularTextures=new Map,this.preEraseBlend=void 0,this._cachedBlendMode=void 0,this._cachedFillStyle=[1,1,1,1],this._cachedStrokeStyle=[0,0,0,1],this.webglVersion===ts?this.blendExt=this.GL:this.blendExt=this.GL.getExtension("EXT_blend_minmax"),this._isBlending=!1,this._useLineColor=!1,this._useVertexColor=!1,this.registerEnabled=new Set,this.states.curCamera._computeCameraDefaultSettings(),this.states.curCamera._setDefaultCamera(),this.filterCamera=new Kh(this),this.filterCamera._computeCameraDefaultSettings(),this.filterCamera._setDefaultCamera(),this.prevTouches=[],this.zoomVelocity=0,this.rotateVelocity=new De(0,0),this.moveVelocity=new De(0,0),this.executeZoom=!1,this.executeRotateAndMove=!1,this._drawingFilter=!1,this._drawingImage=!1,this.specularShader=void 0,this.sphereMapping=void 0,this.diffusedShader=void 0,this._baseFilterShader=void 0,this._defaultLightShader=void 0,this._defaultImmediateModeShader=void 0,this._defaultNormalShader=void 0,this._defaultColorShader=void 0,this._defaultPointShader=void 0,this.states.userFillShader=void 0,this.states.userStrokeShader=void 0,this.states.userPointShader=void 0,this.states.userImageShader=void 0,this.states.curveDetail=1/4,this.shapeBuilder=new Bae(this),this.buffers={fill:[new yi(3,"vertices","vertexBuffer","aPosition",this,this._vToNArray),new yi(3,"vertexNormals","normalBuffer","aNormal",this,this._vToNArray),new yi(4,"vertexColors","colorBuffer","aVertexColor",this),new yi(3,"vertexAmbients","ambientBuffer","aAmbientColor",this),new yi(2,"uvs","uvBuffer","aTexCoord",this,l=>l.flat())],stroke:[new yi(4,"lineVertexColors","lineColorBuffer","aVertexColor",this),new yi(3,"lineVertices","lineVerticesBuffer","aPosition",this),new yi(3,"lineTangentsIn","lineTangentsInBuffer","aTangentIn",this),new yi(3,"lineTangentsOut","lineTangentsOutBuffer","aTangentOut",this),new yi(1,"lineSides","lineSidesBuffer","aSide",this)],text:[new yi(3,"vertices","vertexBuffer","aPosition",this,this._vToNArray),new yi(2,"uvs","uvBuffer","aTexCoord",this,l=>l.flat())],point:this.GL.createBuffer(),user:[]},this.geometryBufferCache=new Vae(this),this.curStrokeCap=Ql,this.curStrokeJoin=Ql,this.textures=new Map,this.framebuffers=new Set,this.activeFramebuffers=[],this.states.filterShader=void 0,this.filterLayer=void 0,this.filterLayerTemp=void 0,this.defaultFilterShaders={},this.fontInfos={},this._curShader=void 0,this.drawShapeCount=1,this.scratchMat3=new qn(3),this._userEnabledStencil=!1,this._internalEnable=this.drawingContext.enable,this._internalDisable=this.drawingContext.disable,this.drawingContext.enable=l=>(l===this.drawingContext.STENCIL_TEST&&(this._clipping||(this._userEnabledStencil=!0)),this._internalEnable.call(this.drawingContext,l)),this.drawingContext.disable=l=>(l===this.drawingContext.STENCIL_TEST&&(this._userEnabledStencil=!1),this._internalDisable.call(this.drawingContext,l))}remove(){this.wrappedElt.remove(),this.wrappedElt=null,this.canvas=null,this.elt=null}beginGeometry(){if(this.geometryBuilder)throw new Error("It looks like `beginGeometry()` is being called while another p5.Geometry is already being build.");this.geometryBuilder=new pb(this),this.geometryBuilder.prevFillColor=this.states.fillColor,this.fill(new _n([-1,-1,-1,-1]))}endGeometry(){if(!this.geometryBuilder)throw new Error("Make sure you call beginGeometry() before endGeometry()!");const t=this.geometryBuilder.finish();return this.fill(this.geometryBuilder.prevFillColor),this.geometryBuilder=void 0,t}buildGeometry(t){return this.beginGeometry(),t(),this.endGeometry()}beginShape(...t){super.beginShape(...t)}curveDetail(t){if(t===void 0)return this.states.curveDetail;this.states.setValue("curveDetail",t)}drawShape(t){const n=new s6({curveDetail:this.states.curveDetail});t.accept(n),this.shapeBuilder.constructFromContours(t,n.contours),this.geometryBuilder?this.geometryBuilder.addImmediate(this.shapeBuilder.geometry,this.shapeBuilder.shapeMode):(this.states.fillColor||this.states.strokeColor)&&(this.shapeBuilder.shapeMode===Mw?this._drawPoints(this.shapeBuilder.geometry.vertices,this.buffers.point):this._drawGeometry(this.shapeBuilder.geometry,{mode:this.shapeBuilder.shapeMode,count:this.drawShapeCount})),this.drawShapeCount=1}endShape(t,n){this.drawShapeCount=n,super.endShape(t,n)}vertexProperty(...t){this.currentShape.vertexProperty(...t)}normal(t,n,s){t instanceof De?this.states.setValue("_currentNormal",t):this.states.setValue("_currentNormal",new De(t,n,s)),this.updateShapeVertexProperties()}model(t,n=1){t.vertices.length>0&&(this.geometryBuilder?this.geometryBuilder.addRetained(t):(this.geometryInHash(t.gid)||(t._edgesToVertices(),this._getOrMakeCachedBuffers(t)),this._drawGeometry(t,{count:n})))}_drawGeometry(t,{mode:n=em,count:s=1}={}){for(const i in t.userVertexProperties){const a=t.userVertexProperties[i];this.buffers.user.push(new yi(a.getDataSize(),a.getSrcName(),a.getDstName(),a.getName(),this))}this.states.fillColor&&t.vertices.length>=3&&![wm,Mw].includes(n)&&this._drawFills(t,{mode:n,count:s}),this.states.strokeColor&&t.lineVertices.length>=1&&this._drawStrokes(t,{count:s}),this.buffers.user=[]}_drawGeometryScaled(t,n,s,i){let a=this.states.uModelMatrix;this.states.setValue("uModelMatrix",this.states.uModelMatrix.clone());try{this.states.uModelMatrix.scale(n,s,i),this.geometryBuilder?this.geometryBuilder.addRetained(t):this._drawGeometry(t)}finally{this.states.setValue("uModelMatrix",a)}}_drawFills(t,{count:n,mode:s}={}){this._useVertexColor=t.vertexColors.length>0;const i=!this._drawingFilter&&this.states.userFillShader?this.states.userFillShader:this._getFillShader();i.bindShader(),this._setGlobalUniforms(i),this._setFillUniforms(i),i.bindTextures();for(const a of this.buffers.fill)a._prepareBuffer(t,i);this._prepareUserAttributes(t,i),i.disableRemainingAttributes(),this._applyColorBlend(this.states.curFillColor,t.hasFillTransparency()),this._drawBuffers(t,{mode:s,count:n}),i.unbindShader()}_drawStrokes(t,{count:n}={}){const s=this.GL;this._useLineColor=t.vertexStrokeColors.length>0;const i=this._getStrokeShader();i.bindShader(),this._setGlobalUniforms(i),this._setStrokeUniforms(i),i.bindTextures();for(const a of this.buffers.stroke)a._prepareBuffer(t,i);if(this._prepareUserAttributes(t,i),i.disableRemainingAttributes(),this._applyColorBlend(this.states.curStrokeColor,t.hasStrokeTransparency()),n===1)s.drawArrays(s.TRIANGLES,0,t.lineVertices.length/3);else try{s.drawArraysInstanced(s.TRIANGLES,0,t.lineVertices.length/3,n)}catch{console.log(" p5.js says: Instancing is only supported in WebGL2 mode")}i.unbindShader()}_drawPoints(t,n){const s=this.GL,i=this._getPointShader();i.bindShader(),this._setGlobalUniforms(i),this._setPointUniforms(i),i.bindTextures(),this._bindBuffer(n,s.ARRAY_BUFFER,this._vToNArray(t),Float32Array,s.STATIC_DRAW),i.enableAttrib(i.attributes.aPosition,3),this._applyColorBlend(this.states.curStrokeColor),s.drawArrays(s.Points,0,t.length),i.unbindShader()}_prepareUserAttributes(t,n){for(const s of this.buffers.user){if(!this._pInst.constructor.disableFriendleErrors){const i=t.userVertexProperties[s.attr];if(i){const a=i.getSrcArray().length/i.getDataSize();a>t.vertices.length?this._pInst.constructor._friendlyError(`One of the geometries has a custom vertex property '${i.getName()}' with more values than vertices. This is probably caused by directly using the Geometry.vertexProperty() method.`,"vertexProperty()"):a<t.vertices.length&&this._pInst.constructor._friendlyError(`One of the geometries has a custom vertex property '${i.getName()}' with fewer values than vertices. This is probably caused by directly using the Geometry.vertexProperty() method.`,"vertexProperty()")}}s._prepareBuffer(t,n)}}_drawBuffers(t,{mode:n=this.GL.TRIANGLES,count:s}){const i=this.GL,a=this.geometryBufferCache.getCached(t);if(a)if(a.indexBuffer){if(this._bindBuffer(a.indexBuffer,i.ELEMENT_ARRAY_BUFFER),this._pInst.webglVersion!==ts&&a.indexBufferType===i.UNSIGNED_INT&&!i.getExtension("OES_element_index_uint"))throw new Error("Unable to render a 3d model with > 65535 triangles. Your web browser does not support the WebGL Extension OES_element_index_uint.");if(s===1)i.drawElements(i.TRIANGLES,t.faces.length*3,a.indexBufferType,0);else try{i.drawElementsInstanced(i.TRIANGLES,t.faces.length*3,a.indexBufferType,0,s)}catch{console.log(" p5.js says: Instancing is only supported in WebGL2 mode")}}else if(s===1)i.drawArrays(n,0,t.vertices.length);else try{i.drawArraysInstanced(n,0,t.vertices.length,s)}catch{console.log(" p5.js says: Instancing is only supported in WebGL2 mode")}}_getOrMakeCachedBuffers(t){return this.geometryBufferCache.ensureCached(t)}_setAttributeDefaults(t){const s={alpha:!0,depth:!0,stencil:!0,antialias:navigator.userAgent.toLowerCase().includes("safari"),premultipliedAlpha:!0,preserveDrawingBuffer:!0,perPixelLighting:!0,version:2};t._glAttributes===null?t._glAttributes=s:t._glAttributes=Object.assign(s,t._glAttributes)}_initContext(){var t;if(((t=this._pInst._glAttributes)==null?void 0:t.version)!==1&&(this.drawingContext=this.canvas.getContext("webgl2",this._pInst._glAttributes)),this.webglVersion=this.drawingContext?ts:ic,this._pInst.webglVersion=this.webglVersion,this.drawingContext||(this.drawingContext=this.canvas.getContext("webgl",this._pInst._glAttributes)||this.canvas.getContext("experimental-webgl",this._pInst._glAttributes)),this.drawingContext===null)throw new Error("Error creating webgl context");{const n=this.drawingContext;n.enable(n.DEPTH_TEST),n.depthFunc(n.LEQUAL),n.viewport(0,0,n.drawingBufferWidth,n.drawingBufferHeight),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),this._viewport=this.drawingContext.getParameter(this.drawingContext.VIEWPORT)}}_getMaxTextureSize(){const t=this.drawingContext;return t.getParameter(t.MAX_TEXTURE_SIZE)}_adjustDimensions(t,n){this._maxTextureSize||(this._maxTextureSize=this._getMaxTextureSize());let s=this._maxTextureSize,i=Math.floor(s/this._pixelDensity),a=Math.min(t,i),o=Math.min(n,i);return(a!==t||o!==n)&&console.warn(`Warning: The requested width/height exceeds hardware limits. Adjusting dimensions to width: ${a}, height: ${o}.`),{adjustedWidth:a,adjustedHeight:o}}_resetContext(t,n){const s=this.width,i=this.height,a=this.canvas.id,o=this._pInst instanceof Em,u={position:this.canvas.style.position,top:this.canvas.style.top,left:this.canvas.style.left};if(o){const c=this._pInst;c.canvas.parentNode.removeChild(c.canvas),c.canvas=document.createElement("canvas"),(c._pInst._userNode||document.body).appendChild(c.canvas),Sr.call(c,c.canvas,c._pInst),c.width=s,c.height=i}else{let c=this.canvas;c&&c.parentNode.removeChild(c),c=document.createElement("canvas"),c.id=a,this._pInst._userNode?this._pInst._userNode.appendChild(c):document.body.appendChild(c),this._pInst.canvas=c,this.canvas=c,this.canvas.style.position=u.position,this.canvas.style.top=u.top,this.canvas.style.left=u.left}const l=new Kt(this._pInst,s,i,!o,this._pInst.canvas);this._pInst._renderer=l,l._applyDefaults(),typeof n=="function"&&setTimeout(()=>{n.apply(window._renderer,t)},0)}_update(){this.states.setValue("uModelMatrix",this.states.uModelMatrix.clone()),this.states.uModelMatrix.reset(),this.states.setValue("uViewMatrix",this.states.uViewMatrix.clone()),this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix),this.states.setValue("ambientLightColors",[]),this.states.setValue("specularColors",[1,1,1]),this.states.setValue("directionalLightDirections",[]),this.states.setValue("directionalLightDiffuseColors",[]),this.states.setValue("directionalLightSpecularColors",[]),this.states.setValue("pointLightPositions",[]),this.states.setValue("pointLightDiffuseColors",[]),this.states.setValue("pointLightSpecularColors",[]),this.states.setValue("spotLightPositions",[]),this.states.setValue("spotLightDirections",[]),this.states.setValue("spotLightDiffuseColors",[]),this.states.setValue("spotLightSpecularColors",[]),this.states.setValue("spotLightAngle",[]),this.states.setValue("spotLightConc",[]),this.states.setValue("enableLighting",!1),this.states.setValue("tint",[255,255,255,255]),this.GL.clearStencil(0),this.GL.clear(this.GL.DEPTH_BUFFER_BIT|this.GL.STENCIL_BUFFER_BIT),this._userEnabledStencil||this._internalDisable.call(this.GL,this.GL.STENCIL_TEST)}background(...t){const n=this._pInst.color(...t);this.clear(...n._getRGBA())}get uModelMatrix(){return this.states.uModelMatrix}get uViewMatrix(){return this.states.uViewMatrix}get uPMatrix(){return this.states.uPMatrix}get uMVMatrix(){const t=this.uModelMatrix.copy();return t.mult(this.uViewMatrix),t}getWorldToScreenMatrix(){const t=this.states.uModelMatrix,n=this.states.uViewMatrix,s=this.states.uPMatrix,i=new qn(4);return i.scale(this.width,this.height,1),i.translate([.5,.5,.5]),i.scale(.5,-.5,.5),t.copy().mult(n).mult(s).mult(i)}fill(...t){super.fill(...t);const n=this.states.fillColor;this.states.setValue("curFillColor",n._array),this.states.setValue("drawMode",Pw),this.states.setValue("_useNormalMaterial",!1),this.states.setValue("_tex",null)}stroke(...t){super.stroke(...t),this.states.setValue("curStrokeColor",this.states.strokeColor._array)}getCommonVertexProperties(){return{...super.getCommonVertexProperties(),stroke:this.states.strokeColor,fill:this.states.fillColor,normal:this.states._currentNormal}}getSupportedIndividualVertexProperties(){return{textureCoordinates:!0}}strokeCap(t){this.curStrokeCap=t}strokeJoin(t){this.curStrokeJoin=t}getFilterLayer(){return this.filterLayer||(this.filterLayer=new yo(this)),this.filterLayer}getFilterLayerTemp(){return this.filterLayerTemp||(this.filterLayerTemp=new yo(this)),this.filterLayerTemp}matchSize(t,n){(t.width!==n.width||t.height!==n.height)&&t.resize(n.width,n.height),t.pixelDensity()!==n.pixelDensity()&&t.pixelDensity(n.pixelDensity())}filter(...t){let n=this.getFilterLayer(),s,i;typeof t[0]=="string"?(i=t[0],s=i in jw&&t[1]===void 0?jw[i]:t[1],i in this.defaultFilterShaders||(this.defaultFilterShaders[i]=new Ns(n.renderer,M6,ioe[i])),this.states.setValue("filterShader",this.defaultFilterShaders[i])):this.states.setValue("filterShader",t[0]);const a=this.activeFramebuffer()||this;this.matchSize(n,a),n.draw(()=>this.clear());let o=[1/(a.width*a.pixelDensity()),1/(a.height*a.pixelDensity())];if(i===Sm){const u=this.getFilterLayerTemp();this.matchSize(u,a),this.push(),this.states.setValue("strokeColor",null),this.blendMode(Si),this.shader(this.states.filterShader),this.states.filterShader.setUniform("texelSize",o),this.states.filterShader.setUniform("canvasSize",[a.width,a.height]),this.states.filterShader.setUniform("radius",Math.max(1,s)),u.draw(()=>{this.states.filterShader.setUniform("direction",[1,0]),this.states.filterShader.setUniform("tex0",a),this.clear(),this.shader(this.states.filterShader),this.noLights(),this.plane(a.width,a.height)}),n.draw(()=>{this.states.filterShader.setUniform("direction",[0,1]),this.states.filterShader.setUniform("tex0",u),this.clear(),this.shader(this.states.filterShader),this.noLights(),this.plane(a.width,a.height)}),this.pop()}else n.draw(()=>{this.states.setValue("strokeColor",null),this.blendMode(Si),this.shader(this.states.filterShader),this.states.filterShader.setUniform("tex0",a),this.states.filterShader.setUniform("texelSize",o),this.states.filterShader.setUniform("canvasSize",[a.width,a.height]),this.states.filterShader.setUniform("filterParameter",s),this.noLights(),this.plane(a.width,a.height)});this.push(),this.states.setValue("strokeColor",null),this.clear(),this.push(),this.states.setValue("imageMode",xa),this.blendMode(Si),a.filterCamera._resize(),this.setCamera(a.filterCamera),this.resetMatrix(),this._drawingFilter=!0,this.image(n,0,0,this.width,this.height,-a.width/2,-a.height/2,a.width,a.height),this._drawingFilter=!1,this.clearDepth(),this.pop(),this.pop()}pixelDensity(t){return t?this._pInst.pixelDensity(t):this._pInst.pixelDensity()}blendMode(t){t===ES||t===IS||t===ob||t===Si||t===kS||t===AS||t===NS||t===DS||t===TS||t===Uh?this.states.setValue("curBlendMode",t):(t===bT||t===fT||t===mT||t===gT||t===yT)&&console.warn("BURN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, and DODGE only work for blendMode in 2D mode.")}erase(t,n){this._isErasing||(this.preEraseBlend=this.states.curBlendMode,this._isErasing=!0,this.blendMode(Uh),this._cachedFillStyle=this.states.curFillColor.slice(),this.states.setValue("curFillColor",[1,1,1,t/255]),this._cachedStrokeStyle=this.states.curStrokeColor.slice(),this.states.setValue("curStrokeColor",[1,1,1,n/255]))}noErase(){this._isErasing&&(this.states.setValue("curFillColor",this._cachedFillStyle.slice()),this.states.setValue("curStrokeColor",this._cachedStrokeStyle.slice()),this.states.setValue("curBlendMode",this.preEraseBlend),this.blendMode(this.preEraseBlend),this._isErasing=!1,this._applyBlendMode())}drawTarget(){return this.activeFramebuffers[this.activeFramebuffers.length-1]||this}beginClip(t={}){super.beginClip(t),this.drawTarget()._isClipApplied=!0;const n=this.GL;n.clearStencil(0),n.clear(n.STENCIL_BUFFER_BIT),this._internalEnable.call(n,n.STENCIL_TEST),this._stencilTestOn=!0,n.stencilFunc(n.ALWAYS,1,255),n.stencilOp(n.KEEP,n.KEEP,n.REPLACE),n.disable(n.DEPTH_TEST),this.push(),this.resetShader(),this.states.fillColor&&this.fill(0,0),this.states.strokeColor&&this.stroke(0,0)}endClip(){this.pop();const t=this.GL;t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.stencilFunc(this._clipInvert?t.EQUAL:t.NOTEQUAL,0,255),t.enable(t.DEPTH_TEST),this._clipDepths.push(this._pushPopDepth),super.endClip()}_clearClip(){this.GL.clearStencil(1),this.GL.clear(this.GL.STENCIL_BUFFER_BIT),this._clipDepths.length>0&&this._clipDepths.pop(),this.drawTarget()._isClipApplied=!1}_getPixel(t,n){const s=this.GL;return V6(s,null,t,n,s.RGBA,s.UNSIGNED_BYTE,this._pInst.height*this._pInst.pixelDensity())}loadPixels(){if(this._pInst._glAttributes.preserveDrawingBuffer!==!0){console.log("loadPixels only works in WebGL when preserveDrawingBuffer is true.");return}const t=this._pixelDensity,n=this.GL;this.pixels=YI(this.pixels,n,null,0,0,this.width*t,this.height*t,n.RGBA,n.UNSIGNED_BYTE,this.height*t)}updatePixels(){const t=this._getTempFramebuffer();t.pixels=this.pixels,t.updatePixels(),this.push(),this.resetMatrix(),this.clear(),this.states.setValue("imageMode",xa),this.image(t,0,0,t.width,t.height,-t.width/2,-t.height/2,t.width,t.height),this.pop(),this.GL.clearDepth(1),this.GL.clear(this.GL.DEPTH_BUFFER_BIT)}_getTempFramebuffer(){return this._tempFramebuffer||(this._tempFramebuffer=new yo(this,{format:Bl,useDepth:this._pInst._glAttributes.depth,depthFormat:Wy,antialias:this._pInst._glAttributes.antialias})),this._tempFramebuffer}geometryInHash(t){return this.geometryBufferCache.isCached(t)}viewport(t,n){this._viewport=[0,0,t,n],this.GL.viewport(0,0,t,n)}resize(t,n){super.resize(t,n);const s={};for(const a in this.drawingContext){const o=this.drawingContext[a];typeof o!="object"&&typeof o!="function"&&(s[a]=o)}const i=this._adjustDimensions(t,n);t=i.adjustedWidth,n=i.adjustedHeight,this.width=t,this.height=n,this.canvas.width=t*this._pixelDensity,this.canvas.height=n*this._pixelDensity,this.canvas.style.width=`${t}px`,this.canvas.style.height=`${n}px`,this._origViewport={width:this.GL.drawingBufferWidth,height:this.GL.drawingBufferHeight},this.viewport(this._origViewport.width,this._origViewport.height),this.states.curCamera._resize(),typeof this.pixels<"u"&&(this.pixels=new Uint8Array(this.GL.drawingBufferWidth*this.GL.drawingBufferHeight*4));for(const a of this.framebuffers)a._canvasSizeChanged();for(const a in s)try{this.drawingContext[a]=s[a]}catch{}}clear(...t){const n=t[0]||0,s=t[1]||0,i=t[2]||0;let a=t[3]||0;const o=this.activeFramebuffer();o&&o.format===Bl&&!o.antialias&&a===0&&(a=1e-10),this.GL.clearColor(n*a,s*a,i*a,a),this.GL.clearDepth(1),this.GL.clear(this.GL.COLOR_BUFFER_BIT|this.GL.DEPTH_BUFFER_BIT)}clearDepth(t=1){this.GL.clearDepth(t),this.GL.clear(this.GL.DEPTH_BUFFER_BIT)}applyMatrix(t,n,s,i,a,o){this.states.setValue("uModelMatrix",this.states.uModelMatrix.clone()),arguments.length===16?qn.prototype.apply.apply(this.states.uModelMatrix,arguments):this.states.uModelMatrix.apply([t,n,0,0,s,i,0,0,0,0,1,0,a,o,0,1])}translate(t,n,s){return t instanceof De&&(s=t.z,n=t.y,t=t.x),this.states.setValue("uModelMatrix",this.states.uModelMatrix.clone()),this.states.uModelMatrix.translate([t,n,s]),this}scale(t,n,s){return this.states.setValue("uModelMatrix",this.states.uModelMatrix.clone()),this.states.uModelMatrix.scale(t,n,s),this}rotate(t,n){return typeof n>"u"?this.rotateZ(t):(this.states.setValue("uModelMatrix",this.states.uModelMatrix.clone()),qn.prototype.rotate4x4.apply(this.states.uModelMatrix,arguments),this)}rotateX(t){return this.rotate(t,1,0,0),this}rotateY(t){return this.rotate(t,0,1,0),this}rotateZ(t){return this.rotate(t,0,0,1),this}pop(...t){this._clipDepths.length>0&&this._pushPopDepth===this._clipDepths[this._clipDepths.length-1]&&(this._clearClip(),this._userEnabledStencil||this._internalDisable.call(this.GL,this.GL.STENCIL_TEST)),super.pop(...t),this._applyStencilTestIfClipping()}_applyStencilTestIfClipping(){const t=this.drawTarget();t._isClipApplied!==this._stencilTestOn&&(t._isClipApplied?(this._internalEnable.call(this.GL,this.GL.STENCIL_TEST),this._stencilTestOn=!0):(this._userEnabledStencil||this._internalDisable.call(this.GL,this.GL.STENCIL_TEST),this._stencilTestOn=!1))}resetMatrix(){return this.states.setValue("uModelMatrix",this.states.uModelMatrix.clone()),this.states.uModelMatrix.reset(),this.states.setValue("uViewMatrix",this.states.uViewMatrix.clone()),this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix),this}_getStrokeShader(){const t=this.states.userStrokeShader;return t||this._getLineShader()}_getSphereMapping(t){return this.sphereMapping||(this.sphereMapping=this._pInst.createFilterShader(soe)),this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix),this.scratchMat3.invert(this.scratchMat3),this.sphereMapping.setUniform("uFovY",this.states.curCamera.cameraFOV),this.sphereMapping.setUniform("uAspect",this.states.curCamera.aspectRatio),this.sphereMapping.setUniform("uNewNormalMatrix",this.scratchMat3.mat3),this.sphereMapping.setUniform("uEnvMap",t),this.sphereMapping}_getFillShader(){return this._drawingImage?this.states.userImageShader&&!this._drawingFilter?this.states.userImageShader:this._getLightShader():this.states.userFillShader?this.states.userFillShader:this.states._useNormalMaterial?this._getNormalShader():this.states.enableLighting||this.states._tex?this._getLightShader():this._getColorShader()}_getPointShader(){const t=this.states.userPointShader;return!t||!t.isPointShader()?this._getPointShader():t}baseMaterialShader(){if(!this._pInst._glAttributes.perPixelLighting)throw new Error("The material shader does not support hooks without perPixelLighting. Try turning it back on.");return this._getLightShader()}_getLightShader(){return this._defaultLightShader||(this._pInst._glAttributes.perPixelLighting?this._defaultLightShader=new Ns(this,this._webGL2CompatibilityPrefix("vert","highp")+Dn.phongVert,this._webGL2CompatibilityPrefix("frag","highp")+Dn.phongFrag,{vertex:{"void beforeVertex":"() {}","Vertex getObjectInputs":"(Vertex inputs) { return inputs; }","Vertex getWorldInputs":"(Vertex inputs) { return inputs; }","Vertex getCameraInputs":"(Vertex inputs) { return inputs; }","void afterVertex":"() {}"},fragment:{"void beforeFragment":"() {}","Inputs getPixelInputs":"(Inputs inputs) { return inputs; }","vec4 combineColors":`(ColorComponents components) {
                vec4 color = vec4(0.);
                color.rgb += components.diffuse * components.baseColor;
                color.rgb += components.ambient * components.ambientColor;
                color.rgb += components.specular * components.specularColor;
                color.rgb += components.emissive;
                color.a = components.opacity;
                return color;
              }`,"vec4 getFinalColor":"(vec4 color) { return color; }","void afterFragment":"() {}"}}):this._defaultLightShader=new Ns(this,this._webGL2CompatibilityPrefix("vert","highp")+Dn.lightVert,this._webGL2CompatibilityPrefix("frag","highp")+Dn.lightTextureFrag)),this._defaultLightShader}baseNormalShader(){return this._getNormalShader()}_getNormalShader(){return this._defaultNormalShader||(this._defaultNormalShader=new Ns(this,this._webGL2CompatibilityPrefix("vert","mediump")+Dn.normalVert,this._webGL2CompatibilityPrefix("frag","mediump")+Dn.normalFrag,{vertex:{"void beforeVertex":"() {}","Vertex getObjectInputs":"(Vertex inputs) { return inputs; }","Vertex getWorldInputs":"(Vertex inputs) { return inputs; }","Vertex getCameraInputs":"(Vertex inputs) { return inputs; }","void afterVertex":"() {}"},fragment:{"void beforeFragment":"() {}","vec4 getFinalColor":"(vec4 color) { return color; }","void afterFragment":"() {}"}})),this._defaultNormalShader}baseColorShader(){return this._getColorShader()}_getColorShader(){return this._defaultColorShader||(this._defaultColorShader=new Ns(this,this._webGL2CompatibilityPrefix("vert","mediump")+Dn.normalVert,this._webGL2CompatibilityPrefix("frag","mediump")+Dn.basicFrag,{vertex:{"void beforeVertex":"() {}","Vertex getObjectInputs":"(Vertex inputs) { return inputs; }","Vertex getWorldInputs":"(Vertex inputs) { return inputs; }","Vertex getCameraInputs":"(Vertex inputs) { return inputs; }","void afterVertex":"() {}"},fragment:{"void beforeFragment":"() {}","vec4 getFinalColor":"(vec4 color) { return color; }","void afterFragment":"() {}"}})),this._defaultColorShader}pointShader(){return this._getPointShader()}_getPointShader(){return this._defaultPointShader||(this._defaultPointShader=new Ns(this,this._webGL2CompatibilityPrefix("vert","mediump")+Dn.pointVert,this._webGL2CompatibilityPrefix("frag","mediump")+Dn.pointFrag,{vertex:{"void beforeVertex":"() {}","vec3 getLocalPosition":"(vec3 position) { return position; }","vec3 getWorldPosition":"(vec3 position) { return position; }","float getPointSize":"(float size) { return size; }","void afterVertex":"() {}"},fragment:{"void beforeFragment":"() {}","vec4 getFinalColor":"(vec4 color) { return color; }","bool shouldDiscard":"(bool outside) { return outside; }","void afterFragment":"() {}"}})),this._defaultPointShader}baseStrokeShader(){return this._getLineShader()}_getLineShader(){return this._defaultLineShader||(this._defaultLineShader=new Ns(this,this._webGL2CompatibilityPrefix("vert","mediump")+Dn.lineVert,this._webGL2CompatibilityPrefix("frag","mediump")+Dn.lineFrag,{vertex:{"void beforeVertex":"() {}","StrokeVertex getObjectInputs":"(StrokeVertex inputs) { return inputs; }","StrokeVertex getWorldInputs":"(StrokeVertex inputs) { return inputs; }","StrokeVertex getCameraInputs":"(StrokeVertex inputs) { return inputs; }","void afterVertex":"() {}"},fragment:{"void beforeFragment":"() {}","Inputs getPixelInputs":"(Inputs inputs) { return inputs; }","vec4 getFinalColor":"(vec4 color) { return color; }","bool shouldDiscard":"(bool outside) { return outside; }","void afterFragment":"() {}"}})),this._defaultLineShader}_getFontShader(){return this._defaultFontShader||(this.webglVersion===ic&&this.GL.getExtension("OES_standard_derivatives"),this._defaultFontShader=new Ns(this,this._webGL2CompatibilityPrefix("vert","highp")+Dn.fontVert,this._webGL2CompatibilityPrefix("frag","highp")+Dn.fontFrag)),this._defaultFontShader}baseFilterShader(){return this._baseFilterShader||(this._baseFilterShader=new Ns(this,this._webGL2CompatibilityPrefix("vert","highp")+Dn.filterBaseVert,this._webGL2CompatibilityPrefix("frag","highp")+Dn.filterBaseFrag,{vertex:{},fragment:{"vec4 getColor":`(FilterInputs inputs, in sampler2D canvasContent) {
                return getTexture(canvasContent, inputs.texCoord);
              }`}})),this._baseFilterShader}_webGL2CompatibilityPrefix(t,n){let s="";return this.webglVersion===ts&&(s+=`#version 300 es
#define WEBGL2
`),t==="vert"?s+=`#define VERTEX_SHADER
`:t==="frag"&&(s+=`#define FRAGMENT_SHADER
`),n&&(s+=`precision ${n} float;
`),s}_getEmptyTexture(){if(!this._emptyTexture){const t=new Do(1,1);t.set(0,0,255),this._emptyTexture=new nl(this,t)}return this._emptyTexture}getTexture(t){let n=t;n instanceof yo&&(n=n.color);const s=this.textures.get(n);if(s)return s;const i=new nl(this,n);return this.textures.set(n,i),i}getDiffusedTexture(t){if(this.diffusedTextures.get(t)!=null)return this.diffusedTextures.get(t);let n,s=200,i=s,a=Math.floor(s*(t.height/t.width));return n=new yo(this,{width:i,height:a,density:1}),this.diffusedShader||(this.diffusedShader=this._pInst.createShader(Dn.imageLightVert,Dn.imageLightDiffusedFrag)),n.draw(()=>{this.shader(this.diffusedShader),this.diffusedShader.setUniform("environmentMap",t),this.states.setValue("strokeColor",null),this.noLights(),this.plane(i,a)}),this.diffusedTextures.set(t,n),n}getSpecularTexture(t){if(this.specularTextures.get(t)!=null)return this.specularTextures.get(t);const n=512;let s;const i=[],a=new yo(this,{width:n,height:n,density:1});let o=Math.log(n)/Math.log(2);this.specularShader||(this.specularShader=this._pInst.createShader(Dn.imageLightVert,Dn.imageLightSpecularFrag));for(let u=n;u>=1;u/=2){a.resize(u,u);let c=1-Math.log(u)/Math.log(2)/o;a.draw(()=>{this.shader(this.specularShader),this.clear(),this.specularShader.setUniform("environmentMap",t),this.specularShader.setUniform("roughness",c),this.states.setValue("strokeColor",null),this.noLights(),this.plane(u,u)}),i.push(a.get().drawingContext.getImageData(0,0,u,u))}return a.remove(),s=new U6(this,i,{}),this.specularTextures.set(t,s),s}activeFramebuffer(){return this.activeFramebuffers[this.activeFramebuffers.length-1]||null}createFramebuffer(t){return new yo(this,t)}_setGlobalUniforms(t){const n=this.states.uModelMatrix,s=this.states.uViewMatrix,i=this.states.uPMatrix,a=n.copy().mult(s);if(t.setUniform("uPerspective",this.states.curCamera.useLinePerspective?1:0),t.setUniform("uViewMatrix",s.mat4),t.setUniform("uProjectionMatrix",i.mat4),t.setUniform("uModelMatrix",n.mat4),t.setUniform("uModelViewMatrix",a.mat4),t.uniforms.uModelViewProjectionMatrix){const o=a.copy();o.mult(i),t.setUniform("uModelViewProjectionMatrix",o.mat4)}t.uniforms.uNormalMatrix&&(this.scratchMat3.inverseTranspose4x4(a),t.setUniform("uNormalMatrix",this.scratchMat3.mat3)),t.uniforms.uModelNormalMatrix&&(this.scratchMat3.inverseTranspose4x4(this.states.uModelMatrix),t.setUniform("uModelNormalMatrix",this.scratchMat3.mat3)),t.uniforms.uCameraNormalMatrix&&(this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix),t.setUniform("uCameraNormalMatrix",this.scratchMat3.mat3)),t.uniforms.uCameraRotation&&(this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix),t.setUniform("uCameraRotation",this.scratchMat3.mat3)),t.setUniform("uViewport",this._viewport)}_setStrokeUniforms(t){t.setUniform("uSimpleLines",this._simpleLines),t.setUniform("uUseLineColor",this._useLineColor),t.setUniform("uMaterialColor",this.states.curStrokeColor),t.setUniform("uStrokeWeight",this.states.strokeWeight),t.setUniform("uStrokeCap",L6[this.curStrokeCap]),t.setUniform("uStrokeJoin",P6[this.curStrokeJoin])}_setFillUniforms(t){this.mixedSpecularColor=[...this.states.curSpecularColor];const n=this._getEmptyTexture();this.states._useMetalness>0&&(this.mixedSpecularColor=this.mixedSpecularColor.map((u,l)=>this.states.curFillColor[l]*this.states._useMetalness+u*(1-this.states._useMetalness))),t.setUniform("uUseVertexColor",this._useVertexColor),t.setUniform("uMaterialColor",this.states.curFillColor),t.setUniform("isTexture",!!this.states._tex),t.setUniform("uSampler",this.states._tex||n),t.setUniform("uTint",this.states.tint),t.setUniform("uHasSetAmbient",this.states._hasSetAmbient),t.setUniform("uAmbientMatColor",this.states.curAmbientColor),t.setUniform("uSpecularMatColor",this.mixedSpecularColor),t.setUniform("uEmissiveMatColor",this.states.curEmissiveColor),t.setUniform("uSpecular",this.states._useSpecularMaterial),t.setUniform("uEmissive",this.states._useEmissiveMaterial),t.setUniform("uShininess",this.states._useShininess),t.setUniform("uMetallic",this.states._useMetalness),this._setImageLightUniforms(t),t.setUniform("uUseLighting",this.states.enableLighting);const s=this.states.pointLightDiffuseColors.length/3;t.setUniform("uPointLightCount",s),t.setUniform("uPointLightLocation",this.states.pointLightPositions),t.setUniform("uPointLightDiffuseColors",this.states.pointLightDiffuseColors),t.setUniform("uPointLightSpecularColors",this.states.pointLightSpecularColors);const i=this.states.directionalLightDiffuseColors.length/3;t.setUniform("uDirectionalLightCount",i),t.setUniform("uLightingDirection",this.states.directionalLightDirections),t.setUniform("uDirectionalDiffuseColors",this.states.directionalLightDiffuseColors),t.setUniform("uDirectionalSpecularColors",this.states.directionalLightSpecularColors);const a=this.states.ambientLightColors.length/3;this.mixedAmbientLight=[...this.states.ambientLightColors],this.states._useMetalness>0&&(this.mixedAmbientLight=this.mixedAmbientLight.map(u=>{let l=u-this.states._useMetalness;return Math.max(0,l)})),t.setUniform("uAmbientLightCount",a),t.setUniform("uAmbientColor",this.mixedAmbientLight);const o=this.states.spotLightDiffuseColors.length/3;t.setUniform("uSpotLightCount",o),t.setUniform("uSpotLightAngle",this.states.spotLightAngle),t.setUniform("uSpotLightConc",this.states.spotLightConc),t.setUniform("uSpotLightDiffuseColors",this.states.spotLightDiffuseColors),t.setUniform("uSpotLightSpecularColors",this.states.spotLightSpecularColors),t.setUniform("uSpotLightLocation",this.states.spotLightPositions),t.setUniform("uSpotLightDirection",this.states.spotLightDirections),t.setUniform("uConstantAttenuation",this.states.constantAttenuation),t.setUniform("uLinearAttenuation",this.states.linearAttenuation),t.setUniform("uQuadraticAttenuation",this.states.quadraticAttenuation)}_setImageLightUniforms(t){if(t.setUniform("uUseImageLight",this.states.activeImageLight!=null),this.states.activeImageLight){let n=this.getDiffusedTexture(this.states.activeImageLight);t.setUniform("environmentMapDiffused",n);let s=this.getSpecularTexture(this.states.activeImageLight);t.setUniform("environmentMapSpecular",s)}}_setPointUniforms(t){t.setUniform("uMaterialColor",this.states.curStrokeColor),t.setUniform("uPointSize",this.states.strokeWeight*this._pixelDensity)}_bindBuffer(t,n,s,i,a){if(n||(n=this.GL.ARRAY_BUFFER),this.GL.bindBuffer(n,t),s!==void 0){let o=s;s instanceof bh?o=s.dataArray():o instanceof(i||Float32Array)||(o=new(i||Float32Array)(o)),this.GL.bufferData(n,o,a||this.GL.STATIC_DRAW)}}_arraysEqual(t,n){return t.length!==n.length?!1:t.every((i,a)=>i===n[a])}_isTypedArray(t){return[Float32Array,Float64Array,Int16Array,Uint16Array,Uint32Array].some(n=>t instanceof n)}_vToNArray(t){return t.flatMap(n=>[n.x,n.y,n.z])}}function B6(r,t){r.RendererGL=Kt,t.setAttributes=function(n,s){if(typeof this._glAttributes>"u"){console.log("You are trying to use setAttributes on a p5.Graphics object that does not use a WEBGL renderer.");return}let i=!0;if(typeof s<"u"?(this._glAttributes===null&&(this._glAttributes={}),this._glAttributes[n]!==s&&(this._glAttributes[n]=s,i=!1)):n instanceof Object&&this._glAttributes!==n&&(this._glAttributes=n,i=!1),!(!this._renderer.isP3D||i)){if(!this._setupDone&&this._renderer.geometryBufferCache.numCached()>0){r._friendlyError("Sorry, Could not set the attributes, you need to call setAttributes() before calling the other drawing methods in setup()");return}this._renderer._resetContext(),this._renderer.states.curCamera&&(this._renderer.states.curCamera._renderer=this._renderer)}},t._assert3d=function(n){if(!this._renderer.isP3D)throw new Error(`${n}() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information.`)},r.renderers[ic]=r.RendererGL,r.renderers[ts]=r.RendererGL}function YI(r,t,n,s,i,a,o,u,l,c){const h=t.getParameter(t.FRAMEBUFFER_BINDING);t.bindFramebuffer(t.FRAMEBUFFER,n);const d=u===t.RGBA?4:3,p=a*o*d,f=l===t.UNSIGNED_BYTE?Uint8Array:Float32Array;if((!(r instanceof f)||r.length!==p)&&(r=new f(p)),t.readPixels(s,c?c-i-o:i,a,o,u,l,r),t.bindFramebuffer(t.FRAMEBUFFER,h),c){const m=Math.floor(o/2),g=new f(a*d);for(let y=0;y<m;y++){const b=y*a*4,x=(o-y-1)*a*4;g.set(r.subarray(b,b+a*4)),r.copyWithin(b,x,x+a*4),r.set(g,x)}}return r}function V6(r,t,n,s,i,a,o){const u=r.getParameter(r.FRAMEBUFFER_BINDING);r.bindFramebuffer(r.FRAMEBUFFER,t);const l=i===r.RGBA?4:3,c=a===r.UNSIGNED_BYTE?Uint8Array:Float32Array,h=new c(l);return r.readPixels(n,o?o-s-1:s,1,1,i,a,h),r.bindFramebuffer(r.FRAMEBUFFER,u),Array.from(h)}typeof p5<"u"&&B6(p5,p5.prototype);function jT(r,t){t.strokeMode=function(s){if(s===void 0)return this._renderer._simpleLines?AI:DI;if(s===AI)this._renderer._simpleLines=!0;else if(s===DI)this._renderer._simpleLines=!1;else throw Error("no such parameter")},t.buildGeometry=function(s){return this._renderer.buildGeometry(s)},t.freeGeometry=function(s){this._renderer.geometryBufferCache.freeBuffers(s.gid)},t.plane=function(s=50,i=s,a=1,o=1){return this._assert3d("plane"),this._renderer.plane(s,i,a,o),this},t.box=function(s,i,a,o,u){return this._assert3d("box"),this._renderer.box(s,i,a,o,u),this},t.sphere=function(s=50,i=24,a=16){return this._assert3d("sphere"),this._renderer.sphere(s,i,a),this},t.cylinder=function(s=50,i=s,a=24,o=1,u=!0,l=!0){return this._assert3d("cylinder"),this._renderer.cylinder(s,i,a,o,u,l),this},t.cone=function(s=50,i=s,a=24,o=1,u=!0){return this._assert3d("cone"),this._renderer.cone(s,i,a,o,u),this},t.ellipsoid=function(s=50,i=s,a=s,o=24,u=16){return this._assert3d("ellipsoid"),this._renderer.ellipsoid(s,i,a,o,u),this},t.torus=function(s,i,a,o){return this._assert3d("torus"),this._renderer.torus(s,i,a,o),this},Kt.prototype.point=function(s,i,a=0){const o=[];return o.push(new De(s,i,a)),this._drawPoints(o,this.buffers.point),this},Kt.prototype.triangle=function(s){const i=s[0],a=s[1],o=s[2],u=s[3],l=s[4],c=s[5],h="tri";if(!this.geometryInHash(h)){const p=function(){const m=[];m.push(new De(0,0,0)),m.push(new De(1,0,0)),m.push(new De(0,1,0)),this.edges=[[0,1],[1,2],[2,0]],this.vertices=m,this.faces=[[0,1,2]],this.uvs=[0,0,1,0,1,1]},f=new ks(1,1,p,this);f._edgesToVertices(),f.computeNormals(),f.gid=h,this.geometryBufferCache.ensureCached(f)}const d=this.states.uModelMatrix.copy();try{const p=Math.sign(i*u-o*a+o*c-l*u+l*a-i*c),f=new qn([o-i,u-a,0,0,l-i,c-a,0,0,0,0,p,0,i,a,0,1]).mult(this.states.uModelMatrix);this.states.setValue("uModelMatrix",f),this._drawGeometry(this.geometryBufferCache.getGeometryByID(h))}finally{this.states.setValue("uModelMatrix",d)}return this},Kt.prototype.ellipse=function(s){this.arc(s[0],s[1],s[2],s[3],0,bi,zh,s[4])},Kt.prototype.arc=function(...s){const i=s[0],a=s[1],o=s[2],u=s[3],l=s[4],c=s[5],h=s[6],d=s[7]||25;let p,f;if(Math.abs(c-l)>=bi?(p="ellipse",f=`${p}|${d}|`):(p="arc",f=`${p}|${l}|${c}|${h}|${d}|`),!this.geometryInHash(f)){const g=function(){if(l.toFixed(10)!==c.toFixed(10)){(h===ab||typeof h>"u")&&(this.vertices.push(new De(.5,.5,0)),this.uvs.push([.5,.5]));for(let b=0;b<=d;b++){const x=b/d,w=(c-l)*x+l,v=.5+Math.cos(w)/2,S=.5+Math.sin(w)/2;this.vertices.push(new De(v,S,0)),this.uvs.push([v,S]),b<d-1&&(this.faces.push([0,b+1,b+2]),this.edges.push([b+1,b+2]))}switch(h){case ab:this.faces.push([0,this.vertices.length-2,this.vertices.length-1]),this.edges.push([0,1]),this.edges.push([this.vertices.length-2,this.vertices.length-1]),this.edges.push([0,this.vertices.length-1]);break;case Lw:this.edges.push([0,1]),this.edges.push([0,this.vertices.length-1]);break;case zh:this.edges.push([0,1]);break;default:this.faces.push([0,this.vertices.length-2,this.vertices.length-1]),this.edges.push([this.vertices.length-2,this.vertices.length-1])}}},y=new ks(d,1,g,this);y.computeNormals(),d<=50?y._edgesToVertices(y):this.states.strokeColor&&console.log(`Cannot apply a stroke to an ${p} with more than 50 detail`),y.gid=f,this.geometryBufferCache.ensureCached(y)}const m=this.states.uModelMatrix;this.states.setValue("uModelMatrix",this.states.uModelMatrix.clone());try{this.states.uModelMatrix.translate([i,a,0]),this.states.uModelMatrix.scale(o,u,1),this._drawGeometry(this.geometryBufferCache.getGeometryByID(f))}finally{this.states.setValue("uModelMatrix",m)}return this},Kt.prototype.rect=function(s){const i=s[0],a=s[1],o=s[2],u=s[3];if(typeof s[4]>"u"){const l=this._pInst._glAttributes.perPixelLighting,c=s[4]||(l?1:24),h=s[5]||(l?1:16),d=`rect|${c}|${h}`;if(!this.geometryInHash(d)){const f=function(){for(let g=0;g<=this.detailY;g++){const y=g/this.detailY;for(let b=0;b<=this.detailX;b++){const x=b/this.detailX,w=new De(x,y,0);this.vertices.push(w),this.uvs.push(x,y)}}c>0&&h>0&&(this.edges=[[0,c],[c,(c+1)*(h+1)-1],[(c+1)*(h+1)-1,(c+1)*h],[(c+1)*h,0]])},m=new ks(c,h,f,this);m.computeFaces().computeNormals()._edgesToVertices(),m.gid=d,this.geometryBufferCache.ensureCached(m)}const p=this.states.uModelMatrix;this.states.setValue("uModelMatrix",this.states.uModelMatrix.copy());try{this.states.uModelMatrix.translate([i,a,0]),this.states.uModelMatrix.scale(o,u,1),this._drawGeometry(this.geometryBufferCache.getGeometryByID(d))}finally{this.states.setValue("uModelMatrix",p)}}else{let l=s[4],c=typeof s[5]>"u"?l:s[5],h=typeof s[6]>"u"?c:s[6],d=typeof s[7]>"u"?h:s[7],p=i,f=a,m=o,g=u;if(m+=p,g+=f,p>m){const I=p;p=m,m=I}if(f>g){const I=f;f=g,g=I}const y=Math.min((m-p)/2,(g-f)/2);l>y&&(l=y),c>y&&(c=y),h>y&&(h=y),d>y&&(d=y);let b=p,x=f,w=m,v=g;const S=this.states.textureMode;this.states.setValue("textureMode",eu);const E=this.bezierOrder();this.bezierOrder(2),this.beginShape();const C=(I,_)=>[I,_,(I-b)/o,(_-x)/u];c!==0?(this.vertex(...C(w-c,x)),this.bezierVertex(...C(w,x)),this.bezierVertex(...C(w,x+c))):this.vertex(...C(w,x)),h!==0?(this.vertex(...C(w,v-h)),this.bezierVertex(...C(w,v)),this.bezierVertex(...C(w-h,v))):this.vertex(...C(w,v)),d!==0?(this.vertex(...C(b+d,v)),this.bezierVertex(...C(b,v)),this.bezierVertex(...C(b,v-d))):this.vertex(...C(b,v)),l!==0?(this.vertex(...C(b,x+l)),this.bezierVertex(...C(b,x)),this.bezierVertex(...C(b+l,x))):this.vertex(...C(b,x)),this.endShape(ib),this.states.setValue("textureMode",S),this.bezierOrder(E)}return this},Kt.prototype.quad=function(s,i,a,o,u,l,c,h,d,p,f,m,g=2,y=2){const b=`quad|${s}|${i}|${a}|${o}|${u}|${l}|${c}|${h}|${d}|${p}|${f}|${m}|${g}|${y}`;if(!this.geometryInHash(b)){const x=new ks(g,y,function(){let v=1/(this.detailX-1),S=1/(this.detailY-1);for(let E=0;E<this.detailY;E++)for(let C=0;C<this.detailX;C++){let I=C*v,_=E*S,A=(1-_)*s+_*p,k=(1-_)*i+_*f,N=(1-_)*a+_*m,D=(1-_)*o+_*c,F=(1-_)*u+_*h,P=(1-_)*l+_*d,G=(1-I)*A+I*D,Y=(1-I)*k+I*F,Z=(1-I)*N+I*P;this.vertices.push(new De(G,Y,Z)),this.uvs.push([I,_])}},this);x.faces=[];for(let v=0;v<y-1;v++)for(let S=0;S<g-1;S++){let E=S+v*g,C=S+1+v*g,I=S+1+(v+1)*g,_=S+(v+1)*g;x.faces.push([E,C,I]),x.faces.push([E,I,_])}x.computeNormals(),x.edges.length=0;const w=[0,2,3,1];for(let v=0;v<w.length;v++){const S=w[v],E=w[(v+1)%w.length];x.edges.push([S,E])}x._edgesToVertices(),x.gid=b,this.geometryBufferCache.ensureCached(x)}return this._drawGeometry(this.geometryBufferCache.getGeometryByID(b)),this},Kt.prototype.bezier=function(s,i,a,o,u,l,c,h,d,p,f,m){arguments.length===8&&(f=h,p=c,h=l,c=u,u=o,o=a,a=l=d=m=0),this.bezierOrder(),this.bezierOrder(3),this.beginShape(),this.vertex(s,i,a),this.bezierVertex(o,u,l),this.bezierVertex(c,h,d),this.bezierVertex(p,f,m),this.endShape()},Kt.prototype.curve=function(s,i,a,o,u,l,c,h,d,p,f,m){arguments.length===8&&(p=c,f=h,c=u,h=o,o=a,u=o,a=l=d=m=0),this.beginShape(),this.splineVertex(s,i,a),this.splineVertex(o,u,l),this.splineVertex(c,h,d),this.splineVertex(p,f,m),this.endShape()},Kt.prototype.line=function(...s){return s.length===6?(this.beginShape(wm),this.vertex(s[0],s[1],s[2]),this.vertex(s[3],s[4],s[5]),this.endShape()):s.length===4&&(this.beginShape(wm),this.vertex(s[0],s[1],0),this.vertex(s[2],s[3],0),this.endShape()),this},Kt.prototype.image=function(s,i,a,o,u,l,c,h,d){this._isErasing&&this.blendMode(this._cachedBlendMode),this.push(),this.noLights(),this.states.setValue("strokeColor",null),this.texture(s),this.states.setValue("textureMode",eu);let p=0;i<=s.width&&(p=i/s.width);let f=1;i+o<=s.width&&(f=(i+o)/s.width);let m=0;a<=s.height&&(m=a/s.height);let g=1;a+u<=s.height&&(g=(a+u)/s.height),this._drawingImage=!0,this.beginShape(),this.vertex(l,c,0,p,m),this.vertex(l+h,c,0,f,m),this.vertex(l+h,c+d,0,f,g),this.vertex(l,c+d,0,p,g),this.endShape(ib),this._drawingImage=!1,this.pop(),this._isErasing&&this.blendMode(Uh)};const n=function(s,i,a,o,u,l,c){s=s<=0?1:s,i=i<0?0:i,a=a<=0?s:a,o=o<3?3:o,u=u<1?1:u,l=l===void 0?!0:l,c=c===void 0?i!==0:c;const h=l?-2:0,d=u+(c?2:0),p=Math.atan2(s-i,a),f=Math.sin(p),m=Math.cos(p);let g,y,b;for(g=h;g<=d;++g){let w=g/u,v=a*w,S;for(g<0?(v=0,w=0,S=s):g>u?(v=a,w=1,S=i):S=s+(i-s)*w,(g===-2||g===u+2)&&(S=0),v-=a/2,y=0;y<o;++y){const E=y/(o-1),C=2*Math.PI*E,I=Math.sin(C),_=Math.cos(C);this.vertices.push(new De(I*S,v,_*S));let A;g<0?A=new De(0,-1,0):g>u&&i?A=new De(0,1,0):A=new De(I*m,f,_*m),this.vertexNormals.push(A),this.uvs.push(E,w)}}let x=0;if(l){for(b=0;b<o;++b){const w=(b+1)%o;this.faces.push([x+b,x+o+w,x+o+b])}x+=o*2}for(g=0;g<u;++g){for(y=0;y<o;++y){const w=(y+1)%o;this.faces.push([x+y,x+w,x+o+w]),this.faces.push([x+y,x+o+w,x+o+y])}x+=o}if(c)for(x+=o,y=0;y<o;++y)this.faces.push([x+y,x+(y+1)%o,x+o])};Kt.prototype.plane=function(s=50,i=s,a=1,o=1){const u=`plane|${a}|${o}`;if(!this.geometryInHash(u)){const l=function(){let h,d,p;for(let f=0;f<=this.detailY;f++){d=f/this.detailY;for(let m=0;m<=this.detailX;m++)h=m/this.detailX,p=new De(h-.5,d-.5,0),this.vertices.push(p),this.uvs.push(h,d)}},c=new ks(a,o,l,this);c.computeFaces().computeNormals(),a<=1&&o<=1?c._makeTriangleEdges()._edgesToVertices():this.states.strokeColor&&console.log("Cannot draw stroke on plane objects with more than 1 detailX or 1 detailY"),c.gid=u,this.geometryBufferCache.ensureCached(c)}this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(u),s,i,1)},Kt.prototype.box=function(s=50,i=s,a=i,o,u){const l=this.attributes&&this.attributes.perPixelLighting;typeof o>"u"&&(o=l?1:4),typeof u>"u"&&(u=l?1:4);const c=`box|${o}|${u}`;if(!this.geometryInHash(c)){const h=function(){const p=[[0,4,2,6],[1,3,5,7],[0,1,4,5],[2,6,3,7],[0,2,1,3],[4,5,6,7]];this.edges=[[0,1],[1,3],[3,2],[6,7],[8,9],[9,11],[14,15],[16,17],[17,19],[18,19],[20,21],[22,23]],p.forEach((f,m)=>{const g=m*4;for(let y=0;y<4;y++){const b=f[y],x=new De(((b&1)*2-1)/2,((b&2)-1)/2,((b&4)/2-1)/2);this.vertices.push(x),this.uvs.push(y&1,(y&2)/2)}this.faces.push([g,g+1,g+2]),this.faces.push([g+2,g+1,g+3])})},d=new ks(o,u,h,this);d.computeNormals(),o<=4&&u<=4?d._edgesToVertices():this.states.strokeColor&&console.log("Cannot draw stroke on box objects with more than 4 detailX or 4 detailY"),d.gid=c,this.geometryBufferCache.ensureCached(d)}this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(c),s,i,a)},Kt.prototype.sphere=function(s=50,i=24,a=16){this.ellipsoid(s,s,s,i,a)},Kt.prototype.ellipsoid=function(s=50,i=s,a=s,o=24,u=16){const l=`ellipsoid|${o}|${u}`;if(!this.geometryInHash(l)){const c=function(){for(let d=0;d<=this.detailY;d++){const p=d/this.detailY,f=Math.PI*p-Math.PI/2,m=Math.cos(f),g=Math.sin(f);for(let y=0;y<=this.detailX;y++){const b=y/this.detailX,x=2*Math.PI*b,w=Math.cos(x),v=Math.sin(x),S=new r.Vector(m*v,g,m*w);this.vertices.push(S),this.vertexNormals.push(S),this.uvs.push(b,p)}}},h=new ks(o,u,c,this);h.computeFaces(),o<=24&&u<=24?h._makeTriangleEdges()._edgesToVertices():this.states.strokeColor&&console.log("Cannot draw stroke on ellipsoids with more than 24 detailX or 24 detailY"),h.gid=l,this.geometryBufferCache.ensureCached(h)}this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(l),s,i,a)},Kt.prototype.cylinder=function(s=50,i=s,a=24,o=1,u=!0,l=!0){const c=`cylinder|${a}|${o}|${u}|${l}`;if(!this.geometryInHash(c)){const h=new r.Geometry(a,o,function(){n.call(this,1,1,1,a,o,u,l)},this);a<=24&&o<=16?h._makeTriangleEdges()._edgesToVertices():this.states.strokeColor&&console.log("Cannot draw stroke on cylinder objects with more than 24 detailX or 16 detailY"),h.gid=c,this.geometryBufferCache.ensureCached(h)}this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(c),s,i,s)},Kt.prototype.cone=function(s=50,i=s,a=24,o=1,u=!0){const l=`cone|${a}|${o}|${u}`;if(!this.geometryInHash(l)){const c=new ks(a,o,function(){n.call(this,1,0,1,a,o,u,!1)},this);a<=24&&o<=16?c._makeTriangleEdges()._edgesToVertices():this.states.strokeColor&&console.log("Cannot draw stroke on cone objects with more than 24 detailX or 16 detailY"),c.gid=l,this.geometryBufferCache.ensureCached(c)}this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(l),s,i,s)},Kt.prototype.torus=function(s=50,i=10,a=24,o=16){if(s===0||i===0)return;const u=(i/s).toPrecision(4),l=`torus|${u}|${a}|${o}`;if(!this.geometryInHash(l)){const c=function(){for(let d=0;d<=this.detailY;d++){const p=d/this.detailY,f=2*Math.PI*p,m=Math.cos(f),g=Math.sin(f),y=1+u*m;for(let b=0;b<=this.detailX;b++){const x=b/this.detailX,w=2*Math.PI*x,v=Math.cos(w),S=Math.sin(w),E=new De(y*v,y*S,u*g),C=new De(m*v,m*S,g);this.vertices.push(E),this.vertexNormals.push(C),this.uvs.push(x,p)}}},h=new ks(a,o,c,this);h.computeFaces(),a<=24&&o<=16?h._makeTriangleEdges()._edgesToVertices():this.states.strokeColor&&console.log("Cannot draw strokes on torus object with more than 24 detailX or 16 detailY"),h.gid=l,this.geometryBufferCache.ensureCached(h)}this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(l),s,s,s)},t.curveDetail=function(s){if(!(this._renderer instanceof Kt))throw new Error("curveDetail() only works in WebGL mode. Did you mean to call createCanvas(width, height, WEBGL)?");return this._renderer.curveDetail(s)}}typeof p5<"u"&&jT(p5,p5.prototype);function qT(r,t){t.ambientLight=function(n,s,i,a){return this._assert3d("ambientLight"),this._renderer.ambientLight(...arguments),this},t.specularColor=function(n,s,i){return this._assert3d("specularColor"),this._renderer.specularColor(...arguments),this},t.directionalLight=function(n,s,i,a,o,u){return this._assert3d("directionalLight"),this._renderer.directionalLight(...arguments),this},t.pointLight=function(n,s,i,a,o,u){return this._assert3d("pointLight"),this._renderer.pointLight(...arguments),this},t.imageLight=function(n){this._renderer.imageLight(n)},t.panorama=function(n){this.filter(this._renderer._getSphereMapping(n))},t.lights=function(){return this._assert3d("lights"),this._renderer.lights(),this},t.lightFalloff=function(n,s,i){return this._assert3d("lightFalloff"),this._renderer.lightFalloff(n,s,i),this},t.spotLight=function(n,s,i,a,o,u,l,c,h,d,p){return this._assert3d("spotLight"),this._renderer.spotLight(...arguments),this},t.noLights=function(...n){return this._assert3d("noLights"),this._renderer.noLights(),this},Kt.prototype.ambientLight=function(n,s,i,a){const o=this._pInst.color(...arguments);this.states.setValue("ambientLightColors",[...this.states.ambientLightColors]),this.states.ambientLightColors.push(o._array[0],o._array[1],o._array[2]),this.states.setValue("enableLighting",!0)},Kt.prototype.specularColor=function(n,s,i){const a=this._pInst.color(...arguments);this.states.setValue("specularColors",[a._array[0],a._array[1],a._array[2]])},Kt.prototype.directionalLight=function(n,s,i,a,o,u){let l;n instanceof _n?l=n:l=this._pInst.color(n,s,i);let c,h,d;const p=arguments[arguments.length-1];typeof p=="number"?(c=arguments[arguments.length-3],h=arguments[arguments.length-2],d=arguments[arguments.length-1]):(c=p.x,h=p.y,d=p.z);const f=Math.sqrt(c*c+h*h+d*d);this.states.setValue("directionalLightDirections",[...this.states.directionalLightDirections]),this.states.directionalLightDirections.push(c/f,h/f,d/f),this.states.setValue("directionalLightDiffuseColors",[...this.states.directionalLightDiffuseColors]),this.states.directionalLightDiffuseColors.push(l._array[0],l._array[1],l._array[2]),this.states.setValue("directionalLightSpecularColors",[...this.states.directionalLightSpecularColors]),Array.prototype.push.apply(this.states.directionalLightSpecularColors,this.states.specularColors),this.states.setValue("enableLighting",!0)},Kt.prototype.pointLight=function(n,s,i,a,o,u){let l;n instanceof _n?l=n:l=this._pInst.color(n,s,i);let c,h,d;const p=arguments[arguments.length-1];typeof p=="number"?(c=arguments[arguments.length-3],h=arguments[arguments.length-2],d=arguments[arguments.length-1]):(c=p.x,h=p.y,d=p.z),this.states.setValue("pointLightPositions",[...this.states.pointLightPositions]),this.states.pointLightPositions.push(c,h,d),this.states.setValue("pointLightDiffuseColors",[...this.states.pointLightDiffuseColors]),this.states.pointLightDiffuseColors.push(l._array[0],l._array[1],l._array[2]),this.states.setValue("pointLightSpecularColors",[...this.states.pointLightSpecularColors]),Array.prototype.push.apply(this.states.pointLightSpecularColors,this.states.specularColors),this.states.setValue("enableLighting",!0)},Kt.prototype.imageLight=function(n){this.states.setValue("activeImageLight",n),this.states.setValue("enableLighting",!0)},Kt.prototype.lights=function(){const n=this._pInst.color("rgb(128,128,128)");this.ambientLight(n),this.directionalLight(n,0,0,-1)},Kt.prototype.lightFalloff=function(n,s,i){n<0&&(n=0,console.warn("Value of constant argument in lightFalloff() should be never be negative. Set to 0.")),s<0&&(s=0,console.warn("Value of linear argument in lightFalloff() should be never be negative. Set to 0.")),i<0&&(i=0,console.warn("Value of quadratic argument in lightFalloff() should be never be negative. Set to 0.")),n===0&&s===0&&i===0&&(n=1,console.warn("Either one of the three arguments in lightFalloff() should be greater than zero. Set constant argument to 1.")),this.states.setValue("constantAttenuation",n),this.states.setValue("linearAttenuation",s),this.states.setValue("quadraticAttenuation",i)},Kt.prototype.spotLight=function(n,s,i,a,o,u,l,c,h,d,p){let f,m,g;const y=arguments.length;switch(y){case 11:case 10:f=this._pInst.color(n,s,i),m=new De(a,o,u),g=new De(l,c,h);break;case 9:n instanceof _n?(f=n,m=new De(s,i,a),g=new De(o,u,l),d=c,p=h):a instanceof De?(f=this._pInst.color(n,s,i),m=a,g=new De(o,u,l),d=c,p=h):l instanceof De?(f=this._pInst.color(n,s,i),m=new De(a,o,u),g=l,d=c,p=h):(f=this._pInst.color(n,s,i),m=new De(a,o,u),g=new De(l,c,h));break;case 8:n instanceof _n?(f=n,m=new De(s,i,a),g=new De(o,u,l),d=c):a instanceof De?(f=this._pInst.color(n,s,i),m=a,g=new De(o,u,l),d=c):(f=this._pInst.color(n,s,i),m=new De(a,o,u),g=l,d=c);break;case 7:n instanceof _n&&s instanceof De?(f=n,m=s,g=new De(i,a,o),d=u,p=l):n instanceof _n&&o instanceof De?(f=n,m=new De(s,i,a),g=o,d=u,p=l):a instanceof De&&o instanceof De?(f=this._pInst.color(n,s,i),m=a,g=o,d=u,p=l):n instanceof _n?(f=n,m=new De(s,i,a),g=new De(o,u,l)):a instanceof De?(f=this._pInst.color(n,s,i),m=a,g=new De(o,u,l)):(f=this._pInst.color(n,s,i),m=new De(a,o,u),g=l);break;case 6:a instanceof De&&o instanceof De?(f=this._pInst.color(n,s,i),m=a,g=o,d=u):n instanceof _n&&o instanceof De?(f=n,m=new De(s,i,a),g=o,d=u):n instanceof _n&&s instanceof De&&(f=n,m=s,g=new De(i,a,o),d=u);break;case 5:n instanceof _n&&s instanceof De&&i instanceof De?(f=n,m=s,g=i,d=a,p=o):a instanceof De&&o instanceof De?(f=this._pInst.color(n,s,i),m=a,g=o):n instanceof _n&&o instanceof De?(f=n,m=new De(s,i,a),g=o):n instanceof _n&&s instanceof De&&(f=n,m=s,g=new De(i,a,o));break;case 4:f=n,m=s,g=i,d=a;break;case 3:f=n,m=s,g=i;break;default:console.warn(`Sorry, input for spotlight() is not in prescribed format. Too ${y<3?"few":"many"} arguments were provided`);return}this.states.setValue("spotLightDiffuseColors",[f._array[0],f._array[1],f._array[2]]),this.states.setValue("spotLightSpecularColors",[...this.states.specularColors]),this.states.setValue("spotLightPositions",[m.x,m.y,m.z]),g.normalize(),this.states.setValue("spotLightDirections",[g.x,g.y,g.z]),d===void 0&&(d=Math.PI/3),p!==void 0&&p<1?(p=1,console.warn("Value of concentration needs to be greater than 1. Setting it to 1")):p===void 0&&(p=100),d=this._pInst._toRadians(d),this.states.setValue("spotLightAngle",[Math.cos(d)]),this.states.setValue("spotLightConc",[p]),this.states.setValue("enableLighting",!0)},Kt.prototype.noLights=function(){this.states.setValue("activeImageLight",null),this.states.setValue("enableLighting",!1),this.states.setValue("ambientLightColors",[]),this.states.setValue("specularColors",[1,1,1]),this.states.setValue("directionalLightDirections",[]),this.states.setValue("directionalLightDiffuseColors",[]),this.states.setValue("directionalLightSpecularColors",[]),this.states.setValue("pointLightPositions",[]),this.states.setValue("pointLightDiffuseColors",[]),this.states.setValue("pointLightSpecularColors",[]),this.states.setValue("spotLightPositions",[]),this.states.setValue("spotLightDirections",[]),this.states.setValue("spotLightDiffuseColors",[]),this.states.setValue("spotLightSpecularColors",[]),this.states.setValue("spotLightAngle",[]),this.states.setValue("spotLightConc",[]),this.states.setValue("constantAttenuation",1),this.states.setValue("linearAttenuation",0),this.states.setValue("quadraticAttenuation",0),this.states.setValue("_useShininess",1),this.states.setValue("_useMetalness",0)}}typeof p5<"u"&&qT(p5,p5.prototype);function z6(r,t){t.loadShader=async function(n,s,i,a){const o=new Ns;try{return o._vertSrc=(await ca(n,"text")).data,o._fragSrc=(await ca(s,"text")).data,i?i(o):o}catch(u){if(a)return a(u);throw u}},t.createShader=function(n,s,i){return new Ns(this._renderer,n,s,i)},t.loadFilterShader=async function(n,s,i){try{const o=await(await this.loadStrings(n)).join(`
`),u=this.createFilterShader(o,!0);return s&&s(u),u}catch(a){i?i(a):console.error(a)}},t.createFilterShader=function(n,s=!1){let o=n.includes("#version 300 es")?`#version 300 es
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      in vec3 aPosition;
      in vec2 aTexCoord;
      out vec2 vTexCoord;

      void main() {
        // transferring texcoords for the frag shader
        vTexCoord = aTexCoord;

        // copy position with a fourth coordinate for projection (1.0 is normal)
        vec4 positionVec4 = vec4(aPosition, 1.0);

        // project to 3D space
        gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
      }
    `:`
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      attribute vec3 aPosition;
      // texcoords only come from p5 to vertex shader
      // so pass texcoords on to the fragment shader in a varying variable
      attribute vec2 aTexCoord;
      varying vec2 vTexCoord;

      void main() {
        // transferring texcoords for the frag shader
        vTexCoord = aTexCoord;

        // copy position with a fourth coordinate for projection (1.0 is normal)
        vec4 positionVec4 = vec4(aPosition, 1.0);

        // project to 3D space
        gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
      }
    `;const u=new Ns(this._renderer,o,n);return s||(this._renderer.GL?u.ensureCompiledOnContext(this._renderer):u.ensureCompiledOnContext(this)),u},t.shader=function(n){return this._assert3d("shader"),this._renderer.shader(n),this},t.strokeShader=function(n){return this._assert3d("strokeShader"),this._renderer.strokeShader(n),this},t.imageShader=function(n){return this._assert3d("imageShader"),this._renderer.imageShader(n),this},t.baseMaterialShader=function(){return this._assert3d("baseMaterialShader"),this._renderer.baseMaterialShader()},t.baseFilterShader=function(){return(this._renderer.filterRenderer||this._renderer).baseFilterShader()},t.baseNormalShader=function(){return this._assert3d("baseNormalShader"),this._renderer.baseNormalShader()},t.baseColorShader=function(){return this._assert3d("baseColorShader"),this._renderer.baseColorShader()},t.baseStrokeShader=function(){return this._assert3d("baseStrokeShader"),this._renderer.baseStrokeShader()},t.resetShader=function(){return this._renderer.resetShader(),this},t.texture=function(n){return this._assert3d("texture"),n.gifProperties&&n._animateGif(this),this._renderer.texture(n),this},t.textureMode=function(n){n!==RS&&n!==eu?console.warn(`You tried to set ${n} textureMode only supports IMAGE & NORMAL `):this._renderer.states.setValue("textureMode",n)},t.textureWrap=function(n,s=n){this._renderer.states.setValue("textureWrapX",n),this._renderer.states.setValue("textureWrapY",s);for(const i of this._renderer.textures.values())i.setWrapMode(n,s)},t.normalMaterial=function(...n){return this._assert3d("normalMaterial"),this._renderer.normalMaterial(...n),this},t.ambientMaterial=function(n,s,i){this._assert3d("ambientMaterial");const a=t.color.apply(this,arguments);return this._renderer.states.setValue("_hasSetAmbient",!0),this._renderer.states.setValue("curAmbientColor",a._array),this._renderer.states.setValue("_useNormalMaterial",!1),this._renderer.states.setValue("enableLighting",!0),this._renderer.states.fillColor||this._renderer.states.setValue("fillColor",new _n([1,1,1])),this},t.emissiveMaterial=function(n,s,i,a){this._assert3d("emissiveMaterial");const o=t.color.apply(this,arguments);return this._renderer.states.setValue("curEmissiveColor",o._array),this._renderer.states.setValue("_useEmissiveMaterial",!0),this._renderer.states.setValue("_useNormalMaterial",!1),this._renderer.states.setValue("enableLighting",!0),this},t.specularMaterial=function(n,s,i,a){this._assert3d("specularMaterial");const o=t.color.apply(this,arguments);return this._renderer.states.setValue("curSpecularColor",o._array),this._renderer.states.setValue("_useSpecularMaterial",!0),this._renderer.states.setValue("_useNormalMaterial",!1),this._renderer.states.setValue("enableLighting",!0),this},t.shininess=function(n){return this._assert3d("shininess"),this._renderer.shininess(n),this},t.metalness=function(n){return this._assert3d("metalness"),this._renderer.metalness(n),this},Kt.prototype._applyColorBlend=function(n,s){const i=this.GL,a=this.states.drawMode===Bw,o=s||this.states.userFillShader||this.states.userStrokeShader||this.states.userPointShader||a||this.states.curBlendMode!==Si||n[n.length-1]<1||this._isErasing;return o!==this._isBlending&&(o||this.states.curBlendMode!==Si&&this.states.curBlendMode!==ob?i.enable(i.BLEND):i.disable(i.BLEND),i.depthMask(!0),this._isBlending=o),this._applyBlendMode(),n},Kt.prototype._applyBlendMode=function(){if(this._cachedBlendMode===this.states.curBlendMode)return;const n=this.GL;switch(this.states.curBlendMode){case Si:n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case ob:n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ONE);break;case Uh:n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ZERO,n.ONE_MINUS_SRC_ALPHA);break;case TS:n.blendEquation(n.FUNC_ADD),n.blendFunc(n.DST_COLOR,n.ONE_MINUS_SRC_ALPHA);break;case AS:n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ONE_MINUS_SRC_COLOR);break;case NS:n.blendEquationSeparate(n.FUNC_ADD,n.FUNC_ADD),n.blendFuncSeparate(n.ONE_MINUS_DST_COLOR,n.ONE_MINUS_SRC_COLOR,n.ONE,n.ONE);break;case DS:n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO);break;case kS:n.blendEquationSeparate(n.FUNC_REVERSE_SUBTRACT,n.FUNC_ADD),n.blendFuncSeparate(n.ONE,n.ONE,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case ES:this.blendExt?(n.blendEquationSeparate(this.blendExt.MIN||this.blendExt.MIN_EXT,n.FUNC_ADD),n.blendFuncSeparate(n.ONE,n.ONE,n.ONE,n.ONE)):console.warn("blendMode(DARKEST) does not work in your browser in WEBGL mode.");break;case IS:this.blendExt?(n.blendEquationSeparate(this.blendExt.MAX||this.blendExt.MAX_EXT,n.FUNC_ADD),n.blendFuncSeparate(n.ONE,n.ONE,n.ONE,n.ONE)):console.warn("blendMode(LIGHTEST) does not work in your browser in WEBGL mode.");break;default:console.error("Oops! Somehow RendererGL set curBlendMode to an unsupported mode.");break}this._cachedBlendMode=this.states.curBlendMode},Kt.prototype.shader=function(n){this.states.setValue("userFillShader",n),this.states.setValue("_useNormalMaterial",!1),n.ensureCompiledOnContext(this),n.setDefaultUniforms()},Kt.prototype.strokeShader=function(n){this.states.setValue("userStrokeShader",n),n.ensureCompiledOnContext(this),n.setDefaultUniforms()},Kt.prototype.imageShader=function(n){this.states.setValue("userImageShader",n),n.ensureCompiledOnContext(this),n.setDefaultUniforms()},Kt.prototype.resetShader=function(){this.states.setValue("userFillShader",null),this.states.setValue("userStrokeShader",null),this.states.setValue("userImageShader",null)},Kt.prototype.texture=function(n){this.states.setValue("drawMode",Bw),this.states.setValue("_useNormalMaterial",!1),this.states.setValue("_tex",n),this.states.setValue("fillColor",new _n([1,1,1]))},Kt.prototype.normalMaterial=function(...n){this.states.setValue("drawMode",Pw),this.states.setValue("_useSpecularMaterial",!1),this.states.setValue("_useEmissiveMaterial",!1),this.states.setValue("_useNormalMaterial",!0),this.states.setValue("curFillColor",[1,1,1,1]),this.states.setValue("fillColor",new _n([1,1,1])),this.states.setValue("strokeColor",null)},Kt.prototype.shininess=function(n){n<1&&(n=1),this.states.setValue("_useShininess",n)},Kt.prototype.metalness=function(n){const s=1-Math.exp(-n/100);this.states.setValue("_useMetalness",s)}}typeof p5<"u"&&loading(p5,p5.prototype);class Em{constructor(t,n,s,i,a){const o=s||Vh;return this._pInst=i,this._renderer=new pw[o](this._pInst,t,n,!1,a),this._initializeInstanceVariables(this),this._renderer._applyDefaults(),this}get deltaTime(){return this._pInst.deltaTime}get canvas(){var t;return(t=this._renderer)==null?void 0:t.canvas}get drawingContext(){return this._renderer.drawingContext}get width(){var t;return(t=this._renderer)==null?void 0:t.width}get height(){var t;return(t=this._renderer)==null?void 0:t.height}get pixels(){var t;return(t=this._renderer)==null?void 0:t.pixels}pixelDensity(t){let n;return typeof t=="number"?(t!==this._renderer._pixelDensity&&(this._renderer._pixelDensity=t),n=this,this.resizeCanvas(this.width,this.height,!0)):n=this._renderer._pixelDensity,n}resizeCanvas(t,n){this._renderer.resize(t,n)}reset(){this._renderer.resetMatrix(),this._renderer.isP3D&&this._renderer._update()}remove(){this._renderer.remove(),this._renderer=void 0}createFramebuffer(t){return new yo(this._renderer,t)}_assert3d(t){if(!this._renderer.isP3D)throw new Error(`${t}() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information.`)}_initializeInstanceVariables(){this._accessibleOutputs={text:!1,grid:!1,textLabel:!1,gridLabel:!1},this._styles=[],this._downKeys={}}}function aoe(r,t){r.Graphics=Em,$T(r,r.Graphics.prototype),RT(r,r.Graphics.prototype),OT(r,r.Graphics.prototype),MT(r,r.Graphics.prototype),TT(r,r.Graphics.prototype),LT(r,r.Graphics.prototype),UT(r,r.Graphics.prototype),zT(r,r.Graphics.prototype),BT(r,r.Graphics.prototype),_T(r,r.Graphics.prototype),jT(r,r.Graphics.prototype),qT(r,r.Graphics.prototype),z6(r,r.Graphics.prototype),kT(r,r.Graphics.prototype),VT(r,r.Graphics.prototype)}class nl{constructor(t,n,s){this._renderer=t;const i=this._renderer.GL;s=s||{},this.src=n,this.glTex=void 0,this.glTarget=i.TEXTURE_2D,this.glFormat=s.format||i.RGBA,this.mipmaps=!1,this.glMinFilter=s.minFilter||i.LINEAR,this.glMagFilter=s.magFilter||i.LINEAR,this.glWrapS=s.wrapS||i.CLAMP_TO_EDGE,this.glWrapT=s.wrapT||i.CLAMP_TO_EDGE,this.glDataType=s.dataType||i.UNSIGNED_BYTE;const a=W6(t);this.glFormat===i.HALF_FLOAT&&!a.halfFloat&&(console.log("This device does not support dataType HALF_FLOAT. Falling back to FLOAT."),this.glDataType=i.FLOAT),this.glFormat===i.HALF_FLOAT&&(this.glMinFilter===i.LINEAR||this.glMagFilter===i.LINEAR)&&!a.halfFloatLinear&&(console.log("This device does not support linear filtering for dataType FLOAT. Falling back to NEAREST."),this.glMinFilter===i.LINEAR&&(this.glMinFilter=i.NEAREST),this.glMagFilter===i.LINEAR&&(this.glMagFilter=i.NEAREST)),this.glFormat===i.FLOAT&&!a.float&&(console.log("This device does not support dataType FLOAT. Falling back to UNSIGNED_BYTE."),this.glDataType=i.UNSIGNED_BYTE),this.glFormat===i.FLOAT&&(this.glMinFilter===i.LINEAR||this.glMagFilter===i.LINEAR)&&!a.floatLinear&&(console.log("This device does not support linear filtering for dataType FLOAT. Falling back to NEAREST."),this.glMinFilter===i.LINEAR&&(this.glMinFilter=i.NEAREST),this.glMagFilter===i.LINEAR&&(this.glMagFilter=i.NEAREST)),this.isSrcMediaElement=!1,this._videoPrevUpdateTime=0,this.isSrcHTMLElement=typeof Sr<"u"&&n instanceof Sr&&!(n instanceof Em)&&!(n instanceof Gt),this.isSrcP5Image=n instanceof Do,this.isSrcP5Graphics=n instanceof Em,this.isSrcP5Renderer=n instanceof Gt,this.isImageData=typeof ImageData<"u"&&n instanceof ImageData,this.isFramebufferTexture=n instanceof Kw;const o=this._getTextureDataFromSource();return this.width=o.width,this.height=o.height,this.init(o),this}remove(){this.glTex&&(this._renderer.GL.deleteTexture(this.glTex),this.glTex=void 0)}_getTextureDataFromSource(){let t;return this.isFramebufferTexture?t=this.src.rawTexture():this.isSrcP5Image?t=this.src.canvas:this.isSrcMediaElement||this.isSrcHTMLElement?(this.src._ensureCanvas&&this.src._ensureCanvas(),t=this.src.elt):this.isSrcP5Graphics||this.isSrcP5Renderer?t=this.src.canvas:this.isImageData&&(t=this.src),t}init(t){const n=this._renderer.GL;if(this.isFramebufferTexture||(this.glTex=n.createTexture()),this.glWrapS=this._renderer.states.textureWrapX,this.glWrapT=this._renderer.states.textureWrapY,this.setWrapMode(this.glWrapS,this.glWrapT),this.bindTexture(),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,this.glMagFilter),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,this.glMinFilter),!this.isFramebufferTexture)if(this.width===0||this.height===0||this.isSrcMediaElement&&!this.src.loadedmetadata){const s=new Uint8Array([1,1,1,1]);n.texImage2D(this.glTarget,0,n.RGBA,1,1,0,this.glFormat,this.glDataType,s)}else n.texImage2D(this.glTarget,0,this.glFormat,this.glFormat,this.glDataType,t)}update(){const t=this.src;if(t.width===0||t.height===0)return!1;if(this.isFramebufferTexture)return this.src.update(),!1;const n=this._getTextureDataFromSource();let s=!1;const i=this._renderer.GL;return n.width!==this.width||n.height!==this.height?(s=!0,this.width=n.width||t.width,this.height=n.height||t.height,this.isSrcP5Image?t.setModified(!1):(this.isSrcMediaElement||this.isSrcHTMLElement)&&t.setModified&&t.setModified(!0)):this.isSrcP5Image?t.isModified()&&(s=!0,t.setModified(!1)):this.isSrcMediaElement?t.isModified()?(s=!0,t.setModified(!1)):t.loadedmetadata&&this._videoPrevUpdateTime!==t.time()&&(this._videoPrevUpdateTime=t.time(),s=!0):this.isImageData?t._dirty&&(t._dirty=!1,s=!0):s=!0,s&&(this.bindTexture(),i.texImage2D(this.glTarget,0,this.glFormat,this.glFormat,this.glDataType,n)),s}bindTexture(){return this._renderer.GL.bindTexture(this.glTarget,this.getTexture()),this}unbindTexture(){this._renderer.GL.bindTexture(this.glTarget,null)}getTexture(){return this.isFramebufferTexture?this.src.rawTexture():this.glTex}setInterpolation(t,n){const s=this._renderer.GL;this.glMinFilter=this.glFilter(t),this.glMagFilter=this.glFilter(n),this.bindTexture(),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,this.glMinFilter),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,this.glMagFilter),this.unbindTexture()}glFilter(t){const n=this._renderer.GL;return t===oU?n.NEAREST:n.LINEAR}setWrapMode(t,n){const s=this._renderer.GL,i=h=>(h&h-1)===0,a=this._getTextureDataFromSource();let o,u;a.naturalWidth&&a.naturalHeight?(o=a.naturalWidth,u=a.naturalHeight):(o=this.width,u=this.height);const l=i(o),c=i(u);t===OI?this._renderer.webglVersion===ts||l&&c?this.glWrapS=s.REPEAT:(console.warn("You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead"),this.glWrapS=s.CLAMP_TO_EDGE):t===LI?this._renderer.webglVersion===ts||l&&c?this.glWrapS=s.MIRRORED_REPEAT:(console.warn("You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead"),this.glWrapS=s.CLAMP_TO_EDGE):this.glWrapS=s.CLAMP_TO_EDGE,n===OI?this._renderer.webglVersion===ts||l&&c?this.glWrapT=s.REPEAT:(console.warn("You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead"),this.glWrapT=s.CLAMP_TO_EDGE):n===LI?this._renderer.webglVersion===ts||l&&c?this.glWrapT=s.MIRRORED_REPEAT:(console.warn("You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead"),this.glWrapT=s.CLAMP_TO_EDGE):this.glWrapT=s.CLAMP_TO_EDGE,this.bindTexture(),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,this.glWrapS),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,this.glWrapT),this.unbindTexture()}}class U6 extends nl{constructor(t,n,s){super(t,n,s);const i=this._renderer.GL;this.glMinFilter===i.LINEAR&&(this.glMinFilter=i.LINEAR_MIPMAP_LINEAR)}glFilter(t){return this._renderer.GL.LINEAR_MIPMAP_LINEAR}_getTextureDataFromSource(){return this.src}init(t){const n=this._renderer.GL;this.glTex=n.createTexture(),this.bindTexture();for(let s=0;s<t.length;s++)n.texImage2D(this.glTarget,s,this.glFormat,this.glFormat,this.glDataType,t[s]);this.glMinFilter=n.LINEAR_MIPMAP_LINEAR,n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,this.glMagFilter),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,this.glMinFilter),this.unbindTexture()}update(){}}function KT(r,t){r.Texture=nl,r.MipmapTexture=U6}function W6({GL:r,webglVersion:t}){const n=r,s=t===ts?n.getExtension("EXT_color_buffer_float")&&n.getExtension("EXT_float_blend"):n.getExtension("OES_texture_float"),i=s&&n.getExtension("OES_texture_float_linear"),a=t===ts?n.getExtension("EXT_color_buffer_float"):n.getExtension("OES_texture_half_float"),o=a&&n.getExtension("OES_texture_half_float_linear");return{float:s,floatLinear:i,halfFloat:a,halfFloatLinear:o}}typeof p5<"u"&&KT(p5,p5.prototype);const Rf=(r,t,n)=>Math.max(Math.min(r,n),t);class G6 extends Kh{constructor(t){super(t.renderer),this.fbo=t,this.yScale=-1}_computeCameraDefaultSettings(){super._computeCameraDefaultSettings(),this.defaultAspectRatio=this.fbo.width/this.fbo.height,this.defaultCameraFOV=2*Math.atan(this.fbo.height/2/this.defaultEyeZ)}}class Kw{constructor(t,n){this.framebuffer=t,this.property=n}get width(){return this.framebuffer.width*this.framebuffer.density}get height(){return this.framebuffer.height*this.framebuffer.density}update(){this.framebuffer._update(this.property)}rawTexture(){return this.framebuffer[this.property]}}class yo{constructor(t,n={}){this.renderer=t,this.renderer.framebuffers.add(this),this._isClipApplied=!1,this.dirty={colorTexture:!1,depthTexture:!1},this.pixels=[],this.format=n.format||Bl,this.channels=n.channels||(this.renderer._pInst._glAttributes.alpha?ow:Cn),this.useDepth=n.depth===void 0?!0:n.depth,this.depthFormat=n.depthFormat||Bi,this.textureFiltering=n.textureFiltering||RI,n.antialias===void 0?this.antialiasSamples=this.renderer._pInst._glAttributes.antialias?2:0:typeof n.antialias=="number"?this.antialiasSamples=n.antialias:this.antialiasSamples=n.antialias?2:0,this.antialias=this.antialiasSamples>0,this.antialias&&this.renderer.webglVersion!==ts&&(console.warn("Antialiasing is unsupported in a WebGL 1 context"),this.antialias=!1),this.density=n.density||this.renderer._pixelDensity;const s=this.renderer.GL;if(this.gl=s,n.width&&n.height){const a=this.renderer._adjustDimensions(n.width,n.height);this.width=a.adjustedWidth,this.height=a.adjustedHeight,this._autoSized=!1}else n.width===void 0!=(n.height===void 0)&&console.warn("Please supply both width and height for a framebuffer to give it a size. Only one was given, so the framebuffer will match the size of its canvas."),this.width=this.renderer.width,this.height=this.renderer.height,this._autoSized=!0;if(this._checkIfFormatsAvailable(),n.stencil&&!this.useDepth&&console.warn("A stencil buffer can only be used if also using depth. Since the framebuffer has no depth buffer, the stencil buffer will be ignored."),this.useStencil=this.useDepth&&(n.stencil===void 0?!0:n.stencil),this.framebuffer=s.createFramebuffer(),!this.framebuffer)throw new Error("Unable to create a framebuffer");if(this.antialias&&(this.aaFramebuffer=s.createFramebuffer(),!this.aaFramebuffer))throw new Error("Unable to create a framebuffer for antialiasing");this._recreateTextures();const i=this.renderer.states.curCamera;this.defaultCamera=this.createCamera(),this.filterCamera=this.createCamera(),this.renderer.states.setValue("curCamera",i),this.draw(()=>this.renderer.clear())}resize(t,n){this._autoSized=!1;const s=this.renderer._adjustDimensions(t,n);t=s.adjustedWidth,n=s.adjustedHeight,this.width=t,this.height=n,this._handleResize()}pixelDensity(t){if(t)this._autoSized=!1,this.density=t,this._handleResize();else return this.density}autoSized(t){if(t===void 0)return this._autoSized;this._autoSized=t,this._handleResize()}_checkIfFormatsAvailable(){const t=this.gl;this.useDepth&&this.renderer.webglVersion===ic&&!t.getExtension("WEBGL_depth_texture")&&(console.warn("Unable to create depth textures in this environment. Falling back to a framebuffer without depth."),this.useDepth=!1),this.useDepth&&this.renderer.webglVersion===ic&&this.depthFormat===Bi&&(console.warn("FLOAT depth format is unavailable in WebGL 1. Defaulting to UNSIGNED_INT."),this.depthFormat=Wy),[Bl,Bi,Uf].includes(this.format)||(console.warn("Unknown Framebuffer format. Please use UNSIGNED_BYTE, FLOAT, or HALF_FLOAT. Defaulting to UNSIGNED_BYTE."),this.format=Bl),this.useDepth&&![Wy,Bi].includes(this.depthFormat)&&(console.warn("Unknown Framebuffer depth format. Please use UNSIGNED_INT or FLOAT. Defaulting to FLOAT."),this.depthFormat=Bi);const n=W6(this.renderer);!n.float&&this.format===Bi&&(console.warn("This environment does not support FLOAT textures. Falling back to UNSIGNED_BYTE."),this.format=Bl),this.useDepth&&!n.float&&this.depthFormat===Bi&&(console.warn("This environment does not support FLOAT depth textures. Falling back to UNSIGNED_INT."),this.depthFormat=Wy),!n.halfFloat&&this.format===Uf&&(console.warn("This environment does not support HALF_FLOAT textures. Falling back to UNSIGNED_BYTE."),this.format=Bl),this.channels===Cn&&[Bi,Uf].includes(this.format)&&(console.warn("FLOAT and HALF_FLOAT formats do not work cross-platform with only RGB channels. Falling back to RGBA."),this.channels=ow)}_recreateTextures(){const t=this.gl;this._updateSize();const n=t.getParameter(t.TEXTURE_BINDING_2D),s=t.getParameter(t.FRAMEBUFFER_BINDING),i=t.createTexture();if(!i)throw new Error("Unable to create color texture");t.bindTexture(t.TEXTURE_2D,i);const a=this._glColorFormat();if(t.texImage2D(t.TEXTURE_2D,0,a.internalFormat,this.width*this.density,this.height*this.density,0,a.format,a.type,null),this.colorTexture=i,t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,i,0),this.useDepth){const u=t.createTexture();if(!u)throw new Error("Unable to create depth texture");const l=this._glDepthFormat();t.bindTexture(t.TEXTURE_2D,u),t.texImage2D(t.TEXTURE_2D,0,l.internalFormat,this.width*this.density,this.height*this.density,0,l.format,l.type,null),t.framebufferTexture2D(t.FRAMEBUFFER,this.useStencil?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,t.TEXTURE_2D,u,0),this.depthTexture=u}if(this.antialias){if(this.colorRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,this.colorRenderbuffer),t.renderbufferStorageMultisample(t.RENDERBUFFER,Math.max(0,Math.min(this.antialiasSamples,t.getParameter(t.MAX_SAMPLES))),a.internalFormat,this.width*this.density,this.height*this.density),this.useDepth){const u=this._glDepthFormat();this.depthRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,this.depthRenderbuffer),t.renderbufferStorageMultisample(t.RENDERBUFFER,Math.max(0,Math.min(this.antialiasSamples,t.getParameter(t.MAX_SAMPLES))),u.internalFormat,this.width*this.density,this.height*this.density)}t.bindFramebuffer(t.FRAMEBUFFER,this.aaFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,this.colorRenderbuffer),this.useDepth&&t.framebufferRenderbuffer(t.FRAMEBUFFER,this.useStencil?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,t.RENDERBUFFER,this.depthRenderbuffer)}if(this.useDepth){this.depth=new Kw(this,"depthTexture");const u=t.NEAREST;this.depthP5Texture=new nl(this.renderer,this.depth,{minFilter:u,magFilter:u}),this.renderer.textures.set(this.depth,this.depthP5Texture)}this.color=new Kw(this,"colorTexture");const o=this.textureFiltering===RI?t.LINEAR:t.NEAREST;this.colorP5Texture=new nl(this.renderer,this.color,{minFilter:o,magFilter:o}),this.renderer.textures.set(this.color,this.colorP5Texture),t.bindTexture(t.TEXTURE_2D,n),t.bindFramebuffer(t.FRAMEBUFFER,s)}_glColorFormat(){let t,n,s;const i=this.gl;return this.format===Bi?t=i.FLOAT:this.format===Uf?t=this.renderer.webglVersion===ts?i.HALF_FLOAT:i.getExtension("OES_texture_half_float").HALF_FLOAT_OES:t=i.UNSIGNED_BYTE,this.channels===ow?n=i.RGBA:n=i.RGB,this.renderer.webglVersion===ts?s={[i.FLOAT]:{[i.RGBA]:i.RGBA32F},[i.HALF_FLOAT]:{[i.RGBA]:i.RGBA16F},[i.UNSIGNED_BYTE]:{[i.RGBA]:i.RGBA8,[i.RGB]:i.RGB8}}[t][n]:this.format===Uf?s=i.RGBA:s=n,{internalFormat:s,format:n,type:t}}_glDepthFormat(){let t,n,s;const i=this.gl;return this.useStencil?this.depthFormat===Bi?t=i.FLOAT_32_UNSIGNED_INT_24_8_REV:this.renderer.webglVersion===ts?t=i.UNSIGNED_INT_24_8:t=i.getExtension("WEBGL_depth_texture").UNSIGNED_INT_24_8_WEBGL:this.depthFormat===Bi?t=i.FLOAT:t=i.UNSIGNED_INT,this.useStencil?n=i.DEPTH_STENCIL:n=i.DEPTH_COMPONENT,this.useStencil?this.depthFormat===Bi?s=i.DEPTH32F_STENCIL8:this.renderer.webglVersion===ts?s=i.DEPTH24_STENCIL8:s=i.DEPTH_STENCIL:this.renderer.webglVersion===ts?this.depthFormat===Bi?s=i.DEPTH_COMPONENT32F:s=i.DEPTH_COMPONENT24:s=i.DEPTH_COMPONENT,{internalFormat:s,format:n,type:t}}_updateSize(){this._autoSized&&(this.width=this.renderer.width,this.height=this.renderer.height,this.density=this.renderer._pixelDensity)}_canvasSizeChanged(){this._autoSized&&this._handleResize()}_handleResize(){const t=this.color,n=this.depth,s=this.colorRenderbuffer,i=this.depthRenderbuffer;this._deleteTexture(t),n&&this._deleteTexture(n);const a=this.gl;s&&a.deleteRenderbuffer(s),i&&a.deleteRenderbuffer(i),this._recreateTextures(),this.defaultCamera._resize()}createCamera(){const t=new G6(this);return t._computeCameraDefaultSettings(),t._setDefaultCamera(),t}_deleteTexture(t){this.gl.deleteTexture(t.rawTexture()),this.renderer.textures.delete(t)}remove(){const t=this.gl;this._deleteTexture(this.color),this.depth&&this._deleteTexture(this.depth),t.deleteFramebuffer(this.framebuffer),this.aaFramebuffer&&t.deleteFramebuffer(this.aaFramebuffer),this.depthRenderbuffer&&t.deleteRenderbuffer(this.depthRenderbuffer),this.colorRenderbuffer&&t.deleteRenderbuffer(this.colorRenderbuffer),this.renderer.framebuffers.delete(this)}begin(){this.prevFramebuffer=this.renderer.activeFramebuffer(),this.prevFramebuffer&&this.prevFramebuffer._beforeEnd(),this.renderer.activeFramebuffers.push(this),this._beforeBegin(),this.renderer.push(),this.renderer.states.setValue("curCamera",this.defaultCamera),this.renderer.states.setValue("uPMatrix",this.renderer.states.uPMatrix.clone()),this.renderer.states.uPMatrix.set(this.defaultCamera.projMatrix),this.renderer.states.setValue("uViewMatrix",this.renderer.states.uViewMatrix.clone()),this.renderer.states.uViewMatrix.set(this.defaultCamera.cameraMatrix),this.renderer.resetMatrix(),this.renderer.states.uViewMatrix.set(this.renderer.states.curCamera.cameraMatrix),this.renderer.states.uModelMatrix.reset(),this.renderer._applyStencilTestIfClipping()}_framebufferToBind(){return this.antialias?this.aaFramebuffer:this.framebuffer}_update(t){if(this.dirty[t]&&this.antialias){const n=this.gl;n.bindFramebuffer(n.READ_FRAMEBUFFER,this.aaFramebuffer),n.bindFramebuffer(n.DRAW_FRAMEBUFFER,this.framebuffer);const s={colorTexture:[n.COLOR_BUFFER_BIT,this.colorP5Texture.glMagFilter]};this.useDepth&&(s.depthTexture=[n.DEPTH_BUFFER_BIT,this.depthP5Texture.glMagFilter]);const[i,a]=s[t];n.blitFramebuffer(0,0,this.width*this.density,this.height*this.density,0,0,this.width*this.density,this.height*this.density,i,a),this.dirty[t]=!1;const o=this.renderer.activeFramebuffer();o?n.bindFramebuffer(n.FRAMEBUFFER,o._framebufferToBind()):n.bindFramebuffer(n.FRAMEBUFFER,null)}}_beforeBegin(){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,this._framebufferToBind()),this.renderer.viewport(this.width*this.density,this.height*this.density)}_beforeEnd(){this.antialias&&(this.dirty={colorTexture:!0,depthTexture:!0})}end(){const t=this.gl;if(this.renderer.pop(),this.renderer.activeFramebuffers.pop()!==this)throw new Error("It looks like you've called end() while another Framebuffer is active.");this._beforeEnd(),this.prevFramebuffer?this.prevFramebuffer._beforeBegin():(t.bindFramebuffer(t.FRAMEBUFFER,null),this.renderer.viewport(this.renderer._origViewport.width,this.renderer._origViewport.height)),this.renderer._applyStencilTestIfClipping()}draw(t){this.begin(),t(),this.end()}loadPixels(){this._update("colorTexture");const t=this.gl,n=this.renderer.activeFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer);const s=this._glColorFormat();this.pixels=YI(this.pixels,t,this.framebuffer,0,0,this.width*this.density,this.height*this.density,s.format,s.type),n?t.bindFramebuffer(t.FRAMEBUFFER,n._framebufferToBind()):t.bindFramebuffer(t.FRAMEBUFFER,null)}get(t,n,s,i){this._update("colorTexture");const a=this._glColorFormat();if(t===void 0&&n===void 0)t=0,n=0,s=this.width,i=this.height;else if(s===void 0&&i===void 0)return(t<0||n<0||t>=this.width||n>=this.height)&&(console.warn("The x and y values passed to p5.Framebuffer.get are outside of its range and will be clamped."),t=Rf(t,0,this.width-1),n=Rf(n,0,this.height-1)),V6(this.gl,this.framebuffer,t*this.density,n*this.density,a.format,a.type);t=Rf(t,0,this.width-1),n=Rf(n,0,this.height-1),s=Rf(s,1,this.width-t),i=Rf(i,1,this.height-n);const o=YI(void 0,this.gl,this.framebuffer,t*this.density,n*this.density,s*this.density,i*this.density,a.format,a.type),u=new Uint8ClampedArray(s*i*this.density*this.density*4);u.fill(255);const l=a.type===this.gl.RGB?3:4;for(let h=0;h<i*this.density;h++)for(let d=0;d<s*this.density;d++)for(let p=0;p<4;p++){const f=(h*s*this.density+d)*4+p;if(p<l){const m=l===4?f:(h*s*this.density+d)*l+p;u[f]=o[m]}}const c=new Do(s*this.density,i*this.density);return c.imageData=c.canvas.getContext("2d").createImageData(c.width,c.height),c.imageData.data.set(u),c.pixels=c.imageData.data,c.updatePixels(),this.density!==1&&c.resize(s,i),c}updatePixels(){const t=this.gl;this.colorP5Texture.bindTexture();const n=this._glColorFormat(),s=n.format===t.RGBA?4:3,i=this.width*this.height*this.density*this.density*s,a=n.type===t.UNSIGNED_BYTE?Uint8Array:Float32Array;if(!(this.pixels instanceof a)||this.pixels.length!==i)throw new Error("The pixels array has not been set correctly. Please call loadPixels() before updatePixels().");t.texImage2D(t.TEXTURE_2D,0,n.internalFormat,this.width*this.density,this.height*this.density,0,n.format,n.type,this.pixels),this.colorP5Texture.unbindTexture(),this.dirty.colorTexture=!1;const o=this.renderer.activeFramebuffer();this.antialias?(this.begin(),this.renderer.push(),this.renderer.states.setValue("imageMode",xa),this.renderer.setCamera(this.filterCamera),this.renderer.resetMatrix(),this.renderer.states.setValue("strokeColor",null),this.renderer.clear(),this.renderer._drawingFilter=!0,this.renderer.image(this,0,0,this.width,this.height,-this.renderer.width/2,-this.renderer.height/2,this.renderer.width,this.renderer.height),this.renderer._drawingFilter=!1,this.renderer.pop(),this.useDepth&&(t.clearDepth(1),t.clear(t.DEPTH_BUFFER_BIT)),this.end()):(t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),this.useDepth&&(t.clearDepth(1),t.clear(t.DEPTH_BUFFER_BIT)),o?t.bindFramebuffer(t.FRAMEBUFFER,o._framebufferToBind()):t.bindFramebuffer(t.FRAMEBUFFER,null))}}function H6(r,t){r.FramebufferCamera=G6,r.FramebufferTexture=Kw,r.Framebuffer=yo}typeof p5<"u"&&H6(p5,p5.prototype);let pw;function j6(r,t){pw=r.renderers={},t.createCanvas=function(n,s,i,...a){let o=Vh;return Reflect.ownKeys(pw).includes(i)?o=i:a.unshift(i),this._renderer&&this._renderer.remove(),this._renderer=new pw[o](this,n,s,!0,...a),this._defaultGraphicsCreated=!0,this._elements.push(this._renderer),this._renderer._applyDefaults(),Object.hasOwn(this,"pixels")||Object.defineProperty(this,"pixels",{get(){var u;return(u=this._renderer)==null?void 0:u.pixels}}),this._renderer},t.resizeCanvas=function(n,s,i){this._renderer&&(this._renderer.resize(n,s),i||this.redraw()),this._addAccsOutput()&&this._updateAccsOutput()},t.noCanvas=function(){this.canvas&&this.canvas.parentNode.removeChild(this.canvas)},t.createGraphics=function(n,s,...i){return i[0]instanceof HTMLCanvasElement&&(i[1]=i[0],i[0]=Vh),new r.Graphics(n,s,i[0],this,i[1])},t.createFramebuffer=function(n){return new yo(this._renderer,n)},t.clearDepth=function(n){this._assert3d("clearDepth"),this._renderer.clearDepth(n)}}typeof p5<"u"&&j6(p5,p5.prototype);class ooe{constructor(t){this.pInst=t,this.canvas=document.createElement("canvas"),this.canvas.width=t.width,this.canvas.height=t.height;let n=ts;if(this.gl=this.canvas.getContext("webgl2"),this.gl||(n=ic,this.gl=this.canvas.getContext("webgl")),!this.gl){console.error("WebGL not supported, cannot apply filter.");return}this._renderer={GL:this.gl,registerEnabled:new Set,_curShader:null,_emptyTexture:null,webglVersion:n,states:{textureWrapX:this.gl.CLAMP_TO_EDGE,textureWrapY:this.gl.CLAMP_TO_EDGE},_arraysEqual:(s,i)=>JSON.stringify(s)===JSON.stringify(i),_getEmptyTexture:()=>{if(!this._emptyTexture){const s=new Do(1,1);s.set(0,0,255),this._emptyTexture=new nl(this._renderer,s)}return this._emptyTexture}},this._baseFilterShader=void 0,this.filterShaderSources={[Sm]:D6,[wT]:R6,[FS]:O6,[CT]:T6,[xT]:N6,[ST]:A6,[$S]:F6,[vT]:$6},this.filterShaders={},this.operation=null,this.filterParameter=1,this.customShader=null,this._shader=null,this.vertexBuffer=this.gl.createBuffer(),this.texcoordBuffer=this.gl.createBuffer(),this.vertices=new Float32Array([-1,-1,1,-1,-1,1,1,1]),this.texcoords=new Float32Array([0,1,1,1,0,0,1,0]),this._bindBufferData(this.vertexBuffer,this.gl.ARRAY_BUFFER,this.vertices),this._bindBufferData(this.texcoordBuffer,this.gl.ARRAY_BUFFER,this.texcoords)}_webGL2CompatibilityPrefix(t,n){let s="";return this._renderer.webglVersion===ts&&(s+=`#version 300 es
#define WEBGL2
`),t==="vert"?s+=`#define VERTEX_SHADER
`:t==="frag"&&(s+=`#define FRAGMENT_SHADER
`),n&&(s+=`precision ${n} float;
`),s}baseFilterShader(){return this._baseFilterShader||(this._baseFilterShader=new Ns(this._renderer,this._webGL2CompatibilityPrefix("vert","highp")+XI+I6,this._webGL2CompatibilityPrefix("frag","highp")+XI+k6,{vertex:{},fragment:{"vec4 getColor":`(FilterInputs inputs, in sampler2D canvasContent) {
                return getTexture(canvasContent, inputs.texCoord);
              }`}})),this._baseFilterShader}setOperation(t,n,s=null){this.operation=t,this.filterParameter=n,t in jw&&n===void 0&&(this.filterParameter=jw[t]),this.customShader=s,this._initializeShader()}_initializeShader(){if(this.customShader){this._shader=this.customShader;return}if(!this.operation){console.error("No operation set for FilterRenderer2D, cannot initialize shader.");return}if(this.filterShaders[this.operation]){this._shader=this.filterShaders[this.operation];return}const t=this.filterShaderSources[this.operation];if(!t){console.error("No shader available for this operation:",this.operation);return}const n=new Ns(this._renderer,M6,t);this.filterShaders[this.operation]=n,this._shader=n}_bindBufferData(t,n,s){const i=this.gl;i.bindBuffer(n,t),i.bufferData(n,s,i.STATIC_DRAW)}get canvasTexture(){return this._canvasTexture||(this._canvasTexture=new nl(this._renderer,this.pInst.wrappedElt)),this._canvasTexture}_renderPass(){const t=this.gl;this._shader.bindShader();const n=this.pInst.pixelDensity?this.pInst.pixelDensity():1,s=[1/(this.pInst.width*n),1/(this.pInst.height*n)],i=this.canvasTexture;this._shader.setUniform("tex0",i),this._shader.setUniform("texelSize",s),this._shader.setUniform("canvasSize",[this.pInst.width,this.pInst.height]),this._shader.setUniform("radius",Math.max(1,this.filterParameter)),this._shader.setUniform("filterParameter",this.filterParameter),this._shader.setDefaultUniforms(),this.pInst.states.setValue("rectMode",xa),this.pInst.states.setValue("imageMode",xa),this.pInst.blendMode(Si),this.pInst.resetMatrix();const a=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];this._shader.setUniform("uModelViewMatrix",a),this._shader.setUniform("uProjectionMatrix",a),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),this._shader.enableAttrib(this._shader.attributes.aPosition,2),t.bindBuffer(t.ARRAY_BUFFER,this.texcoordBuffer),this._shader.enableAttrib(this._shader.attributes.aTexCoord,2),this._shader.bindTextures(),this._shader.disableRemainingAttributes(),t.drawArrays(t.TRIANGLE_STRIP,0,4),this._shader.unbindShader()}applyFilter(){if(!this._shader){console.error("Cannot apply filter: shader not initialized.");return}this.pInst.push(),this.pInst.resetMatrix(),this.operation===Sm&&!this.customShader?(this._shader.setUniform("direction",[1,0]),this._renderPass(),this.pInst.clear(),this.pInst.drawingContext.drawImage(this.canvas,0,0,this.pInst.width,this.pInst.height),this._shader.setUniform("direction",[0,1]),this._renderPass(),this.pInst.clear(),this.pInst.drawingContext.drawImage(this.canvas,0,0,this.pInst.width,this.pInst.height)):(this._renderPass(),this.pInst.clear(),this.pInst.blendMode(Si),this.pInst.drawingContext.drawImage(this.canvas,0,0,this.pInst.width,this.pInst.height)),this.pInst.pop()}}const Go="rgba(0,0,0,0)";class dE extends Gt{constructor(t,n,s,i,a,o={}){super(t,n,s,i),this.canvas=this.elt=a||document.createElement("canvas"),i?(this._pInst._curElement=this,this._pInst.canvas=this.canvas):this.canvas.style.display="none",this.elt.id="defaultCanvas0",this.elt.classList.add("p5Canvas");for(const u of Object.getOwnPropertyNames(Sr.prototype))u!=="constructor"&&u[0]!=="_"&&Object.defineProperty(this,u,{get(){return this.wrappedElt[u]}});if(this.elt.width=n*this._pixelDensity,this.elt.height=s*this._pixelDensity,this.elt.style.width=`${n}px`,this.elt.style.height=`${s}px`,this._pInst._userNode)this._pInst._userNode.appendChild(this.elt);else{if(document.getElementsByTagName("main").length===0){let u=document.createElement("main");document.body.appendChild(u)}document.getElementsByTagName("main")[0].appendChild(this.elt)}this.drawingContext=this.canvas.getContext("2d",o),o.colorSpace==="display-p3"&&(this.states.colorMode=xi),this.scale(this._pixelDensity,this._pixelDensity),this.filterRenderer||(this.filterRenderer=new ooe(this)),this.wrappedElt=new Sr(this.elt,this._pInst),this.clipPath=null}remove(){this.wrappedElt.remove(),this.wrappedElt=null,this.canvas=null,this.elt=null}getFilterGraphicsLayer(){if(!this.filterGraphicsLayer){const t=this._pInst;this.filterGraphicsLayer=new Em(this.width,this.height,ic,t)}return(this.filterGraphicsLayer.width!==this.width||this.filterGraphicsLayer.height!==this.height)&&this.filterGraphicsLayer.resizeCanvas(this.width,this.height),this.filterGraphicsLayer.pixelDensity()!==this._pInst.pixelDensity()&&this.filterGraphicsLayer.pixelDensity(this._pInst.pixelDensity()),this.filterGraphicsLayer}_applyDefaults(){this.states.setValue("_cachedFillStyle",void 0),this.states.setValue("_cachedStrokeStyle",void 0),this._cachedBlendMode=Si,this._setFill(hU),this._setStroke(cU),this.drawingContext.lineCap=Ql,this.drawingContext.font="normal 12px sans-serif"}resize(t,n){super.resize(t,n);const s={};for(const i in this.drawingContext){const a=this.drawingContext[i];typeof a!="object"&&typeof a!="function"&&(s[i]=a)}this.canvas.width=t*this._pixelDensity,this.canvas.height=n*this._pixelDensity,this.canvas.style.width=`${t}px`,this.canvas.style.height=`${n}px`,this.drawingContext.scale(this._pixelDensity,this._pixelDensity);for(const i in s)try{this.drawingContext[i]=s[i]}catch{}}background(...t){if(this.push(),this.resetMatrix(),t[0]instanceof Do)if(t[1]>=0){const n=t[0];this.drawingContext.globalAlpha=t[1]/255,this._pInst.image(n,0,0,this.width,this.height)}else this._pInst.image(t[0],0,0,this.width,this.height);else{const n=this._pInst.color(...t);this._pInst._addAccsOutput()&&this._pInst._accsBackground(n._getRGBA([255,255,255,255]));const s=n.toString();this._setFill(s),this._isErasing&&this.blendMode(this._cachedBlendMode),this.drawingContext.fillRect(0,0,this.width,this.height),this._isErasing&&this._pInst.erase()}this.pop()}clear(){this.drawingContext.save(),this.resetMatrix(),this.drawingContext.clearRect(0,0,this.width,this.height),this.drawingContext.restore()}fill(...t){super.fill(...t);const n=this.states.fillColor;this._setFill(n.toString()),this._pInst._addAccsOutput()&&this._pInst._accsCanvasColors("fill",n._getRGBA([255,255,255,255]))}stroke(...t){super.stroke(...t);const n=this.states.strokeColor;this._setStroke(n.toString()),this._pInst._addAccsOutput()&&this._pInst._accsCanvasColors("stroke",n._getRGBA([255,255,255,255]))}erase(t,n){if(!this._isErasing){this.states.setValue("_cachedFillStyle",this.drawingContext.fillStyle);const s=this._pInst.color(255,t).toString();this.drawingContext.fillStyle=s,this.states.setValue("_cachedStrokeStyle",this.drawingContext.strokeStyle);const i=this._pInst.color(255,n).toString();this.drawingContext.strokeStyle=i;const a=this._cachedBlendMode;this.blendMode(Uh),this._cachedBlendMode=a,this._isErasing=!0}}noErase(){this._isErasing&&(this.drawingContext.fillStyle=this.states._cachedFillStyle,this.drawingContext.strokeStyle=this.states._cachedStrokeStyle,this.blendMode(this._cachedBlendMode),this._isErasing=!1)}drawShape(t){const n=new n6({strokeWeight:this.states.strokeWeight});t.accept(n),this._clipping?(this.clipPath.addPath(n.path),this.clipPath.closePath()):(this.states.fillColor&&this.drawingContext.fill(n.path),this.states.strokeColor&&this.drawingContext.stroke(n.path))}beginClip(t={}){super.beginClip(t),this.states.setValue("_cachedFillStyle",this.drawingContext.fillStyle);const n=this._pInst.color(255,0).toString();this.drawingContext.fillStyle=n,this.states.setValue("_cachedStrokeStyle",this.drawingContext.strokeStyle);const s=this._pInst.color(255,0).toString();this.drawingContext.strokeStyle=s;const i=this._cachedBlendMode;this.blendMode(Si),this._cachedBlendMode=i,this.clipPath=new Path2D,this._clipInvert&&(this.clipPath.moveTo(-2*this.width,-2*this.height),this.clipPath.lineTo(-2*this.width,2*this.height),this.clipPath.lineTo(2*this.width,2*this.height),this.clipPath.lineTo(2*this.width,-2*this.height),this.clipPath.closePath())}endClip(){this.drawingContext.clip(this.clipPath),this.clipPath=null,super.endClip(),this.drawingContext.fillStyle=this.states._cachedFillStyle,this.drawingContext.strokeStyle=this.states._cachedStrokeStyle,this.blendMode(this._cachedBlendMode)}image(t,n,s,i,a,o,u,l,c){let h;t.gifProperties&&t._animateGif(this._pInst);try{t instanceof db&&t._ensureCanvas(),this.states.tint&&t.canvas&&(h=this._getTintedImageCanvas(t)),h||(h=t.canvas||t.elt);let d=1;t.width&&t.width>0&&(d=h.width/t.width),this._isErasing&&this.blendMode(this._cachedBlendMode),this.drawingContext.drawImage(h,d*n,d*s,d*i,d*a,o,u,l,c),this._isErasing&&this._pInst.erase()}catch(d){if(d.name!=="NS_ERROR_NOT_AVAILABLE")throw d}}_getTintedImageCanvas(t){if(!t.canvas)return t;t.tintCanvas||(t.tintCanvas=document.createElement("canvas")),t.tintCanvas.width!==t.canvas.width&&(t.tintCanvas.width=t.canvas.width),t.tintCanvas.height!==t.canvas.height&&(t.tintCanvas.height=t.canvas.height);const n=t.tintCanvas.getContext("2d");return n.save(),n.clearRect(0,0,t.canvas.width,t.canvas.height),this.states.tint[0]<255||this.states.tint[1]<255||this.states.tint[2]<255?(n.drawImage(t.canvas,0,0),n.globalCompositeOperation="luminosity",n.drawImage(t.canvas,0,0),n.globalCompositeOperation="color",n.drawImage(t.canvas,0,0),n.globalCompositeOperation="multiply",n.fillStyle=`rgb(${this.states.tint.slice(0,3).join(", ")})`,n.fillRect(0,0,t.canvas.width,t.canvas.height),n.globalCompositeOperation="destination-in",n.globalAlpha=this.states.tint[3]/255,n.drawImage(t.canvas,0,0)):(n.globalAlpha=this.states.tint[3]/255,n.drawImage(t.canvas,0,0)),n.restore(),t.tintCanvas}blendMode(t){if(t===kS)console.warn("blendMode(SUBTRACT) only works in WEBGL mode.");else if(t===Si||t===Uh||t===ES||t===IS||t===iU||t===TS||t===NS||t===AS||t===DS||t===fT||t===mT||t===gT||t===yT||t===bT||t===ob)this._cachedBlendMode=t,this.drawingContext.globalCompositeOperation=t;else throw new Error(`Mode ${t} not recognized.`)}blend(...t){const n=this.drawingContext.globalCompositeOperation,s=t[t.length-1],i=Array.prototype.slice.call(t,0,t.length-1);this.drawingContext.globalCompositeOperation=s,Zr.prototype.copy.apply(this,i),this.drawingContext.globalCompositeOperation=n}_getPixel(t,n){let s,i;return s=this.drawingContext.getImageData(t,n,1,1).data,i=0,[s[i+0],s[i+1],s[i+2],s[i+3]]}loadPixels(){const t=this._pixelDensity,n=this.width*t,s=this.height*t,i=this.drawingContext.getImageData(0,0,n,s);this.imageData=i,this.pixels=i.data}set(t,n,s){if(t=Math.floor(t),n=Math.floor(n),s instanceof Do)this.drawingContext.save(),this.drawingContext.setTransform(1,0,0,1,0,0),this.drawingContext.scale(this._pixelDensity,this._pixelDensity),this.drawingContext.clearRect(t,n,s.width,s.height),this.drawingContext.drawImage(s.canvas,t,n),this.drawingContext.restore();else{let i=0,a=0,o=0,u=0,l=4*(n*this._pixelDensity*(this.width*this._pixelDensity)+t*this._pixelDensity);if(this.imageData||this.loadPixels(),typeof s=="number")l<this.pixels.length&&(i=s,a=s,o=s,u=255);else if(Array.isArray(s)){if(s.length<4)throw new Error("pixel array must be of the form [R, G, B, A]");l<this.pixels.length&&(i=s[0],a=s[1],o=s[2],u=s[3])}else s instanceof Zr.Color&&l<this.pixels.length&&([i,a,o,u]=s._getRGBA([255,255,255,255]));for(let c=0;c<this._pixelDensity;c++)for(let h=0;h<this._pixelDensity;h++)l=4*((n*this._pixelDensity+h)*this.width*this._pixelDensity+(t*this._pixelDensity+c)),this.pixels[l]=i,this.pixels[l+1]=a,this.pixels[l+2]=o,this.pixels[l+3]=u}}updatePixels(t,n,s,i){const a=this._pixelDensity;t===void 0&&n===void 0&&s===void 0&&i===void 0&&(t=0,n=0,s=this.width,i=this.height),t*=a,n*=a,s*=a,i*=a,this.gifProperties&&(this.gifProperties.frames[this.gifProperties.displayIndex].image=this.imageData),this.drawingContext.putImageData(this.imageData,0,0,t,n,s,i)}arc(t,n,s,i,a,o,u){const l=this.clipPa||this.drawingContext,c=t+s/2,h=n+i/2,d=s/2,p=i/2,f=!(u===Lw||u===zh||(o-a)%bi===0);return this.states.fillColor&&(this._clipping||l.beginPath(),l.ellipse(c,h,d,p,0,a,o),f&&l.lineTo(c,h),l.closePath(),this._clipping||l.fill()),this.states.strokeColor&&(this._clipping||l.beginPath(),l.ellipse(c,h,d,p,0,a,o),u===ab&&f&&l.lineTo(c,h),(u===ab||u===Lw)&&l.closePath(),this._clipping||l.stroke()),this}ellipse(t){const n=this.clipPath||this.drawingContext,s=!!this.states.fillColor,i=this.states.strokeColor,a=parseFloat(t[0]),o=parseFloat(t[1]),u=parseFloat(t[2]),l=parseFloat(t[3]);if(s&&!i){if(this._getFill()===Go)return this}else if(!s&&i&&this._getStroke()===Go)return this;const c=a+u/2,h=o+l/2,d=u/2,p=l/2;this._clipping||n.beginPath(),n.ellipse(c,h,d,p,0,0,2*Math.PI),n.closePath(),!this._clipping&&s&&n.fill(),!this._clipping&&i&&n.stroke()}line(t,n,s,i){const a=this.clipPath||this.drawingContext;if(this.states.strokeColor){if(this._getStroke()===Go)return this}else return this;return this._clipping||a.beginPath(),a.moveTo(t,n),a.lineTo(s,i),a.stroke(),this}point(t,n){const s=this.clipPath||this.drawingContext;if(this.states.strokeColor){if(this._getStroke()===Go)return this}else return this;const i=this._getStroke(),a=this._getFill();this._clipping||this._setFill(i),this._clipping||s.beginPath(),s.arc(t,n,s.lineWidth/2,0,bi,!1),this._clipping||(s.fill(),this._setFill(a))}quad(t,n,s,i,a,o,u,l){const c=this.clipPath||this.drawingContext,h=!!this.states.fillColor,d=this.states.strokeColor;if(h&&!d){if(this._getFill()===Go)return this}else if(!h&&d&&this._getStroke()===Go)return this;return this._clipping||c.beginPath(),c.moveTo(t,n),c.lineTo(s,i),c.lineTo(a,o),c.lineTo(u,l),c.closePath(),!this._clipping&&h&&c.fill(),!this._clipping&&d&&c.stroke(),this}rect(t){const n=t[0],s=t[1],i=t[2],a=t[3];let o=t[4],u=t[5],l=t[6],c=t[7];const h=this.clipPath||this.drawingContext,d=!!this.states.fillColor,p=this.states.strokeColor;if(d&&!p){if(this._getFill()===Go)return this}else if(!d&&p&&this._getStroke()===Go)return this;if(this._clipping||h.beginPath(),typeof o>"u")h.rect(n,s,i,a);else{typeof u>"u"&&(u=o),typeof l>"u"&&(l=u),typeof c>"u"&&(c=l);const f=Math.abs(i),m=Math.abs(a),g=f/2,y=m/2;f<2*o&&(o=g),m<2*o&&(o=y),f<2*u&&(u=g),m<2*u&&(u=y),f<2*l&&(l=g),m<2*l&&(l=y),f<2*c&&(c=g),m<2*c&&(c=y),h.roundRect(n,s,i,a,[o,u,l,c])}return!this._clipping&&this.states.fillColor&&h.fill(),!this._clipping&&this.states.strokeColor&&h.stroke(),this}triangle(t){const n=this.clipPath||this.drawingContext,s=!!this.states.fillColor,i=this.states.strokeColor,a=t[0],o=t[1],u=t[2],l=t[3],c=t[4],h=t[5];if(s&&!i){if(this._getFill()===Go)return this}else if(!s&&i&&this._getStroke()===Go)return this;this._clipping||n.beginPath(),n.moveTo(a,o),n.lineTo(u,l),n.lineTo(c,h),n.closePath(),!this._clipping&&s&&n.fill(),!this._clipping&&i&&n.stroke()}strokeCap(t){return(t===Ql||t===hT||t===cT)&&(this.drawingContext.lineCap=t),this}strokeJoin(t){return(t===Ql||t===dT||t===pT)&&(this.drawingContext.lineJoin=t),this}strokeWeight(t){return super.strokeWeight(t),typeof t>"u"||t===0?this.drawingContext.lineWidth=1e-4:this.drawingContext.lineWidth=t,this}_getFill(){return this.states._cachedFillStyle||this.states.setValue("_cachedFillStyle",this.drawingContext.fillStyle),this.states._cachedFillStyle}_setFill(t){t!==this.states._cachedFillStyle&&(this.drawingContext.fillStyle=t,this.states.setValue("_cachedFillStyle",t))}_getStroke(){return this.states._cachedStrokeStyle||this.states.setValue("_cachedStrokeStyle",this.drawingContext.strokeStyle),this.states._cachedStrokeStyle}_setStroke(t){t!==this.states._cachedStrokeStyle&&(this.drawingContext.strokeStyle=t,this.states.setValue("_cachedStrokeStyle",t))}applyMatrix(t,n,s,i,a,o){this.drawingContext.transform(t,n,s,i,a,o)}getWorldToScreenMatrix(){let t=new DOMMatrix().scale(1/this._pixelDensity).multiply(this.drawingContext.getTransform());return new qn(t.toFloat32Array())}resetMatrix(){return this.drawingContext.setTransform(1,0,0,1,0,0),this.drawingContext.scale(this._pixelDensity,this._pixelDensity),this}rotate(t){this.drawingContext.rotate(t)}scale(t,n){return this.drawingContext.scale(t,n),this}translate(t,n){return t instanceof Zr.Vector&&(n=t.y,t=t.x),this.drawingContext.translate(t,n),this}push(){return this.drawingContext.save(),super.push()}pop(t){this.drawingContext.restore(),super.pop(t)}}function uoe(r,t){r.Renderer2D=dE,r.renderers[Vh]=dE,r.renderers["p2d-hdr"]=new Proxy(dE,{construct(n,[s,i,a,o,u]){return new n(s,i,a,o,u,{colorSpace:"display-p3"})}})}var zn,Dd,ZI,q6;let Zr=(zn=class{constructor(t,n){cn(this,Dd);this.hitCriticalError=!1,this._setupDone=!1,this._userNode=n,this._curElement=null,this._elements=[],this._glAttributes=null,this._requestAnimId=0,this._isGlobal=!1,this._loop=!0,this._startListener=null,this._initializeInstanceVariables(),this._events={pointerdown:null,pointerup:null,pointermove:null,dragend:null,dragover:null,click:null,dblclick:null,mouseover:null,mouseout:null,keydown:null,keyup:null,keypress:null,wheel:null,resize:null,blur:null},this._millisStart=-1,this._recording=!1,this._lcg_random_state=null,this._gaussian_previous=!1,window.DeviceOrientationEvent&&(this._events.deviceorientation=null),window.DeviceMotionEvent&&!window._isNodeWebkit&&(this._events.devicemotion=null),this._updateWindowSize();const s=o=>{Object.defineProperty(window,o,{configurable:!0,enumerable:!0,get:()=>typeof this[o]=="function"?this[o].bind(this):this[o],set:u=>{Object.defineProperty(window,o,{configurable:!0,enumerable:!0,value:u,writable:!0}),zn.disableFriendlyErrors||console.log(`You just changed the value of "${o}", which was a p5 global value. This could cause problems later if you're not careful.`)}})};if(t)t(this),zn._checkForUserDefinedFunctions(this);else{if(this._isGlobal=!0,window.hitCriticalError)return;zn.instance=this;for(const u of Object.getOwnPropertyNames(zn.prototype))u[0]!=="_"&&s(u);const o=["constructor","length"];for(const u in this)if(this.hasOwnProperty(u)){if(u[0]==="_"||o.includes(u))continue;s(u)}}for(const o in this._events){const u=this[`_on${o}`];if(u){const l=u.bind(this);window.addEventListener(o,l,{passive:!1}),this._events[o]=l}}const i=()=>{this.focused=!0},a=()=>{this.focused=!1};window.addEventListener("focus",i),window.addEventListener("blur",a),zn.lifecycleHooks.remove.push(function(){window.removeEventListener("focus",i),window.removeEventListener("blur",a)}),document.readyState==="complete"?es(this,Dd,ZI).call(this):(this._startListener=es(this,Dd,ZI).bind(this),window.addEventListener("load",this._startListener,!1))}get pixels(){return this._renderer.pixels}get drawingContext(){return this._renderer.drawingContext}static registerAddon(t){const n={};t(zn,zn.prototype,n);const s=Object.keys(zn.lifecycleHooks);for(const i of s)typeof n[i]=="function"&&zn.lifecycleHooks[i].push(n[i])}async _draw(t){if(this.hitCriticalError)return;const n=t||window.performance.now(),s=n-this._lastTargetFrameTime,i=1e3/this._targetFrameRate;(!this._loop||s>=i-5)&&(this.deltaTime=n-this._lastRealFrameTime,this._frameRate=1e3/this.deltaTime,await this.redraw(),this._lastTargetFrameTime=Math.max(this._lastTargetFrameTime+i,n),this._lastRealFrameTime=n,typeof this._updateMouseCoords<"u"&&(this._updateMouseCoords(),this.movedX=0,this.movedY=0)),this._loop&&(this._requestAnimId=window.requestAnimationFrame(this._draw.bind(this)))}async remove(){if(this._startListener&&window.removeEventListener("load",this._startListener,!1),this._curElement){this._loop=!1,this._requestAnimId&&window.cancelAnimationFrame(this._requestAnimId);for(const t in this._events)window.removeEventListener(t,this._events[t]);for(const t of this._elements){t.elt&&t.elt.parentNode&&t.elt.parentNode.removeChild(t.elt);for(const n in t._events)t.elt.removeEventListener(n,t._events[n])}await this._runLifecycleHook("remove")}if(this._isGlobal){for(const t in zn.prototype)try{delete window[t]}catch{window[t]=void 0}for(const t in this)if(this.hasOwnProperty(t))try{delete window[t]}catch{window[t]=void 0}zn.instance=null}}async _runLifecycleHook(t){for(const n of zn.lifecycleHooks[t])await n.call(this)}_initializeInstanceVariables(){this._accessibleOutputs={text:!1,grid:!1,textLabel:!1,gridLabel:!1},this._styles=[],this._downKeys={},this._downKeyCodes={}}},Dd=new WeakSet,ZI=async function(){this.hitCriticalError||(this._userNode&&typeof this._userNode=="string"&&(this._userNode=document.getElementById(this._userNode)),await es(this,Dd,q6).call(this),!this.hitCriticalError&&(this._recording||this._draw()))},q6=async function(){if(await this._runLifecycleHook("presetup"),this.hitCriticalError)return;this.createCanvas(100,100,Vh),this._millisStart=window.performance.now();const t=this._isGlobal?window:this;if(typeof t.setup=="function"&&await t.setup(),this.hitCriticalError)return;const n=document.getElementsByTagName("canvas");if(Object.keys(this._events).some(s=>s.startsWith("pointer")))for(const s of n)s.style.touchAction="none";for(const s of n)s.dataset.hidden==="true"&&(s.style.visibility="",delete s.dataset.hidden);this._lastTargetFrameTime=window.performance.now(),this._lastRealFrameTime=window.performance.now(),this._setupDone=!0,(this._accessibleOutputs.grid||this._accessibleOutputs.text)&&this._updateAccsOutput(),await this._runLifecycleHook("postsetup")},Ar(zn,"VERSION",Xz),Ar(zn,"instance",null),Ar(zn,"lifecycleHooks",{presetup:[],postsetup:[],predraw:[],postdraw:[],remove:[]}),Ar(zn,"_checkForUserDefinedFunctions",()=>{}),Ar(zn,"_friendlyFileLoadError",()=>{}),zn);for(const r in Wh)Zr.prototype[r]=Wh[r];Zr.disableFriendlyErrors=!1;Zr.registerAddon(_T);Zr.registerAddon(gU);Zr.registerAddon(bU);Zr.registerAddon(j6);Zr.registerAddon(hae);Zr.registerAddon(uoe);Zr.registerAddon(aoe);function loe(r){r.registerAddon($T),r.registerAddon(RT),r.registerAddon(OT),r.registerAddon(MT),r.registerAddon(TT)}function K6(r,t){const n="_Description",s="_fallbackDesc",i="_fallbackTable",a="_fte_",o="_Label",u="_labelDesc",l="_labelTable",c="_lte_";t.describe=function(p,f){if(typeof p!="string")return;const m=this.canvas.id;p=h(p),this.dummyDOM||(this.dummyDOM=document.getElementById(m).parentNode),this.descriptions||(this.descriptions={}),this.descriptions.fallback?this.descriptions.fallback.innerHTML!==p&&(this.descriptions.fallback.innerHTML=p):this._describeHTML("fallback",p),f===this.LABEL&&(this.descriptions.label?this.descriptions.label.innerHTML!==p&&(this.descriptions.label.innerHTML=p):this._describeHTML("label",p))},t.describeElement=function(p,f,m){if(typeof f!="string"||typeof p!="string")return;const g=this.canvas.id;f=h(f);let y=d(p);p=p.replace(/[^a-zA-Z0-9]/g,"");let b=`<th scope="row">${y}</th><td>${f}</td>`;this.dummyDOM||(this.dummyDOM=document.getElementById(g).parentNode),this.descriptions?this.descriptions.fallbackElements||(this.descriptions.fallbackElements={}):this.descriptions={fallbackElements:{}},this.descriptions.fallbackElements[p]?this.descriptions.fallbackElements[p].innerHTML!==b&&(this.descriptions.fallbackElements[p].innerHTML=b):this._describeElementHTML("fallback",p,b),m===this.LABEL&&(this.descriptions.labelElements||(this.descriptions.labelElements={}),this.descriptions.labelElements[p]?this.descriptions.labelElements[p].innerHTML!==b&&(this.descriptions.labelElements[p].innerHTML=b):this._describeElementHTML("label",p,b))};function h(p){if(p==="label"||p==="fallback")throw new Error("description should not be LABEL or FALLBACK");return!p.endsWith(".")&&!p.endsWith(";")&&!p.endsWith(",")&&!p.endsWith("?")&&!p.endsWith("!")&&(p=p+"."),p}t._describeHTML=function(p,f){const m=this.canvas.id;if(p==="fallback"){if(this.dummyDOM.querySelector(`#${m+n}`))this.dummyDOM.querySelector("#"+m+i).insertAdjacentHTML("beforebegin",`<p id="${m+s}"></p>`);else{let g=`<div id="${m}${n}" role="region" aria-label="Canvas Description"><p id="${m}${s}"></p></div>`;this.dummyDOM.querySelector(`#${m}accessibleOutput`)?this.dummyDOM.querySelector(`#${m}accessibleOutput`).insertAdjacentHTML("beforebegin",g):this.dummyDOM.querySelector(`#${m}`).innerHTML=g}this.descriptions.fallback=this.dummyDOM.querySelector(`#${m}${s}`),this.descriptions.fallback.innerHTML=f;return}else if(p==="label"){if(this.dummyDOM.querySelector(`#${m+o}`))this.dummyDOM.querySelector(`#${m+l}`)&&this.dummyDOM.querySelector(`#${m+l}`).insertAdjacentHTML("beforebegin",`<p id="${m}${u}"></p>`);else{let g=`<div id="${m}${o}" class="p5Label"><p id="${m}${u}"></p></div>`;this.dummyDOM.querySelector(`#${m}accessibleOutputLabel`)?this.dummyDOM.querySelector(`#${m}accessibleOutputLabel`).insertAdjacentHTML("beforebegin",g):this.dummyDOM.querySelector("#"+m).insertAdjacentHTML("afterend",g)}this.descriptions.label=this.dummyDOM.querySelector("#"+m+u),this.descriptions.label.innerHTML=f;return}};function d(p){if(p==="label"||p==="fallback")throw new Error("element name should not be LABEL or FALLBACK");return p.endsWith(".")||p.endsWith(";")||p.endsWith(",")?p=p.replace(/.$/,":"):p.endsWith(":")||(p=p+":"),p}t._describeElementHTML=function(p,f,m){const g=this.canvas.id;if(p==="fallback"){if(this.dummyDOM.querySelector(`#${g+n}`))this.dummyDOM.querySelector("#"+g+i)||this.dummyDOM.querySelector("#"+g+s).insertAdjacentHTML("afterend",`<table id="${g}${i}"><caption>Canvas elements and their descriptions</caption></table>`);else{let b=`<div id="${g}${n}" role="region" aria-label="Canvas Description"><table id="${g}${i}"><caption>Canvas elements and their descriptions</caption></table></div>`;this.dummyDOM.querySelector(`#${g}accessibleOutput`)?this.dummyDOM.querySelector(`#${g}accessibleOutput`).insertAdjacentHTML("beforebegin",b):this.dummyDOM.querySelector("#"+g).innerHTML=b}let y=document.createElement("tr");y.id=g+a+f,this.dummyDOM.querySelector("#"+g+i).appendChild(y),this.descriptions.fallbackElements[f]=this.dummyDOM.querySelector(`#${g}${a}${f}`),this.descriptions.fallbackElements[f].innerHTML=m;return}else if(p==="label"){if(this.dummyDOM.querySelector(`#${g+o}`))this.dummyDOM.querySelector(`#${g+l}`)||this.dummyDOM.querySelector("#"+g+u).insertAdjacentHTML("afterend",`<table id="${g+l}"></table>`);else{let b=`<div id="${g}${o}" class="p5Label"><table id="${g}${l}"></table></div>`;this.dummyDOM.querySelector(`#${g}accessibleOutputLabel`)?this.dummyDOM.querySelector(`#${g}accessibleOutputLabel`).insertAdjacentHTML("beforebegin",b):this.dummyDOM.querySelector("#"+g).insertAdjacentHTML("afterend",b)}let y=document.createElement("tr");y.id=g+c+f,this.dummyDOM.querySelector("#"+g+l).appendChild(y),this.descriptions.labelElements[f]=this.dummyDOM.querySelector(`#${g}${c}${f}`),this.descriptions.labelElements[f].innerHTML=m}}}typeof p5<"u"&&K6(p5,p5.prototype);function X6(r,t){t._updateGridOutput=function(a){if(!this.dummyDOM.querySelector(`#${a}_summary`))return;let o=this._accessibleOutputs[a],u=i(a,this.ingredients.shapes),l=s(u.numShapes,this.ingredients.colors.background,this.width,this.height),c=n(a,this.ingredients.shapes);l!==o.summary.innerHTML&&(o.summary.innerHTML=l),c!==o.map.innerHTML&&(o.map.innerHTML=c),u.details!==o.shapeDetails.innerHTML&&(o.shapeDetails.innerHTML=u.details),this._accessibleOutputs[a]=o};function n(a,o){let u=0,l="",c=Array.from(Array(10),()=>Array(10));for(let h in o)for(let d in o[h]){let p;h!=="line"?p=`<a href="#${a}shape${u}">${o[h][d].color} ${h}</a>`:p=`<a href="#${a}shape${u}">${o[h][d].color} ${h} midpoint</a>`,o[h][d].loc.locY<c.length&&o[h][d].loc.locX<c[o[h][d].loc.locY].length&&(c[o[h][d].loc.locY][o[h][d].loc.locX]?c[o[h][d].loc.locY][o[h][d].loc.locX]=c[o[h][d].loc.locY][o[h][d].loc.locX]+"  "+p:c[o[h][d].loc.locY][o[h][d].loc.locX]=p,u++)}for(let h in c){let d="<tr>";for(let p in c[h])d=d+"<td>",c[h][p]!==void 0&&(d=d+c[h][p]),d=d+"</td>";l=l+d+"</tr>"}return l}function s(a,o,u,l){let c=`${o} canvas, ${u} by ${l} pixels, contains ${a[0]}`;return a[0]===1?c=`${c} shape: ${a[1]}`:c=`${c} shapes: ${a[1]}`,c}function i(a,o){let u="",l="",c=0;for(let h in o){let d=0;for(let p in o[h]){let f=`<li id="${a}shape${c}">${o[h][p].color} ${h},`;h==="line"?f=f+` location = ${o[h][p].pos}, length = ${o[h][p].length} pixels`:(f=f+` location = ${o[h][p].pos}`,h!=="point"&&(f=f+`, area = ${o[h][p].area} %`),f=f+"</li>"),u=u+f,d++,c++}d>1?l=`${l} ${d} ${h}s`:l=`${l} ${d} ${h}`}return{numShapes:[c,l],details:u}}}typeof p5<"u"&&X6(p5,p5.prototype);function Y6(r,t){t._updateTextOutput=function(a){if(!this.dummyDOM.querySelector(`#${a}_summary`))return;let o=this._accessibleOutputs[a],u=i(a,this.ingredients.shapes),l=n(u.numShapes,this.ingredients.colors.background,this.width,this.height),c=s(a,this.ingredients.shapes);l!==o.summary.innerHTML&&(o.summary.innerHTML=l),u.listShapes!==o.list.innerHTML&&(o.list.innerHTML=u.listShapes),c!==o.shapeDetails.innerHTML&&(o.shapeDetails.innerHTML=c),this._accessibleOutputs[a]=o};function n(a,o,u,l){let c=`Your output is a, ${u} by ${l} pixels, ${o} canvas containing the following`;return a===1?c=`${c} shape:`:c=`${c} ${a} shapes:`,c}function s(a,o){let u="",l=0;for(let c in o)for(let h in o[c]){let d=`<tr id="${a}shape${l}"><th>${o[c][h].color} ${c}</th>`;c==="line"?d=d+`<td>location = ${o[c][h].pos}</td><td>length = ${o[c][h].length} pixels</td></tr>`:(d=d+`<td>location = ${o[c][h].pos}</td>`,c!=="point"&&(d=d+`<td> area = ${o[c][h].area}%</td>`),d=d+"</tr>"),u=u+d,l++}return u}function i(a,o){let u="",l=0;for(let c in o)for(let h in o[c]){let d=`<li><a href="#${a}shape${l}">${o[c][h].color} ${c}</a>`;c==="line"?d=d+`, ${o[c][h].pos}, ${o[c][h].length} pixels long.</li>`:(d=d+`, at ${o[c][h].pos}`,c!=="point"&&(d=d+`, covering ${o[c][h].area}% of the canvas`),d=d+".</li>"),u=u+d,l++}return{numShapes:l,listShapes:u}}}typeof p5<"u"&&Y6(p5,p5.prototype);function Z6(r,t){t.textOutput=function(i){this._accessibleOutputs.text||(this._accessibleOutputs.text=!0,this._createOutput("textOutput","Fallback"),i===this.LABEL&&(this._accessibleOutputs.textLabel=!0,this._createOutput("textOutput","Label")))},t.gridOutput=function(i){this._accessibleOutputs.grid||(this._accessibleOutputs.grid=!0,this._createOutput("gridOutput","Fallback"),i===this.LABEL&&(this._accessibleOutputs.gridLabel=!0,this._createOutput("gridOutput","Label")))},t._addAccsOutput=function(){return this._accessibleOutputs||(this._accessibleOutputs={text:!1,grid:!1,textLabel:!1,gridLabel:!1}),this._accessibleOutputs.grid||this._accessibleOutputs.text},t._createOutput=function(i,a){let o=this.canvas.id;this.ingredients||(this.ingredients={shapes:{},colors:{background:"white",fill:"white",stroke:"black"},pShapes:"",pBackground:""}),this.dummyDOM||(this.dummyDOM=document.getElementById(o).parentNode);let u,l,c,h="";a==="Fallback"?(u=o+i,l=o+"accessibleOutput",this.dummyDOM.querySelector(`#${l}`)||(this.dummyDOM.querySelector(`#${o}_Description`)?this.dummyDOM.querySelector(`#${o}_Description`).insertAdjacentHTML("afterend",`<div id="${l}" role="region" aria-label="Canvas Outputs"></div>`):this.dummyDOM.querySelector(`#${o}`).innerHTML=`<div id="${l}" role="region" aria-label="Canvas Outputs"></div>`)):a==="Label"&&(h=a,u=o+i+a,l=o+"accessibleOutput"+a,this.dummyDOM.querySelector(`#${l}`)||(this.dummyDOM.querySelector(`#${o}_Label`)?this.dummyDOM.querySelector(`#${o}_Label`).insertAdjacentHTML("afterend",`<div id="${l}"></div>`):this.dummyDOM.querySelector(`#${o}`).insertAdjacentHTML("afterend",`<div id="${l}"></div>`))),this._accessibleOutputs[u]={},i==="textOutput"?(h=`#${o}gridOutput${h}`,c=`<div id="${u}">Text Output<div id="${u}Summary" aria-label="text output summary"><p id="${u}_summary"></p><ul id="${u}_list"></ul></div><table id="${u}_shapeDetails" summary="text output shape details"></table></div>`,this.dummyDOM.querySelector(h)?this.dummyDOM.querySelector(h).insertAdjacentHTML("beforebegin",c):this.dummyDOM.querySelector(`#${l}`).innerHTML=c,this._accessibleOutputs[u].list=this.dummyDOM.querySelector(`#${u}_list`)):i==="gridOutput"&&(h=`#${o}textOutput${h}`,c=`<div id="${u}">Grid Output<p id="${u}_summary" aria-label="grid output summary"><table id="${u}_map" summary="grid output content"></table><ul id="${u}_shapeDetails" aria-label="grid output shape details"></ul></div>`,this.dummyDOM.querySelector(h)?this.dummyDOM.querySelector(h).insertAdjacentHTML("afterend",c):this.dummyDOM.querySelector(`#${l}`).innerHTML=c,this._accessibleOutputs[u].map=this.dummyDOM.querySelector(`#${u}_map`)),this._accessibleOutputs[u].shapeDetails=this.dummyDOM.querySelector(`#${u}_shapeDetails`),this._accessibleOutputs[u].summary=this.dummyDOM.querySelector(`#${u}_summary`)},t._updateAccsOutput=function(){let i=this.canvas.id;(JSON.stringify(this.ingredients.shapes)!==this.ingredients.pShapes||this.ingredients.colors.background!==this.ingredients.pBackground)&&(this.ingredients.pShapes=JSON.stringify(this.ingredients.shapes),this._accessibleOutputs.text&&this._updateTextOutput(i+"textOutput"),this._accessibleOutputs.grid&&this._updateGridOutput(i+"gridOutput"),this._accessibleOutputs.textLabel&&this._updateTextOutput(i+"textOutputLabel"),this._accessibleOutputs.gridLabel&&this._updateGridOutput(i+"gridOutputLabel"))},t._accsBackground=function(i){this.ingredients.pShapes=JSON.stringify(this.ingredients.shapes),this.ingredients.pBackground=this.ingredients.colors.background,this.ingredients.shapes={},this.ingredients.colors.backgroundRGBA!==i&&(this.ingredients.colors.backgroundRGBA=i,this.ingredients.colors.background=this._rgbColorName(i))},t._accsCanvasColors=function(i,a){i==="fill"?this.ingredients.colors.fillRGBA!==a&&(this.ingredients.colors.fillRGBA=a,this.ingredients.colors.fill=this._rgbColorName(a)):i==="stroke"&&this.ingredients.colors.strokeRGBA!==a&&(this.ingredients.colors.strokeRGBA=a,this.ingredients.colors.stroke=this._rgbColorName(a))},t._accsOutput=function(i,a){i==="ellipse"&&a[2]===a[3]?i="circle":i==="rectangle"&&a[2]===a[3]&&(i="square");let o={},u=!0,l=n(i,a);if(i==="line"){o.color=this.ingredients.colors.stroke,o.length=Math.round(Math.hypot(a[2]-a[0],a[3]-a[1]));let c=this._getPos(a[0],[1]),h=this._getPos(a[2],[3]);o.loc=s(l,this.width,this.height),c===h?o.pos=`at ${c}`:o.pos=`from ${c} to ${h}`}else i==="point"?o.color=this.ingredients.colors.stroke:(o.color=this.ingredients.colors.fill,o.area=this._getArea(i,a)),o.pos=this._getPos(...l),o.loc=s(l,this.width,this.height);if(!this.ingredients.shapes[i])this.ingredients.shapes[i]=[o];else if(this.ingredients.shapes[i]!==[o]){for(let c in this.ingredients.shapes[i])JSON.stringify(this.ingredients.shapes[i][c])===JSON.stringify(o)&&(u=!1);u===!0&&this.ingredients.shapes[i].push(o)}};function n(i,a){let o,u;return i==="rectangle"||i==="ellipse"||i==="arc"||i==="circle"||i==="square"?(o=Math.round(a[0]+a[2]/2),u=Math.round(a[1]+a[3]/2)):i==="triangle"?(o=(a[0]+a[2]+a[4])/3,u=(a[1]+a[3]+a[5])/3):i==="quadrilateral"?(o=(a[0]+a[2]+a[4]+a[6])/4,u=(a[1]+a[3]+a[5]+a[7])/4):i==="line"?(o=(a[0]+a[2])/2,u=(a[1]+a[3])/2):(o=a[0],u=a[1]),[o,u]}t._getPos=function(i,a){const{x:o,y:u}=this.worldToScreen(new r.Vector(i,a)),l=this.width,c=this.height;return o<.4*l?u<.4*c?"top left":u>.6*c?"bottom left":"mid left":o>.6*l?u<.4*c?"top right":u>.6*c?"bottom right":"mid right":u<.4*c?"top middle":u>.6*c?"bottom middle":"middle"};function s(i,a,o){let c=Math.floor(i[0]/a*10),h=Math.floor(i[1]/o*10);return c===10&&(c=c-1),h===10&&(h=h-1),{locX:c,locY:h}}t._getArea=function(i,a){let o=0;if(i==="arc"){const g=((a[5]-a[4])%(Math.PI*2)+Math.PI*2)%(Math.PI*2);if(o=g*a[2]*a[3]/8,a[6]==="open"||a[6]==="chord"){const y=a[0],b=a[1],x=a[0]+a[2]/2*Math.cos(a[4]).toFixed(2),w=a[1]+a[3]/2*Math.sin(a[4]).toFixed(2),v=a[0]+a[2]/2*Math.cos(a[5]).toFixed(2),S=a[1]+a[3]/2*Math.sin(a[5]).toFixed(2),E=Math.abs(y*(w-S)+x*(S-b)+v*(b-w))/2;g>Math.PI?o=o+E:o=o-E}}else i==="ellipse"||i==="circle"?o=3.14*a[2]/2*a[3]/2:i==="line"||i==="point"?o=0:i==="quadrilateral"?o=Math.abs((a[6]+a[0])*(a[7]-a[1])+(a[0]+a[2])*(a[1]-a[3])+(a[2]+a[4])*(a[3]-a[5])+(a[4]+a[6])*(a[5]-a[7]))/2:i==="rectangle"||i==="square"?o=a[2]*a[3]:i==="triangle"&&(o=Math.abs(a[0]*(a[3]-a[5])+a[2]*(a[5]-a[1])+a[4]*(a[1]-a[3]))/2);const u=this.width*this._renderer._pixelDensity,l=this.height*this._renderer._pixelDensity,c=[new DOMPoint(0,0),new DOMPoint(u,0),new DOMPoint(u,l),new DOMPoint(0,l)],d=(this._renderer.isP3D?new DOMMatrix(this._renderer.uMVMatrix.mat4):this.drawingContext.getTransform()).inverse(),p=c.map(g=>g.matrixTransform(d)),f=Math.abs((p[3].x+p[0].x)*(p[3].y-p[0].y)+(p[0].x+p[1].x)*(p[0].y-p[1].y)+(p[1].x+p[2].x)*(p[1].y-p[2].y)+(p[2].x+p[3].x)*(p[2].y-p[3].y))/2;return Math.round(o*100/f)}}typeof p5<"u"&&Z6(p5,p5.prototype);Zr.ColorConversion={_hsbaToHSLA(r){const t=r[0];let n=r[1];const s=r[2],i=(2-n)*s/2;return i!==0&&(i===1?n=0:i<.5?n=n/(2-n):n=n*s/(2-i*2)),[t,n,i,r[3]]},_hsbaToRGBA(r){const t=r[0]*6,n=r[1],s=r[2];let i=[];if(n===0)i=[s,s,s,r[3]];else{const a=Math.floor(t),o=s*(1-n),u=s*(1-n*(t-a)),l=s*(1-n*(1+a-t));let c,h,d;a===1?(c=u,h=s,d=o):a===2?(c=o,h=s,d=l):a===3?(c=o,h=u,d=s):a===4?(c=l,h=o,d=s):a===5?(c=s,h=o,d=u):(c=s,h=l,d=o),i=[c,h,d,r[3]]}return i},_hslaToHSBA(r){const t=r[0];let n=r[1];const s=r[2];let i;return s<.5?i=(1+n)*s:i=s+n-s*n,n=2*(i-s)/i,[t,n,i,r[3]]},_hslaToRGBA(r){const t=r[0]*6,n=r[1],s=r[2];let i=[];if(n===0)i=[s,s,s,r[3]];else{let a;s<.5?a=(1+n)*s:a=s+n-s*n;const o=2*s-a,u=(l,c,h)=>(l<0?l+=6:l>=6&&(l-=6),l<1?c+(h-c)*l:l<3?h:l<4?c+(h-c)*(4-l):c);i=[u(t+2,o,a),u(t,o,a),u(t-2,o,a),r[3]]}return i},_rgbaToHSBA(r){const t=r[0],n=r[1],s=r[2],i=Math.max(t,n,s),a=i-Math.min(t,n,s);let o,u;return a===0?(o=0,u=0):(u=a/i,t===i?o=(n-s)/a:n===i?o=2+(s-t)/a:s===i&&(o=4+(t-n)/a),o<0?o+=6:o>=6&&(o-=6)),[o/6,u,i,r[3]]},_rgbaToHSLA(r){const t=r[0],n=r[1],s=r[2],i=Math.max(t,n,s),a=Math.min(t,n,s),o=i+a,u=i-a;let l,c;return u===0?(l=0,c=0):(o<1?c=u/o:c=u/(2-o),t===i?l=(n-s)/u:n===i?l=2+(s-t)/u:s===i&&(l=4+(t-n)/u),l<0?l+=6:l>=6&&(l-=6)),[l/6,c,o/2,r[3]]}};var coe=Zr.ColorConversion;function J6(r,t){let n;const s=[{h:0,s:0,b:.8275,name:"gray"},{h:0,s:0,b:.8627,name:"gray"},{h:0,s:0,b:.7529,name:"gray"},{h:.0167,s:.1176,b:1,name:"light pink"}],i=[{h:0,s:0,b:0,name:"black"},{h:0,s:0,b:.5,name:"gray"},{h:0,s:0,b:1,name:"white"},{h:0,s:.5,b:.5,name:"dark maroon"},{h:0,s:.5,b:1,name:"salmon pink"},{h:0,s:1,b:0,name:"black"},{h:0,s:1,b:.5,name:"dark red"},{h:0,s:1,b:1,name:"red"},{h:5,s:0,b:1,name:"very light peach"},{h:5,s:.5,b:.5,name:"brown"},{h:5,s:.5,b:1,name:"peach"},{h:5,s:1,b:.5,name:"brick red"},{h:5,s:1,b:1,name:"crimson"},{h:10,s:0,b:1,name:"light peach"},{h:10,s:.5,b:.5,name:"brown"},{h:10,s:.5,b:1,name:"light orange"},{h:10,s:1,b:.5,name:"brown"},{h:10,s:1,b:1,name:"orange"},{h:15,s:0,b:1,name:"very light yellow"},{h:15,s:.5,b:.5,name:"olive green"},{h:15,s:.5,b:1,name:"light yellow"},{h:15,s:1,b:0,name:"dark olive green"},{h:15,s:1,b:.5,name:"olive green"},{h:15,s:1,b:1,name:"yellow"},{h:20,s:0,b:1,name:"very light yellow"},{h:20,s:.5,b:.5,name:"olive green"},{h:20,s:.5,b:1,name:"light yellow green"},{h:20,s:1,b:0,name:"dark olive green"},{h:20,s:1,b:.5,name:"dark yellow green"},{h:20,s:1,b:1,name:"yellow green"},{h:25,s:.5,b:.5,name:"dark yellow green"},{h:25,s:.5,b:1,name:"light green"},{h:25,s:1,b:.5,name:"dark green"},{h:25,s:1,b:1,name:"green"},{h:30,s:.5,b:1,name:"light green"},{h:30,s:1,b:.5,name:"dark green"},{h:30,s:1,b:1,name:"green"},{h:35,s:0,b:.5,name:"light green"},{h:35,s:0,b:1,name:"very light green"},{h:35,s:.5,b:.5,name:"dark green"},{h:35,s:.5,b:1,name:"light green"},{h:35,s:1,b:0,name:"very dark green"},{h:35,s:1,b:.5,name:"dark green"},{h:35,s:1,b:1,name:"green"},{h:40,s:0,b:1,name:"very light green"},{h:40,s:.5,b:.5,name:"dark green"},{h:40,s:.5,b:1,name:"light green"},{h:40,s:1,b:.5,name:"dark green"},{h:40,s:1,b:1,name:"green"},{h:45,s:.5,b:1,name:"light turquoise"},{h:45,s:1,b:.5,name:"dark turquoise"},{h:45,s:1,b:1,name:"turquoise"},{h:50,s:0,b:1,name:"light sky blue"},{h:50,s:.5,b:.5,name:"dark cyan"},{h:50,s:.5,b:1,name:"light cyan"},{h:50,s:1,b:.5,name:"dark cyan"},{h:50,s:1,b:1,name:"cyan"},{h:55,s:0,b:1,name:"light sky blue"},{h:55,s:.5,b:1,name:"light sky blue"},{h:55,s:1,b:.5,name:"dark blue"},{h:55,s:1,b:1,name:"sky blue"},{h:60,s:0,b:.5,name:"gray"},{h:60,s:0,b:1,name:"very light blue"},{h:60,s:.5,b:.5,name:"blue"},{h:60,s:.5,b:1,name:"light blue"},{h:60,s:1,b:.5,name:"navy blue"},{h:60,s:1,b:1,name:"blue"},{h:65,s:0,b:1,name:"lavender"},{h:65,s:.5,b:.5,name:"navy blue"},{h:65,s:.5,b:1,name:"light purple"},{h:65,s:1,b:.5,name:"dark navy blue"},{h:65,s:1,b:1,name:"blue"},{h:70,s:0,b:1,name:"lavender"},{h:70,s:.5,b:.5,name:"navy blue"},{h:70,s:.5,b:1,name:"lavender blue"},{h:70,s:1,b:.5,name:"dark navy blue"},{h:70,s:1,b:1,name:"blue"},{h:75,s:.5,b:1,name:"lavender"},{h:75,s:1,b:.5,name:"dark purple"},{h:75,s:1,b:1,name:"purple"},{h:80,s:.5,b:1,name:"pinkish purple"},{h:80,s:1,b:.5,name:"dark purple"},{h:80,s:1,b:1,name:"purple"},{h:85,s:0,b:1,name:"light pink"},{h:85,s:.5,b:.5,name:"purple"},{h:85,s:.5,b:1,name:"light fuchsia"},{h:85,s:1,b:.5,name:"dark fuchsia"},{h:85,s:1,b:1,name:"fuchsia"},{h:90,s:.5,b:.5,name:"dark fuchsia"},{h:90,s:.5,b:1,name:"hot pink"},{h:90,s:1,b:.5,name:"dark fuchsia"},{h:90,s:1,b:1,name:"fuchsia"},{h:95,s:0,b:1,name:"pink"},{h:95,s:.5,b:1,name:"light pink"},{h:95,s:1,b:.5,name:"dark magenta"},{h:95,s:1,b:1,name:"magenta"}];function a(o){let u;if(o[0]!==0){o[0]=Math.round(o[0]*100);let l=o[0].toString().split("");const c=l.length-1;l[c]=parseInt(l[c]),l[c]<2.5?l[c]=0:l[c]>=2.5&&l[c]<7.5&&(l[c]=5),l.length===2?(l[0]=parseInt(l[0]),l[c]>=7.5&&(l[c]=0,l[0]=l[0]+1),o[0]=l[0]*10+l[1]):l[c]>=7.5?o[0]=10:o[0]=l[c]}o[2]=o[2]/255;for(let l=o.length-1;l>=1;l--)o[l]<=.25?o[l]=0:o[l]>.25&&o[l]<.75?o[l]=.5:o[l]=1;if(o[0]===0&&o[1]===0&&o[2]===1){for(let l=2;l>=0;l--)n[l]=Math.round(n[l]*1e4)/1e4;for(let l=0;l<s.length;l++)if(s[l].h===n[0]&&s[l].s===n[1]&&s[l].b===n[2]){u=s[l].name;break}else u="white"}else for(let l=0;l<i.length;l++)if(i[l].h===o[0]&&i[l].s===o[1]&&i[l].b===o[2]){u=i[l].name;break}return u}t._rgbColorName=function(o){let u=coe._rgbaToHSBA(o);return n=u,a([u[0],u[1],u[2]])}}typeof p5<"u"&&J6(p5,p5.prototype);function hoe(r){r.registerAddon(K6),r.registerAddon(X6),r.registerAddon(Y6),r.registerAddon(Z6),r.registerAddon(J6)}function doe(r){r.registerAddon(kT),r.registerAddon(LU),r.registerAddon(LT)}function Io(r){"@babel/helpers - typeof";return Io=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Io(r)}function poe(r,t){if(Io(r)!="object"||!r)return r;var n=r[Symbol.toPrimitive];if(n!==void 0){var s=n.call(r,t);if(Io(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(r)}function Q6(r){var t=poe(r,"string");return Io(t)=="symbol"?t:t+""}function foe(r,t,n){return(t=Q6(t))in r?Object.defineProperty(r,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):r[t]=n,r}function Js(r){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?Object(arguments[t]):{},s=Object.keys(n);typeof Object.getOwnPropertySymbols=="function"&&s.push.apply(s,Object.getOwnPropertySymbols(n).filter(function(i){return Object.getOwnPropertyDescriptor(n,i).enumerable})),s.forEach(function(i){foe(r,i,n[i])})}return r}function vu(r,t){if(!(r instanceof t))throw new TypeError("Cannot call a class as a function")}function eB(r,t){for(var n=0;n<t.length;n++){var s=t[n];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(r,Q6(s.key),s)}}function wu(r,t,n){return t&&eB(r.prototype,t),n&&eB(r,n),Object.defineProperty(r,"prototype",{writable:!1}),r}function Xh(r){if(r===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return r}function fb(r,t){if(t&&(Io(t)=="object"||typeof t=="function"))return t;if(t!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return Xh(r)}function Im(r){return Im=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Im(r)}function JI(r,t){return JI=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,s){return n.__proto__=s,n},JI(r,t)}function MS(r,t){if(typeof t!="function"&&t!==null)throw new TypeError("Super expression must either be null or a function");r.prototype=Object.create(t&&t.prototype,{constructor:{value:r,writable:!0,configurable:!0}}),Object.defineProperty(r,"prototype",{writable:!1}),t&&JI(r,t)}var moe={type:"logger",log:function(t){this.output("log",t)},warn:function(t){this.output("warn",t)},error:function(t){this.output("error",t)},output:function(t,n){console&&console[t]&&console[t].apply(console,n)}},goe=function(){function r(t){var n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};vu(this,r),this.init(t,n)}return wu(r,[{key:"init",value:function(n){var s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};this.prefix=s.prefix||"i18next:",this.logger=n||moe,this.options=s,this.debug=s.debug}},{key:"setDebug",value:function(n){this.debug=n}},{key:"log",value:function(){for(var n=arguments.length,s=new Array(n),i=0;i<n;i++)s[i]=arguments[i];return this.forward(s,"log","",!0)}},{key:"warn",value:function(){for(var n=arguments.length,s=new Array(n),i=0;i<n;i++)s[i]=arguments[i];return this.forward(s,"warn","",!0)}},{key:"error",value:function(){for(var n=arguments.length,s=new Array(n),i=0;i<n;i++)s[i]=arguments[i];return this.forward(s,"error","")}},{key:"deprecate",value:function(){for(var n=arguments.length,s=new Array(n),i=0;i<n;i++)s[i]=arguments[i];return this.forward(s,"warn","WARNING DEPRECATED: ",!0)}},{key:"forward",value:function(n,s,i,a){return a&&!this.debug?null:(typeof n[0]=="string"&&(n[0]="".concat(i).concat(this.prefix," ").concat(n[0])),this.logger[s](n))}},{key:"create",value:function(n){return new r(this.logger,Js({},{prefix:"".concat(this.prefix,":").concat(n,":")},this.options))}}]),r}(),qu=new goe,ac=function(){function r(){vu(this,r),this.observers={}}return wu(r,[{key:"on",value:function(n,s){var i=this;return n.split(" ").forEach(function(a){i.observers[a]=i.observers[a]||[],i.observers[a].push(s)}),this}},{key:"off",value:function(n,s){if(this.observers[n]){if(!s){delete this.observers[n];return}this.observers[n]=this.observers[n].filter(function(i){return i!==s})}}},{key:"emit",value:function(n){for(var s=arguments.length,i=new Array(s>1?s-1:0),a=1;a<s;a++)i[a-1]=arguments[a];if(this.observers[n]){var o=[].concat(this.observers[n]);o.forEach(function(l){l.apply(void 0,i)})}if(this.observers["*"]){var u=[].concat(this.observers["*"]);u.forEach(function(l){l.apply(l,[n].concat(i))})}}}]),r}();function uy(){var r,t,n=new Promise(function(s,i){r=s,t=i});return n.resolve=r,n.reject=t,n}function tB(r){return r==null?"":""+r}function yoe(r,t,n){r.forEach(function(s){t[s]&&(n[s]=t[s])})}function XT(r,t,n){function s(u){return u&&u.indexOf("###")>-1?u.replace(/###/g,"."):u}function i(){return!r||typeof r=="string"}for(var a=typeof t!="string"?[].concat(t):t.split(".");a.length>1;){if(i())return{};var o=s(a.shift());!r[o]&&n&&(r[o]=new n),Object.prototype.hasOwnProperty.call(r,o)?r=r[o]:r={}}return i()?{}:{obj:r,k:s(a.shift())}}function rB(r,t,n){var s=XT(r,t,Object),i=s.obj,a=s.k;i[a]=n}function boe(r,t,n,s){var i=XT(r,t,Object),a=i.obj,o=i.k;a[o]=a[o]||[],a[o].push(n)}function Xw(r,t){var n=XT(r,t),s=n.obj,i=n.k;if(s)return s[i]}function nB(r,t,n){var s=Xw(r,n);return s!==void 0?s:Xw(t,n)}function eW(r,t,n){for(var s in t)s!=="__proto__"&&s!=="constructor"&&(s in r?typeof r[s]=="string"||r[s]instanceof String||typeof t[s]=="string"||t[s]instanceof String?n&&(r[s]=t[s]):eW(r[s],t[s],n):r[s]=t[s]);return r}function Of(r){return r.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}var xoe={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"};function voe(r){return typeof r=="string"?r.replace(/[&<>"'\/]/g,function(t){return xoe[t]}):r}var LS=typeof window<"u"&&window.navigator&&window.navigator.userAgent&&window.navigator.userAgent.indexOf("MSIE")>-1,woe=function(r){MS(t,r);function t(n){var s,i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{ns:["translation"],defaultNS:"translation"};return vu(this,t),s=fb(this,Im(t).call(this)),LS&&ac.call(Xh(s)),s.data=n||{},s.options=i,s.options.keySeparator===void 0&&(s.options.keySeparator="."),s}return wu(t,[{key:"addNamespaces",value:function(s){this.options.ns.indexOf(s)<0&&this.options.ns.push(s)}},{key:"removeNamespaces",value:function(s){var i=this.options.ns.indexOf(s);i>-1&&this.options.ns.splice(i,1)}},{key:"getResource",value:function(s,i,a){var o=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{},u=o.keySeparator!==void 0?o.keySeparator:this.options.keySeparator,l=[s,i];return a&&typeof a!="string"&&(l=l.concat(a)),a&&typeof a=="string"&&(l=l.concat(u?a.split(u):a)),s.indexOf(".")>-1&&(l=s.split(".")),Xw(this.data,l)}},{key:"addResource",value:function(s,i,a,o){var u=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{silent:!1},l=this.options.keySeparator;l===void 0&&(l=".");var c=[s,i];a&&(c=c.concat(l?a.split(l):a)),s.indexOf(".")>-1&&(c=s.split("."),o=i,i=c[1]),this.addNamespaces(i),rB(this.data,c,o),u.silent||this.emit("added",s,i,a,o)}},{key:"addResources",value:function(s,i,a){var o=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{silent:!1};for(var u in a)(typeof a[u]=="string"||Object.prototype.toString.apply(a[u])==="[object Array]")&&this.addResource(s,i,u,a[u],{silent:!0});o.silent||this.emit("added",s,i,a)}},{key:"addResourceBundle",value:function(s,i,a,o,u){var l=arguments.length>5&&arguments[5]!==void 0?arguments[5]:{silent:!1},c=[s,i];s.indexOf(".")>-1&&(c=s.split("."),o=a,a=i,i=c[1]),this.addNamespaces(i);var h=Xw(this.data,c)||{};o?eW(h,a,u):h=Js({},h,a),rB(this.data,c,h),l.silent||this.emit("added",s,i,a)}},{key:"removeResourceBundle",value:function(s,i){this.hasResourceBundle(s,i)&&delete this.data[s][i],this.removeNamespaces(i),this.emit("removed",s,i)}},{key:"hasResourceBundle",value:function(s,i){return this.getResource(s,i)!==void 0}},{key:"getResourceBundle",value:function(s,i){return i||(i=this.options.defaultNS),this.options.compatibilityAPI==="v1"?Js({},{},this.getResource(s,i)):this.getResource(s,i)}},{key:"getDataByLanguage",value:function(s){return this.data[s]}},{key:"toJSON",value:function(){return this.data}}]),t}(ac),tW={processors:{},addPostProcessor:function(t){this.processors[t.name]=t},handle:function(t,n,s,i,a){var o=this;return t.forEach(function(u){o.processors[u]&&(n=o.processors[u].process(n,s,i,a))}),n}},sB={},iB=function(r){MS(t,r);function t(n){var s,i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return vu(this,t),s=fb(this,Im(t).call(this)),LS&&ac.call(Xh(s)),yoe(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector","i18nFormat","utils"],n,Xh(s)),s.options=i,s.options.keySeparator===void 0&&(s.options.keySeparator="."),s.logger=qu.create("translator"),s}return wu(t,[{key:"changeLanguage",value:function(s){s&&(this.language=s)}},{key:"exists",value:function(s){var i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{interpolation:{}},a=this.resolve(s,i);return a&&a.res!==void 0}},{key:"extractFromKey",value:function(s,i){var a=i.nsSeparator!==void 0?i.nsSeparator:this.options.nsSeparator;a===void 0&&(a=":");var o=i.keySeparator!==void 0?i.keySeparator:this.options.keySeparator,u=i.ns||this.options.defaultNS;if(a&&s.indexOf(a)>-1){var l=s.match(this.interpolator.nestingRegexp);if(l&&l.length>0)return{key:s,namespaces:u};var c=s.split(a);(a!==o||a===o&&this.options.ns.indexOf(c[0])>-1)&&(u=c.shift()),s=c.join(o)}return typeof u=="string"&&(u=[u]),{key:s,namespaces:u}}},{key:"translate",value:function(s,i,a){var o=this;if(Io(i)!=="object"&&this.options.overloadTranslationOptionHandler&&(i=this.options.overloadTranslationOptionHandler(arguments)),i||(i={}),s==null)return"";Array.isArray(s)||(s=[String(s)]);var u=i.keySeparator!==void 0?i.keySeparator:this.options.keySeparator,l=this.extractFromKey(s[s.length-1],i),c=l.key,h=l.namespaces,d=h[h.length-1],p=i.lng||this.language,f=i.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if(p&&p.toLowerCase()==="cimode"){if(f){var m=i.nsSeparator||this.options.nsSeparator;return d+m+c}return c}var g=this.resolve(s,i),y=g&&g.res,b=g&&g.usedKey||c,x=g&&g.exactUsedKey||c,w=Object.prototype.toString.apply(y),v=["[object Number]","[object Function]","[object RegExp]"],S=i.joinArrays!==void 0?i.joinArrays:this.options.joinArrays,E=!this.i18nFormat||this.i18nFormat.handleAsObject,C=typeof y!="string"&&typeof y!="boolean"&&typeof y!="number";if(E&&y&&C&&v.indexOf(w)<0&&!(typeof S=="string"&&w==="[object Array]")){if(!i.returnObjects&&!this.options.returnObjects)return this.logger.warn("accessing an object - but returnObjects options is not enabled!"),this.options.returnedObjectHandler?this.options.returnedObjectHandler(b,y,i):"key '".concat(c," (").concat(this.language,")' returned an object instead of string.");if(u){var I=w==="[object Array]",_=I?[]:{},A=I?x:b;for(var k in y)if(Object.prototype.hasOwnProperty.call(y,k)){var N="".concat(A).concat(u).concat(k);_[k]=this.translate(N,Js({},i,{joinArrays:!1,ns:h})),_[k]===N&&(_[k]=y[k])}y=_}}else if(E&&typeof S=="string"&&w==="[object Array]")y=y.join(S),y&&(y=this.extendTranslation(y,s,i,a));else{var D=!1,F=!1,P=i.count!==void 0&&typeof i.count!="string",G=t.hasDefaultValue(i),Y=P?this.pluralResolver.getSuffix(p,i.count):"",Z=i["defaultValue".concat(Y)]||i.defaultValue;!this.isValidLookup(y)&&G&&(D=!0,y=Z),this.isValidLookup(y)||(F=!0,y=c);var ee=G&&Z!==y&&this.options.updateMissing;if(F||D||ee){if(this.logger.log(ee?"updateKey":"missingKey",p,d,c,ee?Z:y),u){var se=this.resolve(c,Js({},i,{keySeparator:!1}));se&&se.res&&this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")}var re=[],J=this.languageUtils.getFallbackCodes(this.options.fallbackLng,i.lng||this.language);if(this.options.saveMissingTo==="fallback"&&J&&J[0])for(var le=0;le<J.length;le++)re.push(J[le]);else this.options.saveMissingTo==="all"?re=this.languageUtils.toResolveHierarchy(i.lng||this.language):re.push(i.lng||this.language);var he=function(Fe,Le,Ve){o.options.missingKeyHandler?o.options.missingKeyHandler(Fe,d,Le,ee?Ve:y,ee,i):o.backendConnector&&o.backendConnector.saveMissing&&o.backendConnector.saveMissing(Fe,d,Le,ee?Ve:y,ee,i),o.emit("missingKey",Fe,d,Le,y)};this.options.saveMissing&&(this.options.saveMissingPlurals&&P?re.forEach(function(xe){o.pluralResolver.getSuffixes(xe).forEach(function(Fe){he([xe],c+Fe,i["defaultValue".concat(Fe)]||Z)})}):he(re,c,Z))}y=this.extendTranslation(y,s,i,g,a),F&&y===c&&this.options.appendNamespaceToMissingKey&&(y="".concat(d,":").concat(c)),F&&this.options.parseMissingKeyHandler&&(y=this.options.parseMissingKeyHandler(y))}return y}},{key:"extendTranslation",value:function(s,i,a,o,u){var l=this;if(this.i18nFormat&&this.i18nFormat.parse)s=this.i18nFormat.parse(s,a,o.usedLng,o.usedNS,o.usedKey,{resolved:o});else if(!a.skipInterpolation){a.interpolation&&this.interpolator.init(Js({},a,{interpolation:Js({},this.options.interpolation,a.interpolation)}));var c=a.interpolation&&a.interpolation.skipOnVariables||this.options.interpolation.skipOnVariables,h;if(c){var d=s.match(this.interpolator.nestingRegexp);h=d&&d.length}var p=a.replace&&typeof a.replace!="string"?a.replace:a;if(this.options.interpolation.defaultVariables&&(p=Js({},this.options.interpolation.defaultVariables,p)),s=this.interpolator.interpolate(s,p,a.lng||this.language,a),c){var f=s.match(this.interpolator.nestingRegexp),m=f&&f.length;h<m&&(a.nest=!1)}a.nest!==!1&&(s=this.interpolator.nest(s,function(){for(var b=arguments.length,x=new Array(b),w=0;w<b;w++)x[w]=arguments[w];return u&&u[0]===x[0]&&!a.context?(l.logger.warn("It seems you are nesting recursively key: ".concat(x[0]," in key: ").concat(i[0])),null):l.translate.apply(l,x.concat([i]))},a)),a.interpolation&&this.interpolator.reset()}var g=a.postProcess||this.options.postProcess,y=typeof g=="string"?[g]:g;return s!=null&&y&&y.length&&a.applyPostProcessor!==!1&&(s=tW.handle(y,s,i,this.options&&this.options.postProcessPassResolved?Js({i18nResolved:o},a):a,this)),s}},{key:"resolve",value:function(s){var i=this,a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},o,u,l,c,h;return typeof s=="string"&&(s=[s]),s.forEach(function(d){if(!i.isValidLookup(o)){var p=i.extractFromKey(d,a),f=p.key;u=f;var m=p.namespaces;i.options.fallbackNS&&(m=m.concat(i.options.fallbackNS));var g=a.count!==void 0&&typeof a.count!="string",y=a.context!==void 0&&typeof a.context=="string"&&a.context!=="",b=a.lngs?a.lngs:i.languageUtils.toResolveHierarchy(a.lng||i.language,a.fallbackLng);m.forEach(function(x){i.isValidLookup(o)||(h=x,!sB["".concat(b[0],"-").concat(x)]&&i.utils&&i.utils.hasLoadedNamespace&&!i.utils.hasLoadedNamespace(h)&&(sB["".concat(b[0],"-").concat(x)]=!0,i.logger.warn('key "'.concat(u,'" for languages "').concat(b.join(", "),`" won't get resolved as namespace "`).concat(h,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),b.forEach(function(w){if(!i.isValidLookup(o)){c=w;var v=f,S=[v];if(i.i18nFormat&&i.i18nFormat.addLookupKeys)i.i18nFormat.addLookupKeys(S,f,w,x,a);else{var E;g&&(E=i.pluralResolver.getSuffix(w,a.count)),g&&y&&S.push(v+E),y&&S.push(v+="".concat(i.options.contextSeparator).concat(a.context)),g&&S.push(v+=E)}for(var C;C=S.pop();)i.isValidLookup(o)||(l=C,o=i.getResource(w,x,C,a))}}))})}}),{res:o,usedKey:u,exactUsedKey:l,usedLng:c,usedNS:h}}},{key:"isValidLookup",value:function(s){return s!==void 0&&!(!this.options.returnNull&&s===null)&&!(!this.options.returnEmptyString&&s==="")}},{key:"getResource",value:function(s,i,a){var o=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};return this.i18nFormat&&this.i18nFormat.getResource?this.i18nFormat.getResource(s,i,a,o):this.resourceStore.getResource(s,i,a,o)}}],[{key:"hasDefaultValue",value:function(s){var i="defaultValue";for(var a in s)if(Object.prototype.hasOwnProperty.call(s,a)&&i===a.substring(0,i.length)&&s[a]!==void 0)return!0;return!1}}]),t}(ac);function pE(r){return r.charAt(0).toUpperCase()+r.slice(1)}var Soe=function(){function r(t){vu(this,r),this.options=t,this.whitelist=this.options.supportedLngs||!1,this.supportedLngs=this.options.supportedLngs||!1,this.logger=qu.create("languageUtils")}return wu(r,[{key:"getScriptPartFromCode",value:function(n){if(!n||n.indexOf("-")<0)return null;var s=n.split("-");return s.length===2||(s.pop(),s[s.length-1].toLowerCase()==="x")?null:this.formatLanguageCode(s.join("-"))}},{key:"getLanguagePartFromCode",value:function(n){if(!n||n.indexOf("-")<0)return n;var s=n.split("-");return this.formatLanguageCode(s[0])}},{key:"formatLanguageCode",value:function(n){if(typeof n=="string"&&n.indexOf("-")>-1){var s=["hans","hant","latn","cyrl","cans","mong","arab"],i=n.split("-");return this.options.lowerCaseLng?i=i.map(function(a){return a.toLowerCase()}):i.length===2?(i[0]=i[0].toLowerCase(),i[1]=i[1].toUpperCase(),s.indexOf(i[1].toLowerCase())>-1&&(i[1]=pE(i[1].toLowerCase()))):i.length===3&&(i[0]=i[0].toLowerCase(),i[1].length===2&&(i[1]=i[1].toUpperCase()),i[0]!=="sgn"&&i[2].length===2&&(i[2]=i[2].toUpperCase()),s.indexOf(i[1].toLowerCase())>-1&&(i[1]=pE(i[1].toLowerCase())),s.indexOf(i[2].toLowerCase())>-1&&(i[2]=pE(i[2].toLowerCase()))),i.join("-")}return this.options.cleanCode||this.options.lowerCaseLng?n.toLowerCase():n}},{key:"isWhitelisted",value:function(n){return this.logger.deprecate("languageUtils.isWhitelisted",`function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it's usage asap.`),this.isSupportedCode(n)}},{key:"isSupportedCode",value:function(n){return(this.options.load==="languageOnly"||this.options.nonExplicitSupportedLngs)&&(n=this.getLanguagePartFromCode(n)),!this.supportedLngs||!this.supportedLngs.length||this.supportedLngs.indexOf(n)>-1}},{key:"getBestMatchFromCodes",value:function(n){var s=this;if(!n)return null;var i;return n.forEach(function(a){if(!i){var o=s.formatLanguageCode(a);(!s.options.supportedLngs||s.isSupportedCode(o))&&(i=o)}}),!i&&this.options.supportedLngs&&n.forEach(function(a){if(!i){var o=s.getLanguagePartFromCode(a);if(s.isSupportedCode(o))return i=o;i=s.options.supportedLngs.find(function(u){if(u.indexOf(o)===0)return u})}}),i||(i=this.getFallbackCodes(this.options.fallbackLng)[0]),i}},{key:"getFallbackCodes",value:function(n,s){if(!n)return[];if(typeof n=="function"&&(n=n(s)),typeof n=="string"&&(n=[n]),Object.prototype.toString.apply(n)==="[object Array]")return n;if(!s)return n.default||[];var i=n[s];return i||(i=n[this.getScriptPartFromCode(s)]),i||(i=n[this.formatLanguageCode(s)]),i||(i=n[this.getLanguagePartFromCode(s)]),i||(i=n.default),i||[]}},{key:"toResolveHierarchy",value:function(n,s){var i=this,a=this.getFallbackCodes(s||this.options.fallbackLng||[],n),o=[],u=function(c){c&&(i.isSupportedCode(c)?o.push(c):i.logger.warn("rejecting language code not found in supportedLngs: ".concat(c)))};return typeof n=="string"&&n.indexOf("-")>-1?(this.options.load!=="languageOnly"&&u(this.formatLanguageCode(n)),this.options.load!=="languageOnly"&&this.options.load!=="currentOnly"&&u(this.getScriptPartFromCode(n)),this.options.load!=="currentOnly"&&u(this.getLanguagePartFromCode(n))):typeof n=="string"&&u(this.formatLanguageCode(n)),a.forEach(function(l){o.indexOf(l)<0&&u(i.formatLanguageCode(l))}),o}}]),r}(),Coe=[{lngs:["ach","ak","am","arn","br","fil","gun","ln","mfe","mg","mi","oc","pt","pt-BR","tg","tl","ti","tr","uz","wa"],nr:[1,2],fc:1},{lngs:["af","an","ast","az","bg","bn","ca","da","de","dev","el","en","eo","es","et","eu","fi","fo","fur","fy","gl","gu","ha","hi","hu","hy","ia","it","kn","ku","lb","mai","ml","mn","mr","nah","nap","nb","ne","nl","nn","no","nso","pa","pap","pms","ps","pt-PT","rm","sco","se","si","so","son","sq","sv","sw","ta","te","tk","ur","yo"],nr:[1,2],fc:2},{lngs:["ay","bo","cgg","fa","ht","id","ja","jbo","ka","kk","km","ko","ky","lo","ms","sah","su","th","tt","ug","vi","wo","zh"],nr:[1],fc:3},{lngs:["be","bs","cnr","dz","hr","ru","sr","uk"],nr:[1,2,5],fc:4},{lngs:["ar"],nr:[0,1,2,3,11,100],fc:5},{lngs:["cs","sk"],nr:[1,2,5],fc:6},{lngs:["csb","pl"],nr:[1,2,5],fc:7},{lngs:["cy"],nr:[1,2,3,8],fc:8},{lngs:["fr"],nr:[1,2],fc:9},{lngs:["ga"],nr:[1,2,3,7,11],fc:10},{lngs:["gd"],nr:[1,2,3,20],fc:11},{lngs:["is"],nr:[1,2],fc:12},{lngs:["jv"],nr:[0,1],fc:13},{lngs:["kw"],nr:[1,2,3,4],fc:14},{lngs:["lt"],nr:[1,2,10],fc:15},{lngs:["lv"],nr:[1,2,0],fc:16},{lngs:["mk"],nr:[1,2],fc:17},{lngs:["mnk"],nr:[0,1,2],fc:18},{lngs:["mt"],nr:[1,2,11,20],fc:19},{lngs:["or"],nr:[2,1],fc:2},{lngs:["ro"],nr:[1,2,20],fc:20},{lngs:["sl"],nr:[5,1,2,3],fc:21},{lngs:["he","iw"],nr:[1,2,20,21],fc:22}],_oe={1:function(t){return+(t>1)},2:function(t){return+(t!=1)},3:function(t){return 0},4:function(t){return t%10==1&&t%100!=11?0:t%10>=2&&t%10<=4&&(t%100<10||t%100>=20)?1:2},5:function(t){return t==0?0:t==1?1:t==2?2:t%100>=3&&t%100<=10?3:t%100>=11?4:5},6:function(t){return t==1?0:t>=2&&t<=4?1:2},7:function(t){return t==1?0:t%10>=2&&t%10<=4&&(t%100<10||t%100>=20)?1:2},8:function(t){return t==1?0:t==2?1:t!=8&&t!=11?2:3},9:function(t){return+(t>=2)},10:function(t){return t==1?0:t==2?1:t<7?2:t<11?3:4},11:function(t){return t==1||t==11?0:t==2||t==12?1:t>2&&t<20?2:3},12:function(t){return+(t%10!=1||t%100==11)},13:function(t){return+(t!==0)},14:function(t){return t==1?0:t==2?1:t==3?2:3},15:function(t){return t%10==1&&t%100!=11?0:t%10>=2&&(t%100<10||t%100>=20)?1:2},16:function(t){return t%10==1&&t%100!=11?0:t!==0?1:2},17:function(t){return t==1||t%10==1&&t%100!=11?0:1},18:function(t){return t==0?0:t==1?1:2},19:function(t){return t==1?0:t==0||t%100>1&&t%100<11?1:t%100>10&&t%100<20?2:3},20:function(t){return t==1?0:t==0||t%100>0&&t%100<20?1:2},21:function(t){return t%100==1?1:t%100==2?2:t%100==3||t%100==4?3:0},22:function(t){return t==1?0:t==2?1:(t<0||t>10)&&t%10==0?2:3}};function Eoe(){var r={};return Coe.forEach(function(t){t.lngs.forEach(function(n){r[n]={numbers:t.nr,plurals:_oe[t.fc]}})}),r}var Ioe=function(){function r(t){var n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};vu(this,r),this.languageUtils=t,this.options=n,this.logger=qu.create("pluralResolver"),this.rules=Eoe()}return wu(r,[{key:"addRule",value:function(n,s){this.rules[n]=s}},{key:"getRule",value:function(n){return this.rules[n]||this.rules[this.languageUtils.getLanguagePartFromCode(n)]}},{key:"needsPlural",value:function(n){var s=this.getRule(n);return s&&s.numbers.length>1}},{key:"getPluralFormsOfKey",value:function(n,s){return this.getSuffixes(n).map(function(i){return s+i})}},{key:"getSuffixes",value:function(n){var s=this,i=this.getRule(n);return i?i.numbers.map(function(a){return s.getSuffix(n,a)}):[]}},{key:"getSuffix",value:function(n,s){var i=this,a=this.getRule(n);if(a){var o=a.noAbs?a.plurals(s):a.plurals(Math.abs(s)),u=a.numbers[o];this.options.simplifyPluralSuffix&&a.numbers.length===2&&a.numbers[0]===1&&(u===2?u="plural":u===1&&(u=""));var l=function(){return i.options.prepend&&u.toString()?i.options.prepend+u.toString():u.toString()};return this.options.compatibilityJSON==="v1"?u===1?"":typeof u=="number"?"_plural_".concat(u.toString()):l():this.options.compatibilityJSON==="v2"||this.options.simplifyPluralSuffix&&a.numbers.length===2&&a.numbers[0]===1?l():this.options.prepend&&o.toString()?this.options.prepend+o.toString():o.toString()}return this.logger.warn("no plural rule found for: ".concat(n)),""}}]),r}(),koe=function(){function r(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};vu(this,r),this.logger=qu.create("interpolator"),this.options=t,this.format=t.interpolation&&t.interpolation.format||function(n){return n},this.init(t)}return wu(r,[{key:"init",value:function(){var n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};n.interpolation||(n.interpolation={escapeValue:!0});var s=n.interpolation;this.escape=s.escape!==void 0?s.escape:voe,this.escapeValue=s.escapeValue!==void 0?s.escapeValue:!0,this.useRawValueToEscape=s.useRawValueToEscape!==void 0?s.useRawValueToEscape:!1,this.prefix=s.prefix?Of(s.prefix):s.prefixEscaped||"{{",this.suffix=s.suffix?Of(s.suffix):s.suffixEscaped||"}}",this.formatSeparator=s.formatSeparator?s.formatSeparator:s.formatSeparator||",",this.unescapePrefix=s.unescapeSuffix?"":s.unescapePrefix||"-",this.unescapeSuffix=this.unescapePrefix?"":s.unescapeSuffix||"",this.nestingPrefix=s.nestingPrefix?Of(s.nestingPrefix):s.nestingPrefixEscaped||Of("$t("),this.nestingSuffix=s.nestingSuffix?Of(s.nestingSuffix):s.nestingSuffixEscaped||Of(")"),this.nestingOptionsSeparator=s.nestingOptionsSeparator?s.nestingOptionsSeparator:s.nestingOptionsSeparator||",",this.maxReplaces=s.maxReplaces?s.maxReplaces:1e3,this.alwaysFormat=s.alwaysFormat!==void 0?s.alwaysFormat:!1,this.resetRegExp()}},{key:"reset",value:function(){this.options&&this.init(this.options)}},{key:"resetRegExp",value:function(){var n="".concat(this.prefix,"(.+?)").concat(this.suffix);this.regexp=new RegExp(n,"g");var s="".concat(this.prefix).concat(this.unescapePrefix,"(.+?)").concat(this.unescapeSuffix).concat(this.suffix);this.regexpUnescape=new RegExp(s,"g");var i="".concat(this.nestingPrefix,"(.+?)").concat(this.nestingSuffix);this.nestingRegexp=new RegExp(i,"g")}},{key:"interpolate",value:function(n,s,i,a){var o=this,u,l,c,h=this.options&&this.options.interpolation&&this.options.interpolation.defaultVariables||{};function d(y){return y.replace(/\$/g,"$$$$")}var p=function(b){if(b.indexOf(o.formatSeparator)<0){var x=nB(s,h,b);return o.alwaysFormat?o.format(x,void 0,i):x}var w=b.split(o.formatSeparator),v=w.shift().trim(),S=w.join(o.formatSeparator).trim();return o.format(nB(s,h,v),S,i,a)};this.resetRegExp();var f=a&&a.missingInterpolationHandler||this.options.missingInterpolationHandler,m=a&&a.interpolation&&a.interpolation.skipOnVariables||this.options.interpolation.skipOnVariables,g=[{regex:this.regexpUnescape,safeValue:function(b){return d(b)}},{regex:this.regexp,safeValue:function(b){return o.escapeValue?d(o.escape(b)):d(b)}}];return g.forEach(function(y){for(c=0;u=y.regex.exec(n);){if(l=p(u[1].trim()),l===void 0)if(typeof f=="function"){var b=f(n,u,a);l=typeof b=="string"?b:""}else if(m){l=u[0];continue}else o.logger.warn("missed to pass in variable ".concat(u[1]," for interpolating ").concat(n)),l="";else typeof l!="string"&&!o.useRawValueToEscape&&(l=tB(l));if(n=n.replace(u[0],y.safeValue(l)),y.regex.lastIndex=0,c++,c>=o.maxReplaces)break}}),n}},{key:"nest",value:function(n,s){var i=this,a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},o,u,l=Js({},a);l.applyPostProcessor=!1,delete l.defaultValue;function c(f,m){var g=this.nestingOptionsSeparator;if(f.indexOf(g)<0)return f;var y=f.split(new RegExp("".concat(g,"[ ]*{"))),b="{".concat(y[1]);f=y[0],b=this.interpolate(b,l),b=b.replace(/'/g,'"');try{l=JSON.parse(b),m&&(l=Js({},m,l))}catch(x){return this.logger.warn("failed parsing options string in nesting for key ".concat(f),x),"".concat(f).concat(g).concat(b)}return delete l.defaultValue,f}for(;o=this.nestingRegexp.exec(n);){var h=[],d=!1;if(o[0].includes(this.formatSeparator)&&!/{.*}/.test(o[1])){var p=o[1].split(this.formatSeparator).map(function(f){return f.trim()});o[1]=p.shift(),h=p,d=!0}if(u=s(c.call(this,o[1].trim(),l),l),u&&o[0]===n&&typeof u!="string")return u;typeof u!="string"&&(u=tB(u)),u||(this.logger.warn("missed to resolve ".concat(o[1]," for nesting ").concat(n)),u=""),d&&(u=h.reduce(function(f,m){return i.format(f,m,a.lng,a)},u.trim())),n=n.replace(o[0],u),this.regexp.lastIndex=0}return n}}]),r}();function Noe(r,t){for(var n=r.indexOf(t);n!==-1;)r.splice(n,1),n=r.indexOf(t)}var Toe=function(r){MS(t,r);function t(n,s,i){var a,o=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};return vu(this,t),a=fb(this,Im(t).call(this)),LS&&ac.call(Xh(a)),a.backend=n,a.store=s,a.services=i,a.languageUtils=i.languageUtils,a.options=o,a.logger=qu.create("backendConnector"),a.state={},a.queue=[],a.backend&&a.backend.init&&a.backend.init(i,o.backend,o),a}return wu(t,[{key:"queueLoad",value:function(s,i,a,o){var u=this,l=[],c=[],h=[],d=[];return s.forEach(function(p){var f=!0;i.forEach(function(m){var g="".concat(p,"|").concat(m);!a.reload&&u.store.hasResourceBundle(p,m)?u.state[g]=2:u.state[g]<0||(u.state[g]===1?c.indexOf(g)<0&&c.push(g):(u.state[g]=1,f=!1,c.indexOf(g)<0&&c.push(g),l.indexOf(g)<0&&l.push(g),d.indexOf(m)<0&&d.push(m)))}),f||h.push(p)}),(l.length||c.length)&&this.queue.push({pending:c,loaded:{},errors:[],callback:o}),{toLoad:l,pending:c,toLoadLanguages:h,toLoadNamespaces:d}}},{key:"loaded",value:function(s,i,a){var o=s.split("|"),u=o[0],l=o[1];i&&this.emit("failedLoading",u,l,i),a&&this.store.addResourceBundle(u,l,a),this.state[s]=i?-1:2;var c={};this.queue.forEach(function(h){boe(h.loaded,[u],l),Noe(h.pending,s),i&&h.errors.push(i),h.pending.length===0&&!h.done&&(Object.keys(h.loaded).forEach(function(d){c[d]||(c[d]=[]),h.loaded[d].length&&h.loaded[d].forEach(function(p){c[d].indexOf(p)<0&&c[d].push(p)})}),h.done=!0,h.errors.length?h.callback(h.errors):h.callback())}),this.emit("loaded",c),this.queue=this.queue.filter(function(h){return!h.done})}},{key:"read",value:function(s,i,a){var o=this,u=arguments.length>3&&arguments[3]!==void 0?arguments[3]:0,l=arguments.length>4&&arguments[4]!==void 0?arguments[4]:350,c=arguments.length>5?arguments[5]:void 0;return s.length?this.backend[a](s,i,function(h,d){if(h&&d&&u<5){setTimeout(function(){o.read.call(o,s,i,a,u+1,l*2,c)},l);return}c(h,d)}):c(null,{})}},{key:"prepareLoading",value:function(s,i){var a=this,o=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},u=arguments.length>3?arguments[3]:void 0;if(!this.backend)return this.logger.warn("No backend was added via i18next.use. Will not load resources."),u&&u();typeof s=="string"&&(s=this.languageUtils.toResolveHierarchy(s)),typeof i=="string"&&(i=[i]);var l=this.queueLoad(s,i,o,u);if(!l.toLoad.length)return l.pending.length||u(),null;l.toLoad.forEach(function(c){a.loadOne(c)})}},{key:"load",value:function(s,i,a){this.prepareLoading(s,i,{},a)}},{key:"reload",value:function(s,i,a){this.prepareLoading(s,i,{reload:!0},a)}},{key:"loadOne",value:function(s){var i=this,a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"",o=s.split("|"),u=o[0],l=o[1];this.read(u,l,"read",void 0,void 0,function(c,h){c&&i.logger.warn("".concat(a,"loading namespace ").concat(l," for language ").concat(u," failed"),c),!c&&h&&i.logger.log("".concat(a,"loaded namespace ").concat(l," for language ").concat(u),h),i.loaded(s,c,h)})}},{key:"saveMissing",value:function(s,i,a,o,u){var l=arguments.length>5&&arguments[5]!==void 0?arguments[5]:{};if(this.services.utils&&this.services.utils.hasLoadedNamespace&&!this.services.utils.hasLoadedNamespace(i)){this.logger.warn('did not save key "'.concat(a,'" as the namespace "').concat(i,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");return}a==null||a===""||(this.backend&&this.backend.create&&this.backend.create(s,i,a,o,null,Js({},l,{isUpdate:u})),!(!s||!s[0])&&this.store.addResource(s[0],i,a,o))}}]),t}(ac);function Aoe(){return{debug:!1,initImmediate:!0,ns:["translation"],defaultNS:["translation"],fallbackLng:["dev"],fallbackNS:!1,whitelist:!1,nonExplicitWhitelist:!1,supportedLngs:!1,nonExplicitSupportedLngs:!1,load:"all",preload:!1,simplifyPluralSuffix:!0,keySeparator:".",nsSeparator:":",pluralSeparator:"_",contextSeparator:"_",partialBundledLanguages:!1,saveMissing:!1,updateMissing:!1,saveMissingTo:"fallback",saveMissingPlurals:!0,missingKeyHandler:!1,missingInterpolationHandler:!1,postProcess:!1,postProcessPassResolved:!1,returnNull:!0,returnEmptyString:!0,returnObjects:!1,joinArrays:!1,returnedObjectHandler:!1,parseMissingKeyHandler:!1,appendNamespaceToMissingKey:!1,appendNamespaceToCIMode:!1,overloadTranslationOptionHandler:function(t){var n={};if(Io(t[1])==="object"&&(n=t[1]),typeof t[1]=="string"&&(n.defaultValue=t[1]),typeof t[2]=="string"&&(n.tDescription=t[2]),Io(t[2])==="object"||Io(t[3])==="object"){var s=t[3]||t[2];Object.keys(s).forEach(function(i){n[i]=s[i]})}return n},interpolation:{escapeValue:!0,format:function(t,n,s,i){return t},prefix:"{{",suffix:"}}",formatSeparator:",",unescapePrefix:"-",nestingPrefix:"$t(",nestingSuffix:")",nestingOptionsSeparator:",",maxReplaces:1e3,skipOnVariables:!1}}}function aB(r){return typeof r.ns=="string"&&(r.ns=[r.ns]),typeof r.fallbackLng=="string"&&(r.fallbackLng=[r.fallbackLng]),typeof r.fallbackNS=="string"&&(r.fallbackNS=[r.fallbackNS]),r.whitelist&&(r.whitelist&&r.whitelist.indexOf("cimode")<0&&(r.whitelist=r.whitelist.concat(["cimode"])),r.supportedLngs=r.whitelist),r.nonExplicitWhitelist&&(r.nonExplicitSupportedLngs=r.nonExplicitWhitelist),r.supportedLngs&&r.supportedLngs.indexOf("cimode")<0&&(r.supportedLngs=r.supportedLngs.concat(["cimode"])),r}function c1(){}var Doe=function(r){MS(t,r);function t(){var n,s=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},i=arguments.length>1?arguments[1]:void 0;if(vu(this,t),n=fb(this,Im(t).call(this)),LS&&ac.call(Xh(n)),n.options=aB(s),n.services={},n.logger=qu,n.modules={external:[]},i&&!n.isInitialized&&!s.isClone){if(!n.options.initImmediate)return n.init(s,i),fb(n,Xh(n));setTimeout(function(){n.init(s,i)},0)}return n}return wu(t,[{key:"init",value:function(){var s=this,i=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},a=arguments.length>1?arguments[1]:void 0;typeof i=="function"&&(a=i,i={}),i.whitelist&&!i.supportedLngs&&this.logger.deprecate("whitelist",'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.'),i.nonExplicitWhitelist&&!i.nonExplicitSupportedLngs&&this.logger.deprecate("whitelist",'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.'),this.options=Js({},Aoe(),this.options,aB(i)),this.format=this.options.interpolation.format,a||(a=c1);function o(m){return m?typeof m=="function"?new m:m:null}if(!this.options.isClone){this.modules.logger?qu.init(o(this.modules.logger),this.options):qu.init(null,this.options);var u=new Soe(this.options);this.store=new woe(this.options.resources,this.options);var l=this.services;l.logger=qu,l.resourceStore=this.store,l.languageUtils=u,l.pluralResolver=new Ioe(u,{prepend:this.options.pluralSeparator,compatibilityJSON:this.options.compatibilityJSON,simplifyPluralSuffix:this.options.simplifyPluralSuffix}),l.interpolator=new koe(this.options),l.utils={hasLoadedNamespace:this.hasLoadedNamespace.bind(this)},l.backendConnector=new Toe(o(this.modules.backend),l.resourceStore,l,this.options),l.backendConnector.on("*",function(m){for(var g=arguments.length,y=new Array(g>1?g-1:0),b=1;b<g;b++)y[b-1]=arguments[b];s.emit.apply(s,[m].concat(y))}),this.modules.languageDetector&&(l.languageDetector=o(this.modules.languageDetector),l.languageDetector.init(l,this.options.detection,this.options)),this.modules.i18nFormat&&(l.i18nFormat=o(this.modules.i18nFormat),l.i18nFormat.init&&l.i18nFormat.init(this)),this.translator=new iB(this.services,this.options),this.translator.on("*",function(m){for(var g=arguments.length,y=new Array(g>1?g-1:0),b=1;b<g;b++)y[b-1]=arguments[b];s.emit.apply(s,[m].concat(y))}),this.modules.external.forEach(function(m){m.init&&m.init(s)})}if(this.options.fallbackLng&&!this.services.languageDetector&&!this.options.lng){var c=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);c.length>0&&c[0]!=="dev"&&(this.options.lng=c[0])}!this.services.languageDetector&&!this.options.lng&&this.logger.warn("init: no languageDetector is used and no lng is defined");var h=["getResource","hasResourceBundle","getResourceBundle","getDataByLanguage"];h.forEach(function(m){s[m]=function(){var g;return(g=s.store)[m].apply(g,arguments)}});var d=["addResource","addResources","addResourceBundle","removeResourceBundle"];d.forEach(function(m){s[m]=function(){var g;return(g=s.store)[m].apply(g,arguments),s}});var p=uy(),f=function(){var g=function(b,x){s.isInitialized&&s.logger.warn("init: i18next is already initialized. You should call init just once!"),s.isInitialized=!0,s.options.isClone||s.logger.log("initialized",s.options),s.emit("initialized",s.options),p.resolve(x),a(b,x)};if(s.languages&&s.options.compatibilityAPI!=="v1"&&!s.isInitialized)return g(null,s.t.bind(s));s.changeLanguage(s.options.lng,g)};return this.options.resources||!this.options.initImmediate?f():setTimeout(f,0),p}},{key:"loadResources",value:function(s){var i=this,a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:c1,o=a,u=typeof s=="string"?s:this.language;if(typeof s=="function"&&(o=s),!this.options.resources||this.options.partialBundledLanguages){if(u&&u.toLowerCase()==="cimode")return o();var l=[],c=function(p){if(p){var f=i.services.languageUtils.toResolveHierarchy(p);f.forEach(function(m){l.indexOf(m)<0&&l.push(m)})}};if(u)c(u);else{var h=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);h.forEach(function(d){return c(d)})}this.options.preload&&this.options.preload.forEach(function(d){return c(d)}),this.services.backendConnector.load(l,this.options.ns,o)}else o(null)}},{key:"reloadResources",value:function(s,i,a){var o=uy();return s||(s=this.languages),i||(i=this.options.ns),a||(a=c1),this.services.backendConnector.reload(s,i,function(u){o.resolve(),a(u)}),o}},{key:"use",value:function(s){if(!s)throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");if(!s.type)throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");return s.type==="backend"&&(this.modules.backend=s),(s.type==="logger"||s.log&&s.warn&&s.error)&&(this.modules.logger=s),s.type==="languageDetector"&&(this.modules.languageDetector=s),s.type==="i18nFormat"&&(this.modules.i18nFormat=s),s.type==="postProcessor"&&tW.addPostProcessor(s),s.type==="3rdParty"&&this.modules.external.push(s),this}},{key:"changeLanguage",value:function(s,i){var a=this;this.isLanguageChangingTo=s;var o=uy();this.emit("languageChanging",s);var u=function(h,d){d?(a.language=d,a.languages=a.services.languageUtils.toResolveHierarchy(d),a.translator.changeLanguage(d),a.isLanguageChangingTo=void 0,a.emit("languageChanged",d),a.logger.log("languageChanged",d)):a.isLanguageChangingTo=void 0,o.resolve(function(){return a.t.apply(a,arguments)}),i&&i(h,function(){return a.t.apply(a,arguments)})},l=function(h){var d=typeof h=="string"?h:a.services.languageUtils.getBestMatchFromCodes(h);d&&(a.language||(a.language=d,a.languages=a.services.languageUtils.toResolveHierarchy(d)),a.translator.language||a.translator.changeLanguage(d),a.services.languageDetector&&a.services.languageDetector.cacheUserLanguage(d)),a.loadResources(d,function(p){u(p,d)})};return!s&&this.services.languageDetector&&!this.services.languageDetector.async?l(this.services.languageDetector.detect()):!s&&this.services.languageDetector&&this.services.languageDetector.async?this.services.languageDetector.detect(l):l(s),o}},{key:"getFixedT",value:function(s,i){var a=this,o=function u(l,c){var h;if(Io(c)!=="object"){for(var d=arguments.length,p=new Array(d>2?d-2:0),f=2;f<d;f++)p[f-2]=arguments[f];h=a.options.overloadTranslationOptionHandler([l,c].concat(p))}else h=Js({},c);return h.lng=h.lng||u.lng,h.lngs=h.lngs||u.lngs,h.ns=h.ns||u.ns,a.t(l,h)};return typeof s=="string"?o.lng=s:o.lngs=s,o.ns=i,o}},{key:"t",value:function(){var s;return this.translator&&(s=this.translator).translate.apply(s,arguments)}},{key:"exists",value:function(){var s;return this.translator&&(s=this.translator).exists.apply(s,arguments)}},{key:"setDefaultNamespace",value:function(s){this.options.defaultNS=s}},{key:"hasLoadedNamespace",value:function(s){var i=this,a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!this.isInitialized)return this.logger.warn("hasLoadedNamespace: i18next was not initialized",this.languages),!1;if(!this.languages||!this.languages.length)return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty",this.languages),!1;var o=this.languages[0],u=this.options?this.options.fallbackLng:!1,l=this.languages[this.languages.length-1];if(o.toLowerCase()==="cimode")return!0;var c=function(p,f){var m=i.services.backendConnector.state["".concat(p,"|").concat(f)];return m===-1||m===2};if(a.precheck){var h=a.precheck(this,c);if(h!==void 0)return h}return!!(this.hasResourceBundle(o,s)||!this.services.backendConnector.backend||c(o,s)&&(!u||c(l,s)))}},{key:"loadNamespaces",value:function(s,i){var a=this,o=uy();return this.options.ns?(typeof s=="string"&&(s=[s]),s.forEach(function(u){a.options.ns.indexOf(u)<0&&a.options.ns.push(u)}),this.loadResources(function(u){o.resolve(),i&&i(u)}),o):(i&&i(),Promise.resolve())}},{key:"loadLanguages",value:function(s,i){var a=uy();typeof s=="string"&&(s=[s]);var o=this.options.preload||[],u=s.filter(function(l){return o.indexOf(l)<0});return u.length?(this.options.preload=o.concat(u),this.loadResources(function(l){a.resolve(),i&&i(l)}),a):(i&&i(),Promise.resolve())}},{key:"dir",value:function(s){if(s||(s=this.languages&&this.languages.length>0?this.languages[0]:this.language),!s)return"rtl";var i=["ar","shu","sqr","ssh","xaa","yhd","yud","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","afb","ajp","apc","apd","arb","arq","ars","ary","arz","auz","avl","ayh","ayl","ayn","ayp","bbz","pga","he","iw","ps","pbt","pbu","pst","prp","prd","ug","ur","ydd","yds","yih","ji","yi","hbo","men","xmn","fa","jpr","peo","pes","prs","dv","sam"];return i.indexOf(this.services.languageUtils.getLanguagePartFromCode(s))>=0?"rtl":"ltr"}},{key:"createInstance",value:function(){var s=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},i=arguments.length>1?arguments[1]:void 0;return new t(s,i)}},{key:"cloneInstance",value:function(){var s=this,i=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:c1,o=Js({},this.options,i,{isClone:!0}),u=new t(o),l=["store","services","language"];return l.forEach(function(c){u[c]=s[c]}),u.services=Js({},this.services),u.services.utils={hasLoadedNamespace:u.hasLoadedNamespace.bind(u)},u.translator=new iB(u.services,u.options),u.translator.on("*",function(c){for(var h=arguments.length,d=new Array(h>1?h-1:0),p=1;p<h;p++)d[p-1]=arguments[p];u.emit.apply(u,[c].concat(d))}),u.init(o,a),u.translator.options=u.options,u.translator.backendConnector.services.utils={hasLoadedNamespace:u.hasLoadedNamespace.bind(u)},u}}]),t}(ac),rW=new Doe,nW=[],Foe=nW.forEach,$oe=nW.slice;function Roe(r){return Foe.call($oe.call(arguments,1),function(t){if(t)for(var n in t)r[n]===void 0&&(r[n]=t[n])}),r}var oB={create:function(t,n,s,i){var a=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{path:"/"},o;if(s){var u=new Date;u.setTime(u.getTime()+s*60*1e3),o="; expires="+u.toUTCString()}else o="";i=i?"domain="+i+";":"",a=Object.keys(a).reduce(function(l,c){return l+";"+c.replace(/([A-Z])/g,function(h){return"-"+h.toLowerCase()})+"="+a[c]},""),document.cookie=t+"="+encodeURIComponent(n)+o+";"+i+a},read:function(t){for(var n=t+"=",s=document.cookie.split(";"),i=0;i<s.length;i++){for(var a=s[i];a.charAt(0)===" ";)a=a.substring(1,a.length);if(a.indexOf(n)===0)return a.substring(n.length,a.length)}return null},remove:function(t){this.create(t,"",-1)}},Ooe={name:"cookie",lookup:function(t){var n;if(t.lookupCookie&&typeof document<"u"){var s=oB.read(t.lookupCookie);s&&(n=s)}return n},cacheUserLanguage:function(t,n){n.lookupCookie&&typeof document<"u"&&oB.create(n.lookupCookie,t,n.cookieMinutes,n.cookieDomain,n.cookieOptions)}},Moe={name:"querystring",lookup:function(t){var n;if(typeof window<"u")for(var s=window.location.search.substring(1),i=s.split("&"),a=0;a<i.length;a++){var o=i[a].indexOf("=");if(o>0){var u=i[a].substring(0,o);u===t.lookupQuerystring&&(n=i[a].substring(o+1))}}return n}},Yw;try{Yw=window!=="undefined"&&window.localStorage!==null;var uB="i18next.translate.boo";window.localStorage.setItem(uB,"foo"),window.localStorage.removeItem(uB)}catch{Yw=!1}var Loe={name:"localStorage",lookup:function(t){var n;if(t.lookupLocalStorage&&Yw){var s=window.localStorage.getItem(t.lookupLocalStorage);s&&(n=s)}return n},cacheUserLanguage:function(t,n){n.lookupLocalStorage&&Yw&&window.localStorage.setItem(n.lookupLocalStorage,t)}},Zw;try{Zw=window!=="undefined"&&window.sessionStorage!==null;var lB="i18next.translate.boo";window.sessionStorage.setItem(lB,"foo"),window.sessionStorage.removeItem(lB)}catch{Zw=!1}var Poe={name:"sessionStorage",lookup:function(t){var n;if(t.lookupsessionStorage&&Zw){var s=window.sessionStorage.getItem(t.lookupsessionStorage);s&&(n=s)}return n},cacheUserLanguage:function(t,n){n.lookupsessionStorage&&Zw&&window.sessionStorage.setItem(n.lookupsessionStorage,t)}},Boe={name:"navigator",lookup:function(t){var n=[];if(typeof navigator<"u"){if(navigator.languages)for(var s=0;s<navigator.languages.length;s++)n.push(navigator.languages[s]);navigator.userLanguage&&n.push(navigator.userLanguage),navigator.language&&n.push(navigator.language)}return n.length>0?n:void 0}},Voe={name:"htmlTag",lookup:function(t){var n,s=t.htmlTag||(typeof document<"u"?document.documentElement:null);return s&&typeof s.getAttribute=="function"&&(n=s.getAttribute("lang")),n}},zoe={name:"path",lookup:function(t){var n;if(typeof window<"u"){var s=window.location.pathname.match(/\/([a-zA-Z-]*)/g);if(s instanceof Array)if(typeof t.lookupFromPathIndex=="number"){if(typeof s[t.lookupFromPathIndex]!="string")return;n=s[t.lookupFromPathIndex].replace("/","")}else n=s[0].replace("/","")}return n}},Uoe={name:"subdomain",lookup:function(t){var n;if(typeof window<"u"){var s=window.location.href.match(/(?:http[s]*\:\/\/)*(.*?)\.(?=[^\/]*\..{2,5})/gi);s instanceof Array&&(typeof t.lookupFromSubdomainIndex=="number"?n=s[t.lookupFromSubdomainIndex].replace("http://","").replace("https://","").replace(".",""):n=s[0].replace("http://","").replace("https://","").replace(".",""))}return n}};function Woe(){return{order:["querystring","cookie","localStorage","sessionStorage","navigator","htmlTag"],lookupQuerystring:"lng",lookupCookie:"i18next",lookupLocalStorage:"i18nextLng",caches:["localStorage"],excludeCacheFor:["cimode"],checkWhitelist:!0,checkForSimilarInWhitelist:!1}}var sW=function(){function r(t){var n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};vu(this,r),this.type="languageDetector",this.detectors={},this.init(t,n)}return wu(r,[{key:"init",value:function(n){var s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};this.services=n,this.options=Roe(s,this.options||{},Woe()),this.options.checkForSimilarInWhitelist&&(this.options.checkWhitelist=!0),this.options.lookupFromUrlIndex&&(this.options.lookupFromPathIndex=this.options.lookupFromUrlIndex),this.i18nOptions=i,this.addDetector(Ooe),this.addDetector(Moe),this.addDetector(Loe),this.addDetector(Poe),this.addDetector(Boe),this.addDetector(Voe),this.addDetector(zoe),this.addDetector(Uoe)}},{key:"addDetector",value:function(n){this.detectors[n.name]=n}},{key:"detect",value:function(n){var s=this;n||(n=this.options.order);var i=[];n.forEach(function(u){if(s.detectors[u]){var l=s.detectors[u].lookup(s.options);l&&typeof l=="string"&&(l=[l]),l&&(i=i.concat(l))}});var a;if(i.forEach(function(u){if(!a){var l=s.services.languageUtils.formatLanguageCode(u);(!s.options.checkWhitelist||s.services.languageUtils.isWhitelisted(l))&&(a=l),!a&&s.options.checkForSimilarInWhitelist&&(a=s.getSimilarInWhitelist(l))}}),!a){var o=this.i18nOptions.fallbackLng;typeof o=="string"&&(o=[o]),o||(o=[]),Object.prototype.toString.apply(o)==="[object Array]"?a=o[0]:a=o[0]||o.default&&o.default[0]}return a}},{key:"cacheUserLanguage",value:function(n,s){var i=this;s||(s=this.options.caches),s&&(this.options.excludeCacheFor&&this.options.excludeCacheFor.indexOf(n)>-1||s.forEach(function(a){i.detectors[a]&&i.detectors[a].cacheUserLanguage(n,i.options)}))}},{key:"getSimilarInWhitelist",value:function(n){var s=this;if(this.i18nOptions.whitelist){if(n.includes("-")){var i=n.split("-")[0],a=this.services.languageUtils.formatLanguageCode(i);if(this.services.languageUtils.isWhitelisted(a))return a;n=a}var o=this.i18nOptions.whitelist.find(function(u){var l=s.services.languageUtils.formatLanguageCode(u);if(l.startsWith(n))return l});if(o)return o}}}]),r}();sW.type="languageDetector";var Goe={autoplay:`The media that tried to play (with '{{src}}') wasn't allowed to by this browser, most likely due to the browser's autoplay policy.

+ More info: {{url}}`,checkUserDefinedFns:"It seems that you may have accidentally written {{name}} instead of {{actualName}}. Please correct it if it's not intentional.",fileLoadError:{bytes:"It looks like there was a problem loading your file. {{suggestion}}",font:"It looks like there was a problem loading your font. {{suggestion}}",gif:"There was some trouble loading your GIF. Make sure that your GIF is using 87a or 89a encoding.",image:"It looks like there was a problem loading your image. {{suggestion}}",json:"It looks like there was a problem loading your JSON file. {{suggestion}}",large:"If your large file isn't fetched successfully, we recommend splitting the file into smaller segments and fetching those.",strings:"It looks like there was a problem loading your text file. {{suggestion}}",suggestion:`Try checking if the file path ({{filePath}}) is correct, hosting the file online, or running a local server.

+ More info: {{url}}`,table:"It looks like there was a problem loading your table file. {{suggestion}}",xml:"It looks like there was a problem loading your XML file. {{suggestion}}"},friendlyParamError:{type_EMPTY_VAR:`{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received an empty variable instead. If not intentional, this is often a problem with scope.

+ More info: {{url}}`,type_TOO_FEW_ARGUMENTS:"{{location}} {{func}}() was expecting at least {{minParams}} arguments, but received only {{argCount}}.",type_TOO_MANY_ARGUMENTS:"{{location}} {{func}}() was expecting no more than {{maxParams}} arguments, but received {{argCount}}.",type_WRONG_TYPE:"{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received {{argType}} instead."},globalErrors:{reference:{cannotAccess:`
{{location}} "{{symbol}}" is used before declaration. Make sure you have declared the variable before using it.

+ More info: {{url}}`,notDefined:`
{{location}} "{{symbol}}" is not defined in the current scope. If you have defined it in your code, you should check its scope, spelling, and letter-casing (JavaScript is case-sensitive).

+ More info: {{url}}`},stackSubseq:`[{{location}}] 
	 Called from line {{line}} in {{func}}()
`,stackTop:`[{{location}}] 
	 Error at line {{line}} in {{func}}()
`,syntax:{badReturnOrYield:`
Syntax Error - return lies outside of a function. Make sure youre not missing any brackets, so that return lies inside a function.

+ More info: {{url}}`,invalidToken:`
Syntax Error - Found a symbol that JavaScript doesn't recognize or didn't expect at it's place.

+ More info: {{url}}`,missingInitializer:`
Syntax Error - A const variable is declared but not initialized. In JavaScript, an initializer for a const is required. A value must be specified in the same statement in which the variable is declared. Check the line number in the error and assign the const variable a value.

+ More info: {{url}}`,redeclaredVariable:`
Syntax Error - "{{symbol}}" is being redeclared. JavaScript doesn't allow declaring a variable more than once. Check the line number in error for redeclaration of the variable.

+ More info: {{url}}`,unexpectedToken:`
Syntax Error - Symbol present at a place that wasn't expected.
Usually this is due to a typo. Check the line number in the error for anything missing/extra.

+ More info: {{url}}`},type:{constAssign:`
{{location}} A const variable is being re-assigned. In javascript, re-assigning a value to a constant is not allowed. If you want to re-assign new values to a variable, make sure it is declared as var or let.

+ More info: {{url}}`,notfunc:`
{{location}} "{{symbol}}" could not be called as a function.
Check the spelling, letter-casing (JavaScript is case-sensitive) and its type.

+ More info: {{url}}`,notfuncObj:`
{{location}} "{{symbol}}" could not be called as a function.
Verify whether "{{obj}}" has "{{symbol}}" in it and check the spelling, letter-casing (JavaScript is case-sensitive) and its type.

+ More info: {{url}}`,readFromNull:`
{{location}} The property of null can't be read. In javascript the value null indicates that an object has no value.

+ More info: {{url}}`,readFromUndefined:`
{{location}} Cannot read property of undefined. Check the line number in error and make sure the variable which is being operated is not undefined.

 + More info: {{url}}`}},libraryError:'{{location}} An error with message "{{error}}" occurred inside the p5js library when {{func}} was called. If not stated otherwise, it might be an issue with the arguments passed to {{func}}.',location:"[{{file}}, line {{line}}]",misspelling:'{{location}} It seems that you may have accidentally written "{{name}}" instead of "{{actualName}}". Please correct it to {{actualName}} if you wish to use the {{type}} from p5.js.',misspelling_plural:`{{location}} It seems that you may have accidentally written "{{name}}".
You may have meant one of the following: 
{{suggestions}}`,misusedTopLevel:`Did you just try to use p5.js's {{symbolName}} {{symbolType}}? If so, you may want to move it into your sketch's setup() function.

+ More info: {{url}}`,preloadDisabled:"The preload() function has been removed in p5.js 2.0. Please load assets in setup() using async / await keywords or callbacks instead. See https://dev.to/limzykenneth/asynchronous-p5js-20-458f for more information.",positions:{p_1:"first",p_10:"tenth",p_11:"eleventh",p_12:"twelfth",p_2:"second",p_3:"third",p_4:"fourth",p_5:"fifth",p_6:"sixth",p_7:"seventh",p_8:"eighth",p_9:"ninth"},pre:`
 p5.js says: {{message}}`,sketchReaderErrors:{reservedConst:`you have used a p5.js reserved variable "{{symbol}}" make sure you change the variable name to something else.

+ More info: {{url}}`,reservedFunc:`you have used a p5.js reserved function "{{symbol}}" make sure you change the function name to something else.

+ More info: {{url}}`},welcome:"Welcome! This is your friendly debugger. To turn me off, switch to using p5.min.js.",wrongPreload:'{{location}} An error with message "{{error}}" occurred inside the p5js library when "{{func}}" was called. If not stated otherwise, it might be due to "{{func}}" being called from preload. Nothing besides load calls (loadImage, loadJSON, loadFont, loadStrings, etc.) should be inside the preload function.'},Hoe={fes:Goe},Hy={en:{translation:Hoe}};const joe=["en","es","ko","zh","hi","ja"];if(typeof IS_MINIFIED>"u"&&typeof P5_DEV_BUILD<"u"){let r=require("../../translations/dev");for(const t of Object.keys(r)){const n=t.split("_"),s=n.slice(0,n.length-1).join("-"),i=n[n.length-1];Hy[s]=Hy[s]||{},Hy[s][i]=r[t]}}class iW{constructor(t,n){this.init(t,n)}fetchWithTimeout(t,n,s=2e3){return Promise.race([fetch(t,n),new Promise((i,a)=>setTimeout(()=>a(new Error("timeout")),s))])}init(t,n={}){this.services=t,this.options=n}read(t,n,s){const i=this.options.loadPath;if(t===this.options.fallback)s(null,Hy[t][n]);else if(joe.includes(t)){const a=this.services.interpolator.interpolate(i,{lng:t,ns:n});this.loadUrl(a,s)}else s("Not found",!1)}loadUrl(t,n){this.fetchWithTimeout(t).then(s=>{if(!s.ok)throw new Error(`failed loading ${t}`);return s.json()},()=>{throw new Error(`failed loading ${t}`)}).then(s=>n(null,s)).catch(n)}}iW.type="backend";let ar=(r,t)=>{console.debug("p5.js translator called before translations were loaded"),rW.t(r,t)};const qoe=()=>rW.use(sW).use(iW).init({fallbackLng:"en",nestingPrefix:"$tr(",nestingSuffix:")",defaultNS:"translation",returnEmptyString:!1,interpolation:{escapeValue:!1},detection:{checkWhitelist:!1,order:["querystring","navigator","htmlTag","path","subdomain"],caches:[]},backend:{fallback:"en",loadPath:"https://cdn.jsdelivr.net/npm/p5/translations/{{lng}}/{{ns}}.json"},partialBundledLanguages:!0,resources:Hy}).then(t=>{ar=t},t=>console.debug(`Translations failed to load (${t})`)),Koe={ReferenceError:[{msg:"{{}} is not defined",type:"NOTDEFINED",browser:"all"},{msg:"Can't find variable: {{}}",type:"NOTDEFINED",browser:"Safari"},{msg:"Cannot access '{{.}}' before initialization",type:"CANNOTACCESS",browser:"Chrome"},{msg:"can't access lexical declaration '{{.}}' before initialization",type:"CANNOTACCESS",browser:"Firefox"}],SyntaxError:[{msg:"illegal character",type:"INVALIDTOKEN",browser:"Firefox"},{msg:"Invalid character",type:"INVALIDTOKEN",browser:"Safari"},{msg:"Invalid or unexpected token",type:"INVALIDTOKEN",browser:"Chrome"},{msg:"Unexpected token '{{.}}'",type:"UNEXPECTEDTOKEN",browser:"Chrome"},{msg:"expected {{.}}, got '{{.}}'",type:"UNEXPECTEDTOKEN",browser:"Chrome"},{msg:"Identifier '{{.}}' has already been declared",type:"REDECLAREDVARIABLE",browser:"Chrome"},{msg:"redeclaration of {} {{.}}",type:"REDECLAREDVARIABLE",browser:"Firefox"},{msg:"Missing initializer in const declaration",type:"MISSINGINITIALIZER",browser:"Chrome"},{msg:"missing = in const declaration",type:"MISSINGINITIALIZER",browser:"Firefox"},{msg:"Illegal return statement",type:"BADRETURNORYIELD",browser:"Chrome"},{msg:"return not in function",type:"BADRETURNORYIELD",browser:"Firefox"}],TypeError:[{msg:"{{.}} is not a function",type:"NOTFUNC",browser:"all"},{msg:"Cannot read {{.}} null",type:"READNULL",browser:"Chrome"},{msg:"{{.}} is null",type:"READNULL",browser:"Firefox"},{msg:"Cannot read {{.}} undefined",type:"READUDEFINED",browser:"Chrome"},{msg:"{{.}} is undefined",type:"READUDEFINED",browser:"Firefox"},{msg:"Assignment to constant variable",type:"CONSTASSIGN",browser:"Chrome"},{msg:"invalid assignment to const '{{.}}'",type:"CONSTASSIGN",browser:"Firefox"}]};function aW(r,t){const n=["#2D7BB6","#EE9900","#4DB200","#C83C00"];let s=null,i=null;const a=2;class o extends Error{}if(typeof IS_MINIFIED<"u")r._friendlyError=r._checkForUserDefinedFunctions=r._fesErrorMonitor=()=>{};else{const c={},h=c.toString,d=["Boolean","Number","String","Function","Array","Date","RegExp","Object","Error"];for(let S=0;S<d.length;S++)c[`[object ${d[S]}]`]=d[S].toLowerCase();const p=S=>S==null?`${S}`:typeof S=="object"||typeof S=="function"?c[h.call(S)]||"object":typeof S,f=["setup","draw","deviceMoved","deviceTurned","deviceShaken","doubleClicked","mousePressed","mouseReleased","mouseMoved","mouseDragged","mouseClicked","mouseWheel","touchStarted","touchMoved","touchEnded","keyPressed","keyReleased","keyTyped","windowResized"],m=(S,E)=>{let C="";if(E==null||E.substring(0,4)==="load")C=S;else{const I=E.split("."),_=I.length>1?`${I[0]}.${I[1]}`:"p5",A=I.length===1?E:I.slice(2).join("/");A.startsWith("p5.")?C=`${S} (https://p5js.org/reference/${_}.${A})`:C=`${S} (https://p5js.org/reference/${_}/${A})`}return C};r._report=(S,E,C)=>{const I=r._fesLogger==null?console.log.bind(console):r._fesLogger;p(C)==="undefined"?C="#B40033":p(C)==="number"&&(C=n[C]),S=m(S,E);const _=ar("fes.pre",{message:S});I(_)},r._error=(S,E,C)=>{throw r._report(E,C),S.hitCriticalError=!0,new o("Stopping sketch to prevent more errors")},r._friendlyError=function(S,E,C){r._report(S,E,C)},r._friendlyAutoplayError=function(S){const E=ar("fes.autoplay",{src:S,url:"https://developer.mozilla.org/docs/Web/Media/Autoplay_guide"});console.log(ar("fes.pre",{message:E}))};const g=(S,E)=>{const C=S.length,I=E.length;if(C===0)return E;if(I===0)return S;let _=[],A=[];for(let k=0;k<I+1;k++)A[k]=k;_=A;for(let k=1;k<C+1;k++){A=[];for(let N=0;N<I+1;N++)if(N===0)A[N]=k;else{let D=S[k-1],F=E[N-1],P=999999,G=D.toLowerCase()===F.toLowerCase()?0:1;P=P>G+_[N-1]?G+_[N-1]:P,P=P>1+A[N-1]?1+A[N-1]:P,P=P>1+_[N]?1+_[N]:P,A[N]=P}_=A}return A[I]};r.isPreloadSupported=function(){return!1};const y=S=>{if(r.disableFriendlyErrors)return;S=S instanceof r?S:window;const C=f;S.preload&&!r.isPreloadSupported()&&r._error(S,ar("fes.preloadDisabled"));const I={};C.forEach(_=>{I[_.toLowerCase()]=_});for(const _ of Object.keys(S)){const A=_.toLowerCase();if(I.hasOwnProperty(A)&&!S[I[A]]&&typeof S[_]=="function"){const k=ar("fes.checkUserDefinedFns",{name:_,actualName:I[A]});r._friendlyError(k,I[A])}}},b=(S,E)=>{s||i();const C={};let I=999999;if(s.forEach(A=>{let k=g(S,A.name);C[k]?C[k].push(A):C[k]=[A],k<I&&(I=k)}),I>Math.min(a,S.length))return!1;const _=C[I].filter(A=>A.name!==S);if(_.length!==0){const A=r._getErrorStackParser().parse(E);let k;A&&A[0]&&A[0].fileName&&A[0].lineNumber&&A[0].columnNumber&&(k={location:`${A[0].fileName}:${A[0].lineNumber}:${A[0].columnNumber}`,file:A[0].fileName.split("/").slice(-1),line:A[0].lineNumber});let N;if(_.length===1)N=ar("fes.misspelling",{name:S,actualName:_[0].name,type:_[0].type,location:k?ar("fes.location",k):"",count:_.length});else{const D=_.map(F=>{const P=" "+F.name+(F.type==="function"?"()":"");return m(P,F.name)}).join(`
`);N=ar("fes.misspelling",{name:S,suggestions:D,location:k?ar("fes.location",k):"",count:_.length})}return r._friendlyError(N,_.length===1?_[0].name:void 0),!0}return!1},x=S=>{const E=r._fesLogger&&typeof r._fesLogger=="function"?r._fesLogger:console.log.bind(console);if(S.length>1){let C="";S.forEach((I,_)=>{const A=`${I.fileName}:${I.lineNumber}:${I.columnNumber}`;let k,N={func:I.functionName,line:I.lineNumber,location:A,file:I.fileName.split("/").slice(-1)};_===0?k=ar("fes.globalErrors.stackTop",N):k=ar("fes.globalErrors.stackSubseq",N),C+=k}),E(C)}},w=(S,E)=>{if(!E)return[!1,null];E.forEach(k=>{k.functionName=k.functionName||""});let C=!1,I,_,A;try{throw new Error}catch(k){I=r._getErrorStackParser().parse(k)[0].fileName}for(let k=E.length-1;k>=0;k--){let N=E[k].functionName.split(".");if(f.includes(N[N.length-1])){if(_=E.slice(0,k+1),A=N[N.length-1],E[0].fileName===I){C=!0;break}break}}if(_||(_=E),C){if(_=_.map((D,F)=>(D.frameIndex=F,D)).filter(D=>D.fileName!==I),_.length===0)return[!0,null];const k=E[_[0].frameIndex-2].functionName.split(".").slice(-1)[0];let N;if(_[0].fileName&&_[0].lineNumber&&_[0].columnNumber&&(N={location:`${_[0].fileName}:${_[0].lineNumber}:${_[0].columnNumber}`,file:_[0].fileName.split("/").slice(-1),line:_[0].lineNumber},r._fesLogCache[N.location]))return[!0,null];A==="preload"&&t._preloadMethods[k]==null?r._friendlyError(ar("fes.wrongPreload",{func:k,location:N?ar("fes.location",N):"",error:S.message}),"preload"):r._friendlyError(ar("fes.libraryError",{func:k,location:N?ar("fes.location",N):"",error:S.message}),k),_&&_.length&&x(_)}return[C,_]},v=S=>{if(r.disableFriendlyErrors||S&&(S instanceof o||S.reason instanceof o))return;let E;if(S instanceof Error)E=S;else if(S instanceof ErrorEvent)E=S.error;else if(S instanceof PromiseRejectionEvent&&(E=S.reason,!(E instanceof Error)))return;if(!E)return;let C=r._getErrorStackParser().parse(E),[I,_]=w(E,C);if(I)return;const A=Koe[E.name];if(!A)return;let k;for(const D of A){let F=D.msg;F=F.replace(new RegExp("{{}}","g"),"([a-zA-Z0-9_]+)"),F=F.replace(new RegExp("{{.}}","g"),"(.+)"),F=F.replace(new RegExp("{}","g"),"(?:[a-zA-Z0-9_]+)");let P=E.message.match(F);if(P){k=Object.assign({},D),k.match=P;break}}if(!k)return;let N;switch(C&&C[0].fileName&&C[0].lineNumber&&C[0].columnNumber&&(N={location:`${C[0].fileName}:${C[0].lineNumber}:${C[0].columnNumber}`,file:C[0].fileName.split("/").slice(-1),line:_[0].lineNumber}),E.name){case"SyntaxError":{switch(k.type){case"INVALIDTOKEN":{r._friendlyError(ar("fes.globalErrors.syntax.invalidToken",{url:"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Illegal_character#What_went_wrong"}));break}case"UNEXPECTEDTOKEN":{r._friendlyError(ar("fes.globalErrors.syntax.unexpectedToken",{url:"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Unexpected_token#What_went_wrong"}));break}case"REDECLAREDVARIABLE":{let D=k.match[1];r._friendlyError(ar("fes.globalErrors.syntax.redeclaredVariable",{symbol:D,url:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Redeclared_parameter#what_went_wrong"}));break}case"MISSINGINITIALIZER":{r._friendlyError(ar("fes.globalErrors.syntax.missingInitializer",{url:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Missing_initializer_in_const#what_went_wrong"}));break}case"BADRETURNORYIELD":{r._friendlyError(ar("fes.globalErrors.syntax.badReturnOrYield",{url:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Bad_return_or_yield#what_went_wrong"}));break}}break}case"ReferenceError":{switch(k.type){case"NOTDEFINED":{let D=k.match[1];if(D&&b(D,E))break;r._friendlyError(ar("fes.globalErrors.reference.notDefined",{url:"https://p5js.org/examples/data-variable-scope.html",symbol:D,location:N?ar("fes.location",N):""})),_&&x(_);break}case"CANNOTACCESS":{let D=k.match[1];r._friendlyError(ar("fes.globalErrors.reference.cannotAccess",{url:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_lexical_declaration_before_init#what_went_wrong",symbol:D,location:N?ar("fes.location",N):""})),_&&x(_);break}}break}case"TypeError":switch(k.type){case"NOTFUNC":{let F=k.match[1].split("."),G={url:"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Not_a_function#What_went_wrong",symbol:F[F.length-1],obj:F.slice(0,F.length-1).join("."),location:N?ar("fes.location",N):""};F.length>1?r._friendlyError(ar("fes.globalErrors.type.notfuncObj",G)):r._friendlyError(ar("fes.globalErrors.type.notfunc",G)),_&&x(_);break}case"READNULL":{let D=k.match[1];r._friendlyError(ar("fes.globalErrors.type.readFromNull",{url:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_property#what_went_wrong",symbol:D,location:N?ar("fes.location",N):""})),_&&x(_);break}case"READUDEFINED":{let D=k.match[1];r._friendlyError(ar("fes.globalErrors.type.readFromUndefined",{url:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_property#what_went_wrong",symbol:D,location:N?ar("fes.location",N):""})),_&&x(_);break}case"CONSTASSIGN":{r._friendlyError(ar("fes.globalErrors.type.constAssign",{url:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_const_assignment#what_went_wrong",location:N?ar("fes.location",N):""})),_&&x(_);break}}}};r._fesErrorMonitor=v,r._checkForUserDefinedFunctions=y,r._fesLogger=null,r._fesLogCache={},window.addEventListener("load",y,!1),window.addEventListener("error",r._fesErrorMonitor,!1),window.addEventListener("unhandledrejection",r._fesErrorMonitor,!1)}s=null;const u="https://github.com/processing/p5.js/wiki/p5.js-overview#why-cant-i-assign-variables-using-p5-functions-and-variables-before-setup";i=()=>{const c={},h=d=>Object.getOwnPropertyNames(d).filter(p=>p[0]==="_"||p in c?!1:(c[p]=!0,!0)).map(p=>{let f;return typeof d[p]=="function"?f="function":p===p.toUpperCase()?f="constant":f="variable",{name:p,type:f}});s=[].concat(h(t),h(Wh)),s.sort((d,p)=>p.name.length-d.name.length)};const l=(c,h)=>{h||(h=console.log.bind(console)),s||i(),s.some(d=>{if(c.message&&c.message.match(`\\W?${d.name}\\W`)!==null){const p=d.type==="function"?`${d.name}()`:d.name;return h(typeof IS_MINIFIED<"u"?`Did you just try to use p5.js's ${p} ${d.type}? If so, you may want to move it into your sketch's setup() function.

For more details, see: ${u}`:ar("fes.misusedTopLevel",{symbolName:p,symbolType:d.type,url:u})),!0}})};t._helpForMisusedAtTopLevelCode=l,document.readyState!=="complete"&&(window.addEventListener("error",l,!1),window.addEventListener("load",()=>{window.removeEventListener("error",l,!1)}))}typeof p5<"u"&&aW(p5,p5.prototype);function Xoe(){let r=/(^|@)\S+:\d+/,t=/^\s*at .*(\S+:\d+|\(native\))/m,n=/^(eval@)?(\[native code])?$/;return{parse:function(i){if(typeof i.stacktrace<"u"||typeof i["opera#sourceloc"]<"u")return this.parseOpera(i);if(i.stack&&i.stack.match(t))return this.parseV8OrIE(i);if(i.stack)return this.parseFFOrSafari(i)},extractLocation:function(i){if(i.indexOf(":")===-1)return[i];let o=/(.+?)(?::(\d+))?(?::(\d+))?$/.exec(i.replace(/[()]/g,""));return[o[1],o[2]||void 0,o[3]||void 0]},parseV8OrIE:function(i){return i.stack.split(`
`).filter(function(o){return!!o.match(t)},this).map(function(o){o.indexOf("(eval ")>-1&&(o=o.replace(/eval code/g,"eval").replace(/(\(eval at [^()]*)|(\),.*$)/g,""));let u=o.replace(/^\s+/,"").replace(/\(eval code/g,"("),l=u.match(/ (\((.+):(\d+):(\d+)\)$)/);u=l?u.replace(l[0],""):u;let c=u.split(/\s+/).slice(1),h=this.extractLocation(l?l[1]:c.pop()),d=c.join(" ")||void 0,p=["eval","<anonymous>"].indexOf(h[0])>-1?void 0:h[0];return{functionName:d,fileName:p,lineNumber:h[1],columnNumber:h[2],source:o}},this)},parseFFOrSafari:function(i){return i.stack.split(`
`).filter(function(o){return!o.match(n)},this).map(function(o){if(o.indexOf(" > eval")>-1&&(o=o.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,":$1")),o.indexOf("@")===-1&&o.indexOf(":")===-1)return{functionName:o};{let u=/((.*".+"[^@]*)?[^@]*)(?:@)/,l=o.match(u),c=l&&l[1]?l[1]:void 0,h=this.extractLocation(o.replace(u,""));return{functionName:c,fileName:h[0],lineNumber:h[1],columnNumber:h[2],source:o}}},this)},parseOpera:function(i){return!i.stacktrace||i.message.indexOf(`
`)>-1&&i.message.split(`
`).length>i.stacktrace.split(`
`).length?this.parseOpera9(i):i.stack?this.parseOpera11(i):this.parseOpera10(i)},parseOpera9:function(i){let a=/Line (\d+).*script (?:in )?(\S+)/i,o=i.message.split(`
`),u=[];for(let l=2,c=o.length;l<c;l+=2){let h=a.exec(o[l]);h&&u.push({fileName:h[2],lineNumber:h[1],source:o[l]})}return u},parseOpera10:function(i){let a=/Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,o=i.stacktrace.split(`
`),u=[];for(let l=0,c=o.length;l<c;l+=2){let h=a.exec(o[l]);h&&u.push({functionName:h[3]||void 0,fileName:h[2],lineNumber:h[1],source:o[l]})}return u},parseOpera11:function(i){return i.stack.split(`
`).filter(function(o){return!!o.match(r)&&!o.match(/^Error created at/)},this).map(function(o){let u=o.split("@"),l=this.extractLocation(u.pop()),c=u.shift()||"",h=c.replace(/<anonymous function(: (\w+))?>/,"$2").replace(/\([^)]*\)/g,"")||void 0,d;c.match(/\(([^)]*)\)/)&&(d=c.replace(/^[^(]+\(([^)]*)\)$/,"$1"));let p=d===void 0||d==="[arguments not available]"?void 0:d.split(",");return{functionName:h,args:p,fileName:l[0],lineNumber:l[1],columnNumber:l[2],source:o}},this)}}}function oW(r,t){r._getErrorStackParser=function(){return new Xoe}}typeof p5<"u"&&oW(p5,p5.prototype);var zr;(function(r){r.assertEqual=i=>i;function t(i){}r.assertIs=t;function n(i){throw new Error}r.assertNever=n,r.arrayToEnum=i=>{const a={};for(const o of i)a[o]=o;return a},r.getValidEnumValues=i=>{const a=r.objectKeys(i).filter(u=>typeof i[i[u]]!="number"),o={};for(const u of a)o[u]=i[u];return r.objectValues(o)},r.objectValues=i=>r.objectKeys(i).map(function(a){return i[a]}),r.objectKeys=typeof Object.keys=="function"?i=>Object.keys(i):i=>{const a=[];for(const o in i)Object.prototype.hasOwnProperty.call(i,o)&&a.push(o);return a},r.find=(i,a)=>{for(const o of i)if(a(o))return o},r.isInteger=typeof Number.isInteger=="function"?i=>Number.isInteger(i):i=>typeof i=="number"&&isFinite(i)&&Math.floor(i)===i;function s(i,a=" | "){return i.map(o=>typeof o=="string"?`'${o}'`:o).join(a)}r.joinValues=s,r.jsonStringifyReplacer=(i,a)=>typeof a=="bigint"?a.toString():a})(zr||(zr={}));var cB;(function(r){r.mergeShapes=(t,n)=>({...t,...n})})(cB||(cB={}));const Nt=zr.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"]),Ol=r=>{switch(typeof r){case"undefined":return Nt.undefined;case"string":return Nt.string;case"number":return isNaN(r)?Nt.nan:Nt.number;case"boolean":return Nt.boolean;case"function":return Nt.function;case"bigint":return Nt.bigint;case"symbol":return Nt.symbol;case"object":return Array.isArray(r)?Nt.array:r===null?Nt.null:r.then&&typeof r.then=="function"&&r.catch&&typeof r.catch=="function"?Nt.promise:typeof Map<"u"&&r instanceof Map?Nt.map:typeof Set<"u"&&r instanceof Set?Nt.set:typeof Date<"u"&&r instanceof Date?Nt.date:Nt.object;default:return Nt.unknown}},ot=zr.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]);class ja extends Error{get errors(){return this.issues}constructor(t){super(),this.issues=[],this.addIssue=s=>{this.issues=[...this.issues,s]},this.addIssues=(s=[])=>{this.issues=[...this.issues,...s]};const n=new.target.prototype;Object.setPrototypeOf?Object.setPrototypeOf(this,n):this.__proto__=n,this.name="ZodError",this.issues=t}format(t){const n=t||function(a){return a.message},s={_errors:[]},i=a=>{for(const o of a.issues)if(o.code==="invalid_union")o.unionErrors.map(i);else if(o.code==="invalid_return_type")i(o.returnTypeError);else if(o.code==="invalid_arguments")i(o.argumentsError);else if(o.path.length===0)s._errors.push(n(o));else{let u=s,l=0;for(;l<o.path.length;){const c=o.path[l];l===o.path.length-1?(u[c]=u[c]||{_errors:[]},u[c]._errors.push(n(o))):u[c]=u[c]||{_errors:[]},u=u[c],l++}}};return i(this),s}static assert(t){if(!(t instanceof ja))throw new Error(`Not a ZodError: ${t}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,zr.jsonStringifyReplacer,2)}get isEmpty(){return this.issues.length===0}flatten(t=n=>n.message){const n={},s=[];for(const i of this.issues)i.path.length>0?(n[i.path[0]]=n[i.path[0]]||[],n[i.path[0]].push(t(i))):s.push(t(i));return{formErrors:s,fieldErrors:n}}get formErrors(){return this.flatten()}}ja.create=r=>new ja(r);const mb=(r,t)=>{let n;switch(r.code){case ot.invalid_type:r.received===Nt.undefined?n="Required":n=`Expected ${r.expected}, received ${r.received}`;break;case ot.invalid_literal:n=`Invalid literal value, expected ${JSON.stringify(r.expected,zr.jsonStringifyReplacer)}`;break;case ot.unrecognized_keys:n=`Unrecognized key(s) in object: ${zr.joinValues(r.keys,", ")}`;break;case ot.invalid_union:n="Invalid input";break;case ot.invalid_union_discriminator:n=`Invalid discriminator value. Expected ${zr.joinValues(r.options)}`;break;case ot.invalid_enum_value:n=`Invalid enum value. Expected ${zr.joinValues(r.options)}, received '${r.received}'`;break;case ot.invalid_arguments:n="Invalid function arguments";break;case ot.invalid_return_type:n="Invalid function return type";break;case ot.invalid_date:n="Invalid date";break;case ot.invalid_string:typeof r.validation=="object"?"includes"in r.validation?(n=`Invalid input: must include "${r.validation.includes}"`,typeof r.validation.position=="number"&&(n=`${n} at one or more positions greater than or equal to ${r.validation.position}`)):"startsWith"in r.validation?n=`Invalid input: must start with "${r.validation.startsWith}"`:"endsWith"in r.validation?n=`Invalid input: must end with "${r.validation.endsWith}"`:zr.assertNever(r.validation):r.validation!=="regex"?n=`Invalid ${r.validation}`:n="Invalid";break;case ot.too_small:r.type==="array"?n=`Array must contain ${r.exact?"exactly":r.inclusive?"at least":"more than"} ${r.minimum} element(s)`:r.type==="string"?n=`String must contain ${r.exact?"exactly":r.inclusive?"at least":"over"} ${r.minimum} character(s)`:r.type==="number"?n=`Number must be ${r.exact?"exactly equal to ":r.inclusive?"greater than or equal to ":"greater than "}${r.minimum}`:r.type==="date"?n=`Date must be ${r.exact?"exactly equal to ":r.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(r.minimum))}`:n="Invalid input";break;case ot.too_big:r.type==="array"?n=`Array must contain ${r.exact?"exactly":r.inclusive?"at most":"less than"} ${r.maximum} element(s)`:r.type==="string"?n=`String must contain ${r.exact?"exactly":r.inclusive?"at most":"under"} ${r.maximum} character(s)`:r.type==="number"?n=`Number must be ${r.exact?"exactly":r.inclusive?"less than or equal to":"less than"} ${r.maximum}`:r.type==="bigint"?n=`BigInt must be ${r.exact?"exactly":r.inclusive?"less than or equal to":"less than"} ${r.maximum}`:r.type==="date"?n=`Date must be ${r.exact?"exactly":r.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(r.maximum))}`:n="Invalid input";break;case ot.custom:n="Invalid input";break;case ot.invalid_intersection_types:n="Intersection results could not be merged";break;case ot.not_multiple_of:n=`Number must be a multiple of ${r.multipleOf}`;break;case ot.not_finite:n="Number must be finite";break;default:n=t.defaultError,zr.assertNever(r)}return{message:n}};let Yoe=mb;function QI(){return Yoe}const ek=r=>{const{data:t,path:n,errorMaps:s,issueData:i}=r,a=[...n,...i.path||[]],o={...i,path:a};if(i.message!==void 0)return{...i,path:a,message:i.message};let u="";const l=s.filter(c=>!!c).slice().reverse();for(const c of l)u=c(o,{data:t,defaultError:u}).message;return{...i,path:a,message:u}};function St(r,t){const n=QI(),s=ek({issueData:t,data:r.data,path:r.path,errorMaps:[r.common.contextualErrorMap,r.schemaErrorMap,n,n===mb?void 0:mb].filter(i=>!!i)});r.common.issues.push(s)}class Ii{constructor(){this.value="valid"}dirty(){this.value==="valid"&&(this.value="dirty")}abort(){this.value!=="aborted"&&(this.value="aborted")}static mergeArray(t,n){const s=[];for(const i of n){if(i.status==="aborted")return rr;i.status==="dirty"&&t.dirty(),s.push(i.value)}return{status:t.value,value:s}}static async mergeObjectAsync(t,n){const s=[];for(const i of n){const a=await i.key,o=await i.value;s.push({key:a,value:o})}return Ii.mergeObjectSync(t,s)}static mergeObjectSync(t,n){const s={};for(const i of n){const{key:a,value:o}=i;if(a.status==="aborted"||o.status==="aborted")return rr;a.status==="dirty"&&t.dirty(),o.status==="dirty"&&t.dirty(),a.value!=="__proto__"&&(typeof o.value<"u"||i.alwaysSet)&&(s[a.value]=o.value)}return{status:t.value,value:s}}}const rr=Object.freeze({status:"aborted"}),Sy=r=>({status:"dirty",value:r}),ea=r=>({status:"valid",value:r}),hB=r=>r.status==="aborted",dB=r=>r.status==="dirty",km=r=>r.status==="valid",Jw=r=>typeof Promise<"u"&&r instanceof Promise;function Qw(r,t,n,s){if(typeof t=="function"?r!==t||!0:!t.has(r))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t.get(r)}function uW(r,t,n,s,i){if(typeof t=="function"?r!==t||!0:!t.has(r))throw new TypeError("Cannot write private member to an object whose class did not declare it");return t.set(r,n),n}var Vt;(function(r){r.errToObj=t=>typeof t=="string"?{message:t}:t||{},r.toString=t=>typeof t=="string"?t:t==null?void 0:t.message})(Vt||(Vt={}));var Cy,_y;class lu{constructor(t,n,s,i){this._cachedPath=[],this.parent=t,this.data=n,this._path=s,this._key=i}get path(){return this._cachedPath.length||(this._key instanceof Array?this._cachedPath.push(...this._path,...this._key):this._cachedPath.push(...this._path,this._key)),this._cachedPath}}const pB=(r,t)=>{if(km(t))return{success:!0,data:t.value};if(!r.common.issues.length)throw new Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;const n=new ja(r.common.issues);return this._error=n,this._error}}};function fr(r){if(!r)return{};const{errorMap:t,invalid_type_error:n,required_error:s,description:i}=r;if(t&&(n||s))throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);return t?{errorMap:t,description:i}:{errorMap:(o,u)=>{var l,c;const{message:h}=r;return o.code==="invalid_enum_value"?{message:h??u.defaultError}:typeof u.data>"u"?{message:(l=h??s)!==null&&l!==void 0?l:u.defaultError}:o.code!=="invalid_type"?{message:u.defaultError}:{message:(c=h??n)!==null&&c!==void 0?c:u.defaultError}},description:i}}class _r{get description(){return this._def.description}_getType(t){return Ol(t.data)}_getOrReturnCtx(t,n){return n||{common:t.parent.common,data:t.data,parsedType:Ol(t.data),schemaErrorMap:this._def.errorMap,path:t.path,parent:t.parent}}_processInputParams(t){return{status:new Ii,ctx:{common:t.parent.common,data:t.data,parsedType:Ol(t.data),schemaErrorMap:this._def.errorMap,path:t.path,parent:t.parent}}}_parseSync(t){const n=this._parse(t);if(Jw(n))throw new Error("Synchronous parse encountered promise.");return n}_parseAsync(t){const n=this._parse(t);return Promise.resolve(n)}parse(t,n){const s=this.safeParse(t,n);if(s.success)return s.data;throw s.error}safeParse(t,n){var s;const i={common:{issues:[],async:(s=n==null?void 0:n.async)!==null&&s!==void 0?s:!1,contextualErrorMap:n==null?void 0:n.errorMap},path:(n==null?void 0:n.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:t,parsedType:Ol(t)},a=this._parseSync({data:t,path:i.path,parent:i});return pB(i,a)}"~validate"(t){var n,s;const i={common:{issues:[],async:!!this["~standard"].async},path:[],schemaErrorMap:this._def.errorMap,parent:null,data:t,parsedType:Ol(t)};if(!this["~standard"].async)try{const a=this._parseSync({data:t,path:[],parent:i});return km(a)?{value:a.value}:{issues:i.common.issues}}catch(a){!((s=(n=a==null?void 0:a.message)===null||n===void 0?void 0:n.toLowerCase())===null||s===void 0)&&s.includes("encountered")&&(this["~standard"].async=!0),i.common={issues:[],async:!0}}return this._parseAsync({data:t,path:[],parent:i}).then(a=>km(a)?{value:a.value}:{issues:i.common.issues})}async parseAsync(t,n){const s=await this.safeParseAsync(t,n);if(s.success)return s.data;throw s.error}async safeParseAsync(t,n){const s={common:{issues:[],contextualErrorMap:n==null?void 0:n.errorMap,async:!0},path:(n==null?void 0:n.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:t,parsedType:Ol(t)},i=this._parse({data:t,path:s.path,parent:s}),a=await(Jw(i)?i:Promise.resolve(i));return pB(s,a)}refine(t,n){const s=i=>typeof n=="string"||typeof n>"u"?{message:n}:typeof n=="function"?n(i):n;return this._refinement((i,a)=>{const o=t(i),u=()=>a.addIssue({code:ot.custom,...s(i)});return typeof Promise<"u"&&o instanceof Promise?o.then(l=>l?!0:(u(),!1)):o?!0:(u(),!1)})}refinement(t,n){return this._refinement((s,i)=>t(s)?!0:(i.addIssue(typeof n=="function"?n(s,i):n),!1))}_refinement(t){return new sl({schema:this,typeName:er.ZodEffects,effect:{type:"refinement",refinement:t}})}superRefine(t){return this._refinement(t)}constructor(t){this.spa=this.safeParseAsync,this._def=t,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this),this["~standard"]={version:1,vendor:"zod",validate:n=>this["~validate"](n)}}optional(){return Yu.create(this,this._def)}nullable(){return Zh.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return su.create(this)}promise(){return xb.create(this,this._def)}or(t){return bb.create([this,t],this._def)}and(t){return r2.create(this,t,this._def)}transform(t){return new sl({...fr(this._def),schema:this,typeName:er.ZodEffects,effect:{type:"transform",transform:t}})}default(t){const n=typeof t=="function"?t:()=>t;return new o2({...fr(this._def),innerType:this,defaultValue:n,typeName:er.ZodDefault})}brand(){return new dW({typeName:er.ZodBranded,type:this,...fr(this._def)})}catch(t){const n=typeof t=="function"?t:()=>t;return new u2({...fr(this._def),innerType:this,catchValue:n,typeName:er.ZodCatch})}describe(t){const n=this.constructor;return new n({...this._def,description:t})}pipe(t){return PS.create(this,t)}readonly(){return l2.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}const Zoe=/^c[^\s-]{8,}$/i,Joe=/^[0-9a-z]+$/,Qoe=/^[0-9A-HJKMNP-TV-Z]{26}$/i,eue=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,tue=/^[a-z0-9_-]{21}$/i,rue=/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,nue=/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,sue=/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,iue="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";let fE;const aue=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,oue=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,uue=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,lue=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,cue=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,hue=/^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,lW="((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",due=new RegExp(`^${lW}$`);function cW(r){let t="[0-5]\\d";r.precision?t=`${t}\\.\\d{${r.precision}}`:r.precision==null&&(t=`${t}(\\.\\d+)?`);const n=r.precision?"+":"?";return`([01]\\d|2[0-3]):[0-5]\\d(:${t})${n}`}function pue(r){return new RegExp(`^${cW(r)}$`)}function fue(r){let t=`${lW}T${cW(r)}`;const n=[];return n.push(r.local?"Z?":"Z"),r.offset&&n.push("([+-]\\d{2}:?\\d{2})"),t=`${t}(${n.join("|")})`,new RegExp(`^${t}$`)}function mue(r,t){return!!((t==="v4"||!t)&&aue.test(r)||(t==="v6"||!t)&&uue.test(r))}function gue(r,t){if(!rue.test(r))return!1;try{const[n]=r.split("."),s=n.replace(/-/g,"+").replace(/_/g,"/").padEnd(n.length+(4-n.length%4)%4,"="),i=JSON.parse(atob(s));return!(typeof i!="object"||i===null||!i.typ||!i.alg||t&&i.alg!==t)}catch{return!1}}function yue(r,t){return!!((t==="v4"||!t)&&oue.test(r)||(t==="v6"||!t)&&lue.test(r))}class Ku extends _r{_parse(t){if(this._def.coerce&&(t.data=String(t.data)),this._getType(t)!==Nt.string){const a=this._getOrReturnCtx(t);return St(a,{code:ot.invalid_type,expected:Nt.string,received:a.parsedType}),rr}const s=new Ii;let i;for(const a of this._def.checks)if(a.kind==="min")t.data.length<a.value&&(i=this._getOrReturnCtx(t,i),St(i,{code:ot.too_small,minimum:a.value,type:"string",inclusive:!0,exact:!1,message:a.message}),s.dirty());else if(a.kind==="max")t.data.length>a.value&&(i=this._getOrReturnCtx(t,i),St(i,{code:ot.too_big,maximum:a.value,type:"string",inclusive:!0,exact:!1,message:a.message}),s.dirty());else if(a.kind==="length"){const o=t.data.length>a.value,u=t.data.length<a.value;(o||u)&&(i=this._getOrReturnCtx(t,i),o?St(i,{code:ot.too_big,maximum:a.value,type:"string",inclusive:!0,exact:!0,message:a.message}):u&&St(i,{code:ot.too_small,minimum:a.value,type:"string",inclusive:!0,exact:!0,message:a.message}),s.dirty())}else if(a.kind==="email")sue.test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"email",code:ot.invalid_string,message:a.message}),s.dirty());else if(a.kind==="emoji")fE||(fE=new RegExp(iue,"u")),fE.test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"emoji",code:ot.invalid_string,message:a.message}),s.dirty());else if(a.kind==="uuid")eue.test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"uuid",code:ot.invalid_string,message:a.message}),s.dirty());else if(a.kind==="nanoid")tue.test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"nanoid",code:ot.invalid_string,message:a.message}),s.dirty());else if(a.kind==="cuid")Zoe.test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"cuid",code:ot.invalid_string,message:a.message}),s.dirty());else if(a.kind==="cuid2")Joe.test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"cuid2",code:ot.invalid_string,message:a.message}),s.dirty());else if(a.kind==="ulid")Qoe.test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"ulid",code:ot.invalid_string,message:a.message}),s.dirty());else if(a.kind==="url")try{new URL(t.data)}catch{i=this._getOrReturnCtx(t,i),St(i,{validation:"url",code:ot.invalid_string,message:a.message}),s.dirty()}else a.kind==="regex"?(a.regex.lastIndex=0,a.regex.test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"regex",code:ot.invalid_string,message:a.message}),s.dirty())):a.kind==="trim"?t.data=t.data.trim():a.kind==="includes"?t.data.includes(a.value,a.position)||(i=this._getOrReturnCtx(t,i),St(i,{code:ot.invalid_string,validation:{includes:a.value,position:a.position},message:a.message}),s.dirty()):a.kind==="toLowerCase"?t.data=t.data.toLowerCase():a.kind==="toUpperCase"?t.data=t.data.toUpperCase():a.kind==="startsWith"?t.data.startsWith(a.value)||(i=this._getOrReturnCtx(t,i),St(i,{code:ot.invalid_string,validation:{startsWith:a.value},message:a.message}),s.dirty()):a.kind==="endsWith"?t.data.endsWith(a.value)||(i=this._getOrReturnCtx(t,i),St(i,{code:ot.invalid_string,validation:{endsWith:a.value},message:a.message}),s.dirty()):a.kind==="datetime"?fue(a).test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{code:ot.invalid_string,validation:"datetime",message:a.message}),s.dirty()):a.kind==="date"?due.test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{code:ot.invalid_string,validation:"date",message:a.message}),s.dirty()):a.kind==="time"?pue(a).test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{code:ot.invalid_string,validation:"time",message:a.message}),s.dirty()):a.kind==="duration"?nue.test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"duration",code:ot.invalid_string,message:a.message}),s.dirty()):a.kind==="ip"?mue(t.data,a.version)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"ip",code:ot.invalid_string,message:a.message}),s.dirty()):a.kind==="jwt"?gue(t.data,a.alg)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"jwt",code:ot.invalid_string,message:a.message}),s.dirty()):a.kind==="cidr"?yue(t.data,a.version)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"cidr",code:ot.invalid_string,message:a.message}),s.dirty()):a.kind==="base64"?cue.test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"base64",code:ot.invalid_string,message:a.message}),s.dirty()):a.kind==="base64url"?hue.test(t.data)||(i=this._getOrReturnCtx(t,i),St(i,{validation:"base64url",code:ot.invalid_string,message:a.message}),s.dirty()):zr.assertNever(a);return{status:s.value,value:t.data}}_regex(t,n,s){return this.refinement(i=>t.test(i),{validation:n,code:ot.invalid_string,...Vt.errToObj(s)})}_addCheck(t){return new Ku({...this._def,checks:[...this._def.checks,t]})}email(t){return this._addCheck({kind:"email",...Vt.errToObj(t)})}url(t){return this._addCheck({kind:"url",...Vt.errToObj(t)})}emoji(t){return this._addCheck({kind:"emoji",...Vt.errToObj(t)})}uuid(t){return this._addCheck({kind:"uuid",...Vt.errToObj(t)})}nanoid(t){return this._addCheck({kind:"nanoid",...Vt.errToObj(t)})}cuid(t){return this._addCheck({kind:"cuid",...Vt.errToObj(t)})}cuid2(t){return this._addCheck({kind:"cuid2",...Vt.errToObj(t)})}ulid(t){return this._addCheck({kind:"ulid",...Vt.errToObj(t)})}base64(t){return this._addCheck({kind:"base64",...Vt.errToObj(t)})}base64url(t){return this._addCheck({kind:"base64url",...Vt.errToObj(t)})}jwt(t){return this._addCheck({kind:"jwt",...Vt.errToObj(t)})}ip(t){return this._addCheck({kind:"ip",...Vt.errToObj(t)})}cidr(t){return this._addCheck({kind:"cidr",...Vt.errToObj(t)})}datetime(t){var n,s;return typeof t=="string"?this._addCheck({kind:"datetime",precision:null,offset:!1,local:!1,message:t}):this._addCheck({kind:"datetime",precision:typeof(t==null?void 0:t.precision)>"u"?null:t==null?void 0:t.precision,offset:(n=t==null?void 0:t.offset)!==null&&n!==void 0?n:!1,local:(s=t==null?void 0:t.local)!==null&&s!==void 0?s:!1,...Vt.errToObj(t==null?void 0:t.message)})}date(t){return this._addCheck({kind:"date",message:t})}time(t){return typeof t=="string"?this._addCheck({kind:"time",precision:null,message:t}):this._addCheck({kind:"time",precision:typeof(t==null?void 0:t.precision)>"u"?null:t==null?void 0:t.precision,...Vt.errToObj(t==null?void 0:t.message)})}duration(t){return this._addCheck({kind:"duration",...Vt.errToObj(t)})}regex(t,n){return this._addCheck({kind:"regex",regex:t,...Vt.errToObj(n)})}includes(t,n){return this._addCheck({kind:"includes",value:t,position:n==null?void 0:n.position,...Vt.errToObj(n==null?void 0:n.message)})}startsWith(t,n){return this._addCheck({kind:"startsWith",value:t,...Vt.errToObj(n)})}endsWith(t,n){return this._addCheck({kind:"endsWith",value:t,...Vt.errToObj(n)})}min(t,n){return this._addCheck({kind:"min",value:t,...Vt.errToObj(n)})}max(t,n){return this._addCheck({kind:"max",value:t,...Vt.errToObj(n)})}length(t,n){return this._addCheck({kind:"length",value:t,...Vt.errToObj(n)})}nonempty(t){return this.min(1,Vt.errToObj(t))}trim(){return new Ku({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new Ku({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new Ku({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find(t=>t.kind==="datetime")}get isDate(){return!!this._def.checks.find(t=>t.kind==="date")}get isTime(){return!!this._def.checks.find(t=>t.kind==="time")}get isDuration(){return!!this._def.checks.find(t=>t.kind==="duration")}get isEmail(){return!!this._def.checks.find(t=>t.kind==="email")}get isURL(){return!!this._def.checks.find(t=>t.kind==="url")}get isEmoji(){return!!this._def.checks.find(t=>t.kind==="emoji")}get isUUID(){return!!this._def.checks.find(t=>t.kind==="uuid")}get isNANOID(){return!!this._def.checks.find(t=>t.kind==="nanoid")}get isCUID(){return!!this._def.checks.find(t=>t.kind==="cuid")}get isCUID2(){return!!this._def.checks.find(t=>t.kind==="cuid2")}get isULID(){return!!this._def.checks.find(t=>t.kind==="ulid")}get isIP(){return!!this._def.checks.find(t=>t.kind==="ip")}get isCIDR(){return!!this._def.checks.find(t=>t.kind==="cidr")}get isBase64(){return!!this._def.checks.find(t=>t.kind==="base64")}get isBase64url(){return!!this._def.checks.find(t=>t.kind==="base64url")}get minLength(){let t=null;for(const n of this._def.checks)n.kind==="min"&&(t===null||n.value>t)&&(t=n.value);return t}get maxLength(){let t=null;for(const n of this._def.checks)n.kind==="max"&&(t===null||n.value<t)&&(t=n.value);return t}}Ku.create=r=>{var t;return new Ku({checks:[],typeName:er.ZodString,coerce:(t=r==null?void 0:r.coerce)!==null&&t!==void 0?t:!1,...fr(r)})};function bue(r,t){const n=(r.toString().split(".")[1]||"").length,s=(t.toString().split(".")[1]||"").length,i=n>s?n:s,a=parseInt(r.toFixed(i).replace(".","")),o=parseInt(t.toFixed(i).replace(".",""));return a%o/Math.pow(10,i)}class Nm extends _r{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse(t){if(this._def.coerce&&(t.data=Number(t.data)),this._getType(t)!==Nt.number){const a=this._getOrReturnCtx(t);return St(a,{code:ot.invalid_type,expected:Nt.number,received:a.parsedType}),rr}let s;const i=new Ii;for(const a of this._def.checks)a.kind==="int"?zr.isInteger(t.data)||(s=this._getOrReturnCtx(t,s),St(s,{code:ot.invalid_type,expected:"integer",received:"float",message:a.message}),i.dirty()):a.kind==="min"?(a.inclusive?t.data<a.value:t.data<=a.value)&&(s=this._getOrReturnCtx(t,s),St(s,{code:ot.too_small,minimum:a.value,type:"number",inclusive:a.inclusive,exact:!1,message:a.message}),i.dirty()):a.kind==="max"?(a.inclusive?t.data>a.value:t.data>=a.value)&&(s=this._getOrReturnCtx(t,s),St(s,{code:ot.too_big,maximum:a.value,type:"number",inclusive:a.inclusive,exact:!1,message:a.message}),i.dirty()):a.kind==="multipleOf"?bue(t.data,a.value)!==0&&(s=this._getOrReturnCtx(t,s),St(s,{code:ot.not_multiple_of,multipleOf:a.value,message:a.message}),i.dirty()):a.kind==="finite"?Number.isFinite(t.data)||(s=this._getOrReturnCtx(t,s),St(s,{code:ot.not_finite,message:a.message}),i.dirty()):zr.assertNever(a);return{status:i.value,value:t.data}}gte(t,n){return this.setLimit("min",t,!0,Vt.toString(n))}gt(t,n){return this.setLimit("min",t,!1,Vt.toString(n))}lte(t,n){return this.setLimit("max",t,!0,Vt.toString(n))}lt(t,n){return this.setLimit("max",t,!1,Vt.toString(n))}setLimit(t,n,s,i){return new Nm({...this._def,checks:[...this._def.checks,{kind:t,value:n,inclusive:s,message:Vt.toString(i)}]})}_addCheck(t){return new Nm({...this._def,checks:[...this._def.checks,t]})}int(t){return this._addCheck({kind:"int",message:Vt.toString(t)})}positive(t){return this._addCheck({kind:"min",value:0,inclusive:!1,message:Vt.toString(t)})}negative(t){return this._addCheck({kind:"max",value:0,inclusive:!1,message:Vt.toString(t)})}nonpositive(t){return this._addCheck({kind:"max",value:0,inclusive:!0,message:Vt.toString(t)})}nonnegative(t){return this._addCheck({kind:"min",value:0,inclusive:!0,message:Vt.toString(t)})}multipleOf(t,n){return this._addCheck({kind:"multipleOf",value:t,message:Vt.toString(n)})}finite(t){return this._addCheck({kind:"finite",message:Vt.toString(t)})}safe(t){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:Vt.toString(t)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:Vt.toString(t)})}get minValue(){let t=null;for(const n of this._def.checks)n.kind==="min"&&(t===null||n.value>t)&&(t=n.value);return t}get maxValue(){let t=null;for(const n of this._def.checks)n.kind==="max"&&(t===null||n.value<t)&&(t=n.value);return t}get isInt(){return!!this._def.checks.find(t=>t.kind==="int"||t.kind==="multipleOf"&&zr.isInteger(t.value))}get isFinite(){let t=null,n=null;for(const s of this._def.checks){if(s.kind==="finite"||s.kind==="int"||s.kind==="multipleOf")return!0;s.kind==="min"?(n===null||s.value>n)&&(n=s.value):s.kind==="max"&&(t===null||s.value<t)&&(t=s.value)}return Number.isFinite(n)&&Number.isFinite(t)}}Nm.create=r=>new Nm({checks:[],typeName:er.ZodNumber,coerce:(r==null?void 0:r.coerce)||!1,...fr(r)});class Tm extends _r{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte}_parse(t){if(this._def.coerce)try{t.data=BigInt(t.data)}catch{return this._getInvalidInput(t)}if(this._getType(t)!==Nt.bigint)return this._getInvalidInput(t);let s;const i=new Ii;for(const a of this._def.checks)a.kind==="min"?(a.inclusive?t.data<a.value:t.data<=a.value)&&(s=this._getOrReturnCtx(t,s),St(s,{code:ot.too_small,type:"bigint",minimum:a.value,inclusive:a.inclusive,message:a.message}),i.dirty()):a.kind==="max"?(a.inclusive?t.data>a.value:t.data>=a.value)&&(s=this._getOrReturnCtx(t,s),St(s,{code:ot.too_big,type:"bigint",maximum:a.value,inclusive:a.inclusive,message:a.message}),i.dirty()):a.kind==="multipleOf"?t.data%a.value!==BigInt(0)&&(s=this._getOrReturnCtx(t,s),St(s,{code:ot.not_multiple_of,multipleOf:a.value,message:a.message}),i.dirty()):zr.assertNever(a);return{status:i.value,value:t.data}}_getInvalidInput(t){const n=this._getOrReturnCtx(t);return St(n,{code:ot.invalid_type,expected:Nt.bigint,received:n.parsedType}),rr}gte(t,n){return this.setLimit("min",t,!0,Vt.toString(n))}gt(t,n){return this.setLimit("min",t,!1,Vt.toString(n))}lte(t,n){return this.setLimit("max",t,!0,Vt.toString(n))}lt(t,n){return this.setLimit("max",t,!1,Vt.toString(n))}setLimit(t,n,s,i){return new Tm({...this._def,checks:[...this._def.checks,{kind:t,value:n,inclusive:s,message:Vt.toString(i)}]})}_addCheck(t){return new Tm({...this._def,checks:[...this._def.checks,t]})}positive(t){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:Vt.toString(t)})}negative(t){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:Vt.toString(t)})}nonpositive(t){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:Vt.toString(t)})}nonnegative(t){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:Vt.toString(t)})}multipleOf(t,n){return this._addCheck({kind:"multipleOf",value:t,message:Vt.toString(n)})}get minValue(){let t=null;for(const n of this._def.checks)n.kind==="min"&&(t===null||n.value>t)&&(t=n.value);return t}get maxValue(){let t=null;for(const n of this._def.checks)n.kind==="max"&&(t===null||n.value<t)&&(t=n.value);return t}}Tm.create=r=>{var t;return new Tm({checks:[],typeName:er.ZodBigInt,coerce:(t=r==null?void 0:r.coerce)!==null&&t!==void 0?t:!1,...fr(r)})};class tk extends _r{_parse(t){if(this._def.coerce&&(t.data=!!t.data),this._getType(t)!==Nt.boolean){const s=this._getOrReturnCtx(t);return St(s,{code:ot.invalid_type,expected:Nt.boolean,received:s.parsedType}),rr}return ea(t.data)}}tk.create=r=>new tk({typeName:er.ZodBoolean,coerce:(r==null?void 0:r.coerce)||!1,...fr(r)});class gb extends _r{_parse(t){if(this._def.coerce&&(t.data=new Date(t.data)),this._getType(t)!==Nt.date){const a=this._getOrReturnCtx(t);return St(a,{code:ot.invalid_type,expected:Nt.date,received:a.parsedType}),rr}if(isNaN(t.data.getTime())){const a=this._getOrReturnCtx(t);return St(a,{code:ot.invalid_date}),rr}const s=new Ii;let i;for(const a of this._def.checks)a.kind==="min"?t.data.getTime()<a.value&&(i=this._getOrReturnCtx(t,i),St(i,{code:ot.too_small,message:a.message,inclusive:!0,exact:!1,minimum:a.value,type:"date"}),s.dirty()):a.kind==="max"?t.data.getTime()>a.value&&(i=this._getOrReturnCtx(t,i),St(i,{code:ot.too_big,message:a.message,inclusive:!0,exact:!1,maximum:a.value,type:"date"}),s.dirty()):zr.assertNever(a);return{status:s.value,value:new Date(t.data.getTime())}}_addCheck(t){return new gb({...this._def,checks:[...this._def.checks,t]})}min(t,n){return this._addCheck({kind:"min",value:t.getTime(),message:Vt.toString(n)})}max(t,n){return this._addCheck({kind:"max",value:t.getTime(),message:Vt.toString(n)})}get minDate(){let t=null;for(const n of this._def.checks)n.kind==="min"&&(t===null||n.value>t)&&(t=n.value);return t!=null?new Date(t):null}get maxDate(){let t=null;for(const n of this._def.checks)n.kind==="max"&&(t===null||n.value<t)&&(t=n.value);return t!=null?new Date(t):null}}gb.create=r=>new gb({checks:[],coerce:(r==null?void 0:r.coerce)||!1,typeName:er.ZodDate,...fr(r)});class rk extends _r{_parse(t){if(this._getType(t)!==Nt.symbol){const s=this._getOrReturnCtx(t);return St(s,{code:ot.invalid_type,expected:Nt.symbol,received:s.parsedType}),rr}return ea(t.data)}}rk.create=r=>new rk({typeName:er.ZodSymbol,...fr(r)});class e2 extends _r{_parse(t){if(this._getType(t)!==Nt.undefined){const s=this._getOrReturnCtx(t);return St(s,{code:ot.invalid_type,expected:Nt.undefined,received:s.parsedType}),rr}return ea(t.data)}}e2.create=r=>new e2({typeName:er.ZodUndefined,...fr(r)});class t2 extends _r{_parse(t){if(this._getType(t)!==Nt.null){const s=this._getOrReturnCtx(t);return St(s,{code:ot.invalid_type,expected:Nt.null,received:s.parsedType}),rr}return ea(t.data)}}t2.create=r=>new t2({typeName:er.ZodNull,...fr(r)});class yb extends _r{constructor(){super(...arguments),this._any=!0}_parse(t){return ea(t.data)}}yb.create=r=>new yb({typeName:er.ZodAny,...fr(r)});class lm extends _r{constructor(){super(...arguments),this._unknown=!0}_parse(t){return ea(t.data)}}lm.create=r=>new lm({typeName:er.ZodUnknown,...fr(r)});class oc extends _r{_parse(t){const n=this._getOrReturnCtx(t);return St(n,{code:ot.invalid_type,expected:Nt.never,received:n.parsedType}),rr}}oc.create=r=>new oc({typeName:er.ZodNever,...fr(r)});class nk extends _r{_parse(t){if(this._getType(t)!==Nt.undefined){const s=this._getOrReturnCtx(t);return St(s,{code:ot.invalid_type,expected:Nt.void,received:s.parsedType}),rr}return ea(t.data)}}nk.create=r=>new nk({typeName:er.ZodVoid,...fr(r)});class su extends _r{_parse(t){const{ctx:n,status:s}=this._processInputParams(t),i=this._def;if(n.parsedType!==Nt.array)return St(n,{code:ot.invalid_type,expected:Nt.array,received:n.parsedType}),rr;if(i.exactLength!==null){const o=n.data.length>i.exactLength.value,u=n.data.length<i.exactLength.value;(o||u)&&(St(n,{code:o?ot.too_big:ot.too_small,minimum:u?i.exactLength.value:void 0,maximum:o?i.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:i.exactLength.message}),s.dirty())}if(i.minLength!==null&&n.data.length<i.minLength.value&&(St(n,{code:ot.too_small,minimum:i.minLength.value,type:"array",inclusive:!0,exact:!1,message:i.minLength.message}),s.dirty()),i.maxLength!==null&&n.data.length>i.maxLength.value&&(St(n,{code:ot.too_big,maximum:i.maxLength.value,type:"array",inclusive:!0,exact:!1,message:i.maxLength.message}),s.dirty()),n.common.async)return Promise.all([...n.data].map((o,u)=>i.type._parseAsync(new lu(n,o,n.path,u)))).then(o=>Ii.mergeArray(s,o));const a=[...n.data].map((o,u)=>i.type._parseSync(new lu(n,o,n.path,u)));return Ii.mergeArray(s,a)}get element(){return this._def.type}min(t,n){return new su({...this._def,minLength:{value:t,message:Vt.toString(n)}})}max(t,n){return new su({...this._def,maxLength:{value:t,message:Vt.toString(n)}})}length(t,n){return new su({...this._def,exactLength:{value:t,message:Vt.toString(n)}})}nonempty(t){return this.min(1,t)}}su.create=(r,t)=>new su({type:r,minLength:null,maxLength:null,exactLength:null,typeName:er.ZodArray,...fr(t)});function Wf(r){if(r instanceof Un){const t={};for(const n in r.shape){const s=r.shape[n];t[n]=Yu.create(Wf(s))}return new Un({...r._def,shape:()=>t})}else return r instanceof su?new su({...r._def,type:Wf(r.element)}):r instanceof Yu?Yu.create(Wf(r.unwrap())):r instanceof Zh?Zh.create(Wf(r.unwrap())):r instanceof cu?cu.create(r.items.map(t=>Wf(t))):r}class Un extends _r{constructor(){super(...arguments),this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(this._cached!==null)return this._cached;const t=this._def.shape(),n=zr.objectKeys(t);return this._cached={shape:t,keys:n}}_parse(t){if(this._getType(t)!==Nt.object){const c=this._getOrReturnCtx(t);return St(c,{code:ot.invalid_type,expected:Nt.object,received:c.parsedType}),rr}const{status:s,ctx:i}=this._processInputParams(t),{shape:a,keys:o}=this._getCached(),u=[];if(!(this._def.catchall instanceof oc&&this._def.unknownKeys==="strip"))for(const c in i.data)o.includes(c)||u.push(c);const l=[];for(const c of o){const h=a[c],d=i.data[c];l.push({key:{status:"valid",value:c},value:h._parse(new lu(i,d,i.path,c)),alwaysSet:c in i.data})}if(this._def.catchall instanceof oc){const c=this._def.unknownKeys;if(c==="passthrough")for(const h of u)l.push({key:{status:"valid",value:h},value:{status:"valid",value:i.data[h]}});else if(c==="strict")u.length>0&&(St(i,{code:ot.unrecognized_keys,keys:u}),s.dirty());else if(c!=="strip")throw new Error("Internal ZodObject error: invalid unknownKeys value.")}else{const c=this._def.catchall;for(const h of u){const d=i.data[h];l.push({key:{status:"valid",value:h},value:c._parse(new lu(i,d,i.path,h)),alwaysSet:h in i.data})}}return i.common.async?Promise.resolve().then(async()=>{const c=[];for(const h of l){const d=await h.key,p=await h.value;c.push({key:d,value:p,alwaysSet:h.alwaysSet})}return c}).then(c=>Ii.mergeObjectSync(s,c)):Ii.mergeObjectSync(s,l)}get shape(){return this._def.shape()}strict(t){return Vt.errToObj,new Un({...this._def,unknownKeys:"strict",...t!==void 0?{errorMap:(n,s)=>{var i,a,o,u;const l=(o=(a=(i=this._def).errorMap)===null||a===void 0?void 0:a.call(i,n,s).message)!==null&&o!==void 0?o:s.defaultError;return n.code==="unrecognized_keys"?{message:(u=Vt.errToObj(t).message)!==null&&u!==void 0?u:l}:{message:l}}}:{}})}strip(){return new Un({...this._def,unknownKeys:"strip"})}passthrough(){return new Un({...this._def,unknownKeys:"passthrough"})}extend(t){return new Un({...this._def,shape:()=>({...this._def.shape(),...t})})}merge(t){return new Un({unknownKeys:t._def.unknownKeys,catchall:t._def.catchall,shape:()=>({...this._def.shape(),...t._def.shape()}),typeName:er.ZodObject})}setKey(t,n){return this.augment({[t]:n})}catchall(t){return new Un({...this._def,catchall:t})}pick(t){const n={};return zr.objectKeys(t).forEach(s=>{t[s]&&this.shape[s]&&(n[s]=this.shape[s])}),new Un({...this._def,shape:()=>n})}omit(t){const n={};return zr.objectKeys(this.shape).forEach(s=>{t[s]||(n[s]=this.shape[s])}),new Un({...this._def,shape:()=>n})}deepPartial(){return Wf(this)}partial(t){const n={};return zr.objectKeys(this.shape).forEach(s=>{const i=this.shape[s];t&&!t[s]?n[s]=i:n[s]=i.optional()}),new Un({...this._def,shape:()=>n})}required(t){const n={};return zr.objectKeys(this.shape).forEach(s=>{if(t&&!t[s])n[s]=this.shape[s];else{let a=this.shape[s];for(;a instanceof Yu;)a=a._def.innerType;n[s]=a}}),new Un({...this._def,shape:()=>n})}keyof(){return hW(zr.objectKeys(this.shape))}}Un.create=(r,t)=>new Un({shape:()=>r,unknownKeys:"strip",catchall:oc.create(),typeName:er.ZodObject,...fr(t)});Un.strictCreate=(r,t)=>new Un({shape:()=>r,unknownKeys:"strict",catchall:oc.create(),typeName:er.ZodObject,...fr(t)});Un.lazycreate=(r,t)=>new Un({shape:r,unknownKeys:"strip",catchall:oc.create(),typeName:er.ZodObject,...fr(t)});class bb extends _r{_parse(t){const{ctx:n}=this._processInputParams(t),s=this._def.options;function i(a){for(const u of a)if(u.result.status==="valid")return u.result;for(const u of a)if(u.result.status==="dirty")return n.common.issues.push(...u.ctx.common.issues),u.result;const o=a.map(u=>new ja(u.ctx.common.issues));return St(n,{code:ot.invalid_union,unionErrors:o}),rr}if(n.common.async)return Promise.all(s.map(async a=>{const o={...n,common:{...n.common,issues:[]},parent:null};return{result:await a._parseAsync({data:n.data,path:n.path,parent:o}),ctx:o}})).then(i);{let a;const o=[];for(const l of s){const c={...n,common:{...n.common,issues:[]},parent:null},h=l._parseSync({data:n.data,path:n.path,parent:c});if(h.status==="valid")return h;h.status==="dirty"&&!a&&(a={result:h,ctx:c}),c.common.issues.length&&o.push(c.common.issues)}if(a)return n.common.issues.push(...a.ctx.common.issues),a.result;const u=o.map(l=>new ja(l));return St(n,{code:ot.invalid_union,unionErrors:u}),rr}}get options(){return this._def.options}}bb.create=(r,t)=>new bb({options:r,typeName:er.ZodUnion,...fr(t)});const Ru=r=>r instanceof s2?Ru(r.schema):r instanceof sl?Ru(r.innerType()):r instanceof i2?[r.value]:r instanceof Yh?r.options:r instanceof a2?zr.objectValues(r.enum):r instanceof o2?Ru(r._def.innerType):r instanceof e2?[void 0]:r instanceof t2?[null]:r instanceof Yu?[void 0,...Ru(r.unwrap())]:r instanceof Zh?[null,...Ru(r.unwrap())]:r instanceof dW||r instanceof l2?Ru(r.unwrap()):r instanceof u2?Ru(r._def.innerType):[];class YT extends _r{_parse(t){const{ctx:n}=this._processInputParams(t);if(n.parsedType!==Nt.object)return St(n,{code:ot.invalid_type,expected:Nt.object,received:n.parsedType}),rr;const s=this.discriminator,i=n.data[s],a=this.optionsMap.get(i);return a?n.common.async?a._parseAsync({data:n.data,path:n.path,parent:n}):a._parseSync({data:n.data,path:n.path,parent:n}):(St(n,{code:ot.invalid_union_discriminator,options:Array.from(this.optionsMap.keys()),path:[s]}),rr)}get discriminator(){return this._def.discriminator}get options(){return this._def.options}get optionsMap(){return this._def.optionsMap}static create(t,n,s){const i=new Map;for(const a of n){const o=Ru(a.shape[t]);if(!o.length)throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);for(const u of o){if(i.has(u))throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(u)}`);i.set(u,a)}}return new YT({typeName:er.ZodDiscriminatedUnion,discriminator:t,options:n,optionsMap:i,...fr(s)})}}function sk(r,t){const n=Ol(r),s=Ol(t);if(r===t)return{valid:!0,data:r};if(n===Nt.object&&s===Nt.object){const i=zr.objectKeys(t),a=zr.objectKeys(r).filter(u=>i.indexOf(u)!==-1),o={...r,...t};for(const u of a){const l=sk(r[u],t[u]);if(!l.valid)return{valid:!1};o[u]=l.data}return{valid:!0,data:o}}else if(n===Nt.array&&s===Nt.array){if(r.length!==t.length)return{valid:!1};const i=[];for(let a=0;a<r.length;a++){const o=r[a],u=t[a],l=sk(o,u);if(!l.valid)return{valid:!1};i.push(l.data)}return{valid:!0,data:i}}else return n===Nt.date&&s===Nt.date&&+r==+t?{valid:!0,data:r}:{valid:!1}}class r2 extends _r{_parse(t){const{status:n,ctx:s}=this._processInputParams(t),i=(a,o)=>{if(hB(a)||hB(o))return rr;const u=sk(a.value,o.value);return u.valid?((dB(a)||dB(o))&&n.dirty(),{status:n.value,value:u.data}):(St(s,{code:ot.invalid_intersection_types}),rr)};return s.common.async?Promise.all([this._def.left._parseAsync({data:s.data,path:s.path,parent:s}),this._def.right._parseAsync({data:s.data,path:s.path,parent:s})]).then(([a,o])=>i(a,o)):i(this._def.left._parseSync({data:s.data,path:s.path,parent:s}),this._def.right._parseSync({data:s.data,path:s.path,parent:s}))}}r2.create=(r,t,n)=>new r2({left:r,right:t,typeName:er.ZodIntersection,...fr(n)});class cu extends _r{_parse(t){const{status:n,ctx:s}=this._processInputParams(t);if(s.parsedType!==Nt.array)return St(s,{code:ot.invalid_type,expected:Nt.array,received:s.parsedType}),rr;if(s.data.length<this._def.items.length)return St(s,{code:ot.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),rr;!this._def.rest&&s.data.length>this._def.items.length&&(St(s,{code:ot.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),n.dirty());const a=[...s.data].map((o,u)=>{const l=this._def.items[u]||this._def.rest;return l?l._parse(new lu(s,o,s.path,u)):null}).filter(o=>!!o);return s.common.async?Promise.all(a).then(o=>Ii.mergeArray(n,o)):Ii.mergeArray(n,a)}get items(){return this._def.items}rest(t){return new cu({...this._def,rest:t})}}cu.create=(r,t)=>{if(!Array.isArray(r))throw new Error("You must pass an array of schemas to z.tuple([ ... ])");return new cu({items:r,typeName:er.ZodTuple,rest:null,...fr(t)})};class n2 extends _r{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(t){const{status:n,ctx:s}=this._processInputParams(t);if(s.parsedType!==Nt.object)return St(s,{code:ot.invalid_type,expected:Nt.object,received:s.parsedType}),rr;const i=[],a=this._def.keyType,o=this._def.valueType;for(const u in s.data)i.push({key:a._parse(new lu(s,u,s.path,u)),value:o._parse(new lu(s,s.data[u],s.path,u)),alwaysSet:u in s.data});return s.common.async?Ii.mergeObjectAsync(n,i):Ii.mergeObjectSync(n,i)}get element(){return this._def.valueType}static create(t,n,s){return n instanceof _r?new n2({keyType:t,valueType:n,typeName:er.ZodRecord,...fr(s)}):new n2({keyType:Ku.create(),valueType:t,typeName:er.ZodRecord,...fr(n)})}}class ik extends _r{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(t){const{status:n,ctx:s}=this._processInputParams(t);if(s.parsedType!==Nt.map)return St(s,{code:ot.invalid_type,expected:Nt.map,received:s.parsedType}),rr;const i=this._def.keyType,a=this._def.valueType,o=[...s.data.entries()].map(([u,l],c)=>({key:i._parse(new lu(s,u,s.path,[c,"key"])),value:a._parse(new lu(s,l,s.path,[c,"value"]))}));if(s.common.async){const u=new Map;return Promise.resolve().then(async()=>{for(const l of o){const c=await l.key,h=await l.value;if(c.status==="aborted"||h.status==="aborted")return rr;(c.status==="dirty"||h.status==="dirty")&&n.dirty(),u.set(c.value,h.value)}return{status:n.value,value:u}})}else{const u=new Map;for(const l of o){const c=l.key,h=l.value;if(c.status==="aborted"||h.status==="aborted")return rr;(c.status==="dirty"||h.status==="dirty")&&n.dirty(),u.set(c.value,h.value)}return{status:n.value,value:u}}}}ik.create=(r,t,n)=>new ik({valueType:t,keyType:r,typeName:er.ZodMap,...fr(n)});class Am extends _r{_parse(t){const{status:n,ctx:s}=this._processInputParams(t);if(s.parsedType!==Nt.set)return St(s,{code:ot.invalid_type,expected:Nt.set,received:s.parsedType}),rr;const i=this._def;i.minSize!==null&&s.data.size<i.minSize.value&&(St(s,{code:ot.too_small,minimum:i.minSize.value,type:"set",inclusive:!0,exact:!1,message:i.minSize.message}),n.dirty()),i.maxSize!==null&&s.data.size>i.maxSize.value&&(St(s,{code:ot.too_big,maximum:i.maxSize.value,type:"set",inclusive:!0,exact:!1,message:i.maxSize.message}),n.dirty());const a=this._def.valueType;function o(l){const c=new Set;for(const h of l){if(h.status==="aborted")return rr;h.status==="dirty"&&n.dirty(),c.add(h.value)}return{status:n.value,value:c}}const u=[...s.data.values()].map((l,c)=>a._parse(new lu(s,l,s.path,c)));return s.common.async?Promise.all(u).then(l=>o(l)):o(u)}min(t,n){return new Am({...this._def,minSize:{value:t,message:Vt.toString(n)}})}max(t,n){return new Am({...this._def,maxSize:{value:t,message:Vt.toString(n)}})}size(t,n){return this.min(t,n).max(t,n)}nonempty(t){return this.min(1,t)}}Am.create=(r,t)=>new Am({valueType:r,minSize:null,maxSize:null,typeName:er.ZodSet,...fr(t)});class jy extends _r{constructor(){super(...arguments),this.validate=this.implement}_parse(t){const{ctx:n}=this._processInputParams(t);if(n.parsedType!==Nt.function)return St(n,{code:ot.invalid_type,expected:Nt.function,received:n.parsedType}),rr;function s(u,l){return ek({data:u,path:n.path,errorMaps:[n.common.contextualErrorMap,n.schemaErrorMap,QI(),mb].filter(c=>!!c),issueData:{code:ot.invalid_arguments,argumentsError:l}})}function i(u,l){return ek({data:u,path:n.path,errorMaps:[n.common.contextualErrorMap,n.schemaErrorMap,QI(),mb].filter(c=>!!c),issueData:{code:ot.invalid_return_type,returnTypeError:l}})}const a={errorMap:n.common.contextualErrorMap},o=n.data;if(this._def.returns instanceof xb){const u=this;return ea(async function(...l){const c=new ja([]),h=await u._def.args.parseAsync(l,a).catch(f=>{throw c.addIssue(s(l,f)),c}),d=await Reflect.apply(o,this,h);return await u._def.returns._def.type.parseAsync(d,a).catch(f=>{throw c.addIssue(i(d,f)),c})})}else{const u=this;return ea(function(...l){const c=u._def.args.safeParse(l,a);if(!c.success)throw new ja([s(l,c.error)]);const h=Reflect.apply(o,this,c.data),d=u._def.returns.safeParse(h,a);if(!d.success)throw new ja([i(h,d.error)]);return d.data})}}parameters(){return this._def.args}returnType(){return this._def.returns}args(...t){return new jy({...this._def,args:cu.create(t).rest(lm.create())})}returns(t){return new jy({...this._def,returns:t})}implement(t){return this.parse(t)}strictImplement(t){return this.parse(t)}static create(t,n,s){return new jy({args:t||cu.create([]).rest(lm.create()),returns:n||lm.create(),typeName:er.ZodFunction,...fr(s)})}}class s2 extends _r{get schema(){return this._def.getter()}_parse(t){const{ctx:n}=this._processInputParams(t);return this._def.getter()._parse({data:n.data,path:n.path,parent:n})}}s2.create=(r,t)=>new s2({getter:r,typeName:er.ZodLazy,...fr(t)});class i2 extends _r{_parse(t){if(t.data!==this._def.value){const n=this._getOrReturnCtx(t);return St(n,{received:n.data,code:ot.invalid_literal,expected:this._def.value}),rr}return{status:"valid",value:t.data}}get value(){return this._def.value}}i2.create=(r,t)=>new i2({value:r,typeName:er.ZodLiteral,...fr(t)});function hW(r,t){return new Yh({values:r,typeName:er.ZodEnum,...fr(t)})}class Yh extends _r{constructor(){super(...arguments),Cy.set(this,void 0)}_parse(t){if(typeof t.data!="string"){const n=this._getOrReturnCtx(t),s=this._def.values;return St(n,{expected:zr.joinValues(s),received:n.parsedType,code:ot.invalid_type}),rr}if(Qw(this,Cy)||uW(this,Cy,new Set(this._def.values)),!Qw(this,Cy).has(t.data)){const n=this._getOrReturnCtx(t),s=this._def.values;return St(n,{received:n.data,code:ot.invalid_enum_value,options:s}),rr}return ea(t.data)}get options(){return this._def.values}get enum(){const t={};for(const n of this._def.values)t[n]=n;return t}get Values(){const t={};for(const n of this._def.values)t[n]=n;return t}get Enum(){const t={};for(const n of this._def.values)t[n]=n;return t}extract(t,n=this._def){return Yh.create(t,{...this._def,...n})}exclude(t,n=this._def){return Yh.create(this.options.filter(s=>!t.includes(s)),{...this._def,...n})}}Cy=new WeakMap;Yh.create=hW;class a2 extends _r{constructor(){super(...arguments),_y.set(this,void 0)}_parse(t){const n=zr.getValidEnumValues(this._def.values),s=this._getOrReturnCtx(t);if(s.parsedType!==Nt.string&&s.parsedType!==Nt.number){const i=zr.objectValues(n);return St(s,{expected:zr.joinValues(i),received:s.parsedType,code:ot.invalid_type}),rr}if(Qw(this,_y)||uW(this,_y,new Set(zr.getValidEnumValues(this._def.values))),!Qw(this,_y).has(t.data)){const i=zr.objectValues(n);return St(s,{received:s.data,code:ot.invalid_enum_value,options:i}),rr}return ea(t.data)}get enum(){return this._def.values}}_y=new WeakMap;a2.create=(r,t)=>new a2({values:r,typeName:er.ZodNativeEnum,...fr(t)});class xb extends _r{unwrap(){return this._def.type}_parse(t){const{ctx:n}=this._processInputParams(t);if(n.parsedType!==Nt.promise&&n.common.async===!1)return St(n,{code:ot.invalid_type,expected:Nt.promise,received:n.parsedType}),rr;const s=n.parsedType===Nt.promise?n.data:Promise.resolve(n.data);return ea(s.then(i=>this._def.type.parseAsync(i,{path:n.path,errorMap:n.common.contextualErrorMap})))}}xb.create=(r,t)=>new xb({type:r,typeName:er.ZodPromise,...fr(t)});class sl extends _r{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===er.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse(t){const{status:n,ctx:s}=this._processInputParams(t),i=this._def.effect||null,a={addIssue:o=>{St(s,o),o.fatal?n.abort():n.dirty()},get path(){return s.path}};if(a.addIssue=a.addIssue.bind(a),i.type==="preprocess"){const o=i.transform(s.data,a);if(s.common.async)return Promise.resolve(o).then(async u=>{if(n.value==="aborted")return rr;const l=await this._def.schema._parseAsync({data:u,path:s.path,parent:s});return l.status==="aborted"?rr:l.status==="dirty"||n.value==="dirty"?Sy(l.value):l});{if(n.value==="aborted")return rr;const u=this._def.schema._parseSync({data:o,path:s.path,parent:s});return u.status==="aborted"?rr:u.status==="dirty"||n.value==="dirty"?Sy(u.value):u}}if(i.type==="refinement"){const o=u=>{const l=i.refinement(u,a);if(s.common.async)return Promise.resolve(l);if(l instanceof Promise)throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return u};if(s.common.async===!1){const u=this._def.schema._parseSync({data:s.data,path:s.path,parent:s});return u.status==="aborted"?rr:(u.status==="dirty"&&n.dirty(),o(u.value),{status:n.value,value:u.value})}else return this._def.schema._parseAsync({data:s.data,path:s.path,parent:s}).then(u=>u.status==="aborted"?rr:(u.status==="dirty"&&n.dirty(),o(u.value).then(()=>({status:n.value,value:u.value}))))}if(i.type==="transform")if(s.common.async===!1){const o=this._def.schema._parseSync({data:s.data,path:s.path,parent:s});if(!km(o))return o;const u=i.transform(o.value,a);if(u instanceof Promise)throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:n.value,value:u}}else return this._def.schema._parseAsync({data:s.data,path:s.path,parent:s}).then(o=>km(o)?Promise.resolve(i.transform(o.value,a)).then(u=>({status:n.value,value:u})):o);zr.assertNever(i)}}sl.create=(r,t,n)=>new sl({schema:r,typeName:er.ZodEffects,effect:t,...fr(n)});sl.createWithPreprocess=(r,t,n)=>new sl({schema:t,effect:{type:"preprocess",transform:r},typeName:er.ZodEffects,...fr(n)});class Yu extends _r{_parse(t){return this._getType(t)===Nt.undefined?ea(void 0):this._def.innerType._parse(t)}unwrap(){return this._def.innerType}}Yu.create=(r,t)=>new Yu({innerType:r,typeName:er.ZodOptional,...fr(t)});class Zh extends _r{_parse(t){return this._getType(t)===Nt.null?ea(null):this._def.innerType._parse(t)}unwrap(){return this._def.innerType}}Zh.create=(r,t)=>new Zh({innerType:r,typeName:er.ZodNullable,...fr(t)});class o2 extends _r{_parse(t){const{ctx:n}=this._processInputParams(t);let s=n.data;return n.parsedType===Nt.undefined&&(s=this._def.defaultValue()),this._def.innerType._parse({data:s,path:n.path,parent:n})}removeDefault(){return this._def.innerType}}o2.create=(r,t)=>new o2({innerType:r,typeName:er.ZodDefault,defaultValue:typeof t.default=="function"?t.default:()=>t.default,...fr(t)});class u2 extends _r{_parse(t){const{ctx:n}=this._processInputParams(t),s={...n,common:{...n.common,issues:[]}},i=this._def.innerType._parse({data:s.data,path:s.path,parent:{...s}});return Jw(i)?i.then(a=>({status:"valid",value:a.status==="valid"?a.value:this._def.catchValue({get error(){return new ja(s.common.issues)},input:s.data})})):{status:"valid",value:i.status==="valid"?i.value:this._def.catchValue({get error(){return new ja(s.common.issues)},input:s.data})}}removeCatch(){return this._def.innerType}}u2.create=(r,t)=>new u2({innerType:r,typeName:er.ZodCatch,catchValue:typeof t.catch=="function"?t.catch:()=>t.catch,...fr(t)});class ak extends _r{_parse(t){if(this._getType(t)!==Nt.nan){const s=this._getOrReturnCtx(t);return St(s,{code:ot.invalid_type,expected:Nt.nan,received:s.parsedType}),rr}return{status:"valid",value:t.data}}}ak.create=r=>new ak({typeName:er.ZodNaN,...fr(r)});class dW extends _r{_parse(t){const{ctx:n}=this._processInputParams(t),s=n.data;return this._def.type._parse({data:s,path:n.path,parent:n})}unwrap(){return this._def.type}}class PS extends _r{_parse(t){const{status:n,ctx:s}=this._processInputParams(t);if(s.common.async)return(async()=>{const a=await this._def.in._parseAsync({data:s.data,path:s.path,parent:s});return a.status==="aborted"?rr:a.status==="dirty"?(n.dirty(),Sy(a.value)):this._def.out._parseAsync({data:a.value,path:s.path,parent:s})})();{const i=this._def.in._parseSync({data:s.data,path:s.path,parent:s});return i.status==="aborted"?rr:i.status==="dirty"?(n.dirty(),{status:"dirty",value:i.value}):this._def.out._parseSync({data:i.value,path:s.path,parent:s})}}static create(t,n){return new PS({in:t,out:n,typeName:er.ZodPipeline})}}class l2 extends _r{_parse(t){const n=this._def.innerType._parse(t),s=i=>(km(i)&&(i.value=Object.freeze(i.value)),i);return Jw(n)?n.then(i=>s(i)):s(n)}unwrap(){return this._def.innerType}}l2.create=(r,t)=>new l2({innerType:r,typeName:er.ZodReadonly,...fr(t)});function fB(r,t){const n=typeof r=="function"?r(t):typeof r=="string"?{message:r}:r;return typeof n=="string"?{message:n}:n}function pW(r,t={},n){return r?yb.create().superRefine((s,i)=>{var a,o;const u=r(s);if(u instanceof Promise)return u.then(l=>{var c,h;if(!l){const d=fB(t,s),p=(h=(c=d.fatal)!==null&&c!==void 0?c:n)!==null&&h!==void 0?h:!0;i.addIssue({code:"custom",...d,fatal:p})}});if(!u){const l=fB(t,s),c=(o=(a=l.fatal)!==null&&a!==void 0?a:n)!==null&&o!==void 0?o:!0;i.addIssue({code:"custom",...l,fatal:c})}}):yb.create()}Un.lazycreate;var er;(function(r){r.ZodString="ZodString",r.ZodNumber="ZodNumber",r.ZodNaN="ZodNaN",r.ZodBigInt="ZodBigInt",r.ZodBoolean="ZodBoolean",r.ZodDate="ZodDate",r.ZodSymbol="ZodSymbol",r.ZodUndefined="ZodUndefined",r.ZodNull="ZodNull",r.ZodAny="ZodAny",r.ZodUnknown="ZodUnknown",r.ZodNever="ZodNever",r.ZodVoid="ZodVoid",r.ZodArray="ZodArray",r.ZodObject="ZodObject",r.ZodUnion="ZodUnion",r.ZodDiscriminatedUnion="ZodDiscriminatedUnion",r.ZodIntersection="ZodIntersection",r.ZodTuple="ZodTuple",r.ZodRecord="ZodRecord",r.ZodMap="ZodMap",r.ZodSet="ZodSet",r.ZodFunction="ZodFunction",r.ZodLazy="ZodLazy",r.ZodLiteral="ZodLiteral",r.ZodEnum="ZodEnum",r.ZodEffects="ZodEffects",r.ZodNativeEnum="ZodNativeEnum",r.ZodOptional="ZodOptional",r.ZodNullable="ZodNullable",r.ZodDefault="ZodDefault",r.ZodCatch="ZodCatch",r.ZodPromise="ZodPromise",r.ZodBranded="ZodBranded",r.ZodPipeline="ZodPipeline",r.ZodReadonly="ZodReadonly"})(er||(er={}));const mB=(r,t={message:`Input not instance of ${r.name}`})=>pW(n=>n instanceof r,t),xue=Ku.create,gB=Nm.create;ak.create;Tm.create;const vue=tk.create;gb.create;rk.create;e2.create;t2.create;const mE=yb.create;lm.create;oc.create;nk.create;const yB=su.create,wue=Un.create;Un.strictCreate;const bB=bb.create;YT.create;r2.create;const xB=cu.create;n2.create;ik.create;Am.create;const vB=jy.create;s2.create;const wB=i2.create;Yh.create;a2.create;xb.create;sl.create;Yu.create;Zh.create;sl.createWithPreprocess;PS.create;var Sue={describe:{overloads:[["String","FALLBACK|LABEL?"]]},describeElement:{overloads:[["String","String","FALLBACK|LABEL?"]]},textOutput:{overloads:[["FALLBACK|LABEL?"]]},gridOutput:{overloads:[["FALLBACK|LABEL?"]]},p5:{overloads:[["Object","String|HTMLElement"]]},color:{overloads:[["Number","Number?"],["Number","Number","Number","Number?"],["String"],["Number[]"],["p5.Color"]]},red:{overloads:[["p5.Color|Number[]|String"]]},green:{overloads:[["p5.Color|Number[]|String"]]},blue:{overloads:[["p5.Color|Number[]|String"]]},alpha:{overloads:[["p5.Color|Number[]|String"]]},hue:{overloads:[["p5.Color|Number[]|String"]]},saturation:{overloads:[["p5.Color|Number[]|String"]]},brightness:{overloads:[["p5.Color|Number[]|String"]]},lightness:{overloads:[["p5.Color|Number[]|String"]]},lerpColor:{overloads:[["p5.Color","p5.Color","Number"]]},paletteLerp:{overloads:[["[p5.Color|String|Number|Number[], Number][]","Number"]]},beginClip:{overloads:[["Object?"]]},endClip:{overloads:[[]]},clip:{overloads:[["Function","Object?"]]},background:{overloads:[["p5.Color"],["String","Number?"],["Number","Number?"],["Number","Number","Number","Number?"],["Number[]"],["p5.Image","Number?"]]},clear:{overloads:[["Number?","Number?","Number?","Number?"],[]]},colorMode:{overloads:[["RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH","Number?"],["RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH","Number","Number","Number","Number?"]]},fill:{overloads:[["Number","Number","Number","Number?"],["String"],["Number","Number?"],["Number[]"],["p5.Color"]]},noFill:{overloads:[[]]},noStroke:{overloads:[[]]},stroke:{overloads:[["Number","Number","Number","Number?"],["String"],["Number","Number?"],["Number[]"],["p5.Color"]]},erase:{overloads:[["Number?","Number?"]]},noErase:{overloads:[[]]},blendMode:{overloads:[["BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|REMOVE|SUBTRACT"]]},print:{overloads:[["Any"],["String|Number|Array"]]},cursor:{overloads:[["ARROW|CROSS|HAND|MOVE|TEXT|WAIT|String","Number?","Number?"]]},frameRate:{overloads:[["Number"],[]]},getTargetFrameRate:{overloads:[[]]},noCursor:{overloads:[[]]},windowResized:{overloads:[["UIEvent?"]]},fullscreen:{overloads:[["Boolean?"]]},pixelDensity:{overloads:[["Number?"],[]]},displayDensity:{overloads:[[]]},getURL:{overloads:[[]]},getURLPath:{overloads:[[]]},getURLParams:{overloads:[[]]},worldToScreen:{overloads:[["Number|p5.Vector","Number","Number?"]]},screenToWorld:{overloads:[["Number|p5.Vector","Number","Number?"]]},setup:{overloads:[[]]},draw:{overloads:[[]]},createCanvas:{overloads:[["Number?","Number?","P2D|WEBGL|P2DHDR?","HTMLCanvasElement?"],["Number?","Number?","HTMLCanvasElement?"]]},resizeCanvas:{overloads:[["Number","Number","Boolean?"]]},noCanvas:{overloads:[[]]},createGraphics:{overloads:[["Number","Number","P2D|WEBGL?","HTMLCanvasElement?"],["Number","Number","HTMLCanvasElement?"]]},createFramebuffer:{overloads:[["Object?"]]},clearDepth:{overloads:[["Number?"]]},noLoop:{overloads:[[]]},loop:{overloads:[[]]},isLooping:{overloads:[[]]},redraw:{overloads:[["Integer?"]]},applyMatrix:{overloads:[["Array"],["Number","Number","Number","Number","Number","Number"],["Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Number"]]},resetMatrix:{overloads:[[]]},rotate:{overloads:[["Number","p5.Vector|Number[]?"]]},rotateX:{overloads:[["Number"]]},rotateY:{overloads:[["Number"]]},rotateZ:{overloads:[["Number"]]},scale:{overloads:[["Number|p5.Vector|Number[]","Number?","Number?"],["p5.Vector|Number[]"]]},shearX:{overloads:[["Number"]]},shearY:{overloads:[["Number"]]},translate:{overloads:[["Number","Number","Number?"],["p5.Vector"]]},push:{overloads:[[]]},pop:{overloads:[[]]},storeItem:{overloads:[["String","String|Number|Boolean|Object|Array"]]},getItem:{overloads:[["String"]]},clearStorage:{overloads:[[]]},removeItem:{overloads:[["String"]]},select:{overloads:[["String","String|p5.Element|HTMLElement?"]]},selectAll:{overloads:[["String","String|p5.Element|HTMLElement?"]]},createElement:{overloads:[["String","String?"]]},removeElements:{overloads:[[]]},addElement:{overloads:[[]]},createDiv:{overloads:[["String?"]]},createP:{overloads:[["String?"]]},createSpan:{overloads:[["String?"]]},createImg:{overloads:[["String","String"],["String","String","String?","Function?"]]},createA:{overloads:[["String","String","String?"]]},createSlider:{overloads:[["Number","Number","Number?","Number?"]]},createButton:{overloads:[["String","String?"]]},createCheckbox:{overloads:[["String?","Boolean?"]]},createSelect:{overloads:[["Boolean?"],["Object"]]},createRadio:{overloads:[["Object?"],["String?"],[]]},createColorPicker:{overloads:[["String|p5.Color?"]]},createInput:{overloads:[["String?","String?"],["String?"]]},createFileInput:{overloads:[["Function","Boolean?"]]},setMoveThreshold:{overloads:[["Number"]]},setShakeThreshold:{overloads:[["Number"]]},deviceMoved:{overloads:[[]]},deviceTurned:{overloads:[[]]},deviceShaken:{overloads:[[]]},keyPressed:{overloads:[["KeyboardEvent?"]]},keyReleased:{overloads:[["KeyboardEvent?"]]},keyTyped:{overloads:[["KeyboardEvent?"]]},keyIsDown:{overloads:[["Number|String"]]},mouseMoved:{overloads:[["MouseEvent?"]]},mouseDragged:{overloads:[["MouseEvent?"]]},mousePressed:{overloads:[["MouseEvent?"]]},mouseReleased:{overloads:[["MouseEvent?"]]},mouseClicked:{overloads:[["MouseEvent?"]]},doubleClicked:{overloads:[["MouseEvent?"]]},mouseWheel:{overloads:[["WheelEvent?"]]},requestPointerLock:{overloads:[[]]},exitPointerLock:{overloads:[[]]},createImage:{overloads:[["Integer","Integer"]]},saveCanvas:{overloads:[["p5.Framebuffer|p5.Element|HTMLCanvasElement","String?","String?"],["String?","String?"]]},saveFrames:{overloads:[["String","String","Number","Number","function(Array)?"]]},loadImage:{overloads:[["String|Request","function(p5.Image)?","function(Event)?"]]},saveGif:{overloads:[["String","Number","Object?"]]},image:{overloads:[["p5.Image|p5.Element|p5.Texture|p5.Framebuffer|p5.FramebufferTexture|p5.Renderer|p5.Graphics","Number","Number","Number?","Number?"],["p5.Image|p5.Element|p5.Texture|p5.Framebuffer|p5.FramebufferTexture","Number","Number","Number","Number","Number","Number","Number?","Number?","CONTAIN|COVER?","LEFT|RIGHT|CENTER?","TOP|BOTTOM|CENTER?"]]},tint:{overloads:[["Number","Number","Number","Number?"],["String"],["Number","Number?"],["Number[]"],["p5.Color"]]},noTint:{overloads:[[]]},imageMode:{overloads:[["CORNER|CORNERS|CENTER"]]},blend:{overloads:[["p5.Image","Integer","Integer","Integer","Integer","Integer","Integer","Integer","Integer","BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"],["Integer","Integer","Integer","Integer","Integer","Integer","Integer","Integer","BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"]]},copy:{overloads:[["p5.Image|p5.Element","Integer","Integer","Integer","Integer","Integer","Integer","Integer","Integer"],["Integer","Integer","Integer","Integer","Integer","Integer","Integer","Integer"]]},filter:{overloads:[["THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|BLUR|ERODE|DILATE|BLUR","Number?","Boolean?"],["p5.Shader"]]},get:{overloads:[["Number","Number","Number","Number"],[],["Number","Number"]]},loadPixels:{overloads:[[]]},set:{overloads:[["Number","Number","Number|Number[]|Object"]]},updatePixels:{overloads:[["Number?","Number?","Number?","Number?"],[]]},loadJSON:{overloads:[["String|Request","Function?","Function?"]]},loadStrings:{overloads:[["String|Request","Function?","Function?"]]},loadTable:{overloads:[["String|Request","String?","String?","Function?","Function?"]]},loadXML:{overloads:[["String|Request","Function?","Function?"]]},loadBytes:{overloads:[["String|Request","Function?","Function?"]]},loadBlob:{overloads:[["String|Request","Function?","Function?"]]},httpGet:{overloads:[["String|Request","String?","Function?","Function?"],["String|Request","Function","Function?"]]},httpPost:{overloads:[["String|Request","Object|Boolean?","String?","Function?","Function?"],["String|Request","Object|Boolean","Function?","Function?"],["String|Request","Function?","Function?"]]},httpDo:{overloads:[["String|Request","String?","String?","Object?","Function?","Function?"],["String|Request","Function?","Function?"]]},createWriter:{overloads:[["String","String?"]]},write:{overloads:[["String|Number|Array"]]},close:{overloads:[[]]},save:{overloads:[["Object|String?","String?","Boolean|String?"]]},saveJSON:{overloads:[["Array|Object","String","Boolean?"]]},saveStrings:{overloads:[["String[]","String","String?","Boolean?"]]},saveTable:{overloads:[["p5.Table","String","String?"]]},abs:{overloads:[["Number"]]},ceil:{overloads:[["Number"]]},constrain:{overloads:[["Number","Number","Number"]]},dist:{overloads:[["Number","Number","Number","Number"],["Number","Number","Number","Number","Number","Number"],["p5.Vector"]]},exp:{overloads:[["Number"]]},floor:{overloads:[["Number"]]},lerp:{overloads:[["Number","Number","Number"]]},log:{overloads:[["Number"]]},mag:{overloads:[["Number","Number"]]},map:{overloads:[["Number","Number","Number","Number","Number","Boolean?"]]},max:{overloads:[["Number","Number"],["Number[]"]]},min:{overloads:[["Number","Number"],["Number[]"]]},norm:{overloads:[["Number","Number","Number"]]},pow:{overloads:[["Number","Number"]]},round:{overloads:[["Number","Number?"]]},sq:{overloads:[["Number"]]},sqrt:{overloads:[["Number"]]},fract:{overloads:[["Number"]]},createVector:{overloads:[["...Number[]"]]},noise:{overloads:[["Number","Number?","Number?"]]},noiseDetail:{overloads:[["Number","Number"]]},noiseSeed:{overloads:[["Number"]]},randomSeed:{overloads:[["Number"]]},random:{overloads:[["Number?","Number?"],["Array"]]},randomGaussian:{overloads:[["Number?","Number?"]]},acos:{overloads:[["Number"]]},asin:{overloads:[["Number"]]},atan:{overloads:[["Number"]]},atan2:{overloads:[["Number","Number"]]},cos:{overloads:[["Number"]]},sin:{overloads:[["Number"]]},tan:{overloads:[["Number"]]},degrees:{overloads:[["Number"]]},radians:{overloads:[["Number"]]},angleMode:{overloads:[["RADIANS|DEGREES"],[]]},arc:{overloads:[["Number","Number","Number","Number","Number","Number","CHORD|PIE|OPEN?","Integer?"]]},ellipse:{overloads:[["Number","Number","Number","Number?"],["Number","Number","Number","Number","Integer?"]]},circle:{overloads:[["Number","Number","Number"]]},line:{overloads:[["Number","Number","Number","Number"],["Number","Number","Number","Number","Number","Number"]]},point:{overloads:[["Number","Number","Number?"],["p5.Vector"]]},quad:{overloads:[["Number","Number","Number","Number","Number","Number","Number","Number","Integer?","Integer?"],["Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Integer?","Integer?"]]},rect:{overloads:[["Number","Number","Number","Number?","Number?","Number?","Number?","Number?"],["Number","Number","Number","Number","Integer?","Integer?"]]},square:{overloads:[["Number","Number","Number","Number?","Number?","Number?","Number?"]]},triangle:{overloads:[["Number","Number","Number","Number","Number","Number"]]},ellipseMode:{overloads:[["CENTER|RADIUS|CORNER|CORNERS"]]},noSmooth:{overloads:[[]]},rectMode:{overloads:[["CENTER|RADIUS|CORNER|CORNERS"]]},smooth:{overloads:[[]]},strokeCap:{overloads:[["ROUND|SQUARE|PROJECT"]]},strokeJoin:{overloads:[["MITER|BEVEL|ROUND"]]},strokeWeight:{overloads:[["Number"]]},bezier:{overloads:[["Number","Number","Number","Number","Number","Number","Number","Number"],["Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Number"]]},bezierPoint:{overloads:[["Number","Number","Number","Number","Number"]]},bezierTangent:{overloads:[["Number","Number","Number","Number","Number"]]},spline:{overloads:[["Number","Number","Number","Number","Number","Number","Number","Number"],["Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Number","Number"]]},splinePoint:{overloads:[["Number","Number","Number","Number","Number"]]},splineTangent:{overloads:[["Number","Number","Number","Number","Number"]]},bezierOrder:{overloads:[["Number"],[]]},splineVertex:{overloads:[["Number","Number"],["Number","Number","Number?"],["Number","Number","Number?","Number?"],["Number","Number","Number","Number?","Number?"]]},splineProperty:{overloads:[["String",null],["String"]]},splineProperties:{overloads:[["Object"],[]]},vertex:{overloads:[["Number","Number"],["Number","Number","Number?","Number?"],["Number","Number","Number","Number?","Number?"]]},beginContour:{overloads:[[]]},endContour:{overloads:[["OPEN|CLOSE?"]]},beginShape:{overloads:[["POINTS|LINES|TRIANGLES|TRIANGLE_FAN|TRIANGLE_STRIP|QUADS|QUAD_STRIP|PATH?"]]},bezierVertex:{overloads:[["Number","Number","Number?","Number?"],["Number","Number","Number","Number?","Number?"]]},endShape:{overloads:[["CLOSE?","Integer?"]]},normal:{overloads:[["p5.Vector"],["Number","Number","Number"]]},vertexProperty:{overloads:[["String","Number|Number[]"]]},loadFont:{overloads:[["String","String?","Object?","String|String[]?","Function?","Function?"],["String","Function?","Function?"]]},text:{overloads:[["String|Object|Array|Number|Boolean","Number","Number","Number?","Number?"]]},textAlign:{overloads:[["LEFT|CENTER|RIGHT","TOP|BOTTOM|CENTER|BASELINE?"]]},textAscent:{overloads:[["String?"]]},textDescent:{overloads:[["String?"]]},textLeading:{overloads:[["Number"]]},textFont:{overloads:[["p5.Font|String|Object","Number?"]]},textSize:{overloads:[["Number"],[]]},textStyle:{overloads:[["NORMAL|ITALIC|BOLD|BOLDITALIC"],[]]},textWidth:{overloads:[["String"]]},textWrap:{overloads:[["WORD|CHAR"],[]]},textBounds:{overloads:[["String","Number","Number","Number?","Number?"]]},textDirection:{overloads:[["String"],[]]},textProperty:{overloads:[["String",null],["String"]]},textProperties:{overloads:[["Object"],[]]},fontBounds:{overloads:[["String","Number","Number","Number?","Number?"]]},fontWidth:{overloads:[["String"]]},fontAscent:{overloads:[[]]},fontDescent:{overloads:[[]]},textWeight:{overloads:[["Number"],[]]},float:{overloads:[["String"],["String[]"]]},int:{overloads:[["String|Boolean|Number"],["Array"]]},str:{overloads:[["String|Boolean|Number"]]},boolean:{overloads:[["String|Boolean|Number"],["Array"]]},byte:{overloads:[["String|Boolean|Number"],["Array"]]},char:{overloads:[["String|Number"],["Array"]]},unchar:{overloads:[["String"],["String[]"]]},hex:{overloads:[["Number","Number?"],["Number[]","Number?"]]},unhex:{overloads:[["String"],["String[]"]]},day:{overloads:[[]]},hour:{overloads:[[]]},minute:{overloads:[[]]},millis:{overloads:[[]]},month:{overloads:[[]]},second:{overloads:[[]]},year:{overloads:[[]]},nf:{overloads:[["Number|String","Integer|String?","Integer|String?"],["Number[]","Integer|String?","Integer|String?"]]},nfc:{overloads:[["Number|String","Integer|String?"],["Number[]","Integer|String?"]]},nfp:{overloads:[["Number","Integer?","Integer?"],["Number[]","Integer?","Integer?"]]},nfs:{overloads:[["Number","Integer?","Integer?"],["Array","Integer?","Integer?"]]},splitTokens:{overloads:[["String","String?"]]},shuffle:{overloads:[["Array","Boolean?"]]},strokeMode:{overloads:[["String"]]},buildGeometry:{overloads:[["Function"]]},freeGeometry:{overloads:[["p5.Geometry"]]},plane:{overloads:[["Number?","Number?","Integer?","Integer?"]]},box:{overloads:[["Number?","Number?","Number?","Integer?","Integer?"]]},sphere:{overloads:[["Number?","Integer?","Integer?"]]},cylinder:{overloads:[["Number?","Number?","Integer?","Integer?","Boolean?","Boolean?"]]},cone:{overloads:[["Number?","Number?","Integer?","Integer?","Boolean?"]]},ellipsoid:{overloads:[["Number?","Number?","Number?","Integer?","Integer?"]]},torus:{overloads:[["Number?","Number?","Integer?","Integer?"]]},curveDetail:{overloads:[["Number"]]},orbitControl:{overloads:[["Number?","Number?","Number?","Object?"]]},debugMode:{overloads:[[],["GRID|AXES"],["GRID|AXES","Number?","Number?","Number?","Number?","Number?"],["GRID|AXES","Number?","Number?","Number?","Number?"],["Number?","Number?","Number?","Number?","Number?","Number?","Number?","Number?","Number?"]]},noDebugMode:{overloads:[[]]},ambientLight:{overloads:[["Number","Number","Number","Number?"],["Number","Number?"],["String"],["Number[]"],["p5.Color"]]},specularColor:{overloads:[["Number","Number","Number"],["Number"],["String"],["Number[]"],["p5.Color"]]},directionalLight:{overloads:[["Number","Number","Number","Number","Number","Number"],["Number","Number","Number","p5.Vector"],["p5.Color|Number[]|String","Number","Number","Number"],["p5.Color|Number[]|String","p5.Vector"]]},pointLight:{overloads:[["Number","Number","Number","Number","Number","Number"],["Number","Number","Number","p5.Vector"],["p5.Color|Number[]|String","Number","Number","Number"],["p5.Color|Number[]|String","p5.Vector"]]},imageLight:{overloads:[["p5.image"]]},panorama:{overloads:[["p5.Image"]]},lights:{overloads:[[]]},lightFalloff:{overloads:[["Number","Number","Number"]]},spotLight:{overloads:[["Number","Number","Number","Number","Number","Number","Number","Number","Number","Number?","Number?"],["p5.Color|Number[]|String","p5.Vector","p5.Vector","Number?","Number?"],["Number","Number","Number","p5.Vector","p5.Vector","Number?","Number?"],["p5.Color|Number[]|String","Number","Number","Number","p5.Vector","Number?","Number?"],["p5.Color|Number[]|String","p5.Vector","Number","Number","Number","Number?","Number?"],["Number","Number","Number","Number","Number","Number","p5.Vector","Number?","Number?"],["Number","Number","Number","p5.Vector","Number","Number","Number","Number?","Number?"],["p5.Color|Number[]|String","Number","Number","Number","Number","Number","Number","Number?","Number?"]]},noLights:{overloads:[[]]},loadModel:{overloads:[["String|Request","String?","Boolean","function(p5.Geometry)?","function(Event)?"],["String|Request","String?","function(p5.Geometry)?","function(Event)?"],["String|Request","Object?","String?","function(p5.Geometry)?","function(Event)?","Boolean?","Boolean?","Boolean?"]]},model:{overloads:[["p5.Geometry"]]},createModel:{overloads:[["String","String?","Boolean","function(p5.Geometry)?","function(Event)?"],["String","String?","function(p5.Geometry)?","function(Event)?"],["String","String?","Object?","function(p5.Geometry)?","function(Event)?","boolean?","boolean?","boolean?"]]},loadShader:{overloads:[["String|Request","String|Request","Function?","Function?"]]},createShader:{overloads:[["String","String","Object?"]]},loadFilterShader:{overloads:[["String","Function?","Function?"]]},createFilterShader:{overloads:[["String"]]},shader:{overloads:[["p5.Shader"]]},strokeShader:{overloads:[["p5.Shader"]]},imageShader:{overloads:[["p5.Shader"]]},baseMaterialShader:{overloads:[[]]},baseFilterShader:{overloads:[[]]},baseNormalShader:{overloads:[[]]},baseColorShader:{overloads:[[]]},baseStrokeShader:{overloads:[[]]},resetShader:{overloads:[[]]},texture:{overloads:[["p5.Image|p5.MediaElement|p5.Graphics|p5.Texture|p5.Framebuffer|p5.FramebufferTexture"]]},textureMode:{overloads:[["IMAGE|NORMAL"]]},textureWrap:{overloads:[["CLAMP|REPEAT|MIRROR","CLAMP|REPEAT|MIRROR?"]]},normalMaterial:{overloads:[[]]},ambientMaterial:{overloads:[["Number","Number","Number"],["Number"],["p5.Color|Number[]|String"]]},emissiveMaterial:{overloads:[["Number","Number","Number","Number?"],["Number"],["p5.Color|Number[]|String"]]},specularMaterial:{overloads:[["Number","Number?"],["Number","Number","Number","Number?"],["p5.Color|Number[]|String"]]},shininess:{overloads:[["Number"]]},metalness:{overloads:[["Number"]]},camera:{overloads:[["Number?","Number?","Number?","Number?","Number?","Number?","Number?","Number?","Number?"]]},perspective:{overloads:[["Number?","Number?","Number?","Number?"]]},linePerspective:{overloads:[["Boolean"],[]]},ortho:{overloads:[["Number?","Number?","Number?","Number?","Number?","Number?"]]},frustum:{overloads:[["Number?","Number?","Number?","Number?","Number?","Number?"]]},createCamera:{overloads:[[]]},setCamera:{overloads:[["p5.Camera"]]},saveObj:{overloads:[["String?"]]},saveStl:{overloads:[["String?","Object?"]]},setAttributes:{overloads:[["String","Boolean"],["Object"]]},remove:{overloads:[[]]},createVideo:{overloads:[["String|String[]","Function?"]]},createAudio:{overloads:[[],["String|String[]?","Function?"]]},createCapture:{overloads:[["AUDIO|VIDEO|Object?","Object?","Function?"]]}},Cue={p5:Sue,"p5.Geometry":{flipV:{overloads:[[]]},calculateBoundingBox:{overloads:[[]]},clearColors:{overloads:[[]]},flipU:{overloads:[[]]},computeFaces:{overloads:[[]]},computeNormals:{overloads:[["FLAT|SMOOTH?","Object?"]]},makeEdgesFromFaces:{overloads:[[]]},normalize:{overloads:[[]]},vertexProperty:{overloads:[["String","Number|Number[]","Number?"]]}},"p5.Color":{toString:{overloads:[["String?"]]},setRed:{overloads:[["Number"]]},setGreen:{overloads:[["Number"]]},setBlue:{overloads:[["Number"]]},setAlpha:{overloads:[["Number"]]}},"p5.Graphics":{reset:{overloads:[[]]},remove:{overloads:[[]]},createFramebuffer:{overloads:[["Object?"]]}},"p5.Element":{remove:{overloads:[[]]},parent:{overloads:[["String|p5.Element|Object"],[]]},child:{overloads:[[],["String|p5.Element?"]]},html:{overloads:[[],["String?","Boolean?"]]},id:{overloads:[["String"],[]]},class:{overloads:[["String"],[]]},addClass:{overloads:[["String"]]},removeClass:{overloads:[["String"]]},hasClass:{overloads:[[null]]},toggleClass:{overloads:[[null]]},center:{overloads:[["String?"]]},position:{overloads:[[],["Number?","Number?","String?"]]},show:{overloads:[[]]},hide:{overloads:[[]]},size:{overloads:[[],["Number|AUTO?","Number|AUTO?"]]},style:{overloads:[["String"],["String","String|p5.Color"]]},attribute:{overloads:[[],["String","String"]]},removeAttribute:{overloads:[["String"]]},value:{overloads:[[],["String|Number"]]},mousePressed:{overloads:[["Function|Boolean"]]},doubleClicked:{overloads:[["Function|Boolean"]]},mouseWheel:{overloads:[["Function|Boolean"]]},mouseReleased:{overloads:[["Function|Boolean"]]},mouseClicked:{overloads:[["Function|Boolean"]]},mouseMoved:{overloads:[["Function|Boolean"]]},mouseOver:{overloads:[["Function|Boolean"]]},mouseOut:{overloads:[["Function|Boolean"]]},dragOver:{overloads:[["Function|Boolean"]]},dragLeave:{overloads:[["Function|Boolean"]]},changed:{overloads:[["Function|Boolean"]]},input:{overloads:[["Function|Boolean"]]},drop:{overloads:[["Function","Function?"]]},draggable:{overloads:[["p5.Element?"]]}},"p5.MediaElement":{play:{overloads:[[]]},stop:{overloads:[[]]},pause:{overloads:[[]]},loop:{overloads:[[]]},noLoop:{overloads:[[]]},autoplay:{overloads:[["Boolean?"]]},volume:{overloads:[[],["Number"]]},speed:{overloads:[[],["Number"]]},time:{overloads:[[],["Number"]]},duration:{overloads:[[]]},onended:{overloads:[["Function"]]},connect:{overloads:[["AudioNode|Object"]]},disconnect:{overloads:[[]]},showControls:{overloads:[[]]},hideControls:{overloads:[[]]},addCue:{overloads:[["Number","Function","Object?"]]},removeCue:{overloads:[["Number"]]},clearCues:{overloads:[[]]}},"p5.Image":{pixelDensity:{overloads:[["Number?"]]},loadPixels:{overloads:[[]]},updatePixels:{overloads:[["Integer","Integer","Integer","Integer"]]},get:{overloads:[["Number","Number","Number","Number"],[],["Number","Number"]]},set:{overloads:[["Number","Number","Number|Number[]|Object"]]},resize:{overloads:[["Number","Number"]]},copy:{overloads:[["p5.Image|p5.Element","Integer","Integer","Integer","Integer","Integer","Integer","Integer","Integer"],["Integer","Integer","Integer","Integer","Integer","Integer","Integer","Integer"]]},mask:{overloads:[["p5.Image"]]},filter:{overloads:[["THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|ERODE|DILATE|BLUR","Number?"]]},blend:{overloads:[["p5.Image","Integer","Integer","Integer","Integer","Integer","Integer","Integer","Integer","BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"],["Integer","Integer","Integer","Integer","Integer","Integer","Integer","Integer","BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"]]},save:{overloads:[["String","String?"]]},reset:{overloads:[[]]},getCurrentFrame:{overloads:[[]]},setFrame:{overloads:[["Number"]]},numFrames:{overloads:[[]]},play:{overloads:[[]]},pause:{overloads:[[]]},delay:{overloads:[["Number","Number?"]]}},"p5.Table":{addRow:{overloads:[["p5.TableRow?"]]},removeRow:{overloads:[["Integer"]]},getRow:{overloads:[["Integer"]]},getRows:{overloads:[[]]},findRow:{overloads:[["String","Integer|String"]]},findRows:{overloads:[["String","Integer|String"]]},matchRow:{overloads:[["String|RegExp","String|Integer"]]},matchRows:{overloads:[["String","String|Integer?"]]},getColumn:{overloads:[["String|Number"]]},clearRows:{overloads:[[]]},addColumn:{overloads:[["String?"]]},getColumnCount:{overloads:[[]]},getRowCount:{overloads:[[]]},removeTokens:{overloads:[["String","String|Integer?"]]},trim:{overloads:[["String|Integer?"]]},removeColumn:{overloads:[["String|Integer"]]},set:{overloads:[["Integer","String|Integer","String|Number"]]},setNum:{overloads:[["Integer","String|Integer","Number"]]},setString:{overloads:[["Integer","String|Integer","String"]]},get:{overloads:[["Integer","String|Integer"]]},getNum:{overloads:[["Integer","String|Integer"]]},getString:{overloads:[["Integer","String|Integer"]]},getObject:{overloads:[["String?"]]},getArray:{overloads:[[]]}},"p5.TableRow":{set:{overloads:[["String|Integer","String|Number"]]},setNum:{overloads:[["String|Integer","Number|String"]]},setString:{overloads:[["String|Integer","String|Number|Boolean|Object"]]},get:{overloads:[["String|Integer"]]},getNum:{overloads:[["String|Integer"]]},getString:{overloads:[["String|Integer"]]}},"p5.XML":{getParent:{overloads:[[]]},getName:{overloads:[[]]},setName:{overloads:[["String"]]},hasChildren:{overloads:[[]]},listChildren:{overloads:[[]]},getChildren:{overloads:[["String?"]]},getChild:{overloads:[["String|Integer"]]},addChild:{overloads:[["p5.XML"]]},removeChild:{overloads:[["String|Integer"]]},getAttributeCount:{overloads:[[]]},listAttributes:{overloads:[[]]},hasAttribute:{overloads:[["String"]]},getNum:{overloads:[["String","Number?"]]},getString:{overloads:[["String","Number?"]]},setAttribute:{overloads:[["String","Number|String|Boolean"]]},getContent:{overloads:[["String?"]]},serialize:{overloads:[[]]}},"p5.Vector":{getValue:{overloads:[["Number"]]},setValue:{overloads:[["Number","Number"]]},set:{overloads:[["Number?","Number?","Number?"],["p5.Vector|Number[]"]]},copy:{overloads:[[],["p5.Vector"]]},add:{overloads:[["Number|Array","Number?","Number?"],["p5.Vector|Number[]"],["p5.Vector","p5.Vector","p5.Vector?"]]},rem:{overloads:[["Number","Number","Number"],["p5.Vector|Number[]"],["p5.Vector","p5.Vector"]]},sub:{overloads:[["Number","Number?","Number?"],["p5.Vector|Number[]"],["p5.Vector","p5.Vector","p5.Vector?"]]},mult:{overloads:[["Number","Number","Number?"],["Number[]"],["p5.Vector"],[],["p5.Vector","Number","p5.Vector?"],["p5.Vector","p5.Vector","p5.Vector?"],["p5.Vector","Number[]","p5.Vector?"]]},div:{overloads:[["Number"],["Number","Number","Number?"],["Number[]"],["p5.Vector"],[],["p5.Vector","Number","p5.Vector?"],["p5.Vector","p5.Vector","p5.Vector?"],["p5.Vector","Number[]","p5.Vector?"]]},mag:{overloads:[[],["p5.Vector"]]},magSq:{overloads:[[],["p5.Vector"]]},dot:{overloads:[["Number","Number?","Number?"],["p5.Vector"],[],["p5.Vector","p5.Vector"]]},cross:{overloads:[["p5.Vector"],[],["p5.Vector","p5.Vector"]]},normalize:{overloads:[[],["p5.Vector","p5.Vector?"]]},limit:{overloads:[["Number"],[],["p5.Vector","Number","p5.Vector?"]]},setMag:{overloads:[["Number"],[],["p5.Vector","Number","p5.Vector?"]]},heading:{overloads:[[],["p5.Vector"]]},setHeading:{overloads:[["Number"]]},rotate:{overloads:[["Number"],[],["p5.Vector","Number","p5.Vector?"]]},angleBetween:{overloads:[["p5.Vector"],[],["p5.Vector","p5.Vector"]]},lerp:{overloads:[["Number","Number","Number","Number"],["p5.Vector","Number"],[],["p5.Vector","p5.Vector","Number","p5.Vector?"]]},slerp:{overloads:[["p5.Vector","Number"],[],["p5.Vector","p5.Vector","Number","p5.Vector?"]]},reflect:{overloads:[["p5.Vector"],[],["p5.Vector","p5.Vector","p5.Vector?"]]},array:{overloads:[[],["p5.Vector"]]},equals:{overloads:[["Number?","Number?","Number?"],["p5.Vector|Array"],[],["p5.Vector|Array","p5.Vector|Array"]]},fromAngle:{overloads:[["Number","Number?"]]},fromAngles:{overloads:[["Number","Number","Number?"]]},random2D:{overloads:[[]]},random3D:{overloads:[[]]},dist:{overloads:[[],["p5.Vector","p5.Vector"]]}},"p5.Font":{textToPaths:{overloads:[["String","Number","Number","Number?","Number?","Object?"]]},textToPoints:{overloads:[["String","Number","Number","Object?"]]},textToContours:{overloads:[["String","Number","Number","Object?"]]},textToModel:{overloads:[["String","Number","Number","Number","Number","Object?","Number?","Number?"]]}},"p5.Camera":{perspective:{overloads:[["Number?","Number?","Number?","Number?"]]},ortho:{overloads:[["Number?","Number?","Number?","Number?","Number?","Number?"]]},frustum:{overloads:[["Number?","Number?","Number?","Number?","Number?","Number?"]]},pan:{overloads:[["Number"]]},tilt:{overloads:[["Number"]]},lookAt:{overloads:[["Number","Number","Number"]]},camera:{overloads:[["Number?","Number?","Number?","Number?","Number?","Number?","Number?","Number?","Number?"]]},move:{overloads:[["Number","Number","Number"]]},setPosition:{overloads:[["Number","Number","Number"]]},set:{overloads:[["p5.Camera"]]},slerp:{overloads:[["p5.Camera","p5.Camera","Number"]]}},"p5.Framebuffer":{resize:{overloads:[["Number","Number"]]},pixelDensity:{overloads:[["Number?"]]},autoSized:{overloads:[["Boolean?"]]},createCamera:{overloads:[[]]},remove:{overloads:[[]]},begin:{overloads:[[]]},end:{overloads:[[]]},draw:{overloads:[["Function"]]},get:{overloads:[["Number","Number","Number","Number"],[],["Number","Number"]]}},"p5.Shader":{version:{overloads:[[]]},inspectHooks:{overloads:[[]]},modify:{overloads:[["Object?"]]},copyToContext:{overloads:[["p5|p5.Graphics"]]},setUniform:{overloads:[["String","Boolean|Number|Number[]|p5.Image|p5.Graphics|p5.MediaElement|p5.Texture"]]}}};function fW(r,t,n){let s=new Map;const i=Object.keys(r).reduce((m,g)=>(g.match(/^[A-Z]/)&&!g.match(/^[A-Z][A-Z0-9]*$/)&&r[g]instanceof Function&&(m[g]=r[g]),m),{});function a(){for(let m of Object.keys(r))typeof r[m]=="function"&&m[0]!==m[0].toLowerCase()&&(i[m]=r[m])}const o={};for(const[m,g]of Object.entries(Wh))o[m]=g;const u={Any:mE(),Array:yB(mE()),Boolean:vue(),Function:vB(),Integer:gB().int(),Number:gB(),Object:wue({}),String:xue()},l=["AudioNode","HTMLCanvasElement","HTMLElement","KeyboardEvent","MouseEvent","RegExp","TouchEvent","UIEvent","WheelEvent"];function c(m){return m.reduce((g,y)=>(g[y]=pW(b=>b instanceof globalThis[y],{message:`Expected a ${y}`}),g),{})}const h=c(l);Object.assign(u,h);const d=["first","second","third","fourth","fifth","sixth","seventh","eighth","ninth","tenth"];function p(m){const g=m.lastIndexOf("."),y=m.slice(g+1),b=m.slice(0,g!==-1?g:0)||"p5";return{funcName:y,funcClass:b}}function f(m){let g=0;for(let y=0;y<m.length;y++)if(m[y]==="[")g++;else if(m[y]==="]"&&(g--,g<0))return!1;return g===0}t.generateZodSchemasForFunc=function(m){const{funcName:g,funcClass:y}=p(m);let b=Cue[y][g];if(!b)return;let x=[];b.hasOwnProperty("overloads")&&(x=b.overloads);const w=C=>{if(!C)return mE();let I;if(C in o)I=wB(o[C]);else if(C.match(/^[A-Z][A-Z0-9]*$/)&&C in t)I=wB(t[C]);else if(C.startsWith("function"))I=vB();else if(/^p5\.[a-zA-Z0-9]+$/.exec(C)||C==="p5"){const _=C.substring(C.indexOf(".")+1);I=mB(i[_])}else if(u[C])I=u[C];else if(C.startsWith("[")&&C.endsWith("]")&&f(C.slice(1,-1)))I=xB(C.slice(1,-1).split(/, */g).map(_=>w(_)));else if(C.match(/^[A-Z]/)&&C in window)I=mB(window[C]);else if(C.includes("|")&&C.split("|").every(_=>f(_))){const _=C.split("|");I=bB(_.map(A=>w(A)).filter(A=>A!==void 0))}else if(C.endsWith("[]"))I=yB(w(C.slice(0,-2)));else throw new Error(`Unsupported type '${C}' in parameter validation. Please report this issue.`);return I},v=C=>{const I=C==null?void 0:C.endsWith("?");C=C==null?void 0:C.replace(/\?$/,"");const _=(C==null?void 0:C.startsWith("..."))&&(C==null?void 0:C.endsWith("[]"));C=C==null?void 0:C.replace(/^\.\.\.(.+)\[\]$/,"$1");let A=w(C);return I&&(A=A.optional()),{schema:A,rest:_}},S=C=>{if(!C.some(A=>A==null?void 0:A.endsWith("?")))return[C];const I=C.filter(A=>A===null||!A.endsWith("?")).length,_=[];for(let A=I;A<=C.length;A++)_.push(C.slice(0,A));return _},E=x.flatMap(C=>S(C).map(_=>{var D;const A=_.map(F=>v(F)).filter(F=>F.schema!==void 0);let k;(D=A.at(-1))!=null&&D.rest&&(k=A.pop());let N=xB(A.map(F=>F.schema));return k&&(N=N.rest(k.schema)),N}));return E.length===1?E[0]:bB(E)},t.findClosestSchema=function(m,g){if(!(m instanceof bb))return m;const y=v=>{let S=1/0;if(!(v instanceof cu))return console.warn("Schema below is not a tuple: "),printZodSchema(v),S;const E=g.length,C=v.items,I=C.length,_=C.filter(A=>!A.isOptional()).length;E>=_&&E<=I?S=0:S=Math.abs(E<_?_-E:E-I)*4;for(let A=0;A<Math.min(C.length,g.length);A++){const k=C[A],N=g[A];k.safeParse(N).success||S++}return S};let b=m._def.options[0],x=1/0;return m._def.options.forEach(v=>{const S=y(v);S<x&&(b=v,x=S)}),b},t.friendlyParamError=function(m,g,y){let b=" p5.js says: ",x=!1,w=m.errors[0];const v=(C,I,_)=>{const A=_?`at the ${d[_]} parameter`:"",k=C?`, but received ${C}`:"";return`Expected ${I} ${A}${k}`},S=C=>{var A;const I=new Set;let _;if(C.unionErrors.forEach(k=>{const N=k.issues[0];if(N){if(_||(_=N.received),N.code==="invalid_type")I.add(N.expected);else if(N.code==="invalid_literal")I.add("constant (please refer to documentation for allowed values)");else if(N.code==="custom"){const D=N.message.match(/Input not instance of (\w+)/);D&&I.add(D[1])}}}),I.size>0){((A=C.path)==null?void 0:A.length)>0&&y[C.path[0]]instanceof Promise&&(b+="Did you mean to put `await` before a loading function? An unexpected Promise was found. ",x=!0);const k=Array.from(I).join(" or "),N=C.path.join(".");b+=v(_,k,N)}return b};switch(w.code){case"invalid_union":{S(w);break}case"too_small":{const C=w.minimum;b+=`Expected at least ${C} argument${C>1?"s":""}, but received fewer`;break}case"invalid_type":{b+=v(w.received,w.expected,w.path.join("."));break}case"too_big":{const C=w.maximum;b+=`Expected at most ${C} argument${C>1?"s":""}, but received more`;break}default:console.log("Zod error object",w)}b+=` in ${g}().`;const E=C=>{const{funcName:I,funcClass:_}=p(C);return`https://p5js.org/reference/${_}/${I}`};if(w.code==="too_big"||w.code==="too_small"){const C=E(g);b+=` For more information, see ${C}.`}return x?r._error(this,b):console.log(b),b},t.validate=function(m,g){if(r.disableFriendlyErrors)return;if(Array.isArray(g)||(g=Array.from(g)),Array.isArray(g)&&g.length>0&&g.every(b=>b===void 0))return{success:!1,error:` p5.js says: All arguments for ${m}() are undefined. There is likely an error in the code.`};let y=s.get(m);if(!y){if(y=t.generateZodSchemasForFunc(m),!y)return;s.set(m,y)}try{return{success:!0,data:y.parse(g)}}catch{const w=t.findClosestSchema(y,g).safeParse(g).error;return{success:!1,error:t.friendlyParamError(w,m,g)}}},n.presetup=function(){a();const m=["validate"];for(const g in this)if(!m.includes(g)&&!g.startsWith("_")&&typeof this[g]=="function"){const y=this[g];this[g]=function(...b){return this.validate(g,b),y.call(this,...b)}}}}typeof p5<"u"&&fW(p5,p5.prototype);var _ue=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,7,9,32,4,318,1,80,3,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,68,8,2,0,3,0,2,3,2,4,2,0,15,1,83,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,7,19,58,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,343,9,54,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,10,5350,0,7,14,11465,27,2343,9,87,9,39,4,60,6,26,9,535,9,470,0,2,54,8,3,82,0,12,1,19628,1,4178,9,519,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,245,1,2,9,726,6,110,6,6,9,4759,9,787719,239],mW=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,4,51,13,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,39,27,10,22,251,41,7,1,17,2,60,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,31,9,2,0,3,0,2,37,2,0,26,0,2,0,45,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,200,32,32,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,26,3994,6,582,6842,29,1763,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,433,44,212,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,42,9,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,229,29,3,0,496,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,16,621,2467,541,1507,4938,6,4191],Eue="-----------------------------------------------------------------------------------------------------------------------------------------------------",gW="------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",gE={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"},yE="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",Iue={5:yE,"5module":yE+" export import",6:yE+" const class extends export import super"},kue=/^in(stanceof)?$/,Nue=new RegExp("["+gW+"]"),Tue=new RegExp("["+gW+Eue+"]");function ok(r,t){for(var n=65536,s=0;s<t.length;s+=2){if(n+=t[s],n>r)return!1;if(n+=t[s+1],n>=r)return!0}return!1}function il(r,t){return r<65?r===36:r<91?!0:r<97?r===95:r<123?!0:r<=65535?r>=170&&Nue.test(String.fromCharCode(r)):t===!1?!1:ok(r,mW)}function Dm(r,t){return r<48?r===36:r<58?!0:r<65?!1:r<91?!0:r<97?r===95:r<123?!0:r<=65535?r>=170&&Tue.test(String.fromCharCode(r)):t===!1?!1:ok(r,mW)||ok(r,_ue)}var Br=function(t,n){n===void 0&&(n={}),this.label=t,this.keyword=n.keyword,this.beforeExpr=!!n.beforeExpr,this.startsExpr=!!n.startsExpr,this.isLoop=!!n.isLoop,this.isAssign=!!n.isAssign,this.prefix=!!n.prefix,this.postfix=!!n.postfix,this.binop=n.binop||null,this.updateContext=null};function Da(r,t){return new Br(r,{beforeExpr:!0,binop:t})}var Fa={beforeExpr:!0},Mi={startsExpr:!0},ZT={};function Dr(r,t){return t===void 0&&(t={}),t.keyword=r,ZT[r]=new Br(r,t)}var te={num:new Br("num",Mi),regexp:new Br("regexp",Mi),string:new Br("string",Mi),name:new Br("name",Mi),privateId:new Br("privateId",Mi),eof:new Br("eof"),bracketL:new Br("[",{beforeExpr:!0,startsExpr:!0}),bracketR:new Br("]"),braceL:new Br("{",{beforeExpr:!0,startsExpr:!0}),braceR:new Br("}"),parenL:new Br("(",{beforeExpr:!0,startsExpr:!0}),parenR:new Br(")"),comma:new Br(",",Fa),semi:new Br(";",Fa),colon:new Br(":",Fa),dot:new Br("."),question:new Br("?",Fa),questionDot:new Br("?."),arrow:new Br("=>",Fa),template:new Br("template"),invalidTemplate:new Br("invalidTemplate"),ellipsis:new Br("...",Fa),backQuote:new Br("`",Mi),dollarBraceL:new Br("${",{beforeExpr:!0,startsExpr:!0}),eq:new Br("=",{beforeExpr:!0,isAssign:!0}),assign:new Br("_=",{beforeExpr:!0,isAssign:!0}),incDec:new Br("++/--",{prefix:!0,postfix:!0,startsExpr:!0}),prefix:new Br("!/~",{beforeExpr:!0,prefix:!0,startsExpr:!0}),logicalOR:Da("||",1),logicalAND:Da("&&",2),bitwiseOR:Da("|",3),bitwiseXOR:Da("^",4),bitwiseAND:Da("&",5),equality:Da("==/!=/===/!==",6),relational:Da("</>/<=/>=",7),bitShift:Da("<</>>/>>>",8),plusMin:new Br("+/-",{beforeExpr:!0,binop:9,prefix:!0,startsExpr:!0}),modulo:Da("%",10),star:Da("*",10),slash:Da("/",10),starstar:new Br("**",{beforeExpr:!0}),coalesce:Da("??",1),_break:Dr("break"),_case:Dr("case",Fa),_catch:Dr("catch"),_continue:Dr("continue"),_debugger:Dr("debugger"),_default:Dr("default",Fa),_do:Dr("do",{isLoop:!0,beforeExpr:!0}),_else:Dr("else",Fa),_finally:Dr("finally"),_for:Dr("for",{isLoop:!0}),_function:Dr("function",Mi),_if:Dr("if"),_return:Dr("return",Fa),_switch:Dr("switch"),_throw:Dr("throw",Fa),_try:Dr("try"),_var:Dr("var"),_const:Dr("const"),_while:Dr("while",{isLoop:!0}),_with:Dr("with"),_new:Dr("new",{beforeExpr:!0,startsExpr:!0}),_this:Dr("this",Mi),_super:Dr("super",Mi),_class:Dr("class",Mi),_extends:Dr("extends",Fa),_export:Dr("export"),_import:Dr("import",Mi),_null:Dr("null",Mi),_true:Dr("true",Mi),_false:Dr("false",Mi),_in:Dr("in",{beforeExpr:!0,binop:7}),_instanceof:Dr("instanceof",{beforeExpr:!0,binop:7}),_typeof:Dr("typeof",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_void:Dr("void",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_delete:Dr("delete",{beforeExpr:!0,prefix:!0,startsExpr:!0})},Qa=/\r\n?|\n|\u2028|\u2029/,Aue=new RegExp(Qa.source,"g");function ag(r){return r===10||r===13||r===8232||r===8233}function yW(r,t,n){n===void 0&&(n=r.length);for(var s=t;s<n;s++){var i=r.charCodeAt(s);if(ag(i))return s<n-1&&i===13&&r.charCodeAt(s+1)===10?s+2:s+1}return-1}var bW=/[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,Va=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,xW=Object.prototype,Due=xW.hasOwnProperty,Fue=xW.toString,og=Object.hasOwn||function(r,t){return Due.call(r,t)},SB=Array.isArray||function(r){return Fue.call(r)==="[object Array]"},CB=Object.create(null);function Hl(r){return CB[r]||(CB[r]=new RegExp("^(?:"+r.replace(/ /g,"|")+")$"))}function al(r){return r<=65535?String.fromCharCode(r):(r-=65536,String.fromCharCode((r>>10)+55296,(r&1023)+56320))}var $ue=/(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,vb=function(t,n){this.line=t,this.column=n};vb.prototype.offset=function(t){return new vb(this.line,this.column+t)};var BS=function(t,n,s){this.start=n,this.end=s,t.sourceFile!==null&&(this.source=t.sourceFile)};function vW(r,t){for(var n=1,s=0;;){var i=yW(r,s,t);if(i<0)return new vb(n,t-s);++n,s=i}}var uk={ecmaVersion:null,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowAwaitOutsideFunction:null,allowSuperOutsideMethod:null,allowHashBang:!1,checkPrivateFields:!0,locations:!1,onToken:null,onComment:null,ranges:!1,program:null,sourceFile:null,directSourceFile:null,preserveParens:!1},_B=!1;function Rue(r){var t={};for(var n in uk)t[n]=r&&og(r,n)?r[n]:uk[n];if(t.ecmaVersion==="latest"?t.ecmaVersion=1e8:t.ecmaVersion==null?(!_B&&typeof console=="object"&&console.warn&&(_B=!0,console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)),t.ecmaVersion=11):t.ecmaVersion>=2015&&(t.ecmaVersion-=2009),t.allowReserved==null&&(t.allowReserved=t.ecmaVersion<5),(!r||r.allowHashBang==null)&&(t.allowHashBang=t.ecmaVersion>=14),SB(t.onToken)){var s=t.onToken;t.onToken=function(i){return s.push(i)}}return SB(t.onComment)&&(t.onComment=Oue(t,t.onComment)),t}function Oue(r,t){return function(n,s,i,a,o,u){var l={type:n?"Block":"Line",value:s,start:i,end:a};r.locations&&(l.loc=new BS(this,o,u)),r.ranges&&(l.range=[i,a]),t.push(l)}}var wb=1,ug=2,JT=4,wW=8,QT=16,SW=32,VS=64,CW=128,$d=256,fx=512,zS=wb|ug|$d;function eA(r,t){return ug|(r?JT:0)|(t?wW:0)}var c2=0,tA=1,fl=2,_W=3,EW=4,IW=5,Cs=function(t,n,s){this.options=t=Rue(t),this.sourceFile=t.sourceFile,this.keywords=Hl(Iue[t.ecmaVersion>=6?6:t.sourceType==="module"?"5module":5]);var i="";t.allowReserved!==!0&&(i=gE[t.ecmaVersion>=6?6:t.ecmaVersion===5?5:3],t.sourceType==="module"&&(i+=" await")),this.reservedWords=Hl(i);var a=(i?i+" ":"")+gE.strict;this.reservedWordsStrict=Hl(a),this.reservedWordsStrictBind=Hl(a+" "+gE.strictBind),this.input=String(n),this.containsEsc=!1,s?(this.pos=s,this.lineStart=this.input.lastIndexOf(`
`,s-1)+1,this.curLine=this.input.slice(0,this.lineStart).split(Qa).length):(this.pos=this.lineStart=0,this.curLine=1),this.type=te.eof,this.value=null,this.start=this.end=this.pos,this.startLoc=this.endLoc=this.curPosition(),this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,this.context=this.initialContext(),this.exprAllowed=!0,this.inModule=t.sourceType==="module",this.strict=this.inModule||this.strictDirective(this.pos),this.potentialArrowAt=-1,this.potentialArrowInForAwait=!1,this.yieldPos=this.awaitPos=this.awaitIdentPos=0,this.labels=[],this.undefinedExports=Object.create(null),this.pos===0&&t.allowHashBang&&this.input.slice(0,2)==="#!"&&this.skipLineComment(2),this.scopeStack=[],this.enterScope(wb),this.regexpState=null,this.privateNameStack=[]},Su={inFunction:{configurable:!0},inGenerator:{configurable:!0},inAsync:{configurable:!0},canAwait:{configurable:!0},allowSuper:{configurable:!0},allowDirectSuper:{configurable:!0},treatFunctionsAsVar:{configurable:!0},allowNewDotTarget:{configurable:!0},inClassStaticBlock:{configurable:!0}};Cs.prototype.parse=function(){var t=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel(t)};Su.inFunction.get=function(){return(this.currentVarScope().flags&ug)>0};Su.inGenerator.get=function(){return(this.currentVarScope().flags&wW)>0};Su.inAsync.get=function(){return(this.currentVarScope().flags&JT)>0};Su.canAwait.get=function(){for(var r=this.scopeStack.length-1;r>=0;r--){var t=this.scopeStack[r],n=t.flags;if(n&($d|fx))return!1;if(n&ug)return(n&JT)>0}return this.inModule&&this.options.ecmaVersion>=13||this.options.allowAwaitOutsideFunction};Su.allowSuper.get=function(){var r=this.currentThisScope(),t=r.flags;return(t&VS)>0||this.options.allowSuperOutsideMethod};Su.allowDirectSuper.get=function(){return(this.currentThisScope().flags&CW)>0};Su.treatFunctionsAsVar.get=function(){return this.treatFunctionsAsVarInScope(this.currentScope())};Su.allowNewDotTarget.get=function(){for(var r=this.scopeStack.length-1;r>=0;r--){var t=this.scopeStack[r],n=t.flags;if(n&($d|fx)||n&ug&&!(n&QT))return!0}return!1};Su.inClassStaticBlock.get=function(){return(this.currentVarScope().flags&$d)>0};Cs.extend=function(){for(var t=[],n=arguments.length;n--;)t[n]=arguments[n];for(var s=this,i=0;i<t.length;i++)s=t[i](s);return s};Cs.parse=function(t,n){return new this(n,t).parse()};Cs.parseExpressionAt=function(t,n,s){var i=new this(s,t,n);return i.nextToken(),i.parseExpression()};Cs.tokenizer=function(t,n){return new this(n,t)};Object.defineProperties(Cs.prototype,Su);var Fi=Cs.prototype,Mue=/^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;Fi.strictDirective=function(r){if(this.options.ecmaVersion<5)return!1;for(;;){Va.lastIndex=r,r+=Va.exec(this.input)[0].length;var t=Mue.exec(this.input.slice(r));if(!t)return!1;if((t[1]||t[2])==="use strict"){Va.lastIndex=r+t[0].length;var n=Va.exec(this.input),s=n.index+n[0].length,i=this.input.charAt(s);return i===";"||i==="}"||Qa.test(n[0])&&!(/[(`.[+\-/*%<>=,?^&]/.test(i)||i==="!"&&this.input.charAt(s+1)==="=")}r+=t[0].length,Va.lastIndex=r,r+=Va.exec(this.input)[0].length,this.input[r]===";"&&r++}};Fi.eat=function(r){return this.type===r?(this.next(),!0):!1};Fi.isContextual=function(r){return this.type===te.name&&this.value===r&&!this.containsEsc};Fi.eatContextual=function(r){return this.isContextual(r)?(this.next(),!0):!1};Fi.expectContextual=function(r){this.eatContextual(r)||this.unexpected()};Fi.canInsertSemicolon=function(){return this.type===te.eof||this.type===te.braceR||Qa.test(this.input.slice(this.lastTokEnd,this.start))};Fi.insertSemicolon=function(){if(this.canInsertSemicolon())return this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),!0};Fi.semicolon=function(){!this.eat(te.semi)&&!this.insertSemicolon()&&this.unexpected()};Fi.afterTrailingComma=function(r,t){if(this.type===r)return this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),t||this.next(),!0};Fi.expect=function(r){this.eat(r)||this.unexpected()};Fi.unexpected=function(r){this.raise(r??this.start,"Unexpected token")};var US=function(){this.shorthandAssign=this.trailingComma=this.parenthesizedAssign=this.parenthesizedBind=this.doubleProto=-1};Fi.checkPatternErrors=function(r,t){if(r){r.trailingComma>-1&&this.raiseRecoverable(r.trailingComma,"Comma is not permitted after the rest element");var n=t?r.parenthesizedAssign:r.parenthesizedBind;n>-1&&this.raiseRecoverable(n,t?"Assigning to rvalue":"Parenthesized pattern")}};Fi.checkExpressionErrors=function(r,t){if(!r)return!1;var n=r.shorthandAssign,s=r.doubleProto;if(!t)return n>=0||s>=0;n>=0&&this.raise(n,"Shorthand property assignments are valid only in destructuring patterns"),s>=0&&this.raiseRecoverable(s,"Redefinition of __proto__ property")};Fi.checkYieldAwaitInDefaultParams=function(){this.yieldPos&&(!this.awaitPos||this.yieldPos<this.awaitPos)&&this.raise(this.yieldPos,"Yield expression cannot be a default value"),this.awaitPos&&this.raise(this.awaitPos,"Await expression cannot be a default value")};Fi.isSimpleAssignTarget=function(r){return r.type==="ParenthesizedExpression"?this.isSimpleAssignTarget(r.expression):r.type==="Identifier"||r.type==="MemberExpression"};var zt=Cs.prototype;zt.parseTopLevel=function(r){var t=Object.create(null);for(r.body||(r.body=[]);this.type!==te.eof;){var n=this.parseStatement(null,!0,t);r.body.push(n)}if(this.inModule)for(var s=0,i=Object.keys(this.undefinedExports);s<i.length;s+=1){var a=i[s];this.raiseRecoverable(this.undefinedExports[a].start,"Export '"+a+"' is not defined")}return this.adaptDirectivePrologue(r.body),this.next(),r.sourceType=this.options.sourceType,this.finishNode(r,"Program")};var rA={kind:"loop"},Lue={kind:"switch"};zt.isLet=function(r){if(this.options.ecmaVersion<6||!this.isContextual("let"))return!1;Va.lastIndex=this.pos;var t=Va.exec(this.input),n=this.pos+t[0].length,s=this.input.charCodeAt(n);if(s===91||s===92)return!0;if(r)return!1;if(s===123||s>55295&&s<56320)return!0;if(il(s,!0)){for(var i=n+1;Dm(s=this.input.charCodeAt(i),!0);)++i;if(s===92||s>55295&&s<56320)return!0;var a=this.input.slice(n,i);if(!kue.test(a))return!0}return!1};zt.isAsyncFunction=function(){if(this.options.ecmaVersion<8||!this.isContextual("async"))return!1;Va.lastIndex=this.pos;var r=Va.exec(this.input),t=this.pos+r[0].length,n;return!Qa.test(this.input.slice(this.pos,t))&&this.input.slice(t,t+8)==="function"&&(t+8===this.input.length||!(Dm(n=this.input.charCodeAt(t+8))||n>55295&&n<56320))};zt.parseStatement=function(r,t,n){var s=this.type,i=this.startNode(),a;switch(this.isLet(r)&&(s=te._var,a="let"),s){case te._break:case te._continue:return this.parseBreakContinueStatement(i,s.keyword);case te._debugger:return this.parseDebuggerStatement(i);case te._do:return this.parseDoStatement(i);case te._for:return this.parseForStatement(i);case te._function:return r&&(this.strict||r!=="if"&&r!=="label")&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(i,!1,!r);case te._class:return r&&this.unexpected(),this.parseClass(i,!0);case te._if:return this.parseIfStatement(i);case te._return:return this.parseReturnStatement(i);case te._switch:return this.parseSwitchStatement(i);case te._throw:return this.parseThrowStatement(i);case te._try:return this.parseTryStatement(i);case te._const:case te._var:return a=a||this.value,r&&a!=="var"&&this.unexpected(),this.parseVarStatement(i,a);case te._while:return this.parseWhileStatement(i);case te._with:return this.parseWithStatement(i);case te.braceL:return this.parseBlock(!0,i);case te.semi:return this.parseEmptyStatement(i);case te._export:case te._import:if(this.options.ecmaVersion>10&&s===te._import){Va.lastIndex=this.pos;var o=Va.exec(this.input),u=this.pos+o[0].length,l=this.input.charCodeAt(u);if(l===40||l===46)return this.parseExpressionStatement(i,this.parseExpression())}return this.options.allowImportExportEverywhere||(t||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),s===te._import?this.parseImport(i):this.parseExport(i,n);default:if(this.isAsyncFunction())return r&&this.unexpected(),this.next(),this.parseFunctionStatement(i,!0,!r);var c=this.value,h=this.parseExpression();return s===te.name&&h.type==="Identifier"&&this.eat(te.colon)?this.parseLabeledStatement(i,c,h,r):this.parseExpressionStatement(i,h)}};zt.parseBreakContinueStatement=function(r,t){var n=t==="break";this.next(),this.eat(te.semi)||this.insertSemicolon()?r.label=null:this.type!==te.name?this.unexpected():(r.label=this.parseIdent(),this.semicolon());for(var s=0;s<this.labels.length;++s){var i=this.labels[s];if((r.label==null||i.name===r.label.name)&&(i.kind!=null&&(n||i.kind==="loop")||r.label&&n))break}return s===this.labels.length&&this.raise(r.start,"Unsyntactic "+t),this.finishNode(r,n?"BreakStatement":"ContinueStatement")};zt.parseDebuggerStatement=function(r){return this.next(),this.semicolon(),this.finishNode(r,"DebuggerStatement")};zt.parseDoStatement=function(r){return this.next(),this.labels.push(rA),r.body=this.parseStatement("do"),this.labels.pop(),this.expect(te._while),r.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(te.semi):this.semicolon(),this.finishNode(r,"DoWhileStatement")};zt.parseForStatement=function(r){this.next();var t=this.options.ecmaVersion>=9&&this.canAwait&&this.eatContextual("await")?this.lastTokStart:-1;if(this.labels.push(rA),this.enterScope(0),this.expect(te.parenL),this.type===te.semi)return t>-1&&this.unexpected(t),this.parseFor(r,null);var n=this.isLet();if(this.type===te._var||this.type===te._const||n){var s=this.startNode(),i=n?"let":this.value;return this.next(),this.parseVar(s,!0,i),this.finishNode(s,"VariableDeclaration"),(this.type===te._in||this.options.ecmaVersion>=6&&this.isContextual("of"))&&s.declarations.length===1?(this.options.ecmaVersion>=9&&(this.type===te._in?t>-1&&this.unexpected(t):r.await=t>-1),this.parseForIn(r,s)):(t>-1&&this.unexpected(t),this.parseFor(r,s))}var a=this.isContextual("let"),o=!1,u=this.containsEsc,l=new US,c=this.start,h=t>-1?this.parseExprSubscripts(l,"await"):this.parseExpression(!0,l);return this.type===te._in||(o=this.options.ecmaVersion>=6&&this.isContextual("of"))?(t>-1?(this.type===te._in&&this.unexpected(t),r.await=!0):o&&this.options.ecmaVersion>=8&&(h.start===c&&!u&&h.type==="Identifier"&&h.name==="async"?this.unexpected():this.options.ecmaVersion>=9&&(r.await=!1)),a&&o&&this.raise(h.start,"The left-hand side of a for-of loop may not start with 'let'."),this.toAssignable(h,!1,l),this.checkLValPattern(h),this.parseForIn(r,h)):(this.checkExpressionErrors(l,!0),t>-1&&this.unexpected(t),this.parseFor(r,h))};zt.parseFunctionStatement=function(r,t,n){return this.next(),this.parseFunction(r,qy|(n?0:lk),!1,t)};zt.parseIfStatement=function(r){return this.next(),r.test=this.parseParenExpression(),r.consequent=this.parseStatement("if"),r.alternate=this.eat(te._else)?this.parseStatement("if"):null,this.finishNode(r,"IfStatement")};zt.parseReturnStatement=function(r){return!this.inFunction&&!this.options.allowReturnOutsideFunction&&this.raise(this.start,"'return' outside of function"),this.next(),this.eat(te.semi)||this.insertSemicolon()?r.argument=null:(r.argument=this.parseExpression(),this.semicolon()),this.finishNode(r,"ReturnStatement")};zt.parseSwitchStatement=function(r){this.next(),r.discriminant=this.parseParenExpression(),r.cases=[],this.expect(te.braceL),this.labels.push(Lue),this.enterScope(0);for(var t,n=!1;this.type!==te.braceR;)if(this.type===te._case||this.type===te._default){var s=this.type===te._case;t&&this.finishNode(t,"SwitchCase"),r.cases.push(t=this.startNode()),t.consequent=[],this.next(),s?t.test=this.parseExpression():(n&&this.raiseRecoverable(this.lastTokStart,"Multiple default clauses"),n=!0,t.test=null),this.expect(te.colon)}else t||this.unexpected(),t.consequent.push(this.parseStatement(null));return this.exitScope(),t&&this.finishNode(t,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(r,"SwitchStatement")};zt.parseThrowStatement=function(r){return this.next(),Qa.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),r.argument=this.parseExpression(),this.semicolon(),this.finishNode(r,"ThrowStatement")};var Pue=[];zt.parseCatchClauseParam=function(){var r=this.parseBindingAtom(),t=r.type==="Identifier";return this.enterScope(t?SW:0),this.checkLValPattern(r,t?EW:fl),this.expect(te.parenR),r};zt.parseTryStatement=function(r){if(this.next(),r.block=this.parseBlock(),r.handler=null,this.type===te._catch){var t=this.startNode();this.next(),this.eat(te.parenL)?t.param=this.parseCatchClauseParam():(this.options.ecmaVersion<10&&this.unexpected(),t.param=null,this.enterScope(0)),t.body=this.parseBlock(!1),this.exitScope(),r.handler=this.finishNode(t,"CatchClause")}return r.finalizer=this.eat(te._finally)?this.parseBlock():null,!r.handler&&!r.finalizer&&this.raise(r.start,"Missing catch or finally clause"),this.finishNode(r,"TryStatement")};zt.parseVarStatement=function(r,t,n){return this.next(),this.parseVar(r,!1,t,n),this.semicolon(),this.finishNode(r,"VariableDeclaration")};zt.parseWhileStatement=function(r){return this.next(),r.test=this.parseParenExpression(),this.labels.push(rA),r.body=this.parseStatement("while"),this.labels.pop(),this.finishNode(r,"WhileStatement")};zt.parseWithStatement=function(r){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),r.object=this.parseParenExpression(),r.body=this.parseStatement("with"),this.finishNode(r,"WithStatement")};zt.parseEmptyStatement=function(r){return this.next(),this.finishNode(r,"EmptyStatement")};zt.parseLabeledStatement=function(r,t,n,s){for(var i=0,a=this.labels;i<a.length;i+=1){var o=a[i];o.name===t&&this.raise(n.start,"Label '"+t+"' is already declared")}for(var u=this.type.isLoop?"loop":this.type===te._switch?"switch":null,l=this.labels.length-1;l>=0;l--){var c=this.labels[l];if(c.statementStart===r.start)c.statementStart=this.start,c.kind=u;else break}return this.labels.push({name:t,kind:u,statementStart:this.start}),r.body=this.parseStatement(s?s.indexOf("label")===-1?s+"label":s:"label"),this.labels.pop(),r.label=n,this.finishNode(r,"LabeledStatement")};zt.parseExpressionStatement=function(r,t){return r.expression=t,this.semicolon(),this.finishNode(r,"ExpressionStatement")};zt.parseBlock=function(r,t,n){for(r===void 0&&(r=!0),t===void 0&&(t=this.startNode()),t.body=[],this.expect(te.braceL),r&&this.enterScope(0);this.type!==te.braceR;){var s=this.parseStatement(null);t.body.push(s)}return n&&(this.strict=!1),this.next(),r&&this.exitScope(),this.finishNode(t,"BlockStatement")};zt.parseFor=function(r,t){return r.init=t,this.expect(te.semi),r.test=this.type===te.semi?null:this.parseExpression(),this.expect(te.semi),r.update=this.type===te.parenR?null:this.parseExpression(),this.expect(te.parenR),r.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(r,"ForStatement")};zt.parseForIn=function(r,t){var n=this.type===te._in;return this.next(),t.type==="VariableDeclaration"&&t.declarations[0].init!=null&&(!n||this.options.ecmaVersion<8||this.strict||t.kind!=="var"||t.declarations[0].id.type!=="Identifier")&&this.raise(t.start,(n?"for-in":"for-of")+" loop variable declaration may not have an initializer"),r.left=t,r.right=n?this.parseExpression():this.parseMaybeAssign(),this.expect(te.parenR),r.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(r,n?"ForInStatement":"ForOfStatement")};zt.parseVar=function(r,t,n,s){for(r.declarations=[],r.kind=n;;){var i=this.startNode();if(this.parseVarId(i,n),this.eat(te.eq)?i.init=this.parseMaybeAssign(t):!s&&n==="const"&&!(this.type===te._in||this.options.ecmaVersion>=6&&this.isContextual("of"))?this.unexpected():!s&&i.id.type!=="Identifier"&&!(t&&(this.type===te._in||this.isContextual("of")))?this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value"):i.init=null,r.declarations.push(this.finishNode(i,"VariableDeclarator")),!this.eat(te.comma))break}return r};zt.parseVarId=function(r,t){r.id=this.parseBindingAtom(),this.checkLValPattern(r.id,t==="var"?tA:fl,!1)};var qy=1,lk=2,kW=4;zt.parseFunction=function(r,t,n,s,i){this.initFunction(r),(this.options.ecmaVersion>=9||this.options.ecmaVersion>=6&&!s)&&(this.type===te.star&&t&lk&&this.unexpected(),r.generator=this.eat(te.star)),this.options.ecmaVersion>=8&&(r.async=!!s),t&qy&&(r.id=t&kW&&this.type!==te.name?null:this.parseIdent(),r.id&&!(t&lk)&&this.checkLValSimple(r.id,this.strict||r.generator||r.async?this.treatFunctionsAsVar?tA:fl:_W));var a=this.yieldPos,o=this.awaitPos,u=this.awaitIdentPos;return this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(eA(r.async,r.generator)),t&qy||(r.id=this.type===te.name?this.parseIdent():null),this.parseFunctionParams(r),this.parseFunctionBody(r,n,!1,i),this.yieldPos=a,this.awaitPos=o,this.awaitIdentPos=u,this.finishNode(r,t&qy?"FunctionDeclaration":"FunctionExpression")};zt.parseFunctionParams=function(r){this.expect(te.parenL),r.params=this.parseBindingList(te.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams()};zt.parseClass=function(r,t){this.next();var n=this.strict;this.strict=!0,this.parseClassId(r,t),this.parseClassSuper(r);var s=this.enterClassBody(),i=this.startNode(),a=!1;for(i.body=[],this.expect(te.braceL);this.type!==te.braceR;){var o=this.parseClassElement(r.superClass!==null);o&&(i.body.push(o),o.type==="MethodDefinition"&&o.kind==="constructor"?(a&&this.raiseRecoverable(o.start,"Duplicate constructor in the same class"),a=!0):o.key&&o.key.type==="PrivateIdentifier"&&Bue(s,o)&&this.raiseRecoverable(o.key.start,"Identifier '#"+o.key.name+"' has already been declared"))}return this.strict=n,this.next(),r.body=this.finishNode(i,"ClassBody"),this.exitClassBody(),this.finishNode(r,t?"ClassDeclaration":"ClassExpression")};zt.parseClassElement=function(r){if(this.eat(te.semi))return null;var t=this.options.ecmaVersion,n=this.startNode(),s="",i=!1,a=!1,o="method",u=!1;if(this.eatContextual("static")){if(t>=13&&this.eat(te.braceL))return this.parseClassStaticBlock(n),n;this.isClassElementNameStart()||this.type===te.star?u=!0:s="static"}if(n.static=u,!s&&t>=8&&this.eatContextual("async")&&((this.isClassElementNameStart()||this.type===te.star)&&!this.canInsertSemicolon()?a=!0:s="async"),!s&&(t>=9||!a)&&this.eat(te.star)&&(i=!0),!s&&!a&&!i){var l=this.value;(this.eatContextual("get")||this.eatContextual("set"))&&(this.isClassElementNameStart()?o=l:s=l)}if(s?(n.computed=!1,n.key=this.startNodeAt(this.lastTokStart,this.lastTokStartLoc),n.key.name=s,this.finishNode(n.key,"Identifier")):this.parseClassElementName(n),t<13||this.type===te.parenL||o!=="method"||i||a){var c=!n.static&&h2(n,"constructor"),h=c&&r;c&&o!=="method"&&this.raise(n.key.start,"Constructor can't have get/set modifier"),n.kind=c?"constructor":o,this.parseClassMethod(n,i,a,h)}else this.parseClassField(n);return n};zt.isClassElementNameStart=function(){return this.type===te.name||this.type===te.privateId||this.type===te.num||this.type===te.string||this.type===te.bracketL||this.type.keyword};zt.parseClassElementName=function(r){this.type===te.privateId?(this.value==="constructor"&&this.raise(this.start,"Classes can't have an element named '#constructor'"),r.computed=!1,r.key=this.parsePrivateIdent()):this.parsePropertyName(r)};zt.parseClassMethod=function(r,t,n,s){var i=r.key;r.kind==="constructor"?(t&&this.raise(i.start,"Constructor can't be a generator"),n&&this.raise(i.start,"Constructor can't be an async method")):r.static&&h2(r,"prototype")&&this.raise(i.start,"Classes may not have a static property named prototype");var a=r.value=this.parseMethod(t,n,s);return r.kind==="get"&&a.params.length!==0&&this.raiseRecoverable(a.start,"getter should have no params"),r.kind==="set"&&a.params.length!==1&&this.raiseRecoverable(a.start,"setter should have exactly one param"),r.kind==="set"&&a.params[0].type==="RestElement"&&this.raiseRecoverable(a.params[0].start,"Setter cannot use rest params"),this.finishNode(r,"MethodDefinition")};zt.parseClassField=function(r){return h2(r,"constructor")?this.raise(r.key.start,"Classes can't have a field named 'constructor'"):r.static&&h2(r,"prototype")&&this.raise(r.key.start,"Classes can't have a static field named 'prototype'"),this.eat(te.eq)?(this.enterScope(fx|VS),r.value=this.parseMaybeAssign(),this.exitScope()):r.value=null,this.semicolon(),this.finishNode(r,"PropertyDefinition")};zt.parseClassStaticBlock=function(r){r.body=[];var t=this.labels;for(this.labels=[],this.enterScope($d|VS);this.type!==te.braceR;){var n=this.parseStatement(null);r.body.push(n)}return this.next(),this.exitScope(),this.labels=t,this.finishNode(r,"StaticBlock")};zt.parseClassId=function(r,t){this.type===te.name?(r.id=this.parseIdent(),t&&this.checkLValSimple(r.id,fl,!1)):(t===!0&&this.unexpected(),r.id=null)};zt.parseClassSuper=function(r){r.superClass=this.eat(te._extends)?this.parseExprSubscripts(null,!1):null};zt.enterClassBody=function(){var r={declared:Object.create(null),used:[]};return this.privateNameStack.push(r),r.declared};zt.exitClassBody=function(){var r=this.privateNameStack.pop(),t=r.declared,n=r.used;if(this.options.checkPrivateFields)for(var s=this.privateNameStack.length,i=s===0?null:this.privateNameStack[s-1],a=0;a<n.length;++a){var o=n[a];og(t,o.name)||(i?i.used.push(o):this.raiseRecoverable(o.start,"Private field '#"+o.name+"' must be declared in an enclosing class"))}};function Bue(r,t){var n=t.key.name,s=r[n],i="true";return t.type==="MethodDefinition"&&(t.kind==="get"||t.kind==="set")&&(i=(t.static?"s":"i")+t.kind),s==="iget"&&i==="iset"||s==="iset"&&i==="iget"||s==="sget"&&i==="sset"||s==="sset"&&i==="sget"?(r[n]="true",!1):s?!0:(r[n]=i,!1)}function h2(r,t){var n=r.computed,s=r.key;return!n&&(s.type==="Identifier"&&s.name===t||s.type==="Literal"&&s.value===t)}zt.parseExportAllDeclaration=function(r,t){return this.options.ecmaVersion>=11&&(this.eatContextual("as")?(r.exported=this.parseModuleExportName(),this.checkExport(t,r.exported,this.lastTokStart)):r.exported=null),this.expectContextual("from"),this.type!==te.string&&this.unexpected(),r.source=this.parseExprAtom(),this.options.ecmaVersion>=16&&(r.attributes=this.parseWithClause()),this.semicolon(),this.finishNode(r,"ExportAllDeclaration")};zt.parseExport=function(r,t){if(this.next(),this.eat(te.star))return this.parseExportAllDeclaration(r,t);if(this.eat(te._default))return this.checkExport(t,"default",this.lastTokStart),r.declaration=this.parseExportDefaultDeclaration(),this.finishNode(r,"ExportDefaultDeclaration");if(this.shouldParseExportStatement())r.declaration=this.parseExportDeclaration(r),r.declaration.type==="VariableDeclaration"?this.checkVariableExport(t,r.declaration.declarations):this.checkExport(t,r.declaration.id,r.declaration.id.start),r.specifiers=[],r.source=null,this.options.ecmaVersion>=16&&(r.attributes=[]);else{if(r.declaration=null,r.specifiers=this.parseExportSpecifiers(t),this.eatContextual("from"))this.type!==te.string&&this.unexpected(),r.source=this.parseExprAtom(),this.options.ecmaVersion>=16&&(r.attributes=this.parseWithClause());else{for(var n=0,s=r.specifiers;n<s.length;n+=1){var i=s[n];this.checkUnreserved(i.local),this.checkLocalExport(i.local),i.local.type==="Literal"&&this.raise(i.local.start,"A string literal cannot be used as an exported binding without `from`.")}r.source=null,this.options.ecmaVersion>=16&&(r.attributes=[])}this.semicolon()}return this.finishNode(r,"ExportNamedDeclaration")};zt.parseExportDeclaration=function(r){return this.parseStatement(null)};zt.parseExportDefaultDeclaration=function(){var r;if(this.type===te._function||(r=this.isAsyncFunction())){var t=this.startNode();return this.next(),r&&this.next(),this.parseFunction(t,qy|kW,!1,r)}else if(this.type===te._class){var n=this.startNode();return this.parseClass(n,"nullableID")}else{var s=this.parseMaybeAssign();return this.semicolon(),s}};zt.checkExport=function(r,t,n){r&&(typeof t!="string"&&(t=t.type==="Identifier"?t.name:t.value),og(r,t)&&this.raiseRecoverable(n,"Duplicate export '"+t+"'"),r[t]=!0)};zt.checkPatternExport=function(r,t){var n=t.type;if(n==="Identifier")this.checkExport(r,t,t.start);else if(n==="ObjectPattern")for(var s=0,i=t.properties;s<i.length;s+=1){var a=i[s];this.checkPatternExport(r,a)}else if(n==="ArrayPattern")for(var o=0,u=t.elements;o<u.length;o+=1){var l=u[o];l&&this.checkPatternExport(r,l)}else n==="Property"?this.checkPatternExport(r,t.value):n==="AssignmentPattern"?this.checkPatternExport(r,t.left):n==="RestElement"&&this.checkPatternExport(r,t.argument)};zt.checkVariableExport=function(r,t){if(r)for(var n=0,s=t;n<s.length;n+=1){var i=s[n];this.checkPatternExport(r,i.id)}};zt.shouldParseExportStatement=function(){return this.type.keyword==="var"||this.type.keyword==="const"||this.type.keyword==="class"||this.type.keyword==="function"||this.isLet()||this.isAsyncFunction()};zt.parseExportSpecifier=function(r){var t=this.startNode();return t.local=this.parseModuleExportName(),t.exported=this.eatContextual("as")?this.parseModuleExportName():t.local,this.checkExport(r,t.exported,t.exported.start),this.finishNode(t,"ExportSpecifier")};zt.parseExportSpecifiers=function(r){var t=[],n=!0;for(this.expect(te.braceL);!this.eat(te.braceR);){if(n)n=!1;else if(this.expect(te.comma),this.afterTrailingComma(te.braceR))break;t.push(this.parseExportSpecifier(r))}return t};zt.parseImport=function(r){return this.next(),this.type===te.string?(r.specifiers=Pue,r.source=this.parseExprAtom()):(r.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),r.source=this.type===te.string?this.parseExprAtom():this.unexpected()),this.options.ecmaVersion>=16&&(r.attributes=this.parseWithClause()),this.semicolon(),this.finishNode(r,"ImportDeclaration")};zt.parseImportSpecifier=function(){var r=this.startNode();return r.imported=this.parseModuleExportName(),this.eatContextual("as")?r.local=this.parseIdent():(this.checkUnreserved(r.imported),r.local=r.imported),this.checkLValSimple(r.local,fl),this.finishNode(r,"ImportSpecifier")};zt.parseImportDefaultSpecifier=function(){var r=this.startNode();return r.local=this.parseIdent(),this.checkLValSimple(r.local,fl),this.finishNode(r,"ImportDefaultSpecifier")};zt.parseImportNamespaceSpecifier=function(){var r=this.startNode();return this.next(),this.expectContextual("as"),r.local=this.parseIdent(),this.checkLValSimple(r.local,fl),this.finishNode(r,"ImportNamespaceSpecifier")};zt.parseImportSpecifiers=function(){var r=[],t=!0;if(this.type===te.name&&(r.push(this.parseImportDefaultSpecifier()),!this.eat(te.comma)))return r;if(this.type===te.star)return r.push(this.parseImportNamespaceSpecifier()),r;for(this.expect(te.braceL);!this.eat(te.braceR);){if(t)t=!1;else if(this.expect(te.comma),this.afterTrailingComma(te.braceR))break;r.push(this.parseImportSpecifier())}return r};zt.parseWithClause=function(){var r=[];if(!this.eat(te._with))return r;this.expect(te.braceL);for(var t={},n=!0;!this.eat(te.braceR);){if(n)n=!1;else if(this.expect(te.comma),this.afterTrailingComma(te.braceR))break;var s=this.parseImportAttribute(),i=s.key.type==="Identifier"?s.key.name:s.key.value;og(t,i)&&this.raiseRecoverable(s.key.start,"Duplicate attribute key '"+i+"'"),t[i]=!0,r.push(s)}return r};zt.parseImportAttribute=function(){var r=this.startNode();return r.key=this.type===te.string?this.parseExprAtom():this.parseIdent(this.options.allowReserved!=="never"),this.expect(te.colon),this.type!==te.string&&this.unexpected(),r.value=this.parseExprAtom(),this.finishNode(r,"ImportAttribute")};zt.parseModuleExportName=function(){if(this.options.ecmaVersion>=13&&this.type===te.string){var r=this.parseLiteral(this.value);return $ue.test(r.value)&&this.raise(r.start,"An export name cannot include a lone surrogate."),r}return this.parseIdent(!0)};zt.adaptDirectivePrologue=function(r){for(var t=0;t<r.length&&this.isDirectiveCandidate(r[t]);++t)r[t].directive=r[t].expression.raw.slice(1,-1)};zt.isDirectiveCandidate=function(r){return this.options.ecmaVersion>=5&&r.type==="ExpressionStatement"&&r.expression.type==="Literal"&&typeof r.expression.value=="string"&&(this.input[r.start]==='"'||this.input[r.start]==="'")};var eo=Cs.prototype;eo.toAssignable=function(r,t,n){if(this.options.ecmaVersion>=6&&r)switch(r.type){case"Identifier":this.inAsync&&r.name==="await"&&this.raise(r.start,"Cannot use 'await' as identifier inside an async function");break;case"ObjectPattern":case"ArrayPattern":case"AssignmentPattern":case"RestElement":break;case"ObjectExpression":r.type="ObjectPattern",n&&this.checkPatternErrors(n,!0);for(var s=0,i=r.properties;s<i.length;s+=1){var a=i[s];this.toAssignable(a,t),a.type==="RestElement"&&(a.argument.type==="ArrayPattern"||a.argument.type==="ObjectPattern")&&this.raise(a.argument.start,"Unexpected token")}break;case"Property":r.kind!=="init"&&this.raise(r.key.start,"Object pattern can't contain getter or setter"),this.toAssignable(r.value,t);break;case"ArrayExpression":r.type="ArrayPattern",n&&this.checkPatternErrors(n,!0),this.toAssignableList(r.elements,t);break;case"SpreadElement":r.type="RestElement",this.toAssignable(r.argument,t),r.argument.type==="AssignmentPattern"&&this.raise(r.argument.start,"Rest elements cannot have a default value");break;case"AssignmentExpression":r.operator!=="="&&this.raise(r.left.end,"Only '=' operator can be used for specifying default value."),r.type="AssignmentPattern",delete r.operator,this.toAssignable(r.left,t);break;case"ParenthesizedExpression":this.toAssignable(r.expression,t,n);break;case"ChainExpression":this.raiseRecoverable(r.start,"Optional chaining cannot appear in left-hand side");break;case"MemberExpression":if(!t)break;default:this.raise(r.start,"Assigning to rvalue")}else n&&this.checkPatternErrors(n,!0);return r};eo.toAssignableList=function(r,t){for(var n=r.length,s=0;s<n;s++){var i=r[s];i&&this.toAssignable(i,t)}if(n){var a=r[n-1];this.options.ecmaVersion===6&&t&&a&&a.type==="RestElement"&&a.argument.type!=="Identifier"&&this.unexpected(a.argument.start)}return r};eo.parseSpread=function(r){var t=this.startNode();return this.next(),t.argument=this.parseMaybeAssign(!1,r),this.finishNode(t,"SpreadElement")};eo.parseRestBinding=function(){var r=this.startNode();return this.next(),this.options.ecmaVersion===6&&this.type!==te.name&&this.unexpected(),r.argument=this.parseBindingAtom(),this.finishNode(r,"RestElement")};eo.parseBindingAtom=function(){if(this.options.ecmaVersion>=6)switch(this.type){case te.bracketL:var r=this.startNode();return this.next(),r.elements=this.parseBindingList(te.bracketR,!0,!0),this.finishNode(r,"ArrayPattern");case te.braceL:return this.parseObj(!0)}return this.parseIdent()};eo.parseBindingList=function(r,t,n,s){for(var i=[],a=!0;!this.eat(r);)if(a?a=!1:this.expect(te.comma),t&&this.type===te.comma)i.push(null);else{if(n&&this.afterTrailingComma(r))break;if(this.type===te.ellipsis){var o=this.parseRestBinding();this.parseBindingListItem(o),i.push(o),this.type===te.comma&&this.raiseRecoverable(this.start,"Comma is not permitted after the rest element"),this.expect(r);break}else i.push(this.parseAssignableListItem(s))}return i};eo.parseAssignableListItem=function(r){var t=this.parseMaybeDefault(this.start,this.startLoc);return this.parseBindingListItem(t),t};eo.parseBindingListItem=function(r){return r};eo.parseMaybeDefault=function(r,t,n){if(n=n||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(te.eq))return n;var s=this.startNodeAt(r,t);return s.left=n,s.right=this.parseMaybeAssign(),this.finishNode(s,"AssignmentPattern")};eo.checkLValSimple=function(r,t,n){t===void 0&&(t=c2);var s=t!==c2;switch(r.type){case"Identifier":this.strict&&this.reservedWordsStrictBind.test(r.name)&&this.raiseRecoverable(r.start,(s?"Binding ":"Assigning to ")+r.name+" in strict mode"),s&&(t===fl&&r.name==="let"&&this.raiseRecoverable(r.start,"let is disallowed as a lexically bound name"),n&&(og(n,r.name)&&this.raiseRecoverable(r.start,"Argument name clash"),n[r.name]=!0),t!==IW&&this.declareName(r.name,t,r.start));break;case"ChainExpression":this.raiseRecoverable(r.start,"Optional chaining cannot appear in left-hand side");break;case"MemberExpression":s&&this.raiseRecoverable(r.start,"Binding member expression");break;case"ParenthesizedExpression":return s&&this.raiseRecoverable(r.start,"Binding parenthesized expression"),this.checkLValSimple(r.expression,t,n);default:this.raise(r.start,(s?"Binding":"Assigning to")+" rvalue")}};eo.checkLValPattern=function(r,t,n){switch(t===void 0&&(t=c2),r.type){case"ObjectPattern":for(var s=0,i=r.properties;s<i.length;s+=1){var a=i[s];this.checkLValInnerPattern(a,t,n)}break;case"ArrayPattern":for(var o=0,u=r.elements;o<u.length;o+=1){var l=u[o];l&&this.checkLValInnerPattern(l,t,n)}break;default:this.checkLValSimple(r,t,n)}};eo.checkLValInnerPattern=function(r,t,n){switch(t===void 0&&(t=c2),r.type){case"Property":this.checkLValInnerPattern(r.value,t,n);break;case"AssignmentPattern":this.checkLValPattern(r.left,t,n);break;case"RestElement":this.checkLValPattern(r.argument,t,n);break;default:this.checkLValPattern(r,t,n)}};var ho=function(t,n,s,i,a){this.token=t,this.isExpr=!!n,this.preserveSpace=!!s,this.override=i,this.generator=!!a},$n={b_stat:new ho("{",!1),b_expr:new ho("{",!0),b_tmpl:new ho("${",!1),p_stat:new ho("(",!1),p_expr:new ho("(",!0),q_tmpl:new ho("`",!0,!0,function(r){return r.tryReadTemplateToken()}),f_stat:new ho("function",!1),f_expr:new ho("function",!0),f_expr_gen:new ho("function",!0,!1,null,!0),f_gen:new ho("function",!1,!1,null,!0)},lg=Cs.prototype;lg.initialContext=function(){return[$n.b_stat]};lg.curContext=function(){return this.context[this.context.length-1]};lg.braceIsBlock=function(r){var t=this.curContext();return t===$n.f_expr||t===$n.f_stat?!0:r===te.colon&&(t===$n.b_stat||t===$n.b_expr)?!t.isExpr:r===te._return||r===te.name&&this.exprAllowed?Qa.test(this.input.slice(this.lastTokEnd,this.start)):r===te._else||r===te.semi||r===te.eof||r===te.parenR||r===te.arrow?!0:r===te.braceL?t===$n.b_stat:r===te._var||r===te._const||r===te.name?!1:!this.exprAllowed};lg.inGeneratorContext=function(){for(var r=this.context.length-1;r>=1;r--){var t=this.context[r];if(t.token==="function")return t.generator}return!1};lg.updateContext=function(r){var t,n=this.type;n.keyword&&r===te.dot?this.exprAllowed=!1:(t=n.updateContext)?t.call(this,r):this.exprAllowed=n.beforeExpr};lg.overrideContext=function(r){this.curContext()!==r&&(this.context[this.context.length-1]=r)};te.parenR.updateContext=te.braceR.updateContext=function(){if(this.context.length===1){this.exprAllowed=!0;return}var r=this.context.pop();r===$n.b_stat&&this.curContext().token==="function"&&(r=this.context.pop()),this.exprAllowed=!r.isExpr};te.braceL.updateContext=function(r){this.context.push(this.braceIsBlock(r)?$n.b_stat:$n.b_expr),this.exprAllowed=!0};te.dollarBraceL.updateContext=function(){this.context.push($n.b_tmpl),this.exprAllowed=!0};te.parenL.updateContext=function(r){var t=r===te._if||r===te._for||r===te._with||r===te._while;this.context.push(t?$n.p_stat:$n.p_expr),this.exprAllowed=!0};te.incDec.updateContext=function(){};te._function.updateContext=te._class.updateContext=function(r){r.beforeExpr&&r!==te._else&&!(r===te.semi&&this.curContext()!==$n.p_stat)&&!(r===te._return&&Qa.test(this.input.slice(this.lastTokEnd,this.start)))&&!((r===te.colon||r===te.braceL)&&this.curContext()===$n.b_stat)?this.context.push($n.f_expr):this.context.push($n.f_stat),this.exprAllowed=!1};te.colon.updateContext=function(){this.curContext().token==="function"&&this.context.pop(),this.exprAllowed=!0};te.backQuote.updateContext=function(){this.curContext()===$n.q_tmpl?this.context.pop():this.context.push($n.q_tmpl),this.exprAllowed=!1};te.star.updateContext=function(r){if(r===te._function){var t=this.context.length-1;this.context[t]===$n.f_expr?this.context[t]=$n.f_expr_gen:this.context[t]=$n.f_gen}this.exprAllowed=!0};te.name.updateContext=function(r){var t=!1;this.options.ecmaVersion>=6&&r!==te.dot&&(this.value==="of"&&!this.exprAllowed||this.value==="yield"&&this.inGeneratorContext())&&(t=!0),this.exprAllowed=t};var sr=Cs.prototype;sr.checkPropClash=function(r,t,n){if(!(this.options.ecmaVersion>=9&&r.type==="SpreadElement")&&!(this.options.ecmaVersion>=6&&(r.computed||r.method||r.shorthand))){var s=r.key,i;switch(s.type){case"Identifier":i=s.name;break;case"Literal":i=String(s.value);break;default:return}var a=r.kind;if(this.options.ecmaVersion>=6){i==="__proto__"&&a==="init"&&(t.proto&&(n?n.doubleProto<0&&(n.doubleProto=s.start):this.raiseRecoverable(s.start,"Redefinition of __proto__ property")),t.proto=!0);return}i="$"+i;var o=t[i];if(o){var u;a==="init"?u=this.strict&&o.init||o.get||o.set:u=o.init||o[a],u&&this.raiseRecoverable(s.start,"Redefinition of property")}else o=t[i]={init:!1,get:!1,set:!1};o[a]=!0}};sr.parseExpression=function(r,t){var n=this.start,s=this.startLoc,i=this.parseMaybeAssign(r,t);if(this.type===te.comma){var a=this.startNodeAt(n,s);for(a.expressions=[i];this.eat(te.comma);)a.expressions.push(this.parseMaybeAssign(r,t));return this.finishNode(a,"SequenceExpression")}return i};sr.parseMaybeAssign=function(r,t,n){if(this.isContextual("yield")){if(this.inGenerator)return this.parseYield(r);this.exprAllowed=!1}var s=!1,i=-1,a=-1,o=-1;t?(i=t.parenthesizedAssign,a=t.trailingComma,o=t.doubleProto,t.parenthesizedAssign=t.trailingComma=-1):(t=new US,s=!0);var u=this.start,l=this.startLoc;(this.type===te.parenL||this.type===te.name)&&(this.potentialArrowAt=this.start,this.potentialArrowInForAwait=r==="await");var c=this.parseMaybeConditional(r,t);if(n&&(c=n.call(this,c,u,l)),this.type.isAssign){var h=this.startNodeAt(u,l);return h.operator=this.value,this.type===te.eq&&(c=this.toAssignable(c,!1,t)),s||(t.parenthesizedAssign=t.trailingComma=t.doubleProto=-1),t.shorthandAssign>=c.start&&(t.shorthandAssign=-1),this.type===te.eq?this.checkLValPattern(c):this.checkLValSimple(c),h.left=c,this.next(),h.right=this.parseMaybeAssign(r),o>-1&&(t.doubleProto=o),this.finishNode(h,"AssignmentExpression")}else s&&this.checkExpressionErrors(t,!0);return i>-1&&(t.parenthesizedAssign=i),a>-1&&(t.trailingComma=a),c};sr.parseMaybeConditional=function(r,t){var n=this.start,s=this.startLoc,i=this.parseExprOps(r,t);if(this.checkExpressionErrors(t))return i;if(this.eat(te.question)){var a=this.startNodeAt(n,s);return a.test=i,a.consequent=this.parseMaybeAssign(),this.expect(te.colon),a.alternate=this.parseMaybeAssign(r),this.finishNode(a,"ConditionalExpression")}return i};sr.parseExprOps=function(r,t){var n=this.start,s=this.startLoc,i=this.parseMaybeUnary(t,!1,!1,r);return this.checkExpressionErrors(t)||i.start===n&&i.type==="ArrowFunctionExpression"?i:this.parseExprOp(i,n,s,-1,r)};sr.parseExprOp=function(r,t,n,s,i){var a=this.type.binop;if(a!=null&&(!i||this.type!==te._in)&&a>s){var o=this.type===te.logicalOR||this.type===te.logicalAND,u=this.type===te.coalesce;u&&(a=te.logicalAND.binop);var l=this.value;this.next();var c=this.start,h=this.startLoc,d=this.parseExprOp(this.parseMaybeUnary(null,!1,!1,i),c,h,a,i),p=this.buildBinary(t,n,r,d,l,o||u);return(o&&this.type===te.coalesce||u&&(this.type===te.logicalOR||this.type===te.logicalAND))&&this.raiseRecoverable(this.start,"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"),this.parseExprOp(p,t,n,s,i)}return r};sr.buildBinary=function(r,t,n,s,i,a){s.type==="PrivateIdentifier"&&this.raise(s.start,"Private identifier can only be left side of binary expression");var o=this.startNodeAt(r,t);return o.left=n,o.operator=i,o.right=s,this.finishNode(o,a?"LogicalExpression":"BinaryExpression")};sr.parseMaybeUnary=function(r,t,n,s){var i=this.start,a=this.startLoc,o;if(this.isContextual("await")&&this.canAwait)o=this.parseAwait(s),t=!0;else if(this.type.prefix){var u=this.startNode(),l=this.type===te.incDec;u.operator=this.value,u.prefix=!0,this.next(),u.argument=this.parseMaybeUnary(null,!0,l,s),this.checkExpressionErrors(r,!0),l?this.checkLValSimple(u.argument):this.strict&&u.operator==="delete"&&NW(u.argument)?this.raiseRecoverable(u.start,"Deleting local variable in strict mode"):u.operator==="delete"&&ck(u.argument)?this.raiseRecoverable(u.start,"Private fields can not be deleted"):t=!0,o=this.finishNode(u,l?"UpdateExpression":"UnaryExpression")}else if(!t&&this.type===te.privateId)(s||this.privateNameStack.length===0)&&this.options.checkPrivateFields&&this.unexpected(),o=this.parsePrivateIdent(),this.type!==te._in&&this.unexpected();else{if(o=this.parseExprSubscripts(r,s),this.checkExpressionErrors(r))return o;for(;this.type.postfix&&!this.canInsertSemicolon();){var c=this.startNodeAt(i,a);c.operator=this.value,c.prefix=!1,c.argument=o,this.checkLValSimple(o),this.next(),o=this.finishNode(c,"UpdateExpression")}}if(!n&&this.eat(te.starstar))if(t)this.unexpected(this.lastTokStart);else return this.buildBinary(i,a,o,this.parseMaybeUnary(null,!1,!1,s),"**",!1);else return o};function NW(r){return r.type==="Identifier"||r.type==="ParenthesizedExpression"&&NW(r.expression)}function ck(r){return r.type==="MemberExpression"&&r.property.type==="PrivateIdentifier"||r.type==="ChainExpression"&&ck(r.expression)||r.type==="ParenthesizedExpression"&&ck(r.expression)}sr.parseExprSubscripts=function(r,t){var n=this.start,s=this.startLoc,i=this.parseExprAtom(r,t);if(i.type==="ArrowFunctionExpression"&&this.input.slice(this.lastTokStart,this.lastTokEnd)!==")")return i;var a=this.parseSubscripts(i,n,s,!1,t);return r&&a.type==="MemberExpression"&&(r.parenthesizedAssign>=a.start&&(r.parenthesizedAssign=-1),r.parenthesizedBind>=a.start&&(r.parenthesizedBind=-1),r.trailingComma>=a.start&&(r.trailingComma=-1)),a};sr.parseSubscripts=function(r,t,n,s,i){for(var a=this.options.ecmaVersion>=8&&r.type==="Identifier"&&r.name==="async"&&this.lastTokEnd===r.end&&!this.canInsertSemicolon()&&r.end-r.start===5&&this.potentialArrowAt===r.start,o=!1;;){var u=this.parseSubscript(r,t,n,s,a,o,i);if(u.optional&&(o=!0),u===r||u.type==="ArrowFunctionExpression"){if(o){var l=this.startNodeAt(t,n);l.expression=u,u=this.finishNode(l,"ChainExpression")}return u}r=u}};sr.shouldParseAsyncArrow=function(){return!this.canInsertSemicolon()&&this.eat(te.arrow)};sr.parseSubscriptAsyncArrow=function(r,t,n,s){return this.parseArrowExpression(this.startNodeAt(r,t),n,!0,s)};sr.parseSubscript=function(r,t,n,s,i,a,o){var u=this.options.ecmaVersion>=11,l=u&&this.eat(te.questionDot);s&&l&&this.raise(this.lastTokStart,"Optional chaining cannot appear in the callee of new expressions");var c=this.eat(te.bracketL);if(c||l&&this.type!==te.parenL&&this.type!==te.backQuote||this.eat(te.dot)){var h=this.startNodeAt(t,n);h.object=r,c?(h.property=this.parseExpression(),this.expect(te.bracketR)):this.type===te.privateId&&r.type!=="Super"?h.property=this.parsePrivateIdent():h.property=this.parseIdent(this.options.allowReserved!=="never"),h.computed=!!c,u&&(h.optional=l),r=this.finishNode(h,"MemberExpression")}else if(!s&&this.eat(te.parenL)){var d=new US,p=this.yieldPos,f=this.awaitPos,m=this.awaitIdentPos;this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0;var g=this.parseExprList(te.parenR,this.options.ecmaVersion>=8,!1,d);if(i&&!l&&this.shouldParseAsyncArrow())return this.checkPatternErrors(d,!1),this.checkYieldAwaitInDefaultParams(),this.awaitIdentPos>0&&this.raise(this.awaitIdentPos,"Cannot use 'await' as identifier inside an async function"),this.yieldPos=p,this.awaitPos=f,this.awaitIdentPos=m,this.parseSubscriptAsyncArrow(t,n,g,o);this.checkExpressionErrors(d,!0),this.yieldPos=p||this.yieldPos,this.awaitPos=f||this.awaitPos,this.awaitIdentPos=m||this.awaitIdentPos;var y=this.startNodeAt(t,n);y.callee=r,y.arguments=g,u&&(y.optional=l),r=this.finishNode(y,"CallExpression")}else if(this.type===te.backQuote){(l||a)&&this.raise(this.start,"Optional chaining cannot appear in the tag of tagged template expressions");var b=this.startNodeAt(t,n);b.tag=r,b.quasi=this.parseTemplate({isTagged:!0}),r=this.finishNode(b,"TaggedTemplateExpression")}return r};sr.parseExprAtom=function(r,t,n){this.type===te.slash&&this.readRegexp();var s,i=this.potentialArrowAt===this.start;switch(this.type){case te._super:return this.allowSuper||this.raise(this.start,"'super' keyword outside a method"),s=this.startNode(),this.next(),this.type===te.parenL&&!this.allowDirectSuper&&this.raise(s.start,"super() call outside constructor of a subclass"),this.type!==te.dot&&this.type!==te.bracketL&&this.type!==te.parenL&&this.unexpected(),this.finishNode(s,"Super");case te._this:return s=this.startNode(),this.next(),this.finishNode(s,"ThisExpression");case te.name:var a=this.start,o=this.startLoc,u=this.containsEsc,l=this.parseIdent(!1);if(this.options.ecmaVersion>=8&&!u&&l.name==="async"&&!this.canInsertSemicolon()&&this.eat(te._function))return this.overrideContext($n.f_expr),this.parseFunction(this.startNodeAt(a,o),0,!1,!0,t);if(i&&!this.canInsertSemicolon()){if(this.eat(te.arrow))return this.parseArrowExpression(this.startNodeAt(a,o),[l],!1,t);if(this.options.ecmaVersion>=8&&l.name==="async"&&this.type===te.name&&!u&&(!this.potentialArrowInForAwait||this.value!=="of"||this.containsEsc))return l=this.parseIdent(!1),(this.canInsertSemicolon()||!this.eat(te.arrow))&&this.unexpected(),this.parseArrowExpression(this.startNodeAt(a,o),[l],!0,t)}return l;case te.regexp:var c=this.value;return s=this.parseLiteral(c.value),s.regex={pattern:c.pattern,flags:c.flags},s;case te.num:case te.string:return this.parseLiteral(this.value);case te._null:case te._true:case te._false:return s=this.startNode(),s.value=this.type===te._null?null:this.type===te._true,s.raw=this.type.keyword,this.next(),this.finishNode(s,"Literal");case te.parenL:var h=this.start,d=this.parseParenAndDistinguishExpression(i,t);return r&&(r.parenthesizedAssign<0&&!this.isSimpleAssignTarget(d)&&(r.parenthesizedAssign=h),r.parenthesizedBind<0&&(r.parenthesizedBind=h)),d;case te.bracketL:return s=this.startNode(),this.next(),s.elements=this.parseExprList(te.bracketR,!0,!0,r),this.finishNode(s,"ArrayExpression");case te.braceL:return this.overrideContext($n.b_expr),this.parseObj(!1,r);case te._function:return s=this.startNode(),this.next(),this.parseFunction(s,0);case te._class:return this.parseClass(this.startNode(),!1);case te._new:return this.parseNew();case te.backQuote:return this.parseTemplate();case te._import:return this.options.ecmaVersion>=11?this.parseExprImport(n):this.unexpected();default:return this.parseExprAtomDefault()}};sr.parseExprAtomDefault=function(){this.unexpected()};sr.parseExprImport=function(r){var t=this.startNode();if(this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword import"),this.next(),this.type===te.parenL&&!r)return this.parseDynamicImport(t);if(this.type===te.dot){var n=this.startNodeAt(t.start,t.loc&&t.loc.start);return n.name="import",t.meta=this.finishNode(n,"Identifier"),this.parseImportMeta(t)}else this.unexpected()};sr.parseDynamicImport=function(r){if(this.next(),r.source=this.parseMaybeAssign(),this.options.ecmaVersion>=16)this.eat(te.parenR)?r.options=null:(this.expect(te.comma),this.afterTrailingComma(te.parenR)?r.options=null:(r.options=this.parseMaybeAssign(),this.eat(te.parenR)||(this.expect(te.comma),this.afterTrailingComma(te.parenR)||this.unexpected())));else if(!this.eat(te.parenR)){var t=this.start;this.eat(te.comma)&&this.eat(te.parenR)?this.raiseRecoverable(t,"Trailing comma is not allowed in import()"):this.unexpected(t)}return this.finishNode(r,"ImportExpression")};sr.parseImportMeta=function(r){this.next();var t=this.containsEsc;return r.property=this.parseIdent(!0),r.property.name!=="meta"&&this.raiseRecoverable(r.property.start,"The only valid meta property for import is 'import.meta'"),t&&this.raiseRecoverable(r.start,"'import.meta' must not contain escaped characters"),this.options.sourceType!=="module"&&!this.options.allowImportExportEverywhere&&this.raiseRecoverable(r.start,"Cannot use 'import.meta' outside a module"),this.finishNode(r,"MetaProperty")};sr.parseLiteral=function(r){var t=this.startNode();return t.value=r,t.raw=this.input.slice(this.start,this.end),t.raw.charCodeAt(t.raw.length-1)===110&&(t.bigint=t.raw.slice(0,-1).replace(/_/g,"")),this.next(),this.finishNode(t,"Literal")};sr.parseParenExpression=function(){this.expect(te.parenL);var r=this.parseExpression();return this.expect(te.parenR),r};sr.shouldParseArrow=function(r){return!this.canInsertSemicolon()};sr.parseParenAndDistinguishExpression=function(r,t){var n=this.start,s=this.startLoc,i,a=this.options.ecmaVersion>=8;if(this.options.ecmaVersion>=6){this.next();var o=this.start,u=this.startLoc,l=[],c=!0,h=!1,d=new US,p=this.yieldPos,f=this.awaitPos,m;for(this.yieldPos=0,this.awaitPos=0;this.type!==te.parenR;)if(c?c=!1:this.expect(te.comma),a&&this.afterTrailingComma(te.parenR,!0)){h=!0;break}else if(this.type===te.ellipsis){m=this.start,l.push(this.parseParenItem(this.parseRestBinding())),this.type===te.comma&&this.raiseRecoverable(this.start,"Comma is not permitted after the rest element");break}else l.push(this.parseMaybeAssign(!1,d,this.parseParenItem));var g=this.lastTokEnd,y=this.lastTokEndLoc;if(this.expect(te.parenR),r&&this.shouldParseArrow(l)&&this.eat(te.arrow))return this.checkPatternErrors(d,!1),this.checkYieldAwaitInDefaultParams(),this.yieldPos=p,this.awaitPos=f,this.parseParenArrowList(n,s,l,t);(!l.length||h)&&this.unexpected(this.lastTokStart),m&&this.unexpected(m),this.checkExpressionErrors(d,!0),this.yieldPos=p||this.yieldPos,this.awaitPos=f||this.awaitPos,l.length>1?(i=this.startNodeAt(o,u),i.expressions=l,this.finishNodeAt(i,"SequenceExpression",g,y)):i=l[0]}else i=this.parseParenExpression();if(this.options.preserveParens){var b=this.startNodeAt(n,s);return b.expression=i,this.finishNode(b,"ParenthesizedExpression")}else return i};sr.parseParenItem=function(r){return r};sr.parseParenArrowList=function(r,t,n,s){return this.parseArrowExpression(this.startNodeAt(r,t),n,!1,s)};var Vue=[];sr.parseNew=function(){this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword new");var r=this.startNode();if(this.next(),this.options.ecmaVersion>=6&&this.type===te.dot){var t=this.startNodeAt(r.start,r.loc&&r.loc.start);t.name="new",r.meta=this.finishNode(t,"Identifier"),this.next();var n=this.containsEsc;return r.property=this.parseIdent(!0),r.property.name!=="target"&&this.raiseRecoverable(r.property.start,"The only valid meta property for new is 'new.target'"),n&&this.raiseRecoverable(r.start,"'new.target' must not contain escaped characters"),this.allowNewDotTarget||this.raiseRecoverable(r.start,"'new.target' can only be used in functions and class static block"),this.finishNode(r,"MetaProperty")}var s=this.start,i=this.startLoc;return r.callee=this.parseSubscripts(this.parseExprAtom(null,!1,!0),s,i,!0,!1),this.eat(te.parenL)?r.arguments=this.parseExprList(te.parenR,this.options.ecmaVersion>=8,!1):r.arguments=Vue,this.finishNode(r,"NewExpression")};sr.parseTemplateElement=function(r){var t=r.isTagged,n=this.startNode();return this.type===te.invalidTemplate?(t||this.raiseRecoverable(this.start,"Bad escape sequence in untagged template literal"),n.value={raw:this.value.replace(/\r\n?/g,`
`),cooked:null}):n.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,`
`),cooked:this.value},this.next(),n.tail=this.type===te.backQuote,this.finishNode(n,"TemplateElement")};sr.parseTemplate=function(r){r===void 0&&(r={});var t=r.isTagged;t===void 0&&(t=!1);var n=this.startNode();this.next(),n.expressions=[];var s=this.parseTemplateElement({isTagged:t});for(n.quasis=[s];!s.tail;)this.type===te.eof&&this.raise(this.pos,"Unterminated template literal"),this.expect(te.dollarBraceL),n.expressions.push(this.parseExpression()),this.expect(te.braceR),n.quasis.push(s=this.parseTemplateElement({isTagged:t}));return this.next(),this.finishNode(n,"TemplateLiteral")};sr.isAsyncProp=function(r){return!r.computed&&r.key.type==="Identifier"&&r.key.name==="async"&&(this.type===te.name||this.type===te.num||this.type===te.string||this.type===te.bracketL||this.type.keyword||this.options.ecmaVersion>=9&&this.type===te.star)&&!Qa.test(this.input.slice(this.lastTokEnd,this.start))};sr.parseObj=function(r,t){var n=this.startNode(),s=!0,i={};for(n.properties=[],this.next();!this.eat(te.braceR);){if(s)s=!1;else if(this.expect(te.comma),this.options.ecmaVersion>=5&&this.afterTrailingComma(te.braceR))break;var a=this.parseProperty(r,t);r||this.checkPropClash(a,i,t),n.properties.push(a)}return this.finishNode(n,r?"ObjectPattern":"ObjectExpression")};sr.parseProperty=function(r,t){var n=this.startNode(),s,i,a,o;if(this.options.ecmaVersion>=9&&this.eat(te.ellipsis))return r?(n.argument=this.parseIdent(!1),this.type===te.comma&&this.raiseRecoverable(this.start,"Comma is not permitted after the rest element"),this.finishNode(n,"RestElement")):(n.argument=this.parseMaybeAssign(!1,t),this.type===te.comma&&t&&t.trailingComma<0&&(t.trailingComma=this.start),this.finishNode(n,"SpreadElement"));this.options.ecmaVersion>=6&&(n.method=!1,n.shorthand=!1,(r||t)&&(a=this.start,o=this.startLoc),r||(s=this.eat(te.star)));var u=this.containsEsc;return this.parsePropertyName(n),!r&&!u&&this.options.ecmaVersion>=8&&!s&&this.isAsyncProp(n)?(i=!0,s=this.options.ecmaVersion>=9&&this.eat(te.star),this.parsePropertyName(n)):i=!1,this.parsePropertyValue(n,r,s,i,a,o,t,u),this.finishNode(n,"Property")};sr.parseGetterSetter=function(r){var t=r.key.name;this.parsePropertyName(r),r.value=this.parseMethod(!1),r.kind=t;var n=r.kind==="get"?0:1;if(r.value.params.length!==n){var s=r.value.start;r.kind==="get"?this.raiseRecoverable(s,"getter should have no params"):this.raiseRecoverable(s,"setter should have exactly one param")}else r.kind==="set"&&r.value.params[0].type==="RestElement"&&this.raiseRecoverable(r.value.params[0].start,"Setter cannot use rest params")};sr.parsePropertyValue=function(r,t,n,s,i,a,o,u){(n||s)&&this.type===te.colon&&this.unexpected(),this.eat(te.colon)?(r.value=t?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(!1,o),r.kind="init"):this.options.ecmaVersion>=6&&this.type===te.parenL?(t&&this.unexpected(),r.method=!0,r.value=this.parseMethod(n,s),r.kind="init"):!t&&!u&&this.options.ecmaVersion>=5&&!r.computed&&r.key.type==="Identifier"&&(r.key.name==="get"||r.key.name==="set")&&this.type!==te.comma&&this.type!==te.braceR&&this.type!==te.eq?((n||s)&&this.unexpected(),this.parseGetterSetter(r)):this.options.ecmaVersion>=6&&!r.computed&&r.key.type==="Identifier"?((n||s)&&this.unexpected(),this.checkUnreserved(r.key),r.key.name==="await"&&!this.awaitIdentPos&&(this.awaitIdentPos=i),t?r.value=this.parseMaybeDefault(i,a,this.copyNode(r.key)):this.type===te.eq&&o?(o.shorthandAssign<0&&(o.shorthandAssign=this.start),r.value=this.parseMaybeDefault(i,a,this.copyNode(r.key))):r.value=this.copyNode(r.key),r.kind="init",r.shorthand=!0):this.unexpected()};sr.parsePropertyName=function(r){if(this.options.ecmaVersion>=6){if(this.eat(te.bracketL))return r.computed=!0,r.key=this.parseMaybeAssign(),this.expect(te.bracketR),r.key;r.computed=!1}return r.key=this.type===te.num||this.type===te.string?this.parseExprAtom():this.parseIdent(this.options.allowReserved!=="never")};sr.initFunction=function(r){r.id=null,this.options.ecmaVersion>=6&&(r.generator=r.expression=!1),this.options.ecmaVersion>=8&&(r.async=!1)};sr.parseMethod=function(r,t,n){var s=this.startNode(),i=this.yieldPos,a=this.awaitPos,o=this.awaitIdentPos;return this.initFunction(s),this.options.ecmaVersion>=6&&(s.generator=r),this.options.ecmaVersion>=8&&(s.async=!!t),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(eA(t,s.generator)|VS|(n?CW:0)),this.expect(te.parenL),s.params=this.parseBindingList(te.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams(),this.parseFunctionBody(s,!1,!0,!1),this.yieldPos=i,this.awaitPos=a,this.awaitIdentPos=o,this.finishNode(s,"FunctionExpression")};sr.parseArrowExpression=function(r,t,n,s){var i=this.yieldPos,a=this.awaitPos,o=this.awaitIdentPos;return this.enterScope(eA(n,!1)|QT),this.initFunction(r),this.options.ecmaVersion>=8&&(r.async=!!n),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,r.params=this.toAssignableList(t,!0),this.parseFunctionBody(r,!0,!1,s),this.yieldPos=i,this.awaitPos=a,this.awaitIdentPos=o,this.finishNode(r,"ArrowFunctionExpression")};sr.parseFunctionBody=function(r,t,n,s){var i=t&&this.type!==te.braceL,a=this.strict,o=!1;if(i)r.body=this.parseMaybeAssign(s),r.expression=!0,this.checkParams(r,!1);else{var u=this.options.ecmaVersion>=7&&!this.isSimpleParamList(r.params);(!a||u)&&(o=this.strictDirective(this.end),o&&u&&this.raiseRecoverable(r.start,"Illegal 'use strict' directive in function with non-simple parameter list"));var l=this.labels;this.labels=[],o&&(this.strict=!0),this.checkParams(r,!a&&!o&&!t&&!n&&this.isSimpleParamList(r.params)),this.strict&&r.id&&this.checkLValSimple(r.id,IW),r.body=this.parseBlock(!1,void 0,o&&!a),r.expression=!1,this.adaptDirectivePrologue(r.body.body),this.labels=l}this.exitScope()};sr.isSimpleParamList=function(r){for(var t=0,n=r;t<n.length;t+=1){var s=n[t];if(s.type!=="Identifier")return!1}return!0};sr.checkParams=function(r,t){for(var n=Object.create(null),s=0,i=r.params;s<i.length;s+=1){var a=i[s];this.checkLValInnerPattern(a,tA,t?null:n)}};sr.parseExprList=function(r,t,n,s){for(var i=[],a=!0;!this.eat(r);){if(a)a=!1;else if(this.expect(te.comma),t&&this.afterTrailingComma(r))break;var o=void 0;n&&this.type===te.comma?o=null:this.type===te.ellipsis?(o=this.parseSpread(s),s&&this.type===te.comma&&s.trailingComma<0&&(s.trailingComma=this.start)):o=this.parseMaybeAssign(!1,s),i.push(o)}return i};sr.checkUnreserved=function(r){var t=r.start,n=r.end,s=r.name;if(this.inGenerator&&s==="yield"&&this.raiseRecoverable(t,"Cannot use 'yield' as identifier inside a generator"),this.inAsync&&s==="await"&&this.raiseRecoverable(t,"Cannot use 'await' as identifier inside an async function"),!(this.currentThisScope().flags&zS)&&s==="arguments"&&this.raiseRecoverable(t,"Cannot use 'arguments' in class field initializer"),this.inClassStaticBlock&&(s==="arguments"||s==="await")&&this.raise(t,"Cannot use "+s+" in class static initialization block"),this.keywords.test(s)&&this.raise(t,"Unexpected keyword '"+s+"'"),!(this.options.ecmaVersion<6&&this.input.slice(t,n).indexOf("\\")!==-1)){var i=this.strict?this.reservedWordsStrict:this.reservedWords;i.test(s)&&(!this.inAsync&&s==="await"&&this.raiseRecoverable(t,"Cannot use keyword 'await' outside an async function"),this.raiseRecoverable(t,"The keyword '"+s+"' is reserved"))}};sr.parseIdent=function(r){var t=this.parseIdentNode();return this.next(!!r),this.finishNode(t,"Identifier"),r||(this.checkUnreserved(t),t.name==="await"&&!this.awaitIdentPos&&(this.awaitIdentPos=t.start)),t};sr.parseIdentNode=function(){var r=this.startNode();return this.type===te.name?r.name=this.value:this.type.keyword?(r.name=this.type.keyword,(r.name==="class"||r.name==="function")&&(this.lastTokEnd!==this.lastTokStart+1||this.input.charCodeAt(this.lastTokStart)!==46)&&this.context.pop(),this.type=te.name):this.unexpected(),r};sr.parsePrivateIdent=function(){var r=this.startNode();return this.type===te.privateId?r.name=this.value:this.unexpected(),this.next(),this.finishNode(r,"PrivateIdentifier"),this.options.checkPrivateFields&&(this.privateNameStack.length===0?this.raise(r.start,"Private field '#"+r.name+"' must be declared in an enclosing class"):this.privateNameStack[this.privateNameStack.length-1].used.push(r)),r};sr.parseYield=function(r){this.yieldPos||(this.yieldPos=this.start);var t=this.startNode();return this.next(),this.type===te.semi||this.canInsertSemicolon()||this.type!==te.star&&!this.type.startsExpr?(t.delegate=!1,t.argument=null):(t.delegate=this.eat(te.star),t.argument=this.parseMaybeAssign(r)),this.finishNode(t,"YieldExpression")};sr.parseAwait=function(r){this.awaitPos||(this.awaitPos=this.start);var t=this.startNode();return this.next(),t.argument=this.parseMaybeUnary(null,!0,!1,r),this.finishNode(t,"AwaitExpression")};var d2=Cs.prototype;d2.raise=function(r,t){var n=vW(this.input,r);t+=" ("+n.line+":"+n.column+")",this.sourceFile&&(t+=" in "+this.sourceFile);var s=new SyntaxError(t);throw s.pos=r,s.loc=n,s.raisedAt=this.pos,s};d2.raiseRecoverable=d2.raise;d2.curPosition=function(){if(this.options.locations)return new vb(this.curLine,this.pos-this.lineStart)};var Ac=Cs.prototype,zue=function(t){this.flags=t,this.var=[],this.lexical=[],this.functions=[]};Ac.enterScope=function(r){this.scopeStack.push(new zue(r))};Ac.exitScope=function(){this.scopeStack.pop()};Ac.treatFunctionsAsVarInScope=function(r){return r.flags&ug||!this.inModule&&r.flags&wb};Ac.declareName=function(r,t,n){var s=!1;if(t===fl){var i=this.currentScope();s=i.lexical.indexOf(r)>-1||i.functions.indexOf(r)>-1||i.var.indexOf(r)>-1,i.lexical.push(r),this.inModule&&i.flags&wb&&delete this.undefinedExports[r]}else if(t===EW){var a=this.currentScope();a.lexical.push(r)}else if(t===_W){var o=this.currentScope();this.treatFunctionsAsVar?s=o.lexical.indexOf(r)>-1:s=o.lexical.indexOf(r)>-1||o.var.indexOf(r)>-1,o.functions.push(r)}else for(var u=this.scopeStack.length-1;u>=0;--u){var l=this.scopeStack[u];if(l.lexical.indexOf(r)>-1&&!(l.flags&SW&&l.lexical[0]===r)||!this.treatFunctionsAsVarInScope(l)&&l.functions.indexOf(r)>-1){s=!0;break}if(l.var.push(r),this.inModule&&l.flags&wb&&delete this.undefinedExports[r],l.flags&zS)break}s&&this.raiseRecoverable(n,"Identifier '"+r+"' has already been declared")};Ac.checkLocalExport=function(r){this.scopeStack[0].lexical.indexOf(r.name)===-1&&this.scopeStack[0].var.indexOf(r.name)===-1&&(this.undefinedExports[r.name]=r)};Ac.currentScope=function(){return this.scopeStack[this.scopeStack.length-1]};Ac.currentVarScope=function(){for(var r=this.scopeStack.length-1;;r--){var t=this.scopeStack[r];if(t.flags&(zS|fx|$d))return t}};Ac.currentThisScope=function(){for(var r=this.scopeStack.length-1;;r--){var t=this.scopeStack[r];if(t.flags&(zS|fx|$d)&&!(t.flags&QT))return t}};var WS=function(t,n,s){this.type="",this.start=n,this.end=0,t.options.locations&&(this.loc=new BS(t,s)),t.options.directSourceFile&&(this.sourceFile=t.options.directSourceFile),t.options.ranges&&(this.range=[n,0])},mx=Cs.prototype;mx.startNode=function(){return new WS(this,this.start,this.startLoc)};mx.startNodeAt=function(r,t){return new WS(this,r,t)};function TW(r,t,n,s){return r.type=t,r.end=n,this.options.locations&&(r.loc.end=s),this.options.ranges&&(r.range[1]=n),r}mx.finishNode=function(r,t){return TW.call(this,r,t,this.lastTokEnd,this.lastTokEndLoc)};mx.finishNodeAt=function(r,t,n,s){return TW.call(this,r,t,n,s)};mx.copyNode=function(r){var t=new WS(this,r.start,this.startLoc);for(var n in r)t[n]=r[n];return t};var Uue="Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz",AW="ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",DW=AW+" Extended_Pictographic",FW=DW,$W=FW+" EBase EComp EMod EPres ExtPict",RW=$W,Wue=RW,Gue={9:AW,10:DW,11:FW,12:$W,13:RW,14:Wue},Hue="Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji",jue={9:"",10:"",11:"",12:"",13:"",14:Hue},EB="Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",OW="Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",MW=OW+" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",LW=MW+" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",PW=LW+" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi",BW=PW+" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith",que=BW+" "+Uue,Kue={9:OW,10:MW,11:LW,12:PW,13:BW,14:que},VW={};function Xue(r){var t=VW[r]={binary:Hl(Gue[r]+" "+EB),binaryOfStrings:Hl(jue[r]),nonBinary:{General_Category:Hl(EB),Script:Hl(Kue[r])}};t.nonBinary.Script_Extensions=t.nonBinary.Script,t.nonBinary.gc=t.nonBinary.General_Category,t.nonBinary.sc=t.nonBinary.Script,t.nonBinary.scx=t.nonBinary.Script_Extensions}for(var bE=0,IB=[9,10,11,12,13,14];bE<IB.length;bE+=1){var Yue=IB[bE];Xue(Yue)}var Ot=Cs.prototype,p2=function(t,n){this.parent=t,this.base=n||this};p2.prototype.separatedFrom=function(t){for(var n=this;n;n=n.parent)for(var s=t;s;s=s.parent)if(n.base===s.base&&n!==s)return!0;return!1};p2.prototype.sibling=function(){return new p2(this.parent,this.base)};var Cu=function(t){this.parser=t,this.validFlags="gim"+(t.options.ecmaVersion>=6?"uy":"")+(t.options.ecmaVersion>=9?"s":"")+(t.options.ecmaVersion>=13?"d":"")+(t.options.ecmaVersion>=15?"v":""),this.unicodeProperties=VW[t.options.ecmaVersion>=14?14:t.options.ecmaVersion],this.source="",this.flags="",this.start=0,this.switchU=!1,this.switchV=!1,this.switchN=!1,this.pos=0,this.lastIntValue=0,this.lastStringValue="",this.lastAssertionIsQuantifiable=!1,this.numCapturingParens=0,this.maxBackReference=0,this.groupNames=Object.create(null),this.backReferenceNames=[],this.branchID=null};Cu.prototype.reset=function(t,n,s){var i=s.indexOf("v")!==-1,a=s.indexOf("u")!==-1;this.start=t|0,this.source=n+"",this.flags=s,i&&this.parser.options.ecmaVersion>=15?(this.switchU=!0,this.switchV=!0,this.switchN=!0):(this.switchU=a&&this.parser.options.ecmaVersion>=6,this.switchV=!1,this.switchN=a&&this.parser.options.ecmaVersion>=9)};Cu.prototype.raise=function(t){this.parser.raiseRecoverable(this.start,"Invalid regular expression: /"+this.source+"/: "+t)};Cu.prototype.at=function(t,n){n===void 0&&(n=!1);var s=this.source,i=s.length;if(t>=i)return-1;var a=s.charCodeAt(t);if(!(n||this.switchU)||a<=55295||a>=57344||t+1>=i)return a;var o=s.charCodeAt(t+1);return o>=56320&&o<=57343?(a<<10)+o-56613888:a};Cu.prototype.nextIndex=function(t,n){n===void 0&&(n=!1);var s=this.source,i=s.length;if(t>=i)return i;var a=s.charCodeAt(t),o;return!(n||this.switchU)||a<=55295||a>=57344||t+1>=i||(o=s.charCodeAt(t+1))<56320||o>57343?t+1:t+2};Cu.prototype.current=function(t){return t===void 0&&(t=!1),this.at(this.pos,t)};Cu.prototype.lookahead=function(t){return t===void 0&&(t=!1),this.at(this.nextIndex(this.pos,t),t)};Cu.prototype.advance=function(t){t===void 0&&(t=!1),this.pos=this.nextIndex(this.pos,t)};Cu.prototype.eat=function(t,n){return n===void 0&&(n=!1),this.current(n)===t?(this.advance(n),!0):!1};Cu.prototype.eatChars=function(t,n){n===void 0&&(n=!1);for(var s=this.pos,i=0,a=t;i<a.length;i+=1){var o=a[i],u=this.at(s,n);if(u===-1||u!==o)return!1;s=this.nextIndex(s,n)}return this.pos=s,!0};Ot.validateRegExpFlags=function(r){for(var t=r.validFlags,n=r.flags,s=!1,i=!1,a=0;a<n.length;a++){var o=n.charAt(a);t.indexOf(o)===-1&&this.raise(r.start,"Invalid regular expression flag"),n.indexOf(o,a+1)>-1&&this.raise(r.start,"Duplicate regular expression flag"),o==="u"&&(s=!0),o==="v"&&(i=!0)}this.options.ecmaVersion>=15&&s&&i&&this.raise(r.start,"Invalid regular expression flag")};function Zue(r){for(var t in r)return!0;return!1}Ot.validateRegExpPattern=function(r){this.regexp_pattern(r),!r.switchN&&this.options.ecmaVersion>=9&&Zue(r.groupNames)&&(r.switchN=!0,this.regexp_pattern(r))};Ot.regexp_pattern=function(r){r.pos=0,r.lastIntValue=0,r.lastStringValue="",r.lastAssertionIsQuantifiable=!1,r.numCapturingParens=0,r.maxBackReference=0,r.groupNames=Object.create(null),r.backReferenceNames.length=0,r.branchID=null,this.regexp_disjunction(r),r.pos!==r.source.length&&(r.eat(41)&&r.raise("Unmatched ')'"),(r.eat(93)||r.eat(125))&&r.raise("Lone quantifier brackets")),r.maxBackReference>r.numCapturingParens&&r.raise("Invalid escape");for(var t=0,n=r.backReferenceNames;t<n.length;t+=1){var s=n[t];r.groupNames[s]||r.raise("Invalid named capture referenced")}};Ot.regexp_disjunction=function(r){var t=this.options.ecmaVersion>=16;for(t&&(r.branchID=new p2(r.branchID,null)),this.regexp_alternative(r);r.eat(124);)t&&(r.branchID=r.branchID.sibling()),this.regexp_alternative(r);t&&(r.branchID=r.branchID.parent),this.regexp_eatQuantifier(r,!0)&&r.raise("Nothing to repeat"),r.eat(123)&&r.raise("Lone quantifier brackets")};Ot.regexp_alternative=function(r){for(;r.pos<r.source.length&&this.regexp_eatTerm(r););};Ot.regexp_eatTerm=function(r){return this.regexp_eatAssertion(r)?(r.lastAssertionIsQuantifiable&&this.regexp_eatQuantifier(r)&&r.switchU&&r.raise("Invalid quantifier"),!0):(r.switchU?this.regexp_eatAtom(r):this.regexp_eatExtendedAtom(r))?(this.regexp_eatQuantifier(r),!0):!1};Ot.regexp_eatAssertion=function(r){var t=r.pos;if(r.lastAssertionIsQuantifiable=!1,r.eat(94)||r.eat(36))return!0;if(r.eat(92)){if(r.eat(66)||r.eat(98))return!0;r.pos=t}if(r.eat(40)&&r.eat(63)){var n=!1;if(this.options.ecmaVersion>=9&&(n=r.eat(60)),r.eat(61)||r.eat(33))return this.regexp_disjunction(r),r.eat(41)||r.raise("Unterminated group"),r.lastAssertionIsQuantifiable=!n,!0}return r.pos=t,!1};Ot.regexp_eatQuantifier=function(r,t){return t===void 0&&(t=!1),this.regexp_eatQuantifierPrefix(r,t)?(r.eat(63),!0):!1};Ot.regexp_eatQuantifierPrefix=function(r,t){return r.eat(42)||r.eat(43)||r.eat(63)||this.regexp_eatBracedQuantifier(r,t)};Ot.regexp_eatBracedQuantifier=function(r,t){var n=r.pos;if(r.eat(123)){var s=0,i=-1;if(this.regexp_eatDecimalDigits(r)&&(s=r.lastIntValue,r.eat(44)&&this.regexp_eatDecimalDigits(r)&&(i=r.lastIntValue),r.eat(125)))return i!==-1&&i<s&&!t&&r.raise("numbers out of order in {} quantifier"),!0;r.switchU&&!t&&r.raise("Incomplete quantifier"),r.pos=n}return!1};Ot.regexp_eatAtom=function(r){return this.regexp_eatPatternCharacters(r)||r.eat(46)||this.regexp_eatReverseSolidusAtomEscape(r)||this.regexp_eatCharacterClass(r)||this.regexp_eatUncapturingGroup(r)||this.regexp_eatCapturingGroup(r)};Ot.regexp_eatReverseSolidusAtomEscape=function(r){var t=r.pos;if(r.eat(92)){if(this.regexp_eatAtomEscape(r))return!0;r.pos=t}return!1};Ot.regexp_eatUncapturingGroup=function(r){var t=r.pos;if(r.eat(40)){if(r.eat(63)){if(this.options.ecmaVersion>=16){var n=this.regexp_eatModifiers(r),s=r.eat(45);if(n||s){for(var i=0;i<n.length;i++){var a=n.charAt(i);n.indexOf(a,i+1)>-1&&r.raise("Duplicate regular expression modifiers")}if(s){var o=this.regexp_eatModifiers(r);!n&&!o&&r.current()===58&&r.raise("Invalid regular expression modifiers");for(var u=0;u<o.length;u++){var l=o.charAt(u);(o.indexOf(l,u+1)>-1||n.indexOf(l)>-1)&&r.raise("Duplicate regular expression modifiers")}}}}if(r.eat(58)){if(this.regexp_disjunction(r),r.eat(41))return!0;r.raise("Unterminated group")}}r.pos=t}return!1};Ot.regexp_eatCapturingGroup=function(r){if(r.eat(40)){if(this.options.ecmaVersion>=9?this.regexp_groupSpecifier(r):r.current()===63&&r.raise("Invalid group"),this.regexp_disjunction(r),r.eat(41))return r.numCapturingParens+=1,!0;r.raise("Unterminated group")}return!1};Ot.regexp_eatModifiers=function(r){for(var t="",n=0;(n=r.current())!==-1&&Jue(n);)t+=al(n),r.advance();return t};function Jue(r){return r===105||r===109||r===115}Ot.regexp_eatExtendedAtom=function(r){return r.eat(46)||this.regexp_eatReverseSolidusAtomEscape(r)||this.regexp_eatCharacterClass(r)||this.regexp_eatUncapturingGroup(r)||this.regexp_eatCapturingGroup(r)||this.regexp_eatInvalidBracedQuantifier(r)||this.regexp_eatExtendedPatternCharacter(r)};Ot.regexp_eatInvalidBracedQuantifier=function(r){return this.regexp_eatBracedQuantifier(r,!0)&&r.raise("Nothing to repeat"),!1};Ot.regexp_eatSyntaxCharacter=function(r){var t=r.current();return zW(t)?(r.lastIntValue=t,r.advance(),!0):!1};function zW(r){return r===36||r>=40&&r<=43||r===46||r===63||r>=91&&r<=94||r>=123&&r<=125}Ot.regexp_eatPatternCharacters=function(r){for(var t=r.pos,n=0;(n=r.current())!==-1&&!zW(n);)r.advance();return r.pos!==t};Ot.regexp_eatExtendedPatternCharacter=function(r){var t=r.current();return t!==-1&&t!==36&&!(t>=40&&t<=43)&&t!==46&&t!==63&&t!==91&&t!==94&&t!==124?(r.advance(),!0):!1};Ot.regexp_groupSpecifier=function(r){if(r.eat(63)){this.regexp_eatGroupName(r)||r.raise("Invalid group");var t=this.options.ecmaVersion>=16,n=r.groupNames[r.lastStringValue];if(n)if(t)for(var s=0,i=n;s<i.length;s+=1){var a=i[s];a.separatedFrom(r.branchID)||r.raise("Duplicate capture group name")}else r.raise("Duplicate capture group name");t?(n||(r.groupNames[r.lastStringValue]=[])).push(r.branchID):r.groupNames[r.lastStringValue]=!0}};Ot.regexp_eatGroupName=function(r){if(r.lastStringValue="",r.eat(60)){if(this.regexp_eatRegExpIdentifierName(r)&&r.eat(62))return!0;r.raise("Invalid capture group name")}return!1};Ot.regexp_eatRegExpIdentifierName=function(r){if(r.lastStringValue="",this.regexp_eatRegExpIdentifierStart(r)){for(r.lastStringValue+=al(r.lastIntValue);this.regexp_eatRegExpIdentifierPart(r);)r.lastStringValue+=al(r.lastIntValue);return!0}return!1};Ot.regexp_eatRegExpIdentifierStart=function(r){var t=r.pos,n=this.options.ecmaVersion>=11,s=r.current(n);return r.advance(n),s===92&&this.regexp_eatRegExpUnicodeEscapeSequence(r,n)&&(s=r.lastIntValue),Que(s)?(r.lastIntValue=s,!0):(r.pos=t,!1)};function Que(r){return il(r,!0)||r===36||r===95}Ot.regexp_eatRegExpIdentifierPart=function(r){var t=r.pos,n=this.options.ecmaVersion>=11,s=r.current(n);return r.advance(n),s===92&&this.regexp_eatRegExpUnicodeEscapeSequence(r,n)&&(s=r.lastIntValue),ele(s)?(r.lastIntValue=s,!0):(r.pos=t,!1)};function ele(r){return Dm(r,!0)||r===36||r===95||r===8204||r===8205}Ot.regexp_eatAtomEscape=function(r){return this.regexp_eatBackReference(r)||this.regexp_eatCharacterClassEscape(r)||this.regexp_eatCharacterEscape(r)||r.switchN&&this.regexp_eatKGroupName(r)?!0:(r.switchU&&(r.current()===99&&r.raise("Invalid unicode escape"),r.raise("Invalid escape")),!1)};Ot.regexp_eatBackReference=function(r){var t=r.pos;if(this.regexp_eatDecimalEscape(r)){var n=r.lastIntValue;if(r.switchU)return n>r.maxBackReference&&(r.maxBackReference=n),!0;if(n<=r.numCapturingParens)return!0;r.pos=t}return!1};Ot.regexp_eatKGroupName=function(r){if(r.eat(107)){if(this.regexp_eatGroupName(r))return r.backReferenceNames.push(r.lastStringValue),!0;r.raise("Invalid named reference")}return!1};Ot.regexp_eatCharacterEscape=function(r){return this.regexp_eatControlEscape(r)||this.regexp_eatCControlLetter(r)||this.regexp_eatZero(r)||this.regexp_eatHexEscapeSequence(r)||this.regexp_eatRegExpUnicodeEscapeSequence(r,!1)||!r.switchU&&this.regexp_eatLegacyOctalEscapeSequence(r)||this.regexp_eatIdentityEscape(r)};Ot.regexp_eatCControlLetter=function(r){var t=r.pos;if(r.eat(99)){if(this.regexp_eatControlLetter(r))return!0;r.pos=t}return!1};Ot.regexp_eatZero=function(r){return r.current()===48&&!GS(r.lookahead())?(r.lastIntValue=0,r.advance(),!0):!1};Ot.regexp_eatControlEscape=function(r){var t=r.current();return t===116?(r.lastIntValue=9,r.advance(),!0):t===110?(r.lastIntValue=10,r.advance(),!0):t===118?(r.lastIntValue=11,r.advance(),!0):t===102?(r.lastIntValue=12,r.advance(),!0):t===114?(r.lastIntValue=13,r.advance(),!0):!1};Ot.regexp_eatControlLetter=function(r){var t=r.current();return UW(t)?(r.lastIntValue=t%32,r.advance(),!0):!1};function UW(r){return r>=65&&r<=90||r>=97&&r<=122}Ot.regexp_eatRegExpUnicodeEscapeSequence=function(r,t){t===void 0&&(t=!1);var n=r.pos,s=t||r.switchU;if(r.eat(117)){if(this.regexp_eatFixedHexDigits(r,4)){var i=r.lastIntValue;if(s&&i>=55296&&i<=56319){var a=r.pos;if(r.eat(92)&&r.eat(117)&&this.regexp_eatFixedHexDigits(r,4)){var o=r.lastIntValue;if(o>=56320&&o<=57343)return r.lastIntValue=(i-55296)*1024+(o-56320)+65536,!0}r.pos=a,r.lastIntValue=i}return!0}if(s&&r.eat(123)&&this.regexp_eatHexDigits(r)&&r.eat(125)&&tle(r.lastIntValue))return!0;s&&r.raise("Invalid unicode escape"),r.pos=n}return!1};function tle(r){return r>=0&&r<=1114111}Ot.regexp_eatIdentityEscape=function(r){if(r.switchU)return this.regexp_eatSyntaxCharacter(r)?!0:r.eat(47)?(r.lastIntValue=47,!0):!1;var t=r.current();return t!==99&&(!r.switchN||t!==107)?(r.lastIntValue=t,r.advance(),!0):!1};Ot.regexp_eatDecimalEscape=function(r){r.lastIntValue=0;var t=r.current();if(t>=49&&t<=57){do r.lastIntValue=10*r.lastIntValue+(t-48),r.advance();while((t=r.current())>=48&&t<=57);return!0}return!1};var WW=0,ol=1,Ua=2;Ot.regexp_eatCharacterClassEscape=function(r){var t=r.current();if(rle(t))return r.lastIntValue=-1,r.advance(),ol;var n=!1;if(r.switchU&&this.options.ecmaVersion>=9&&((n=t===80)||t===112)){r.lastIntValue=-1,r.advance();var s;if(r.eat(123)&&(s=this.regexp_eatUnicodePropertyValueExpression(r))&&r.eat(125))return n&&s===Ua&&r.raise("Invalid property name"),s;r.raise("Invalid property name")}return WW};function rle(r){return r===100||r===68||r===115||r===83||r===119||r===87}Ot.regexp_eatUnicodePropertyValueExpression=function(r){var t=r.pos;if(this.regexp_eatUnicodePropertyName(r)&&r.eat(61)){var n=r.lastStringValue;if(this.regexp_eatUnicodePropertyValue(r)){var s=r.lastStringValue;return this.regexp_validateUnicodePropertyNameAndValue(r,n,s),ol}}if(r.pos=t,this.regexp_eatLoneUnicodePropertyNameOrValue(r)){var i=r.lastStringValue;return this.regexp_validateUnicodePropertyNameOrValue(r,i)}return WW};Ot.regexp_validateUnicodePropertyNameAndValue=function(r,t,n){og(r.unicodeProperties.nonBinary,t)||r.raise("Invalid property name"),r.unicodeProperties.nonBinary[t].test(n)||r.raise("Invalid property value")};Ot.regexp_validateUnicodePropertyNameOrValue=function(r,t){if(r.unicodeProperties.binary.test(t))return ol;if(r.switchV&&r.unicodeProperties.binaryOfStrings.test(t))return Ua;r.raise("Invalid property name")};Ot.regexp_eatUnicodePropertyName=function(r){var t=0;for(r.lastStringValue="";GW(t=r.current());)r.lastStringValue+=al(t),r.advance();return r.lastStringValue!==""};function GW(r){return UW(r)||r===95}Ot.regexp_eatUnicodePropertyValue=function(r){var t=0;for(r.lastStringValue="";nle(t=r.current());)r.lastStringValue+=al(t),r.advance();return r.lastStringValue!==""};function nle(r){return GW(r)||GS(r)}Ot.regexp_eatLoneUnicodePropertyNameOrValue=function(r){return this.regexp_eatUnicodePropertyValue(r)};Ot.regexp_eatCharacterClass=function(r){if(r.eat(91)){var t=r.eat(94),n=this.regexp_classContents(r);return r.eat(93)||r.raise("Unterminated character class"),t&&n===Ua&&r.raise("Negated character class may contain strings"),!0}return!1};Ot.regexp_classContents=function(r){return r.current()===93?ol:r.switchV?this.regexp_classSetExpression(r):(this.regexp_nonEmptyClassRanges(r),ol)};Ot.regexp_nonEmptyClassRanges=function(r){for(;this.regexp_eatClassAtom(r);){var t=r.lastIntValue;if(r.eat(45)&&this.regexp_eatClassAtom(r)){var n=r.lastIntValue;r.switchU&&(t===-1||n===-1)&&r.raise("Invalid character class"),t!==-1&&n!==-1&&t>n&&r.raise("Range out of order in character class")}}};Ot.regexp_eatClassAtom=function(r){var t=r.pos;if(r.eat(92)){if(this.regexp_eatClassEscape(r))return!0;if(r.switchU){var n=r.current();(n===99||qW(n))&&r.raise("Invalid class escape"),r.raise("Invalid escape")}r.pos=t}var s=r.current();return s!==93?(r.lastIntValue=s,r.advance(),!0):!1};Ot.regexp_eatClassEscape=function(r){var t=r.pos;if(r.eat(98))return r.lastIntValue=8,!0;if(r.switchU&&r.eat(45))return r.lastIntValue=45,!0;if(!r.switchU&&r.eat(99)){if(this.regexp_eatClassControlLetter(r))return!0;r.pos=t}return this.regexp_eatCharacterClassEscape(r)||this.regexp_eatCharacterEscape(r)};Ot.regexp_classSetExpression=function(r){var t=ol,n;if(!this.regexp_eatClassSetRange(r))if(n=this.regexp_eatClassSetOperand(r)){n===Ua&&(t=Ua);for(var s=r.pos;r.eatChars([38,38]);){if(r.current()!==38&&(n=this.regexp_eatClassSetOperand(r))){n!==Ua&&(t=ol);continue}r.raise("Invalid character in character class")}if(s!==r.pos)return t;for(;r.eatChars([45,45]);)this.regexp_eatClassSetOperand(r)||r.raise("Invalid character in character class");if(s!==r.pos)return t}else r.raise("Invalid character in character class");for(;;)if(!this.regexp_eatClassSetRange(r)){if(n=this.regexp_eatClassSetOperand(r),!n)return t;n===Ua&&(t=Ua)}};Ot.regexp_eatClassSetRange=function(r){var t=r.pos;if(this.regexp_eatClassSetCharacter(r)){var n=r.lastIntValue;if(r.eat(45)&&this.regexp_eatClassSetCharacter(r)){var s=r.lastIntValue;return n!==-1&&s!==-1&&n>s&&r.raise("Range out of order in character class"),!0}r.pos=t}return!1};Ot.regexp_eatClassSetOperand=function(r){return this.regexp_eatClassSetCharacter(r)?ol:this.regexp_eatClassStringDisjunction(r)||this.regexp_eatNestedClass(r)};Ot.regexp_eatNestedClass=function(r){var t=r.pos;if(r.eat(91)){var n=r.eat(94),s=this.regexp_classContents(r);if(r.eat(93))return n&&s===Ua&&r.raise("Negated character class may contain strings"),s;r.pos=t}if(r.eat(92)){var i=this.regexp_eatCharacterClassEscape(r);if(i)return i;r.pos=t}return null};Ot.regexp_eatClassStringDisjunction=function(r){var t=r.pos;if(r.eatChars([92,113])){if(r.eat(123)){var n=this.regexp_classStringDisjunctionContents(r);if(r.eat(125))return n}else r.raise("Invalid escape");r.pos=t}return null};Ot.regexp_classStringDisjunctionContents=function(r){for(var t=this.regexp_classString(r);r.eat(124);)this.regexp_classString(r)===Ua&&(t=Ua);return t};Ot.regexp_classString=function(r){for(var t=0;this.regexp_eatClassSetCharacter(r);)t++;return t===1?ol:Ua};Ot.regexp_eatClassSetCharacter=function(r){var t=r.pos;if(r.eat(92))return this.regexp_eatCharacterEscape(r)||this.regexp_eatClassSetReservedPunctuator(r)?!0:r.eat(98)?(r.lastIntValue=8,!0):(r.pos=t,!1);var n=r.current();return n<0||n===r.lookahead()&&sle(n)||ile(n)?!1:(r.advance(),r.lastIntValue=n,!0)};function sle(r){return r===33||r>=35&&r<=38||r>=42&&r<=44||r===46||r>=58&&r<=64||r===94||r===96||r===126}function ile(r){return r===40||r===41||r===45||r===47||r>=91&&r<=93||r>=123&&r<=125}Ot.regexp_eatClassSetReservedPunctuator=function(r){var t=r.current();return ale(t)?(r.lastIntValue=t,r.advance(),!0):!1};function ale(r){return r===33||r===35||r===37||r===38||r===44||r===45||r>=58&&r<=62||r===64||r===96||r===126}Ot.regexp_eatClassControlLetter=function(r){var t=r.current();return GS(t)||t===95?(r.lastIntValue=t%32,r.advance(),!0):!1};Ot.regexp_eatHexEscapeSequence=function(r){var t=r.pos;if(r.eat(120)){if(this.regexp_eatFixedHexDigits(r,2))return!0;r.switchU&&r.raise("Invalid escape"),r.pos=t}return!1};Ot.regexp_eatDecimalDigits=function(r){var t=r.pos,n=0;for(r.lastIntValue=0;GS(n=r.current());)r.lastIntValue=10*r.lastIntValue+(n-48),r.advance();return r.pos!==t};function GS(r){return r>=48&&r<=57}Ot.regexp_eatHexDigits=function(r){var t=r.pos,n=0;for(r.lastIntValue=0;HW(n=r.current());)r.lastIntValue=16*r.lastIntValue+jW(n),r.advance();return r.pos!==t};function HW(r){return r>=48&&r<=57||r>=65&&r<=70||r>=97&&r<=102}function jW(r){return r>=65&&r<=70?10+(r-65):r>=97&&r<=102?10+(r-97):r-48}Ot.regexp_eatLegacyOctalEscapeSequence=function(r){if(this.regexp_eatOctalDigit(r)){var t=r.lastIntValue;if(this.regexp_eatOctalDigit(r)){var n=r.lastIntValue;t<=3&&this.regexp_eatOctalDigit(r)?r.lastIntValue=t*64+n*8+r.lastIntValue:r.lastIntValue=t*8+n}else r.lastIntValue=t;return!0}return!1};Ot.regexp_eatOctalDigit=function(r){var t=r.current();return qW(t)?(r.lastIntValue=t-48,r.advance(),!0):(r.lastIntValue=0,!1)};function qW(r){return r>=48&&r<=55}Ot.regexp_eatFixedHexDigits=function(r,t){var n=r.pos;r.lastIntValue=0;for(var s=0;s<t;++s){var i=r.current();if(!HW(i))return r.pos=n,!1;r.lastIntValue=16*r.lastIntValue+jW(i),r.advance()}return!0};var nA=function(t){this.type=t.type,this.value=t.value,this.start=t.start,this.end=t.end,t.options.locations&&(this.loc=new BS(t,t.startLoc,t.endLoc)),t.options.ranges&&(this.range=[t.start,t.end])},kr=Cs.prototype;kr.next=function(r){!r&&this.type.keyword&&this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword "+this.type.keyword),this.options.onToken&&this.options.onToken(new nA(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken()};kr.getToken=function(){return this.next(),new nA(this)};typeof Symbol<"u"&&(kr[Symbol.iterator]=function(){var r=this;return{next:function(){var t=r.getToken();return{done:t.type===te.eof,value:t}}}});kr.nextToken=function(){var r=this.curContext();if((!r||!r.preserveSpace)&&this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length)return this.finishToken(te.eof);if(r.override)return r.override(this);this.readToken(this.fullCharCodeAtPos())};kr.readToken=function(r){return il(r,this.options.ecmaVersion>=6)||r===92?this.readWord():this.getTokenFromCode(r)};kr.fullCharCodeAtPos=function(){var r=this.input.charCodeAt(this.pos);if(r<=55295||r>=56320)return r;var t=this.input.charCodeAt(this.pos+1);return t<=56319||t>=57344?r:(r<<10)+t-56613888};kr.skipBlockComment=function(){var r=this.options.onComment&&this.curPosition(),t=this.pos,n=this.input.indexOf("*/",this.pos+=2);if(n===-1&&this.raise(this.pos-2,"Unterminated comment"),this.pos=n+2,this.options.locations)for(var s=void 0,i=t;(s=yW(this.input,i,this.pos))>-1;)++this.curLine,i=this.lineStart=s;this.options.onComment&&this.options.onComment(!0,this.input.slice(t+2,n),t,this.pos,r,this.curPosition())};kr.skipLineComment=function(r){for(var t=this.pos,n=this.options.onComment&&this.curPosition(),s=this.input.charCodeAt(this.pos+=r);this.pos<this.input.length&&!ag(s);)s=this.input.charCodeAt(++this.pos);this.options.onComment&&this.options.onComment(!1,this.input.slice(t+r,this.pos),t,this.pos,n,this.curPosition())};kr.skipSpace=function(){e:for(;this.pos<this.input.length;){var r=this.input.charCodeAt(this.pos);switch(r){case 32:case 160:++this.pos;break;case 13:this.input.charCodeAt(this.pos+1)===10&&++this.pos;case 10:case 8232:case 8233:++this.pos,this.options.locations&&(++this.curLine,this.lineStart=this.pos);break;case 47:switch(this.input.charCodeAt(this.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break e}break;default:if(r>8&&r<14||r>=5760&&bW.test(String.fromCharCode(r)))++this.pos;else break e}}};kr.finishToken=function(r,t){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var n=this.type;this.type=r,this.value=t,this.updateContext(n)};kr.readToken_dot=function(){var r=this.input.charCodeAt(this.pos+1);if(r>=48&&r<=57)return this.readNumber(!0);var t=this.input.charCodeAt(this.pos+2);return this.options.ecmaVersion>=6&&r===46&&t===46?(this.pos+=3,this.finishToken(te.ellipsis)):(++this.pos,this.finishToken(te.dot))};kr.readToken_slash=function(){var r=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):r===61?this.finishOp(te.assign,2):this.finishOp(te.slash,1)};kr.readToken_mult_modulo_exp=function(r){var t=this.input.charCodeAt(this.pos+1),n=1,s=r===42?te.star:te.modulo;return this.options.ecmaVersion>=7&&r===42&&t===42&&(++n,s=te.starstar,t=this.input.charCodeAt(this.pos+2)),t===61?this.finishOp(te.assign,n+1):this.finishOp(s,n)};kr.readToken_pipe_amp=function(r){var t=this.input.charCodeAt(this.pos+1);if(t===r){if(this.options.ecmaVersion>=12){var n=this.input.charCodeAt(this.pos+2);if(n===61)return this.finishOp(te.assign,3)}return this.finishOp(r===124?te.logicalOR:te.logicalAND,2)}return t===61?this.finishOp(te.assign,2):this.finishOp(r===124?te.bitwiseOR:te.bitwiseAND,1)};kr.readToken_caret=function(){var r=this.input.charCodeAt(this.pos+1);return r===61?this.finishOp(te.assign,2):this.finishOp(te.bitwiseXOR,1)};kr.readToken_plus_min=function(r){var t=this.input.charCodeAt(this.pos+1);return t===r?t===45&&!this.inModule&&this.input.charCodeAt(this.pos+2)===62&&(this.lastTokEnd===0||Qa.test(this.input.slice(this.lastTokEnd,this.pos)))?(this.skipLineComment(3),this.skipSpace(),this.nextToken()):this.finishOp(te.incDec,2):t===61?this.finishOp(te.assign,2):this.finishOp(te.plusMin,1)};kr.readToken_lt_gt=function(r){var t=this.input.charCodeAt(this.pos+1),n=1;return t===r?(n=r===62&&this.input.charCodeAt(this.pos+2)===62?3:2,this.input.charCodeAt(this.pos+n)===61?this.finishOp(te.assign,n+1):this.finishOp(te.bitShift,n)):t===33&&r===60&&!this.inModule&&this.input.charCodeAt(this.pos+2)===45&&this.input.charCodeAt(this.pos+3)===45?(this.skipLineComment(4),this.skipSpace(),this.nextToken()):(t===61&&(n=2),this.finishOp(te.relational,n))};kr.readToken_eq_excl=function(r){var t=this.input.charCodeAt(this.pos+1);return t===61?this.finishOp(te.equality,this.input.charCodeAt(this.pos+2)===61?3:2):r===61&&t===62&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(te.arrow)):this.finishOp(r===61?te.eq:te.prefix,1)};kr.readToken_question=function(){var r=this.options.ecmaVersion;if(r>=11){var t=this.input.charCodeAt(this.pos+1);if(t===46){var n=this.input.charCodeAt(this.pos+2);if(n<48||n>57)return this.finishOp(te.questionDot,2)}if(t===63){if(r>=12){var s=this.input.charCodeAt(this.pos+2);if(s===61)return this.finishOp(te.assign,3)}return this.finishOp(te.coalesce,2)}}return this.finishOp(te.question,1)};kr.readToken_numberSign=function(){var r=this.options.ecmaVersion,t=35;if(r>=13&&(++this.pos,t=this.fullCharCodeAtPos(),il(t,!0)||t===92))return this.finishToken(te.privateId,this.readWord1());this.raise(this.pos,"Unexpected character '"+al(t)+"'")};kr.getTokenFromCode=function(r){switch(r){case 46:return this.readToken_dot();case 40:return++this.pos,this.finishToken(te.parenL);case 41:return++this.pos,this.finishToken(te.parenR);case 59:return++this.pos,this.finishToken(te.semi);case 44:return++this.pos,this.finishToken(te.comma);case 91:return++this.pos,this.finishToken(te.bracketL);case 93:return++this.pos,this.finishToken(te.bracketR);case 123:return++this.pos,this.finishToken(te.braceL);case 125:return++this.pos,this.finishToken(te.braceR);case 58:return++this.pos,this.finishToken(te.colon);case 96:if(this.options.ecmaVersion<6)break;return++this.pos,this.finishToken(te.backQuote);case 48:var t=this.input.charCodeAt(this.pos+1);if(t===120||t===88)return this.readRadixNumber(16);if(this.options.ecmaVersion>=6){if(t===111||t===79)return this.readRadixNumber(8);if(t===98||t===66)return this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(!1);case 34:case 39:return this.readString(r);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo_exp(r);case 124:case 38:return this.readToken_pipe_amp(r);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(r);case 60:case 62:return this.readToken_lt_gt(r);case 61:case 33:return this.readToken_eq_excl(r);case 63:return this.readToken_question();case 126:return this.finishOp(te.prefix,1);case 35:return this.readToken_numberSign()}this.raise(this.pos,"Unexpected character '"+al(r)+"'")};kr.finishOp=function(r,t){var n=this.input.slice(this.pos,this.pos+t);return this.pos+=t,this.finishToken(r,n)};kr.readRegexp=function(){for(var r,t,n=this.pos;;){this.pos>=this.input.length&&this.raise(n,"Unterminated regular expression");var s=this.input.charAt(this.pos);if(Qa.test(s)&&this.raise(n,"Unterminated regular expression"),r)r=!1;else{if(s==="[")t=!0;else if(s==="]"&&t)t=!1;else if(s==="/"&&!t)break;r=s==="\\"}++this.pos}var i=this.input.slice(n,this.pos);++this.pos;var a=this.pos,o=this.readWord1();this.containsEsc&&this.unexpected(a);var u=this.regexpState||(this.regexpState=new Cu(this));u.reset(n,i,o),this.validateRegExpFlags(u),this.validateRegExpPattern(u);var l=null;try{l=new RegExp(i,o)}catch{}return this.finishToken(te.regexp,{pattern:i,flags:o,value:l})};kr.readInt=function(r,t,n){for(var s=this.options.ecmaVersion>=12&&t===void 0,i=n&&this.input.charCodeAt(this.pos)===48,a=this.pos,o=0,u=0,l=0,c=t??1/0;l<c;++l,++this.pos){var h=this.input.charCodeAt(this.pos),d=void 0;if(s&&h===95){i&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed in legacy octal numeric literals"),u===95&&this.raiseRecoverable(this.pos,"Numeric separator must be exactly one underscore"),l===0&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed at the first of digits"),u=h;continue}if(h>=97?d=h-97+10:h>=65?d=h-65+10:h>=48&&h<=57?d=h-48:d=1/0,d>=r)break;u=h,o=o*r+d}return s&&u===95&&this.raiseRecoverable(this.pos-1,"Numeric separator is not allowed at the last of digits"),this.pos===a||t!=null&&this.pos-a!==t?null:o};function ole(r,t){return t?parseInt(r,8):parseFloat(r.replace(/_/g,""))}function KW(r){return typeof BigInt!="function"?null:BigInt(r.replace(/_/g,""))}kr.readRadixNumber=function(r){var t=this.pos;this.pos+=2;var n=this.readInt(r);return n==null&&this.raise(this.start+2,"Expected number in radix "+r),this.options.ecmaVersion>=11&&this.input.charCodeAt(this.pos)===110?(n=KW(this.input.slice(t,this.pos)),++this.pos):il(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(te.num,n)};kr.readNumber=function(r){var t=this.pos;!r&&this.readInt(10,void 0,!0)===null&&this.raise(t,"Invalid number");var n=this.pos-t>=2&&this.input.charCodeAt(t)===48;n&&this.strict&&this.raise(t,"Invalid number");var s=this.input.charCodeAt(this.pos);if(!n&&!r&&this.options.ecmaVersion>=11&&s===110){var i=KW(this.input.slice(t,this.pos));return++this.pos,il(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(te.num,i)}n&&/[89]/.test(this.input.slice(t,this.pos))&&(n=!1),s===46&&!n&&(++this.pos,this.readInt(10),s=this.input.charCodeAt(this.pos)),(s===69||s===101)&&!n&&(s=this.input.charCodeAt(++this.pos),(s===43||s===45)&&++this.pos,this.readInt(10)===null&&this.raise(t,"Invalid number")),il(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var a=ole(this.input.slice(t,this.pos),n);return this.finishToken(te.num,a)};kr.readCodePoint=function(){var r=this.input.charCodeAt(this.pos),t;if(r===123){this.options.ecmaVersion<6&&this.unexpected();var n=++this.pos;t=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,t>1114111&&this.invalidStringToken(n,"Code point out of bounds")}else t=this.readHexChar(4);return t};kr.readString=function(r){for(var t="",n=++this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated string constant");var s=this.input.charCodeAt(this.pos);if(s===r)break;s===92?(t+=this.input.slice(n,this.pos),t+=this.readEscapedChar(!1),n=this.pos):s===8232||s===8233?(this.options.ecmaVersion<10&&this.raise(this.start,"Unterminated string constant"),++this.pos,this.options.locations&&(this.curLine++,this.lineStart=this.pos)):(ag(s)&&this.raise(this.start,"Unterminated string constant"),++this.pos)}return t+=this.input.slice(n,this.pos++),this.finishToken(te.string,t)};var XW={};kr.tryReadTemplateToken=function(){this.inTemplateElement=!0;try{this.readTmplToken()}catch(r){if(r===XW)this.readInvalidTemplateToken();else throw r}this.inTemplateElement=!1};kr.invalidStringToken=function(r,t){if(this.inTemplateElement&&this.options.ecmaVersion>=9)throw XW;this.raise(r,t)};kr.readTmplToken=function(){for(var r="",t=this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated template");var n=this.input.charCodeAt(this.pos);if(n===96||n===36&&this.input.charCodeAt(this.pos+1)===123)return this.pos===this.start&&(this.type===te.template||this.type===te.invalidTemplate)?n===36?(this.pos+=2,this.finishToken(te.dollarBraceL)):(++this.pos,this.finishToken(te.backQuote)):(r+=this.input.slice(t,this.pos),this.finishToken(te.template,r));if(n===92)r+=this.input.slice(t,this.pos),r+=this.readEscapedChar(!0),t=this.pos;else if(ag(n)){switch(r+=this.input.slice(t,this.pos),++this.pos,n){case 13:this.input.charCodeAt(this.pos)===10&&++this.pos;case 10:r+=`
`;break;default:r+=String.fromCharCode(n);break}this.options.locations&&(++this.curLine,this.lineStart=this.pos),t=this.pos}else++this.pos}};kr.readInvalidTemplateToken=function(){for(;this.pos<this.input.length;this.pos++)switch(this.input[this.pos]){case"\\":++this.pos;break;case"$":if(this.input[this.pos+1]!=="{")break;case"`":return this.finishToken(te.invalidTemplate,this.input.slice(this.start,this.pos));case"\r":this.input[this.pos+1]===`
`&&++this.pos;case`
`:case"\u2028":case"\u2029":++this.curLine,this.lineStart=this.pos+1;break}this.raise(this.start,"Unterminated template")};kr.readEscapedChar=function(r){var t=this.input.charCodeAt(++this.pos);switch(++this.pos,t){case 110:return`
`;case 114:return"\r";case 120:return String.fromCharCode(this.readHexChar(2));case 117:return al(this.readCodePoint());case 116:return"	";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 13:this.input.charCodeAt(this.pos)===10&&++this.pos;case 10:return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";case 56:case 57:if(this.strict&&this.invalidStringToken(this.pos-1,"Invalid escape sequence"),r){var n=this.pos-1;this.invalidStringToken(n,"Invalid escape sequence in template string")}default:if(t>=48&&t<=55){var s=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],i=parseInt(s,8);return i>255&&(s=s.slice(0,-1),i=parseInt(s,8)),this.pos+=s.length-1,t=this.input.charCodeAt(this.pos),(s!=="0"||t===56||t===57)&&(this.strict||r)&&this.invalidStringToken(this.pos-1-s.length,r?"Octal literal in template string":"Octal literal in strict mode"),String.fromCharCode(i)}return ag(t)?(this.options.locations&&(this.lineStart=this.pos,++this.curLine),""):String.fromCharCode(t)}};kr.readHexChar=function(r){var t=this.pos,n=this.readInt(16,r);return n===null&&this.invalidStringToken(t,"Bad character escape sequence"),n};kr.readWord1=function(){this.containsEsc=!1;for(var r="",t=!0,n=this.pos,s=this.options.ecmaVersion>=6;this.pos<this.input.length;){var i=this.fullCharCodeAtPos();if(Dm(i,s))this.pos+=i<=65535?1:2;else if(i===92){this.containsEsc=!0,r+=this.input.slice(n,this.pos);var a=this.pos;this.input.charCodeAt(++this.pos)!==117&&this.invalidStringToken(this.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.pos;var o=this.readCodePoint();(t?il:Dm)(o,s)||this.invalidStringToken(a,"Invalid Unicode escape"),r+=al(o),n=this.pos}else break;t=!1}return r+this.input.slice(n,this.pos)};kr.readWord=function(){var r=this.readWord1(),t=te.name;return this.keywords.test(r)&&(t=ZT[r]),this.finishToken(t,r)};var ule="8.14.1";Cs.acorn={Parser:Cs,version:ule,defaultOptions:uk,Position:vb,SourceLocation:BS,getLineInfo:vW,Node:WS,TokenType:Br,tokTypes:te,keywordTypes:ZT,TokContext:ho,tokContexts:$n,isIdentifierChar:Dm,isIdentifierStart:il,Token:nA,isNewLine:ag,lineBreak:Qa,lineBreakG:Aue,nonASCIIwhitespace:bW};function YW(r,t){return Cs.parse(r,t)}function lle(r,t,n,s,i){n||(n=ft),function a(o,u,l){var c=l||o.type;n[c](o,u,a),t[c]&&t[c](o,u)}(r,s,i)}function cle(r,t,n,s,i){var a=[];n||(n=ft),function o(u,l,c){var h=c||u.type,d=u!==a[a.length-1];d&&a.push(u),n[h](u,l,o),t[h]&&t[h](u,l||a,a),d&&a.pop()}(r,s,i)}function sA(r,t,n){n(r,t)}function Rd(r,t,n){}var ft={};ft.Program=ft.BlockStatement=ft.StaticBlock=function(r,t,n){for(var s=0,i=r.body;s<i.length;s+=1){var a=i[s];n(a,t,"Statement")}};ft.Statement=sA;ft.EmptyStatement=Rd;ft.ExpressionStatement=ft.ParenthesizedExpression=ft.ChainExpression=function(r,t,n){return n(r.expression,t,"Expression")};ft.IfStatement=function(r,t,n){n(r.test,t,"Expression"),n(r.consequent,t,"Statement"),r.alternate&&n(r.alternate,t,"Statement")};ft.LabeledStatement=function(r,t,n){return n(r.body,t,"Statement")};ft.BreakStatement=ft.ContinueStatement=Rd;ft.WithStatement=function(r,t,n){n(r.object,t,"Expression"),n(r.body,t,"Statement")};ft.SwitchStatement=function(r,t,n){n(r.discriminant,t,"Expression");for(var s=0,i=r.cases;s<i.length;s+=1){var a=i[s];n(a,t)}};ft.SwitchCase=function(r,t,n){r.test&&n(r.test,t,"Expression");for(var s=0,i=r.consequent;s<i.length;s+=1){var a=i[s];n(a,t,"Statement")}};ft.ReturnStatement=ft.YieldExpression=ft.AwaitExpression=function(r,t,n){r.argument&&n(r.argument,t,"Expression")};ft.ThrowStatement=ft.SpreadElement=function(r,t,n){return n(r.argument,t,"Expression")};ft.TryStatement=function(r,t,n){n(r.block,t,"Statement"),r.handler&&n(r.handler,t),r.finalizer&&n(r.finalizer,t,"Statement")};ft.CatchClause=function(r,t,n){r.param&&n(r.param,t,"Pattern"),n(r.body,t,"Statement")};ft.WhileStatement=ft.DoWhileStatement=function(r,t,n){n(r.test,t,"Expression"),n(r.body,t,"Statement")};ft.ForStatement=function(r,t,n){r.init&&n(r.init,t,"ForInit"),r.test&&n(r.test,t,"Expression"),r.update&&n(r.update,t,"Expression"),n(r.body,t,"Statement")};ft.ForInStatement=ft.ForOfStatement=function(r,t,n){n(r.left,t,"ForInit"),n(r.right,t,"Expression"),n(r.body,t,"Statement")};ft.ForInit=function(r,t,n){r.type==="VariableDeclaration"?n(r,t):n(r,t,"Expression")};ft.DebuggerStatement=Rd;ft.FunctionDeclaration=function(r,t,n){return n(r,t,"Function")};ft.VariableDeclaration=function(r,t,n){for(var s=0,i=r.declarations;s<i.length;s+=1){var a=i[s];n(a,t)}};ft.VariableDeclarator=function(r,t,n){n(r.id,t,"Pattern"),r.init&&n(r.init,t,"Expression")};ft.Function=function(r,t,n){r.id&&n(r.id,t,"Pattern");for(var s=0,i=r.params;s<i.length;s+=1){var a=i[s];n(a,t,"Pattern")}n(r.body,t,r.expression?"Expression":"Statement")};ft.Pattern=function(r,t,n){r.type==="Identifier"?n(r,t,"VariablePattern"):r.type==="MemberExpression"?n(r,t,"MemberPattern"):n(r,t)};ft.VariablePattern=Rd;ft.MemberPattern=sA;ft.RestElement=function(r,t,n){return n(r.argument,t,"Pattern")};ft.ArrayPattern=function(r,t,n){for(var s=0,i=r.elements;s<i.length;s+=1){var a=i[s];a&&n(a,t,"Pattern")}};ft.ObjectPattern=function(r,t,n){for(var s=0,i=r.properties;s<i.length;s+=1){var a=i[s];a.type==="Property"?(a.computed&&n(a.key,t,"Expression"),n(a.value,t,"Pattern")):a.type==="RestElement"&&n(a.argument,t,"Pattern")}};ft.Expression=sA;ft.ThisExpression=ft.Super=ft.MetaProperty=Rd;ft.ArrayExpression=function(r,t,n){for(var s=0,i=r.elements;s<i.length;s+=1){var a=i[s];a&&n(a,t,"Expression")}};ft.ObjectExpression=function(r,t,n){for(var s=0,i=r.properties;s<i.length;s+=1){var a=i[s];n(a,t)}};ft.FunctionExpression=ft.ArrowFunctionExpression=ft.FunctionDeclaration;ft.SequenceExpression=function(r,t,n){for(var s=0,i=r.expressions;s<i.length;s+=1){var a=i[s];n(a,t,"Expression")}};ft.TemplateLiteral=function(r,t,n){for(var s=0,i=r.quasis;s<i.length;s+=1){var a=i[s];n(a,t)}for(var o=0,u=r.expressions;o<u.length;o+=1){var l=u[o];n(l,t,"Expression")}};ft.TemplateElement=Rd;ft.UnaryExpression=ft.UpdateExpression=function(r,t,n){n(r.argument,t,"Expression")};ft.BinaryExpression=ft.LogicalExpression=function(r,t,n){n(r.left,t,"Expression"),n(r.right,t,"Expression")};ft.AssignmentExpression=ft.AssignmentPattern=function(r,t,n){n(r.left,t,"Pattern"),n(r.right,t,"Expression")};ft.ConditionalExpression=function(r,t,n){n(r.test,t,"Expression"),n(r.consequent,t,"Expression"),n(r.alternate,t,"Expression")};ft.NewExpression=ft.CallExpression=function(r,t,n){if(n(r.callee,t,"Expression"),r.arguments)for(var s=0,i=r.arguments;s<i.length;s+=1){var a=i[s];n(a,t,"Expression")}};ft.MemberExpression=function(r,t,n){n(r.object,t,"Expression"),r.computed&&n(r.property,t,"Expression")};ft.ExportNamedDeclaration=ft.ExportDefaultDeclaration=function(r,t,n){r.declaration&&n(r.declaration,t,r.type==="ExportNamedDeclaration"||r.declaration.id?"Statement":"Expression"),r.source&&n(r.source,t,"Expression")};ft.ExportAllDeclaration=function(r,t,n){r.exported&&n(r.exported,t),n(r.source,t,"Expression")};ft.ImportDeclaration=function(r,t,n){for(var s=0,i=r.specifiers;s<i.length;s+=1){var a=i[s];n(a,t)}n(r.source,t,"Expression")};ft.ImportExpression=function(r,t,n){n(r.source,t,"Expression")};ft.ImportSpecifier=ft.ImportDefaultSpecifier=ft.ImportNamespaceSpecifier=ft.Identifier=ft.PrivateIdentifier=ft.Literal=Rd;ft.TaggedTemplateExpression=function(r,t,n){n(r.tag,t,"Expression"),n(r.quasi,t,"Expression")};ft.ClassDeclaration=ft.ClassExpression=function(r,t,n){return n(r,t,"Class")};ft.Class=function(r,t,n){r.id&&n(r.id,t,"Pattern"),r.superClass&&n(r.superClass,t,"Expression"),n(r.body,t)};ft.ClassBody=function(r,t,n){for(var s=0,i=r.body;s<i.length;s+=1){var a=i[s];n(a,t)}};ft.MethodDefinition=ft.PropertyDefinition=ft.Property=function(r,t,n){r.computed&&n(r.key,t,"Expression"),r.value&&n(r.value,t,"Expression")};const hle=["setup","draw","preload","deviceMoved","deviceTurned","deviceShaken","doubleClicked","mousePressed","mouseReleased","mouseMoved","mouseDragged","mouseClicked","mouseWheel","touchStarted","touchMoved","touchEnded","keyPressed","keyReleased","keyTyped","windowResized"],Ey={fetchScript:async function(r){if(r.src)try{return await fetch(r.src).then(n=>n.text())}catch(t){return console.error("Error fetching script:",t),""}else return r.textContent},extractUserDefinedVariablesAndFuncs:function(r){const t={variables:[],functions:[]},n=-1;try{const s=YW(r,{ecmaVersion:2021,sourceType:"module",locations:!0});lle(s,{VariableDeclarator(i){if(i.id.type==="Identifier"){const a=i.init&&["ArrowFunctionExpression","FunctionExpression"].includes(i.init.type)?"functions":"variables";t[a].push({name:i.id.name,line:i.loc.start.line+n})}},FunctionDeclaration(i){i.id&&i.id.type==="Identifier"&&t.functions.push({name:i.id.name,line:i.loc.start.line+n})},ClassDeclaration(i){i.id&&i.id.type==="Identifier"&&t.variables.push({name:i.id.name,line:i.loc.start.line+n})}})}catch(s){console.error("Error parsing code:",s)}return t},checkForConstsAndFuncs:function(r,t){const n=[...r.variables,...r.functions];function s(a,o,u){const l=`https://p5js.org/reference/p5/${o}`;return`${a} "${o}" on line ${u} is being redeclared and conflicts with a p5.js ${a.toLowerCase()}. p5.js reference: ${l}`}for(let{name:a,line:o}of n)if(Wh[a]!==void 0){const l=s("Constant",a,o);return console.log(l),!0}const i=new Set(Object.getOwnPropertyNames(t.prototype).filter(a=>!a.startsWith("_")&&a!=="constructor"));for(let{name:a,line:o}of n)if(!hle.includes(a)&&i.has(a)){const u=s("Function",a,o);return console.log(u),!0}return!1},getUserCode:async function(){const r=document.querySelectorAll("script"),t=r[r.length-1];return await Ey.fetchScript(t)},runFES:async function(r){const t=await Ey.getUserCode(),n=Ey.extractUserDefinedVariablesAndFuncs(t);Ey.checkForConstsAndFuncs(n,r)}};function ZW(r,t,n){n.presetup=async function(){r.disableFriendlyErrors||Ey.runFES(r)}}typeof p5<"u"&&ZW(p5,p5.prototype);function JW(r,t){const n=(s,i)=>{const a=ar("fes.fileLoadError.suggestion",{filePath:i,url:"https://github.com/processing/p5.js/wiki/Local-server"});switch(s){case 0:return{message:ar("fes.fileLoadError.image",{suggestion:a}),method:"loadImage"};case 1:return{message:ar("fes.fileLoadError.xml",{suggestion:a}),method:"loadXML"};case 2:return{message:ar("fes.fileLoadError.table",{suggestion:a}),method:"loadTable"};case 3:return{message:ar("fes.fileLoadError.strings",{suggestion:a}),method:"loadStrings"};case 4:return{message:ar("fes.fileLoadError.font",{suggestion:a}),method:"loadFont"};case 5:return{message:ar("fes.fileLoadError.json",{suggestion:a}),method:"loadJSON"};case 6:return{message:ar("fes.fileLoadError.bytes",{suggestion:a}),method:"loadBytes"};case 7:return{message:ar("fes.fileLoadError.large"),method:"loadX"};case 8:return{message:ar("fes.fileLoadError.gif"),method:"loadImage"}}};r._friendlyFileLoadError=function(s,i){const{message:a,method:o}=n(s,i);r._friendlyError(a,o,3)}}typeof p5<"u"&&JW(p5,p5.prototype);function dle(r){r.registerAddon(aW),r.registerAddon(oW),r.registerAddon(fW),r.registerAddon(ZW),r.registerAddon(JW)}function QW(r,t){t.storeItem=function(n,s){typeof n!="string"&&console.log(`The argument that you passed to storeItem() - ${n} is not a string.`),n.endsWith("p5TypeID")&&console.log(`The argument that you passed to storeItem() - ${n} must not end with 'p5TypeID'.`),typeof s>"u"&&console.log("You cannot store undefined variables using storeItem().");let i=typeof s;switch(i){case"number":case"boolean":s=s.toString();break;case"object":s instanceof r.Color?(i="p5.Color",s=s.toString()):s instanceof r.Vector&&(i="p5.Vector",s=[s.x,s.y,s.z]),s=JSON.stringify(s);break}localStorage.setItem(n,s);const a=`${n}p5TypeID`;localStorage.setItem(a,i)},t.getItem=function(n){let s=localStorage.getItem(n);const i=localStorage.getItem(`${n}p5TypeID`);if(typeof i>"u")console.log(`Unable to determine type of item stored under ${n}in local storage. Did you save the item with something other than setItem()?`);else if(s!==null)switch(i){case"number":s=parseFloat(s);break;case"boolean":s=s==="true";break;case"object":s=JSON.parse(s);break;case"p5.Color":s=this.color(JSON.parse(s));break;case"p5.Vector":s=JSON.parse(s),s=this.createVector(...s);break}return s},t.clearStorage=function(){Object.keys(localStorage).forEach(s=>{s.endsWith("p5TypeID")&&this.removeItem(s.replace("p5TypeID",""))})},t.removeItem=function(n){typeof n!="string"&&console.log(`The argument that you passed to removeItem() - ${n} is not a string.`),localStorage.removeItem(n),localStorage.removeItem(`${n}p5TypeID`)}}typeof p5<"u"&&QW(p5,p5.prototype);function ple(r){r.registerAddon(QW)}function e8(r,t){t.select=function(i,a){const u=this._getContainer(a).querySelector(i);return u?this._wrapElement(u):null},t.selectAll=function(i,a){const o=[],l=this._getContainer(a).querySelectorAll(i);if(l)for(let c=0;c<l.length;c++){const h=this._wrapElement(l[c]);o.push(h)}return o},t._getContainer=function(i){let a=document;return typeof i=="string"?a=document.querySelector(i)||document:i instanceof Sr?a=i.elt:i instanceof HTMLElement&&(a=i),a},t._wrapElement=function(i){const a=Array.prototype.slice.call(i.children);if(i.tagName==="INPUT"&&i.type==="checkbox"){let o=new Sr(i,this);return o.checked=function(...u){return u.length===0?this.elt.checked:(u[0]?this.elt.checked=!0:this.elt.checked=!1,this)},o}else return i.tagName==="VIDEO"||i.tagName==="AUDIO"?new db(i,this):i.tagName==="SELECT"?this.createSelect(new Sr(i,this)):a.length>0&&a.every(function(o){return o.tagName==="INPUT"||o.tagName==="LABEL"})&&(i.tagName==="DIV"||i.tagName==="SPAN")?this.createRadio(new Sr(i,this)):new Sr(i,this)},t.createElement=function(i,a){const o=document.createElement(i);return typeof a<"u"&&(o.innerHTML=a),n(o,this)},t.removeElements=function(i){const a=u=>!(u.elt instanceof HTMLCanvasElement);this._elements.filter(a).map(u=>u.remove())};function n(i,a,o){(a._userNode?a._userNode:document.body).appendChild(i);const l=o?new db(i,a):new Sr(i,a);return a._elements.push(l),l}t.createDiv=function(i=""){let a=document.createElement("div");return a.innerHTML=i,n(a,this)},t.createP=function(i=""){let a=document.createElement("p");return a.innerHTML=i,n(a,this)},t.createSpan=function(i=""){let a=document.createElement("span");return a.innerHTML=i,n(a,this)},t.createImg=function(){const i=document.createElement("img"),a=arguments;let o;return a.length>1&&typeof a[1]=="string"&&(i.alt=a[1]),a.length>2&&typeof a[2]=="string"&&(i.crossOrigin=a[2]),i.src=a[0],o=n(i,this),i.addEventListener("load",function(){o.width=i.offsetWidth||i.width,o.height=i.offsetHeight||i.height;const u=a[a.length-1];typeof u=="function"&&u(o)}),o},t.createA=function(i,a,o){const u=document.createElement("a");return u.href=i,u.innerHTML=a,o&&(u.target=o),n(u,this)},t.createSlider=function(i,a,o,u){const l=document.createElement("input");return l.type="range",l.min=i,l.max=a,u===0?l.step=1e-18:u&&(l.step=u),typeof o=="number"&&(l.value=o),n(l,this)},t.createButton=function(i,a){const o=document.createElement("button");return o.innerHTML=i,a&&(o.value=a),n(o,this)},t.createCheckbox=function(...i){const a=document.createElement("div"),o=document.createElement("input");o.type="checkbox";const u=document.createElement("label");u.appendChild(o),a.appendChild(u);const l=n(a,this);if(l.checked=function(...c){const h=l.elt.firstElementChild.getElementsByTagName("input")[0];if(h){if(c.length===0)return h.checked;c[0]?h.checked=!0:h.checked=!1}return l},this.value=function(c){return l.value=c,this},i[0]){l.value(i[0]);const c=document.createElement("span");c.innerHTML=i[0],u.appendChild(c)}return i[1]&&(o.checked=!0),l},t.createSelect=function(...i){let a,o=i[0];if(o instanceof Sr&&o.elt instanceof HTMLSelectElement)a=o,this.elt=o.elt;else if(o instanceof HTMLSelectElement)a=n(o,this),this.elt=o;else{const u=document.createElement("select");o&&typeof o=="boolean"&&u.setAttribute("multiple","true"),a=n(u,this),this.elt=u}return a.option=function(u,l){let c;if(u!==void 0){for(let h=0;h<this.elt.length;h+=1)if(this.elt[h].textContent===u){c=h;break}if(c!==void 0)l===!1?this.elt.remove(c):this.elt[c].value=l;else{const h=document.createElement("option");h.textContent=u,h.value=l===void 0?u:l,this.elt.appendChild(h),this._pInst._elements.push(h)}}},a.selected=function(u){if(u!==void 0){for(let l=0;l<this.elt.length;l+=1)this.elt[l].value.toString()===u.toString()&&(this.elt.selectedIndex=l);return this}else if(this.elt.getAttribute("multiple")){let l=[];for(const c of this.elt.selectedOptions)l.push(c.value);return l}else return this.elt.value},a.disable=function(u){if(typeof u=="string")for(let l=0;l<this.elt.length;l++)this.elt[l].value.toString()===u&&(this.elt[l].disabled=!0,this.elt[l].selected=!1);else this.elt.disabled=!0;return this},a.enable=function(u){if(typeof u=="string")for(let l=0;l<this.elt.length;l++)this.elt[l].value.toString()===u&&(this.elt[l].disabled=!1,this.elt[l].selected=!1);else{this.elt.disabled=!1;for(let l=0;l<this.elt.length;l++)this.elt[l].disabled=!1,this.elt[l].selected=!1}return this},a};let s=0;t.createRadio=function(...i){let a,o,u;const l=i[0];l instanceof Sr&&(l.elt instanceof HTMLDivElement||l.elt instanceof HTMLSpanElement)?(a=l,this.elt=l.elt):l instanceof HTMLDivElement||l instanceof HTMLSpanElement?(a=n(l,this),this.elt=l,o=l,typeof i[1]=="string"&&(u=i[1])):(typeof l=="string"&&(u=l),o=document.createElement("div"),a=n(o,this),this.elt=o),a._name=u||`radioOption_${s++}`;const c=p=>p instanceof HTMLInputElement&&p.type==="radio",h=p=>p instanceof HTMLLabelElement,d=p=>p instanceof HTMLSpanElement;return a._getOptionsArray=function(){return Array.from(this.elt.children).filter(p=>c(p)||h(p)&&c(p.firstElementChild)).map(p=>c(p)?p:p.firstElementChild)},a.option=function(p,f){let m;for(const b of a._getOptionsArray())if(b.value===p){m=b;break}m===void 0&&(m=document.createElement("input"),m.setAttribute("type","radio"),m.setAttribute("value",p)),m.setAttribute("name",a._name);let g;h(m.parentElement)?g=m.parentElement:(g=document.createElement("label"),g.insertAdjacentElement("afterbegin",m));let y;return d(g.lastElementChild)?y=g.lastElementChild:(y=document.createElement("span"),m.insertAdjacentElement("afterend",y)),y.innerHTML=f===void 0?p:f,this.elt.appendChild(g),m},a.remove=function(p){for(const f of a._getOptionsArray())if(f.value===p){h(f.parentElement)?f.parentElement.remove():f.remove();return}},a.value=function(){let p="";for(const f of a._getOptionsArray())if(f.checked){p=f.value;break}return p},a.selected=function(p){let f=null;if(p===void 0){for(const m of a._getOptionsArray())if(m.checked){f=m;break}}else{a._getOptionsArray().forEach(m=>{m.checked=!1,m.removeAttribute("checked")});for(const m of a._getOptionsArray())m.value===p&&(m.setAttribute("checked",!0),m.checked=!0,f=m)}return f},a.disable=function(p=!0){for(const f of a._getOptionsArray())f.setAttribute("disabled",p)},a},t.createColorPicker=function(i){const a=document.createElement("input");let o;a.type="color",i?i instanceof r.Color?a.value=i.toString("#rrggbb"):(this.push(),this.colorMode("rgb"),a.value=this.color(i).toString("#rrggbb"),this.pop()):a.value="#000000",o=n(a,this);const u=this;return o.color=function(){u.push(),i&&i.mode&&u.colorMode(i.mode,...i!=null&&i.maxes?i.maxes[i.mode]||[]:[]);const l=u.color(this.elt.value);return u.pop(),l},o},t.createInput=function(i="",a="text"){let o=document.createElement("input");return o.setAttribute("value",i),o.setAttribute("type",a),n(o,this)},t.createFileInput=function(i,a=!1){const o=function(l){for(const c of l.target.files)NT._load(c,i)};if(!(window.File&&window.FileReader&&window.FileList&&window.Blob)){console.log("The File APIs are not fully supported in this browser. Cannot create element.");return}const u=document.createElement("input");return u.setAttribute("type","file"),a&&u.setAttribute("multiple",!0),u.addEventListener("change",o,!1),n(u,this)}}typeof p5<"u"&&e8(p5,p5.prototype);function fle(r){r.registerAddon(e8),r.registerAddon(VU),r.registerAddon(a6),r.registerAddon(BU)}function t8(r,t){t.deviceOrientation=window.innerWidth/window.innerHeight>1?"landscape":"portrait",t.accelerationX=0,t.accelerationY=0,t.accelerationZ=0,t.pAccelerationX=0,t.pAccelerationY=0,t.pAccelerationZ=0,t._updatePAccelerations=function(){this.pAccelerationX=this.accelerationX,this.pAccelerationY=this.accelerationY,this.pAccelerationZ=this.accelerationZ},t.rotationX=0,t.rotationY=0,t.rotationZ=0,t.pRotationX=0,t.pRotationY=0,t.pRotationZ=0;let n=0,s=0,i=0,a="clockwise",o="clockwise",u="clockwise";t.pRotateDirectionX=void 0,t.pRotateDirectionY=void 0,t.pRotateDirectionZ=void 0,t._updatePRotations=function(){this.pRotationX=this.rotationX,this.pRotationY=this.rotationY,this.pRotationZ=this.rotationZ},t.turnAxis=void 0;let l=.5,c=30;t.setMoveThreshold=function(h){l=h},t.setShakeThreshold=function(h){c=h},t._ondeviceorientation=function(h){this._updatePRotations(),this.rotationX=this._fromDegrees(h.beta),this.rotationY=this._fromDegrees(h.gamma),this.rotationZ=this._fromDegrees(h.alpha),this._handleMotion()},t._ondevicemotion=function(h){this._updatePAccelerations(),this.accelerationX=h.acceleration.x*2,this.accelerationY=h.acceleration.y*2,this.accelerationZ=h.acceleration.z*2,this._handleMotion()},t._handleMotion=function(){window.orientation===90||window.orientation===-90?this.deviceOrientation="landscape":window.orientation===0?this.deviceOrientation="portrait":window.orientation===void 0&&(this.deviceOrientation="undefined");const h=this._isGlobal?window:this;if(typeof h.deviceMoved=="function"&&(Math.abs(this.accelerationX-this.pAccelerationX)>l||Math.abs(this.accelerationY-this.pAccelerationY)>l||Math.abs(this.accelerationZ-this.pAccelerationZ)>l)&&h.deviceMoved(),typeof h.deviceTurned=="function"){const d=this._toDegrees(this.rotationX)+180,p=this._toDegrees(this.pRotationX)+180;let f=n+180;d-p>0&&d-p<270||d-p<-270?a="clockwise":(d-p<0||d-p>270)&&(a="counter-clockwise"),a!==this.pRotateDirectionX&&(f=d),Math.abs(d-f)>90&&Math.abs(d-f)<270&&(f=d,this.turnAxis="X",h.deviceTurned()),this.pRotateDirectionX=a,n=f-180;const m=this._toDegrees(this.rotationY)+180,g=this._toDegrees(this.pRotationY)+180;let y=s+180;m-g>0&&m-g<270||m-g<-270?o="clockwise":(m-g<0||m-this.pRotationY>270)&&(o="counter-clockwise"),o!==this.pRotateDirectionY&&(y=m),Math.abs(m-y)>90&&Math.abs(m-y)<270&&(y=m,this.turnAxis="Y",h.deviceTurned()),this.pRotateDirectionY=o,s=y-180;const b=this._toDegrees(this.rotationZ),x=this._toDegrees(this.pRotationZ);b-x>0&&b-x<270||b-x<-270?u="clockwise":(b-x<0||b-x>270)&&(u="counter-clockwise"),u!==this.pRotateDirectionZ&&(i=b),Math.abs(b-i)>90&&Math.abs(b-i)<270&&(i=b,this.turnAxis="Z",h.deviceTurned()),this.pRotateDirectionZ=u,this.turnAxis=void 0}if(typeof h.deviceShaken=="function"){let d,p;this.pAccelerationX!==null&&(d=Math.abs(this.accelerationX-this.pAccelerationX),p=Math.abs(this.accelerationY-this.pAccelerationY)),d+p>c&&h.deviceShaken()}}}typeof p5<"u"&&t8(p5,p5.prototype);function mle(r){return["Alt","Shift","Control","Meta"].includes(r)||typeof r!="string"?!1:r.length>1}function r8(r,t){t.keyIsPressed=!1,t.code=null,t.key="",t.keyCode=0,t._onkeydown=function(n){if(this._downKeys[n.code])return;this.keyIsPressed=!0,this.keyCode=n.which,this.key=n.key,this.code=n.code,this._downKeyCodes[n.code]=!0,this._downKeys[n.key]=!0;const s=this._isGlobal?window:this;typeof s.keyPressed=="function"&&!n.charCode&&s.keyPressed(n)===!1&&n.preventDefault()},t._onkeyup=function(n){const s=this._isGlobal?window:this;if(typeof s.keyReleased=="function"&&s.keyReleased(n)===!1&&n.preventDefault(),delete this._downKeyCodes[n.code],delete this._downKeys[n.key],!this._areDownKeys())this.keyIsPressed=!1,this.key="",this.code=null;else{const i=Object.keys(this._downKeyCodes).pop();this.code=i;const a=Object.keys(this._downKeys).pop();this.key=a}},t._onkeypress=function(n){if(n.which===this._lastKeyCodeTyped&&n.repeat)return;this._lastKeyCodeTyped=n.which,this.key=n.key||String.fromCharCode(n.which)||n.which;const s=this._isGlobal?window:this;typeof s.keyTyped=="function"&&s.keyTyped(n)===!1&&n.preventDefault()},t._onblur=function(n){this._downKeys={}},t.keyIsDown=function(n){return mle(n)?this._downKeyCodes[n]||this._downKeys[n]||!1:this._downKeys[n]||this._downKeyCodes[n]||!1},t._areDownKeys=function(){for(const n in this._downKeys)if(this._downKeys.hasOwnProperty(n)&&this._downKeys[n]===!0)return!0;return!1}}typeof p5<"u"&&r8(p5,p5.prototype);function n8(r,t){t.movedX=0,t.movedY=0,t._hasMouseInteracted=!1,t.mouseX=0,t.mouseY=0,t.pmouseX=0,t.pmouseY=0,t.winMouseX=0,t.winMouseY=0,t.pwinMouseX=0,t.pwinMouseY=0,t.mouseButton={left:!1,right:!1,center:!1},t.touches=[],t._activePointers=new Map,t.mouseIsPressed=!1,t._updatePointerCoords=function(i){if(this._curElement!==null){const a=this._curElement.elt,o=a.scrollWidth/this.width||1,u=a.scrollHeight/this.height||1;if(i.pointerType=="touch"){const c=[];for(const h of this._activePointers.values())c.push(s(a,o,u,h));this.touches=c}const l=n(a,o,u,i);this.movedX=i.movementX||0,this.movedY=i.movementY||0,this.mouseX=l.x,this.mouseY=l.y,this.winMouseX=l.winX,this.winMouseY=l.winY,this._hasMouseInteracted||(this._updateMouseCoords(),this._hasMouseInteracted=!0)}},t._updateMouseCoords=function(){this.pmouseX=this.mouseX,this.pmouseY=this.mouseY,this.pwinMouseX=this.winMouseX,this.pwinMouseY=this.winMouseY,this._pmouseWheelDeltaY=this._mouseWheelDeltaY};function n(i,a,o,u){const l=i.getBoundingClientRect();return{x:(u.clientX-l.left)/a,y:(u.clientY-l.top)/o,winX:u.clientX,winY:u.clientY}}function s(i,a,o,u){const l=i.getBoundingClientRect();return{x:(u.clientX-l.left)/a,y:(u.clientY-l.top)/o,winX:u.clientX,winY:u.clientY,id:u.pointerId}}t._setMouseButton=function(i){this.mouseButton.left=Array.from(this._activePointers.values()).some(a=>(a.buttons&1)!==0),this.mouseButton.center=Array.from(this._activePointers.values()).some(a=>(a.buttons&4)!==0),this.mouseButton.right=Array.from(this._activePointers.values()).some(a=>(a.buttons&2)!==0)},t._onpointermove=function(i){const a=this._isGlobal?window:this;let o;this._updatePointerCoords(i),this._activePointers.set(i.pointerId,i),this._setMouseButton(i),!this.mouseIsPressed&&typeof a.mouseMoved=="function"?(o=a.mouseMoved(i),o===!1&&i.preventDefault()):this.mouseIsPressed&&typeof a.mouseDragged=="function"&&(o=a.mouseDragged(i),o===!1&&i.preventDefault())},t._onpointerdown=function(i){const a=this._isGlobal?window:this;let o;this.mouseIsPressed=!0,this._activePointers.set(i.pointerId,i),this._setMouseButton(i),this._updatePointerCoords(i),typeof a.mousePressed=="function"&&(o=a.mousePressed(i),o===!1&&i.preventDefault())},t._onpointerup=function(i){const a=this._isGlobal?window:this;let o;this.mouseIsPressed=!1,this._activePointers.delete(i.pointerId),this._setMouseButton(i),this._updatePointerCoords(i),typeof a.mouseReleased=="function"&&(o=a.mouseReleased(i),o===!1&&i.preventDefault())},t._ondragend=t._onpointerup,t._ondragover=t._onpointermove,t._onclick=function(i){const a=this._isGlobal?window:this;typeof a.mouseClicked=="function"&&a.mouseClicked(i)===!1&&i.preventDefault()},t._ondblclick=function(i){const a=this._isGlobal?window:this;typeof a.doubleClicked=="function"&&a.doubleClicked(i)===!1&&i.preventDefault()},t._mouseWheelDeltaY=0,t._pmouseWheelDeltaY=0,t._onwheel=function(i){const a=this._isGlobal?window:this;this._mouseWheelDeltaY=i.deltaY,typeof a.mouseWheel=="function"&&(i.delta=i.deltaY,a.mouseWheel(i)===!1&&i.preventDefault())},t.requestPointerLock=function(){const i=this._curElement.elt;return i.requestPointerLock=i.requestPointerLock||i.mozRequestPointerLock,i.requestPointerLock?(i.requestPointerLock(),!0):(console.log("requestPointerLock is not implemented in this browser"),!1)},t.exitPointerLock=function(){document.exitPointerLock()}}typeof p5<"u"&&n8(p5,p5.prototype);function gle(r){r.registerAddon(t8),r.registerAddon(r8),r.registerAddon(n8)}function yle(r){r.registerAddon(zT),r.registerAddon(UT),r.registerAddon(i6),r.registerAddon(BT),r.registerAddon(WT),r.registerAddon(KT)}class ble{constructor(t){this.columns=[],this.rows=[]}toString(t=","){let n=this.rows.map(s=>s.arr);return this.columns.some(s=>s===null)||(n=[this.columns,...n]),gae(n,{separator:t})}addRow(t){const n=t||new p5.TableRow;if(typeof n.arr>"u"||typeof n.obj>"u")throw new Error(`invalid TableRow: ${n}`);return n.table=this,this.rows.push(n),n}removeRow(t){this.rows[t].table=null;const n=this.rows.splice(t+1,this.rows.length);this.rows.pop(),this.rows=this.rows.concat(n)}getRow(t){return this.rows[t]}getRows(){return this.rows}findRow(t,n){if(typeof n=="string"){for(let s=0;s<this.rows.length;s++)if(this.rows[s].obj[this.columns.indexOf(n)]===t)return this.rows[s]}else for(let s=0;s<this.rows.length;s++)if(this.rows[s].arr[n]===t)return this.rows[s];return null}findRows(t,n){const s=[];if(typeof n=="string")for(let i=0;i<this.rows.length;i++)this.rows[i].obj[this.columns.indexOf(n)]===t&&s.push(this.rows[i]);else for(let i=0;i<this.rows.length;i++)this.rows[i].arr[n]===t&&s.push(this.rows[i]);return s}matchRow(t,n){if(typeof n=="number"){for(let s=0;s<this.rows.length;s++)if(this.rows[s].arr[n].match(t))return this.rows[s]}else for(let s=0;s<this.rows.length;s++)if(this.rows[s].obj[this.columns.indexOf(n)].match(t))return this.rows[s];return null}matchRows(t,n){const s=[];if(typeof n=="number")for(let i=0;i<this.rows.length;i++)this.rows[i].arr[n].match(t)&&s.push(this.rows[i]);else for(let i=0;i<this.rows.length;i++)this.rows[i].obj[this.columns.indexOf(n)].match(t)&&s.push(this.rows[i]);return s}getColumn(t){const n=[];if(typeof t=="string")for(let s=0;s<this.rows.length;s++)n.push(this.rows[s].obj[this.columns.indexOf(t)]);else for(let s=0;s<this.rows.length;s++)n.push(this.rows[s].arr[t]);return n}clearRows(){delete this.rows,this.rows=[]}addColumn(t){const n=t||null;this.columns.push(n)}getColumnCount(){return this.columns.length}getRowCount(){return this.rows.length}removeTokens(t,n){const s=o=>o.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&"),i=[];for(let o=0;o<t.length;o++)i.push(s(t.charAt(o)));const a=new RegExp(i.join("|"),"g");if(typeof n>"u")for(let o=0;o<this.columns.length;o++)for(let u=0;u<this.rows.length;u++){let l=this.rows[u].arr[o];l=l.replace(a,""),this.rows[u].arr[o]=l,this.rows[u].obj[this.columns[o]]=l}else if(typeof n=="string")for(let o=0;o<this.rows.length;o++){let u=this.rows[o].obj[n];u=u.replace(a,""),this.rows[o].obj[n]=u;const l=this.columns.indexOf(n);this.rows[o].arr[l]=u}else for(let o=0;o<this.rows.length;o++){let u=this.rows[o].arr[n];u=u.replace(a,""),this.rows[o].arr[n]=u,this.rows[o].obj[this.columns[n]]=u}}trim(t){const n=new RegExp(" ","g");if(typeof t>"u")for(let s=0;s<this.columns.length;s++)for(let i=0;i<this.rows.length;i++){let a=this.rows[i].arr[s];a=a.replace(n,""),this.rows[i].arr[s]=a,this.rows[i].obj[this.columns[s]]=a}else if(typeof t=="string")for(let s=0;s<this.rows.length;s++){let i=this.rows[s].obj[t];i=i.replace(n,""),this.rows[s].obj[t]=i;const a=this.columns.indexOf(t);this.rows[s].arr[a]=i}else for(let s=0;s<this.rows.length;s++){let i=this.rows[s].arr[t];i=i.replace(n,""),this.rows[s].arr[t]=i,this.rows[s].obj[this.columns[t]]=i}}removeColumn(t){let n,s;typeof t=="string"?(n=t,s=this.columns.indexOf(t)):(s=t,n=this.columns[t]);const i=this.columns.splice(s+1,this.columns.length);this.columns.pop(),this.columns=this.columns.concat(i);for(let a=0;a<this.rows.length;a++){const o=this.rows[a].arr,u=o.splice(s+1,o.length);o.pop(),this.rows[a].arr=o.concat(u),delete this.rows[a].obj[n]}}set(t,n,s){this.rows[t].set(n,s)}setNum(t,n,s){this.rows[t].setNum(n,s)}setString(t,n,s){this.rows[t].setString(n,s)}get(t,n){return typeof n=="string"?this.rows[t].get(this.columns.indexOf(n)):this.rows[t].get(n)}getNum(t,n){return this.rows[t].getNum(n)}getString(t,n){return this.rows[t].getString(n)}getObject(t){const n={};let s,i,a;for(let o=0;o<this.rows.length;o++)if(s=this.rows[o].obj,typeof t=="string")if(i=this.columns.indexOf(t),i>=0)a=s[t],n[a]=s;else throw new Error(`This table has no column named "${t}"`);else n[o]=this.rows[o].obj;return n}getArray(){const t=[];for(let n=0;n<this.rows.length;n++)t.push(this.rows[n].arr);return t}}function s8(r,t){r.Table=ble}typeof p5<"u"&&s8(p5,p5.prototype);class xle{constructor(t=[]){let n=t;this.arr=n,this.obj=Object.fromEntries(n.entries()),this.table=null}set(t,n){if(typeof t=="string"){const s=this.table.columns.indexOf(t);if(s>=0)this.obj[t]=n,this.arr[s]=n;else throw new Error(`This table has no column named "${t}"`)}else if(t<this.table.columns.length){this.arr[t]=n;const s=this.table.columns[t];this.obj[s]=n}else throw new Error(`Column #${t} is out of the range of this table`)}setNum(t,n){const s=parseFloat(n);this.set(t,s)}setString(t,n){const s=n.toString();this.set(t,s)}get(t){return typeof t=="string"?this.obj[this.table.columns.indexOf(t)]:this.arr[t]}getNum(t){let n;if(typeof t=="string"?n=parseFloat(this.obj[this.table.columns.indexOf(t)]):n=parseFloat(this.arr[t]),n.toString()==="NaN")throw`Error: ${this.obj[t]} is NaN (Not a Number)`;return n}getString(t){return typeof t=="string"?this.obj[this.table.columns.indexOf(t)].toString():this.arr[t].toString()}}function i8(r,t){r.TableRow=xle}typeof p5<"u"&&i8(p5,p5.prototype);function vle(r){r.registerAddon(_6),r.registerAddon(s8),r.registerAddon(i8),r.registerAddon(PU)}function a8(r,t){t.abs=Math.abs,t.ceil=Math.ceil,t.constrain=function(n,s,i){return Math.max(Math.min(n,i),s)},t.dist=function(...n){if(n.length===4)return Math.hypot(n[2]-n[0],n[3]-n[1]);if(n.length===6)return Math.hypot(n[3]-n[0],n[4]-n[1],n[5]-n[2])},t.exp=Math.exp,t.floor=Math.floor,t.lerp=function(n,s,i){return i*(s-n)+n},t.log=Math.log,t.mag=function(n,s){return Math.hypot(n,s)},t.map=function(n,s,i,a,o,u){const l=(n-s)/(i-s)*(o-a)+a;return u?a<o?this.constrain(l,a,o):this.constrain(l,o,a):l},t.max=function(...n){const s=i=>{let a=-1/0;for(let o of i)a=Math.max(a,o);return a};return n[0]instanceof Array?s(n[0]):s(n)},t.min=function(...n){const s=i=>{let a=1/0;for(let o of i)a=Math.min(a,o);return a};return n[0]instanceof Array?s(n[0]):s(n)},t.norm=function(n,s,i){return this.map(n,s,i,0,1)},t.pow=Math.pow,t.round=function(n,s){if(!s)return Math.round(n);const i=Math.pow(10,s);return Math.round(n*i)/i},t.sq=n=>n*n,t.sqrt=Math.sqrt,t.fract=function(n){let s=0,i=Number(n);if(isNaN(i)||Math.abs(i)===1/0)return i;if(i<0&&(i=-i,s=1),String(i).includes(".")&&!String(i).includes("e")){let a=String(i);return a=+("0"+a.slice(a.indexOf("."))),Math.abs(s-a)}else return i<1?Math.abs(s-i):0}}typeof p5<"u"&&a8(p5,p5.prototype);function o8(r,t){let u=4,l=.5;const c=d=>.5*(1-Math.cos(d*Math.PI));let h;t.noise=function(d,p=0,f=0){if(h==null){h=new Array(4096);for(let k=0;k<4096;k++)h[k]=Math.random()}d<0&&(d=-d),p<0&&(p=-p),f<0&&(f=-f);let m=Math.floor(d),g=Math.floor(p),y=Math.floor(f),b=d-m,x=p-g,w=f-y,v,S,E=0,C=.5,I,_,A;for(let k=0;k<u;k++){let N=m+(g<<4)+(y<<8);v=c(b),S=c(x),I=h[N&4095],I+=v*(h[N+1&4095]-I),_=h[N+16&4095],_+=v*(h[N+16+1&4095]-_),I+=S*(_-I),N+=256,_=h[N&4095],_+=v*(h[N+1&4095]-_),A=h[N+16&4095],A+=v*(h[N+16+1&4095]-A),_+=S*(A-_),I+=c(w)*(_-I),E+=I*C,C*=l,m<<=1,b*=2,g<<=1,x*=2,y<<=1,w*=2,b>=1&&(m++,b--),x>=1&&(g++,x--),w>=1&&(y++,w--)}return E},t.noiseDetail=function(d,p){d>0&&(u=d),p>0&&(l=p)},t.noiseSeed=function(d){const p=(()=>{let y,b;return{setSeed(x){b=y=(x??Math.random()*4294967296)>>>0},getSeed(){return y},rand(){return b=(1664525*b+1013904223)%4294967296,b/4294967296}}})();p.setSeed(d),h=new Array(4096);for(let f=0;f<4096;f++)h[f]=p.rand()}}typeof p5<"u"&&o8(p5,p5.prototype);function u8(r,t){const n="_lcg_random_state";let o=0;t._lcg=function(u){return this[u]=(1664525*this[u]+1013904223)%4294967296,this[u]/4294967296},t._lcgSetSeed=function(u,l){this[u]=(l??Math.random()*4294967296)>>>0},t.randomSeed=function(u){this._lcgSetSeed(n,u),this._gaussian_previous=!1},t.random=function(u,l){let c;if(this[n]!=null?c=this._lcg(n):c=Math.random(),typeof u>"u")return c;if(typeof l>"u")return u instanceof Array?u[Math.floor(c*u.length)]:c*u;if(u>l){const h=u;u=l,l=h}return c*(l-u)+u},t.randomGaussian=function(u,l=1){let c,h,d,p;if(this._gaussian_previous)c=o,this._gaussian_previous=!1;else{do h=this.random(2)-1,d=this.random(2)-1,p=h*h+d*d;while(p>=1);p=Math.sqrt(-2*Math.log(p)/p),c=h*p,o=d*p,this._gaussian_previous=!0}const f=u||0;return c*l+f}}typeof p5<"u"&&u8(p5,p5.prototype);function l8(r,t){t.createVector=function(n,s,i){return this instanceof r?new r.Vector(this._fromRadians.bind(this),this._toRadians.bind(this),...arguments):new r.Vector(n,s,i)},t.createMatrix=function(...n){return new r.Matrix(...n)}}typeof p5<"u"&&l8(p5,p5.prototype);function wle(r){r.registerAddon(a8),r.registerAddon(o8),r.registerAddon(u8),r.registerAddon(VT),r.registerAddon(l8),r.registerAddon(yU)}function c8(r,t){t.float=function(n){return n instanceof Array?n.map(parseFloat):parseFloat(n)},t.int=function(n,s=10){if(n===1/0||n==="Infinity")return 1/0;if(n===-1/0||n==="-Infinity")return-1/0;if(typeof n=="string")return parseInt(n,s);if(typeof n=="number")return n|0;if(typeof n=="boolean")return n?1:0;if(n instanceof Array)return n.map(i=>t.int(i,s))},t.str=function(n){return n instanceof Array?n.map(t.str):String(n)},t.boolean=function(n){if(typeof n=="number")return n!==0;if(typeof n=="string")return n.toLowerCase()==="true";if(typeof n=="boolean")return n;if(n instanceof Array)return n.map(t.boolean)},t.byte=function(n){const s=t.int(n,10);if(typeof s=="number")return(s+128)%256-128;if(s instanceof Array)return s.map(t.byte)},t.char=function(n){if(typeof n=="number"&&!isNaN(n))return String.fromCharCode(n);if(n instanceof Array)return n.map(t.char);if(typeof n=="string")return t.char(parseInt(n,10))},t.unchar=function(n){if(typeof n=="string"&&n.length===1)return n.charCodeAt(0);if(n instanceof Array)return n.map(t.unchar)},t.hex=function(n,s){if(s=s??(s=8),n instanceof Array)return n.map(i=>t.hex(i,s));if(n===1/0||n===-1/0)return(n===1/0?"F":"0").repeat(s);if(typeof n=="number"){n<0&&(n=4294967295+n+1);let i=Number(n).toString(16).toUpperCase();for(;i.length<s;)i=`0${i}`;return i.length>=s&&(i=i.substring(i.length-s,i.length)),i}},t.unhex=function(n){return n instanceof Array?n.map(t.unhex):parseInt(`0x${n}`,16)}}typeof p5<"u"&&c8(p5,p5.prototype);function h8(r,t){t.nf=function(o,u,l){return o instanceof Array?o.map(c=>n(c,u,l)):Object.prototype.toString.call(o)==="[object Arguments]"?o.length===3?this.nf(o[0],o[1],o[2]):o.length===2?this.nf(o[0],o[1]):this.nf(o[0]):n(o,u,l)};function n(o,u,l){let c=o<0;o=Math.abs(o);let[h,d]=o.toString().split(".");if(typeof l>"u"){h=h.padStart(u,"0");let p=d?h+"."+d:h;return c?"-"+p:p}else{[h,d]=o.toFixed(l).toString().split("."),h=h.padStart(u,"0");let f=typeof d>"u"?h:h+"."+d;return c?"-"+f:f}}t.nfc=function(o,u){return o instanceof Array?o.map(l=>s(l,u)):s(o,u)};function s(o,u){o=o.toString();const l=o.indexOf(".");let c=l!==-1?o.substring(l):"",h=l!==-1?o.substring(0,l):o;if(h=h.toString().replace(/\B(?=(\d{3})+(?!\d))/g,","),u===0)c="";else if(typeof u<"u")if(u>c.length){c+=l===-1?".":"";const d=u-c.length+1;for(let p=0;p<d;p++)c+="0"}else c=c.substring(0,u+1);return h+c}t.nfp=function(...o){const u=t.nf.apply(this,o);return u instanceof Array?u.map(i):i(u)};function i(o){return parseFloat(o)>0?`+${o.toString()}`:o.toString()}t.nfs=function(...o){const u=t.nf.apply(this,o);return u instanceof Array?u.map(a):a(u)};function a(o){return parseFloat(o)>=0?` ${o.toString()}`:o.toString()}t.splitTokens=function(o,u){let l;if(typeof u<"u"){let c=u;const h=/\]/g.exec(c);let d=/\[/g.exec(c);d&&h?(c=c.slice(0,h.index)+c.slice(h.index+1),d=/\[/g.exec(c),c=c.slice(0,d.index)+c.slice(d.index+1),l=new RegExp(`[\\[${c}\\]]`,"g")):h?(c=c.slice(0,h.index)+c.slice(h.index+1),l=new RegExp(`[${c}\\]]`,"g")):d?(c=c.slice(0,d.index)+c.slice(d.index+1),l=new RegExp(`[${c}\\[]`,"g")):l=new RegExp(`[${c}]`,"g")}else l=/\s/g;return o.split(l).filter(c=>c)},t.shuffle=function(o,u){const l=ArrayBuffer&&ArrayBuffer.isView&&ArrayBuffer.isView(o);o=u||l?o:o.slice();let c,h,d=o.length;for(;d>1;)c=this.random(0,1)*d|0,h=o[--d],o[d]=o[c],o[c]=h;return o}}typeof p5<"u"&&h8(p5,p5.prototype);function d8(r,t){t.day=function(){return new Date().getDate()},t.hour=function(){return new Date().getHours()},t.minute=function(){return new Date().getMinutes()},t.millis=function(){return this._millisStart===-1?0:window.performance.now()-this._millisStart},t.month=function(){return new Date().getMonth()+1},t.second=function(){return new Date().getSeconds()},t.year=function(){return new Date().getFullYear()}}typeof p5<"u"&&d8(p5,p5.prototype);function Sle(r){r.registerAddon(c8),r.registerAddon(h8),r.registerAddon(d8)}function p8(r,t){t.orbitControl=function(n,s,i,a){this._assert3d("orbitControl");const o=this._renderer.states.curCamera;typeof n>"u"&&(n=1),typeof s>"u"&&(s=n),typeof i>"u"&&(i=1),typeof a!="object"&&(a={}),this.contextMenuDisabled!==!0&&(this.canvas.oncontextmenu=()=>!1,this.contextMenuDisabled=!0),this.wheelDefaultDisabled!==!0&&(this.canvas.onwheel=()=>!1,this.wheelDefaultDisabled=!0);const{disableTouchActions:u=!0}=a;this.touchActionsDisabled!==!0&&u&&(this.canvas.style["touch-action"]="none",this.touchActionsDisabled=!0);const{freeRotation:l=!1}=a,c=[];this.touches.forEach(E=>{this._renderer.prevTouches.forEach(C=>{if(E.id===C.id){const I={x:E.x,y:E.y,px:C.x,py:C.y};c.push(I)}})}),this._renderer.prevTouches=this.touches;let h=0,d=0,p=0,f=0,m=0;const g=.85,y=.6,b=.15,x=.01,w=4e-4,v=this.height<this.width?this.height:this.width;let S=!1;if(c.length>0){if(S=c[0].x>0&&c[0].x<this.width&&c[0].y>0&&c[0].y<this.height,c.length===1){const E=c[0];d=-n*(E.x-E.px)/v,p=s*(E.y-E.py)/v}else{const E=c[0],C=c[1],I=Math.hypot(E.x-C.x,E.y-C.y),_=Math.hypot(E.px-C.px,E.py-C.py);h=-(I-_)*i*w,f=.5*(E.x+C.x)-.5*(E.px+C.px),m=.5*(E.y+C.y)-.5*(E.py+C.py)}this.touches.length>0?S&&(this._renderer.executeRotateAndMove=!0,this._renderer.executeZoom=!0):(this._renderer.executeRotateAndMove=!1,this._renderer.executeZoom=!1)}else S=this.mouseX>0&&this.mouseX<this.width&&this.mouseY>0&&this.mouseY<this.height,this._mouseWheelDeltaY!==0?(h=Math.sign(this._mouseWheelDeltaY)*i,h*=x,this._mouseWheelDeltaY=0,S&&(this._renderer.executeZoom=!0)):this._renderer.executeZoom=!1,this.mouseIsPressed?(this.mouseButton.left?(d=-n*this.movedX/v,p=s*this.movedY/v):this.mouseButton.right&&(f=this.movedX,m=this.movedY*o.yScale),S&&(this._renderer.executeRotateAndMove=!0)):this._renderer.executeRotateAndMove=!1;if(h!==0&&this._renderer.executeZoom&&(this._renderer.zoomVelocity+=h),Math.abs(this._renderer.zoomVelocity)>.001?(l?o._orbitFree(0,0,this._renderer.zoomVelocity):o._orbit(0,0,this._renderer.zoomVelocity),o.projMatrix.mat4[15]!==0&&(o.projMatrix.mat4[0]*=Math.pow(10,-this._renderer.zoomVelocity),o.projMatrix.mat4[5]*=Math.pow(10,-this._renderer.zoomVelocity),this._renderer.states.setValue("uPMatrix",this._renderer.states.uPMatrix.clone()),this._renderer.states.uPMatrix.mat4[0]=o.projMatrix.mat4[0],this._renderer.states.uPMatrix.mat4[5]=o.projMatrix.mat4[5]),this._renderer.zoomVelocity*=g):this._renderer.zoomVelocity=0,(d!==0||p!==0)&&this._renderer.executeRotateAndMove&&this._renderer.rotateVelocity.add(d*y,p*y),this._renderer.rotateVelocity.magSq()>1e-6?(l?o._orbitFree(-this._renderer.rotateVelocity.x,this._renderer.rotateVelocity.y,0):o._orbit(this._renderer.rotateVelocity.x,this._renderer.rotateVelocity.y,0),this._renderer.rotateVelocity.mult(g)):this._renderer.rotateVelocity.set(0,0),(f!==0||m!==0)&&this._renderer.executeRotateAndMove){const E=f*2/this.width,C=-m*2/this.height;this._renderer.moveVelocity.add(E*b,C*b)}if(this._renderer.moveVelocity.magSq()>1e-6){const E=o._getLocalAxes(),C=o.eyeX-o.centerX,I=o.eyeY-o.centerY,_=o.eyeZ-o.centerZ,A=Math.sqrt(C*C+I*I+_*_);let k=new De(o.centerX,o.centerY,o.centerZ);k=o.cameraMatrix.multiplyPoint(k),k=this._renderer.states.uPMatrix.multiplyAndNormalizePoint(k),k.x-=this._renderer.moveVelocity.x,k.y-=this._renderer.moveVelocity.y;let N,D;const F=this._renderer.states.uPMatrix.mat4;F[15]===0?(N=(F[8]+k.x)/F[0]*A,D=(F[9]+k.y)/F[5]*A):(N=(k.x-F[12])/F[0],D=(k.y-F[13])/F[5]),o.setPosition(o.eyeX+N*E.x[0]+D*E.y[0],o.eyeY+N*E.x[1]+D*E.y[1],o.eyeZ+N*E.x[2]+D*E.y[2]),this._renderer.moveVelocity.mult(g)}else this._renderer.moveVelocity.set(0,0);return this},t.debugMode=function(...n){this._assert3d("debugMode");for(let s=r.lifecycleHooks.postdraw.length-1;s>=0;s--)(r.lifecycleHooks.postdraw[s].toString()===this._grid().toString()||r.lifecycleHooks.postdraw[s].toString()===this._axesIcon().toString())&&r.lifecycleHooks.postdraw.splice(s,1);n[0]===dU?r.lifecycleHooks.postdraw.push(this._grid(n[1],n[2],n[3],n[4],n[5])):n[0]===pU?r.lifecycleHooks.postdraw.push(this._axesIcon(n[1],n[2],n[3],n[4])):(r.lifecycleHooks.postdraw.push(this._grid(n[0],n[1],n[2],n[3],n[4])),r.lifecycleHooks.postdraw.push(this._axesIcon(n[5],n[6],n[7],n[8])))},t.noDebugMode=function(){this._assert3d("noDebugMode");for(let n=r.lifecycleHooks.postdraw.length-1;n>=0;n--)(r.lifecycleHooks.postdraw[n].toString()===this._grid().toString()||r.lifecycleHooks.postdraw[n].toString()===this._axesIcon().toString())&&r.lifecycleHooks.postdraw.splice(n,1)},t._grid=function(n,s,i,a,o){typeof n>"u"&&(n=this.width/2),typeof s>"u"&&(s=Math.round(n/30)<4?4:Math.round(n/30)),typeof i>"u"&&(i=0),typeof a>"u"&&(a=0),typeof o>"u"&&(o=0);const u=n/s,l=n/2;return function(){this.push(),this.stroke(this._renderer.states.curStrokeColor[0]*255,this._renderer.states.curStrokeColor[1]*255,this._renderer.states.curStrokeColor[2]*255),this._renderer.states.setValue("uModelMatrix",this._renderer.states.uModelMatrix.clone()),this._renderer.states.uModelMatrix.reset();for(let c=0;c<=s;c++)this.beginShape(this.LINES),this.vertex(-l+i,a,c*u-l+o),this.vertex(+l+i,a,c*u-l+o),this.endShape();for(let c=0;c<=s;c++)this.beginShape(this.LINES),this.vertex(c*u-l+i,a,-l+o),this.vertex(c*u-l+i,a,+l+o),this.endShape();this.pop()}},t._axesIcon=function(n,s,i,a){return typeof n>"u"&&(n=this.width/20>40?this.width/20:40),typeof s>"u"&&(s=-this.width/4),typeof i>"u"&&(i=s),typeof a>"u"&&(a=s),()=>{this.push(),this._renderer.states.setValue("uModelMatrix",this._renderer.states.uModelMatrix.clone()),this._renderer.states.uModelMatrix.reset(),this.strokeWeight(2),this.stroke(255,0,0),this.beginShape(this.LINES),this.vertex(s,i,a),this.vertex(s+n,i,a),this.endShape(),this.stroke(0,255,0),this.beginShape(this.LINES),this.vertex(s,i,a),this.vertex(s,i+n,a),this.endShape(),this.stroke(0,0,255),this.beginShape(this.LINES),this.vertex(s,i,a),this.vertex(s,i,a+n),this.endShape(),this.pop()}}}typeof p5<"u"&&p8(p5,p5.prototype);async function Cle(r){try{return(await fetch(r,{method:"HEAD"})).ok}catch{return!1}}function f8(r,t){t.loadModel=async function(h,d,p,f,m){let g=!1,y=!1;typeof d=="object"?(p=d.normalize||!1,f=d.successCallback,m=d.failureCallback,d=d.fileType||d,g=d.flipU||!1,y=d.flipV||!1):(typeof arguments[arguments.length-1]=="function"&&(typeof arguments[arguments.length-2]=="function"?(f=arguments[arguments.length-2],m=arguments[arguments.length-1]):f=arguments[arguments.length-1]),typeof d=="string"?typeof p!="boolean"&&(p=!1):typeof d=="boolean"?(p=d,d=h.slice(-4)):(d=h.slice(-4),p=!1)),d.toLowerCase()!==".obj"&&d.toLowerCase()!==".stl"&&(d=".obj");const b=new ks(void 0,void 0,void 0,this._renderer);b.gid=`${h}|${p}`;async function x(w){const v=[];for(let S of w){const E=S.match(/^mtllib (.+)/);if(E){let C="";const I=E[1],_=h.split("/");_.length>1?(_.pop(),C=_.join("/")+"/"+I):C=I,v.push(Cle(C).then(A=>A?n(C):(console.warn(`MTL file not found or error in parsing; proceeding without materials: ${C}`),{})).catch(A=>(console.warn(`Error loading MTL file: ${C}`,A),{})))}}try{const S=await Promise.all(v);return Object.assign({},...S)}catch{return{}}}try{if(d.match(/\.stl$/i)){const{data:w}=await ca(h,"arrayBuffer");return i(b,w),p&&b.normalize(),g&&b.flipU(),y&&b.flipV(),b._makeTriangleEdges(),f?f(b):b}else if(d.match(/\.obj$/i)){const{data:w}=await ca(h,"text"),v=w.split(`
`),S=await x(v);return s(b,v,S),p&&b.normalize(),g&&b.flipU(),y&&b.flipV(),b._makeTriangleEdges(),f?f(b):b}}catch(w){if(r._friendlyFileLoadError(3,h),m)return m(w);throw w}};async function n(h){let d=null,p={};const{data:f}=await ca(h,"text"),m=f.split(`
`);for(let g=0;g<m.length;++g){const y=m[g].trim().split(/\s+/);y[0]==="newmtl"?(d=y[1],p[d]={}):y[0]==="Kd"?p[d].diffuseColor=[parseFloat(y[1]),parseFloat(y[2]),parseFloat(y[3])]:y[0]==="Ka"?p[d].ambientColor=[parseFloat(y[1]),parseFloat(y[2]),parseFloat(y[3])]:y[0]==="Ks"?p[d].specularColor=[parseFloat(y[1]),parseFloat(y[2]),parseFloat(y[3])]:y[0]==="map_Kd"&&(p[d].texturePath=y[1])}return p}function s(h,d,p={}){const f={v:[],vt:[],vn:[]},m={};let g=null,y=!1,b=!1;for(let x=0;x<d.length;++x){const w=d[x].trim().split(/\b\s+/);if(w.length>0){if(w[0]==="usemtl")g=w[1];else if(w[0]==="v"||w[0]==="vn"){const v=new De(parseFloat(w[1]),parseFloat(w[2]),parseFloat(w[3]));f[w[0]].push(v)}else if(w[0]==="vt"){const v=[parseFloat(w[1]),1-parseFloat(w[2])];f[w[0]].push(v)}else if(w[0]==="f")for(let v=3;v<w.length;++v){const S=[],E=[1,v-1,v];for(let C=0;C<E.length;++C){const I=w[E[C]];let _=I.split("/");for(let A=0;A<_.length;A++)_[A]=parseInt(_[A])-1;if(m[I]||(m[I]={}),m[I][g]===void 0){const A=h.vertices.length;if(h.vertices.push(f.v[_[0]].copy()),h.uvs.push(f.vt[_[1]]?f.vt[_[1]].slice():[0,0]),h.vertexNormals.push(f.vn[_[2]]?f.vn[_[2]].copy():new De),m[I][g]=A,S.push(A),g&&p[g]&&p[g].diffuseColor){y=!0;const k=p[g].diffuseColor;h.vertexColors.push(k[0]),h.vertexColors.push(k[1]),h.vertexColors.push(k[2]),h.vertexColors.push(1)}else b=!0}else S.push(m[I][g])}S[0]!==S[1]&&S[0]!==S[2]&&S[1]!==S[2]&&h.faces.push(S)}}}if(h.vertexNormals.length===0&&h.computeNormals(),y===b)throw new Error("Model coloring is inconsistent. Either all vertices should have colors or none should.");return h}function i(h,d){if(a(d))u(h,d);else{const p=new DataView(d);if(!("TextDecoder"in window))return console.warn("Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)"),h;const g=new TextDecoder("utf-8").decode(p).split(`
`);l(h,g)}return h}function a(h){const d=new DataView(h),p=[115,111,108,105,100];for(let f=0;f<5;f++)if(o(p,d,f))return!1;return!0}function o(h,d,p){for(let f=0,m=h.length;f<m;f++)if(h[f]!==d.getUint8(p+f,!1))return!1;return!0}function u(h,d){const p=new DataView(d),f=p.getUint32(80,!0);let m,g,y,b=!1,x,w,v,S;for(let I=0;I<70;I++)p.getUint32(I,!1)===1129270351&&p.getUint8(I+4)===82&&p.getUint8(I+5)===61&&(b=!0,x=[],w=p.getUint8(I+6)/255,v=p.getUint8(I+7)/255,S=p.getUint8(I+8)/255);const E=84,C=12*4+2;for(let I=0;I<f;I++){const _=E+I*C,A=p.getFloat32(_,!0),k=p.getFloat32(_+4,!0),N=p.getFloat32(_+8,!0);if(b){const F=p.getUint16(_+48,!0);(F&32768)===0?(m=(F&31)/31,g=(F>>5&31)/31,y=(F>>10&31)/31):(m=w,g=v,y=S)}const D=new De(A,k,N);for(let F=1;F<=3;F++){const P=_+F*12,G=new De(p.getFloat32(P,!0),p.getFloat32(P+4,!0),p.getFloat32(P+8,!0));h.vertices.push(G),h.vertexNormals.push(D),b&&x.push(m,g,y)}h.faces.push([3*I,3*I+1,3*I+2]),h.uvs.push([0,0],[0,0],[0,0])}return h}function l(h,d){let p="",f=[],m,g;for(let y=0;y<d.length;++y){const b=d[y].trim(),x=b.split(" ");for(let w=0;w<x.length;++w)x[w]===""&&x.splice(w,1);if(x.length!==0)switch(p){case"":if(x[0]!=="solid"){console.error(b),console.error(`Invalid state "${x[0]}", should be "solid"`);return}else p="solid";break;case"solid":if(x[0]!=="facet"||x[1]!=="normal"){console.error(b),console.error(`Invalid state "${x[0]}", should be "facet normal"`);return}else m=new De(parseFloat(x[2]),parseFloat(x[3]),parseFloat(x[4])),h.vertexNormals.push(m,m,m),p="facet normal";break;case"facet normal":if(x[0]!=="outer"||x[1]!=="loop"){console.error(b),console.error(`Invalid state "${x[0]}", should be "outer loop"`);return}else p="vertex";break;case"vertex":if(x[0]==="vertex")g=new De(parseFloat(x[1]),parseFloat(x[2]),parseFloat(x[3])),h.vertices.push(g),h.uvs.push([0,0]),f.push(h.vertices.indexOf(g));else if(x[0]==="endloop")h.faces.push(f),f=[],p="endloop";else{console.error(b),console.error(`Invalid state "${x[0]}", should be "vertex" or "endloop"`);return}break;case"endloop":if(x[0]!=="endfacet"){console.error(b),console.error(`Invalid state "${x[0]}", should be "endfacet"`);return}else p="endfacet";break;case"endfacet":if(x[0]!=="endsolid")if(x[0]==="facet"&&x[1]==="normal")m=new De(parseFloat(x[2]),parseFloat(x[3]),parseFloat(x[4])),h.vertexNormals.push(m,m,m),p="facet normal";else{console.error(b),console.error(`Invalid state "${x[0]}", should be "endsolid" or "facet normal"`);return}break;default:console.error(`Invalid state "${p}"`);break}}return h}t.model=function(h,d=1){this._assert3d("model"),this._renderer.model(h,d)};let c=0;t.createModel=function(h,d=" ",p){let f=!1,m,g,y=!1,b=!1;p&&typeof p=="object"?(f=p.normalize||!1,m=p.successCallback,g=p.failureCallback,y=p.flipU||!1,b=p.flipV||!1):typeof p=="boolean"?(f=p,m=arguments[3],g=arguments[4]):(m=typeof arguments[2]=="function"?arguments[2]:void 0,g=arguments[3]);const x=new r.Geometry;if(x.gid=`${d}|${f}|${c++}`,d.match(/\.stl$/i))try{let v=new TextEncoder().encode(h).buffer;i(x,v)}catch(w){g?g(w):r._friendlyError("Error during parsing: "+w.message);return}else if(d.match(/\.obj$/i))try{const w=h.split(`
`);s(x,w)}catch(w){g?g(w):r._friendlyError("Error during parsing: "+w.message);return}else r._friendlyFileLoadError(3,h),g?g():r._friendlyError("Sorry, the file type is invalid. Only OBJ and STL files are supported.");return f&&x.normalize(),y&&x.flipU(),b&&x.flipV(),x._makeTriangleEdges(),typeof m=="function"&&m(x),x}}typeof p5<"u"&&f8(p5,p5.prototype);const Vi={IDEOGRAPHIC:"ideographic",_CTX_MIDDLE:"middle",_TEXT_BOUNDS:"_textBoundsSingle",_FONT_BOUNDS:"_fontBoundsSingle",HANGING:"hanging",START:"start",END:"end"};function m8(r,t){const s="#000000",i=/\r?\n/g,a=/,\s+/,o=/^".*"$/,u=/\t/g,l="fontVariationSettings",c=["wght","wdth","ital","slnt","opsz"],h=new RegExp(`(?:${c.join("|")})`);["text","textAlign","textAscent","textDescent","textLeading","textMode","textFont","textSize","textStyle","textWidth","textWrap","textBounds","textDirection","textProperty","textProperties","fontBounds","fontWidth","fontAscent","fontDescent","textWeight"].forEach(x=>{t[x]=function(...w){if(!(x in Gt.prototype))throw Error(`Renderer2D.prototype.${x} is not defined.`);return this._renderer[x](...w)},r.Graphics.prototype[x]=function(...w){return this._renderer[x](...w)}});const p={textAlign:{default:t.LEFT,type:"Context2d"},textBaseline:{default:t.BASELINE,type:"Context2d"},textFont:{default:{family:"sans-serif"}},textLeading:{default:15},textSize:{default:12},textWrap:{default:t.WORD},fontStretch:{default:t.NORMAL,isShorthand:!0},fontWeight:{default:t.NORMAL,isShorthand:!0},lineHeight:{default:t.NORMAL,isShorthand:!0},fontVariant:{default:t.NORMAL,isShorthand:!0},fontStyle:{default:t.NORMAL,isShorthand:!0},direction:{default:"inherit"}},f=["font","direction","fontKerning","fontStretch","fontVariantCaps","letterSpacing","textAlign","textBaseline","textRendering","wordSpacing"],m=Object.keys(p).filter(x=>p[x].isShorthand),g=["ultra-condensed","extra-condensed","condensed","semi-condensed","normal","semi-expanded","expanded","extra-expanded","ultra-expanded"];let y,b;if(Gt.prototype.text=function(x,w,v,S,E){let C=this.textDrawingContext().textBaseline;({x:w,y:v,width:S,height:E}=this._handleRectMode(w,v,S,E));let I=this._processLines(x,S,E);I=this._positionLines(w,v,S,E,I),I.forEach(_=>this._renderText(_.text,_.x,_.y)),this.textDrawingContext().textBaseline=C},Gt.prototype.textBounds=function(x,w,v,S,E){return this._computeBounds(Vi._TEXT_BOUNDS,x,w,v,S,E).bounds},Gt.prototype.fontBounds=function(x,w,v,S,E){return this._computeBounds(Vi._FONT_BOUNDS,x,w,v,S,E).bounds},Gt.prototype.textWidth=function(x){let w=this._processLines(x);return Math.max(...w.map(v=>this._textWidthSingle(v)))},Gt.prototype.fontWidth=function(x){let w=this._processLines(x);return Math.max(...w.map(v=>this._fontWidthSingle(v)))},Gt.prototype.textAscent=function(x=""){return x.length?this.textDrawingContext().measureText(x).actualBoundingBoxAscent:this.fontAscent()},Gt.prototype.fontAscent=function(){return this.textDrawingContext().measureText("_").fontBoundingBoxAscent},Gt.prototype.textDescent=function(x=""){return x.length?this.textDrawingContext().measureText(x).actualBoundingBoxDescent:this.fontDescent()},Gt.prototype.fontDescent=function(){return this.textDrawingContext().measureText("_").fontBoundingBoxDescent},Gt.prototype.textAlign=function(x,w){return typeof x<"u"?(this.states.setValue("textAlign",x),typeof w<"u"&&(w===t.CENTER&&(w=Vi._CTX_MIDDLE),this.states.setValue("textBaseline",w)),this._applyTextProperties()):{horizontal:this.states.textAlign,vertical:this.states.textBaseline}},Gt.prototype._currentTextFont=function(){return this.states.textFont.font||this.states.textFont.family},Gt.prototype.textFont=function(x,w,v){var E;if(arguments.length===0)return this._currentTextFont();let S=x;if(x instanceof r.Font?S=x.face.family:x.data instanceof Uint8Array?(S=x.name.fontFamily,(E=x.name)!=null&&E.fontSubfamily&&(S+="-"+x.name.fontSubfamily)):typeof x=="string"&&typeof w>"u"&&/[.0-9]+(%|em|p[xt])/.test(S)&&({family:S,size:w}=this._directSetFontString(S)),typeof S!="string")throw Error("null font in textFont()");return arguments.length===2&&typeof w=="object"&&(v=w,w=void 0),this.states.setValue("textFont",{font:x,family:S,size:w}),typeof w<"u"&&this._setTextSize(w),typeof v=="object"&&this.textProperties(v),this._applyTextProperties()},Gt.prototype._directSetFontString=function(x,w=0){w&&console.log('_directSetFontString"'+x+'"');let v=m.reduce((C,I)=>(C[I]=p[I].default,C),{}),S=this._cachedDiv(v);S.style.font=x;let E=getComputedStyle(S);return m.forEach(C=>{this.states[C]=E[C],w&&console.log("  this.states."+C+'="'+E[C]+'"')}),{family:E.fontFamily,size:E.fontSize}},Gt.prototype.textLeading=function(x){return typeof x=="number"?(this.states.setValue("leadingSet",!0),this.states.setValue("textLeading",x),this._applyTextProperties()):this.states.textLeading},Gt.prototype.textWeight=function(x){if(typeof x=="number"){this.states.setValue("fontWeight",x),this._applyTextProperties(),r.prototype._isSafari()||this._setCanvasStyleProperty("font-variation-settings",`"wght" ${x}`);return}return this.states.fontWeight},Gt.prototype.textSize=function(x){return typeof x<"u"?(this._setTextSize(x),this._applyTextProperties()):this.states.textSize},Gt.prototype.textStyle=function(x){return typeof x<"u"?(this.states.setValue("fontStyle",x),this._applyTextProperties()):this.states.fontStyle},Gt.prototype.textWrap=function(x){return x===t.WORD||x===t.CHAR?(this.states.setValue("textWrap",x),this._pInst):this.states.textWrap},Gt.prototype.textDirection=function(x){return typeof x<"u"?(this.states.setValue("direction",x),this._applyTextProperties()):this.states.direction},Gt.prototype.textProperty=function(x,w,v){let S=!1,E=(v==null?void 0:v.debug)||!1;if(typeof w>"u"){let C=this.textProperties();if(x in C)return C[x];throw Error('Unknown text option "'+x+'"')}return x in this.states&&this.states[x]!==w?(this.states[x]=w,S=!0,E&&console.log("this.states."+x+'="'+options[x]+'"')):x in this.textDrawingContext()?(this._setContextProperty(x,w,E),S=!0):x in this.textCanvas().style?(this._setCanvasStyleProperty(x,w,E),S=!0):console.warn('Ignoring unknown text option: "'+x+`"
`),S?this._applyTextProperties():this._pInst},Gt.prototype.textProperties=function(x){if(typeof x<"u")return Object.keys(x).forEach(v=>{this.textProperty(v,x[v])}),this._pInst;let w=this.textDrawingContext();return x=f.reduce((v,S)=>(v[S]=w[S],v),{}),Object.keys(p).forEach(v=>{var S;if(((S=p[v])==null?void 0:S.type)==="Context2d")x[v]=w[v];else if(v==="textFont"){let E=this._currentTextFont();typeof E=="object"&&"_pInst"in E&&(E=Object.assign({},E),delete E._pInst),x[v]=E}else x[v]=this.states[v]}),x},Gt.prototype.textMode=function(){},Gt.prototype._currentTextFont=function(){return this.states.textFont.font||this.states.textFont.family},Gt.prototype._computeBounds=function(x,w,v,S,E,C,I){let _=this.textDrawingContext(),A=_.textBaseline,{textLeading:k,textAlign:N}=this.states;({width:E,height:C}=this._rectModeAdjust(v,S,E,C));let D=this._processLines(w,E,C),F=D.map((G,Y)=>this[x].bind(this)(G,v,S+Y*k));D.length>1&&F.forEach(G=>G.x+=r.Renderer2D.prototype._xAlignOffset.call(this,N,E)),typeof C<"u"&&r.Renderer2D.prototype._yAlignOffset.call(this,F,C);let P=F[0];return D.length>1&&(P=this._aggregateBounds(F),I!=null&&I.ignoreRectMode||this._rectModeAlign(P,E||0,C||0)),_.textBaseline=A,{bounds:P,lines:D}},Gt.prototype._rectModeAdjust=function(x,w,v,S){if(typeof v<"u")switch(this.states.rectMode){case t.CENTER:break;case t.CORNERS:v-=x,S-=w;break;case t.RADIUS:v*=2,S*=2;break}return{x,y:w,width:v,height:S}},Gt.prototype._setCanvasStyleProperty=function(x,w,v){let S=w.toString();v&&console.log("canvas.style."+x+'="'+S+'"'),x===l&&this._handleFontVariationSettings(S),this.textCanvas().style[x]=S,this.textCanvas().style[x]},Gt.prototype._handleFontVariationSettings=function(x,w=!1){typeof x=="object"&&(x=Object.keys(x).map(S=>S+" "+x[S]).join(", ")),x.split(a).forEach(S=>{S=S.replace(/["']/g,"");let E=h.exec(S);if(E&&E.length){let C=E[0],I=parseFloat(parseFloat(S.replace(C,"").trim()).toFixed(3));switch(C){case"wght":return w&&console.log("setting font-weight="+I),this.states.fontWeight!==I&&this.textWeight(I),I;case"wdth":break;case"ital":w&&console.log("setting font-style="+(I?"italic":"normal"));break;case"slnt":w&&console.log("setting font-style="+(I?"oblique":"normal"));break;case"opsz":w&&console.log("setting font-optical-size="+I);break}}})},Gt.prototype._setContextProperty=function(x,w,v=!1){if(this.textDrawingContext()[x]===w)return this._pInst;(y??(y=[])).push([x,w]),v&&console.log("queued context2d."+x+'="'+w+'"')},Gt.prototype._handleRectMode=function(x,w,v,S){let E=this.states.rectMode;if(typeof v<"u")switch(E){case t.RADIUS:v*=2,x-=v/2,typeof S<"u"&&(S*=2,w-=S/2);break;case t.CENTER:x-=v/2,typeof S<"u"&&(w-=S/2);break;case t.CORNERS:v-=x,typeof S<"u"&&(S-=w);break}return{x,y:w,width:v,height:S}},Gt.prototype._fontSizePx=function(x,{family:w}=this.states.textFont){if((I=>!isNaN(I)&&I.trim()!=="")(x))return parseFloat(x);let S=this._cachedDiv({fontSize:x});S.style.fontSize=x,S.style.fontFamily=w;let E=getComputedStyle(S).fontSize,C=parseFloat(E);if(typeof C!="number")throw Error("textSize: invalid font-size");return C},Gt.prototype._cachedDiv=function(x){if(typeof b>"u"){let w=document.createElement("div");w.ariaHidden="true",w.style.display="none",Object.entries(x).forEach(([v,S])=>{w.style[v]=S}),this.textCanvas().appendChild(w),b=w}return b},Gt.prototype._aggregateBounds=function(x){let w=Math.min(...x.map(C=>C.x)),v=Math.min(...x.map(C=>C.y)),S=Math.max(...x.map(C=>C.y+C.h)),E=Math.max(...x.map(C=>C.x+C.w));return{x:w,y:v,w:E-w,h:S-v}},Gt.prototype._processLines=function(x,w,v){typeof w<"u"&&this.textDrawingContext().textBaseline===t.BASELINE&&(this.drawingContext.textBaseline=t.TOP);let S=this._splitOnBreaks(x.toString()),E=S.length>1,C=typeof w<"u",I=C&&S.some(k=>this._textWidthSingle(k)>w),{textLeading:_,textWrap:A}=this.states;if((E||I)&&C&&(S=this._lineate(A,S,w)),C&&typeof v<"u"){if(typeof _>"u")throw Error("leading is required if height is specified");for(let k=0;k<S.length;k++)if(_*(k+1)>v){S=S.slice(0,k);break}}return S},Gt.prototype._xAlignOffset=function(x,w){switch(x){case t.LEFT:return 0;case t.CENTER:return w/2;case t.RIGHT:return w;case Vi.START:return 0;case Vi.END:throw new Error("textBounds: END not yet supported for textAlign");default:return 0}},Gt.prototype._rectModeAlign=function(x,w,v){if(typeof w<"u"){switch(this.states.rectMode){case t.CENTER:x.x-=(w-x.w)/2,x.y-=(v-x.h)/2;break;case t.CORNERS:x.w+=x.x,x.h+=x.y;break;case t.RADIUS:x.x-=(w-x.w)/2,x.y-=(v-x.h)/2,x.w/=2,x.h/=2;break}return x}},Gt.prototype._rectModeAlignRevert=function(x,w,v){if(typeof w<"u"){switch(this.states.rectMode){case t.CENTER:x.x+=(w-x.w)/2,x.y+=(v-x.h)/2;break;case t.CORNERS:x.w-=x.x,x.h-=x.y;break;case t.RADIUS:x.x+=(w-x.w)/2,x.y+=(v-x.h)/2,x.w*=2,x.h*=2;break}return x}},Gt.prototype._textWidthSingle=function(x){let w=this.textDrawingContext().measureText(x),v=w.actualBoundingBoxLeft;return w.actualBoundingBoxRight+v},Gt.prototype._fontWidthSingle=function(x){return this.textDrawingContext().measureText(x).width},Gt.prototype._textBoundsSingle=function(x,w=0,v=0){let S=this.textDrawingContext().measureText(x),E=S.actualBoundingBoxAscent,C=S.actualBoundingBoxDescent,I=S.actualBoundingBoxLeft,_=S.actualBoundingBoxRight;return{x:w-I,y:v-E,w:_+I,h:E+C}},Gt.prototype._fontBoundsSingle=function(x,w=0,v=0){let S=this.textDrawingContext().measureText(x),E=S.fontBoundingBoxAscent,C=S.fontBoundingBoxDescent;return w-=this._xAlignOffset(this.states.textAlign,S.width),{x:w,y:v-E,w:S.width,h:E+C}},Gt.prototype._setTextSize=function(x){if(typeof x=="string"&&(x=this._fontSizePx(x)),typeof x=="number"){if(this.states.textSize!==x)return this.states.setValue("textSize",x),this.states.leadingSet||this.states.setValue("textLeading",this.states.textSize*1.275),!0}else console.warn("textSize: invalid size: "+x);return!1},Gt.prototype._lineate=function(x,w,v=1/0,S={}){let E=S.splitChar??(x===t.WORD?" ":""),C,I,_,A,k=[];for(let N=0;N<w.length;N++){C="",A=w[N].split(E);for(let D=0;D<A.length;D++)I=`${C+A[D]}`+E,_=this._textWidthSingle(I),C.length>0&&_>v?(k.push(C.trim()),C=`${A[D]}`+E):C=I;k.push(C.trim())}return k},Gt.prototype._splitOnBreaks=function(x){return!x||x.length===0?[""]:x.replace(u,"  ").split(i)},Gt.prototype._parseFontFamily=function(x){return x.split(a).map(S=>(S=S.trim(),S.indexOf(" ")>-1&&!o.test(S)&&(S=`"${S}"`),S)).join(", ")},Gt.prototype._applyFontString=function(){let{textFont:x,textSize:w,lineHeight:v,fontStyle:S,fontWeight:E,fontVariant:C}=this.states,I=this.textDrawingContext(),_=this._parseFontFamily(x.family),A=S!==t.NORMAL?`${S} `:"",k=E!==t.NORMAL?`${E} `:"",N=C!==t.NORMAL?`${C} `:"",D=`${w}px`+(v!==t.NORMAL?`/${v} `:" "),F=`${A}${N}${k}${D}${_}`.trim();if(I.font=F,I.font!==F){let P=F,G=I.font;if(P!==G)return!1}return!0},Gt.prototype._applyTextProperties=function(x=!1){this._applyFontString();let w=this.textDrawingContext();w.direction=this.states.direction,w.textAlign=this.states.textAlign,w.textBaseline=this.states.textBaseline;let v=this.states.fontStretch;for(g.includes(v)&&w.fontStretch!==v&&(w.fontStretch=v);y!=null&&y.length;){let[S,E]=y.shift();x&&console.log('apply context property "'+S+'" = "'+E+'"'),w[S]=E,w[S]!==E&&(console.warn(`Unable to set '${S}' property on context2d. It may not be supported.`),console.log('Expected "'+E+'" but got: "'+w[S]+'"'))}return this._pInst},r.Renderer2D&&(r.Renderer2D.prototype.textCanvas=function(){return this.canvas},r.Renderer2D.prototype.textDrawingContext=function(){return this.drawingContext},r.Renderer2D.prototype._renderText=function(x,w,v,S,E){let C=this.states,I=this.textDrawingContext();v<E||v>=S||(this.push(),C.strokeColor&&C.strokeSet&&I.strokeText(x,w,v),!this._clipping&&C.fillColor&&(C.fillSet||this._setFill(s),I.fillText(x,w,v)),this.pop())},r.Renderer2D.prototype._positionLines=function(x,w,v,S,E){let{textLeading:C,textAlign:I}=this.states,_,A=new Array(E.length),k=typeof v>"u"?0:v,N=typeof S>"u"?0:S;for(let D=0;D<E.length;D++){switch(I){case Vi.START:throw new Error("textBounds: START not yet supported for textAlign");case t.LEFT:_=x;break;case t.CENTER:_=x+k/2;break;case t.RIGHT:_=x+k;break;case Vi.END:throw new Error("textBounds: END not yet supported for textAlign")}A[D]={text:E[D],x:_,y:w+D*C}}return this._yAlignOffset(A,N)},r.Renderer2D.prototype._yAlignOffset=function(x,w){if(typeof w>"u")throw Error("_yAlignOffset: height is required");let{textLeading:v,textBaseline:S}=this.states,E=0,C=x.length,I=w-v*(C-1);switch(S){case t.TOP:break;case t.BASELINE:break;case Vi._CTX_MIDDLE:E=I/2;break;case t.BOTTOM:E=I;break;case Vi.IDEOGRAPHIC:console.warn("textBounds: IDEOGRAPHIC not yet supported for textBaseline");break;case Vi.HANGING:console.warn("textBounds: HANGING not yet supported for textBaseline");break}return x.forEach(_=>_.y+=E),x}),r.RendererGL){r.RendererGL.prototype.textCanvas=function(){return this._textCanvas||(this._textCanvas=document.createElement("canvas"),this._textCanvas.width=1,this._textCanvas.height=1,this._textCanvas.style.display="none",this.canvas.parentElement.insertBefore(this._textCanvas,this.canvas)),this._textCanvas},r.RendererGL.prototype.textDrawingContext=function(){if(!this._textDrawingContext){const w=this.textCanvas();this._textDrawingContext=w.getContext("2d")}return this._textDrawingContext};const x=r.RendererGL.prototype.remove;r.RendererGL.prototype.remove=function(){this._textCanvas&&this._textCanvas.parentElement.removeChild(this._textCanvas),x.call(this)},r.RendererGL.prototype._positionLines=function(w,v,S,E,C){let{textLeading:I,textAlign:_}=this.states;const A=C.map(P=>this._fontWidthSingle(P));let k,N=new Array(C.length),D=typeof S>"u"?Math.max(0,...A):S,F=typeof E>"u"?0:E;for(let P=0;P<C.length;P++){switch(_){case Vi.START:throw new Error("textBounds: START not yet supported for textAlign");case t.LEFT:k=w;break;case t.CENTER:k=w+(D-A[P])/2-D/2+(S||0)/2;break;case t.RIGHT:k=w+D-A[P]-D+(S||0);break;case Vi.END:throw new Error("textBounds: END not yet supported for textAlign")}N[P]={text:C[P],x:k,y:v+P*I}}return this._yAlignOffset(N,F)},r.RendererGL.prototype._yAlignOffset=function(w,v){var N;if(typeof v>"u")throw Error("_yAlignOffset: height is required");let{textLeading:S,textBaseline:E,textSize:C,textFont:I}=this.states,_=0,A=w.length,k=C*A+(S-C)*(A-1);switch(E){case t.TOP:_=C;break;case t.BASELINE:break;case Vi._CTX_MIDDLE:_=-k/2+C+(v||0)/2;break;case t.BOTTOM:_=-(k-C)+(v||0);break;default:console.warn(`${E} is not supported in WebGL mode.`);break}return _+=((N=this.states.textFont.font)==null?void 0:N._verticalAlign(C))||0,w.forEach(D=>D.y+=_),w}}}typeof p5<"u"&&m8(p5,p5.prototype);var h1={},kB;function _le(){if(kB)return h1;kB=1,Object.defineProperty(h1,"__esModule",{value:!0});var r=function(){function t(){}return t.parse=function(n){for(var s=new Set,i=0,a=n;i<a.length;i++){var o=a[i];if(!t.REGEXP.test(o))throw new TypeError('"'+o+'" is invalid unicode-range.');var u=o.match(t.REGEXP),l=u[1],c=u[2],h=u[3];if(l){if(/\?[^?]+$/.test(l))throw new TypeError('"'+o+'" is invalid unicode-range.');if(l.includes("?"))for(var d=l.replace(/\?/g,"0"),p=l.replace(/\?/g,"F"),f=t.parse(["U+"+d+"-"+p]),m=0,g=f;m<g.length;m++){var y=g[m];s.add(y)}else s.add(parseInt(l,16))}if(c&&h)for(var b=parseInt(c,16),x=parseInt(h,16),y=b;y<=x;y++)s.add(y)}return Array.from(s).sort(function(w,v){return w-v})},t.stringify=function(n){for(var s=Array.from(new Set(n)).sort(function(c,h){return c-h}),i=[],a,o=0;o<s.length;o++){var u=s[o],l=s[o-1];a&&u-l!==1&&(i.push(t.rangeString(a,l)),a=u),a||(a=u),o===s.length-1&&(a===u?i.push(t.rangeString(u)):i.push(t.rangeString(a,u)))}return i},t.rangeString=function(n,s){return!s||n===s?"U+"+n.toString(16):"U+"+n.toString(16)+"-"+s.toString(16)},t.REGEXP=/^u\+(?:([0-9a-f]?[0-9a-f?]{1,5})|([0-9a-f]{1,6})-([0-9a-f]{1,6}))?$/i,t}();return h1.UnicodeRange=r,h1}var NB=_le();const Ele=[{category:"control character",hexrange:["0000","001f"]},{category:"basic latin",hexrange:["0000","007f"]},{category:"latin-1 supplement",hexrange:["0080","00ff"]},{category:"latin extended-a",hexrange:["0100","017f"]},{category:"latin extended-b",hexrange:["0180","024f"]},{category:"ipa extensions",hexrange:["0250","02af"]},{category:"spacing modifier letters",hexrange:["02b0","02ff"]},{category:"combining diacritical marks",hexrange:["0300","036f"]},{category:"greek and coptic",hexrange:["0370","03ff"]},{category:"cyrillic",hexrange:["0400","04ff"]},{category:"cyrillic supplement",hexrange:["0500","052f"]},{category:"armenian",hexrange:["0530","058f"]},{category:"hebrew",hexrange:["0590","05ff"]},{category:"arabic",hexrange:["0600","06ff"]},{category:"syriac",hexrange:["0700","074f"]},{category:"arabic supplement",hexrange:["0750","077f"]},{category:"thaana",hexrange:["0780","07bf"]},{category:"nko",hexrange:["07c0","07ff"]},{category:"samaritan",hexrange:["0800","083f"]},{category:"mandaic",hexrange:["0840","085f"]},{category:"syriac supplement",hexrange:["0860","086f"]},{category:"arabic extended-b",hexrange:["0870","089f"]},{category:"arabic extended-a",hexrange:["08a0","08ff"]},{category:"devanagari",hexrange:["0900","097f"]},{category:"bengali",hexrange:["0980","09ff"]},{category:"gurmukhi",hexrange:["0a00","0a7f"]},{category:"gujarati",hexrange:["0a80","0aff"]},{category:"oriya",hexrange:["0b00","0b7f"]},{category:"tamil",hexrange:["0b80","0bff"]},{category:"telugu",hexrange:["0c00","0c7f"]},{category:"kannada",hexrange:["0c80","0cff"]},{category:"malayalam",hexrange:["0d00","0d7f"]},{category:"sinhala",hexrange:["0d80","0dff"]},{category:"thai",hexrange:["0e00","0e7f"]},{category:"lao",hexrange:["0e80","0eff"]},{category:"tibetan",hexrange:["0f00","0fff"]},{category:"myanmar",hexrange:["1000","109f"]},{category:"georgian",hexrange:["10a0","10ff"]},{category:"hangul jamo",hexrange:["1100","11ff"]},{category:"ethiopic",hexrange:["1200","137f"]},{category:"ethiopic supplement",hexrange:["1380","139f"]},{category:"cherokee",hexrange:["13a0","13ff"]},{category:"unified canadian aboriginal syllabics",hexrange:["1400","167f"]},{category:"ogham",hexrange:["1680","169f"]},{category:"runic",hexrange:["16a0","16ff"]},{category:"tagalog",hexrange:["1700","171f"]},{category:"hanunoo",hexrange:["1720","173f"]},{category:"buhid",hexrange:["1740","175f"]},{category:"tagbanwa",hexrange:["1760","177f"]},{category:"khmer",hexrange:["1780","17ff"]},{category:"mongolian",hexrange:["1800","18af"]},{category:"unified canadian aboriginal syllabics extended",hexrange:["18b0","18ff"]},{category:"limbu",hexrange:["1900","194f"]},{category:"tai le",hexrange:["1950","197f"]},{category:"new tai lue",hexrange:["1980","19df"]},{category:"khmer symbols",hexrange:["19e0","19ff"]},{category:"buginese",hexrange:["1a00","1a1f"]},{category:"tai tham",hexrange:["1a20","1aaf"]},{category:"combining diacritical marks extended",hexrange:["1ab0","1aff"]},{category:"balinese",hexrange:["1b00","1b7f"]},{category:"sundanese",hexrange:["1b80","1bbf"]},{category:"batak",hexrange:["1bc0","1bff"]},{category:"lepcha",hexrange:["1c00","1c4f"]},{category:"ol chiki",hexrange:["1c50","1c7f"]},{category:"cyrillic extended-c",hexrange:["1c80","1c8f"]},{category:"georgian extended",hexrange:["1c90","1cbf"]},{category:"sundanese supplement",hexrange:["1cc0","1ccf"]},{category:"vedic extensions",hexrange:["1cd0","1cff"]},{category:"phonetic extensions",hexrange:["1d00","1d7f"]},{category:"phonetic extensions supplement",hexrange:["1d80","1dbf"]},{category:"combining diacritical marks supplement",hexrange:["1dc0","1dff"]},{category:"latin extended additional",hexrange:["1e00","1eff"]},{category:"greek extended",hexrange:["1f00","1fff"]},{category:"general punctuation",hexrange:["2000","206f"]},{category:"superscripts and subscripts",hexrange:["2070","209f"]},{category:"currency symbols",hexrange:["20a0","20cf"]},{category:"combining diacritical marks for symbols",hexrange:["20d0","20ff"]},{category:"letterlike symbols",hexrange:["2100","214f"]},{category:"number forms",hexrange:["2150","218f"]},{category:"arrows",hexrange:["2190","21ff"]},{category:"mathematical operators",hexrange:["2200","22ff"]},{category:"miscellaneous technical",hexrange:["2300","23ff"]},{category:"control pictures",hexrange:["2400","243f"]},{category:"optical character recognition",hexrange:["2440","245f"]},{category:"enclosed alphanumerics",hexrange:["2460","24ff"]},{category:"box drawing",hexrange:["2500","257f"]},{category:"block elements",hexrange:["2580","259f"]},{category:"geometric shapes",hexrange:["25a0","25ff"]},{category:"miscellaneous symbols",hexrange:["2600","26ff"]},{category:"dingbats",hexrange:["2700","27bf"]},{category:"miscellaneous mathematical symbols-a",hexrange:["27c0","27ef"]},{category:"supplemental arrows-a",hexrange:["27f0","27ff"]},{category:"braille patterns",hexrange:["2800","28ff"]},{category:"supplemental arrows-b",hexrange:["2900","297f"]},{category:"miscellaneous mathematical symbols-b",hexrange:["2980","29ff"]},{category:"supplemental mathematical operators",hexrange:["2a00","2aff"]},{category:"miscellaneous symbols and arrows",hexrange:["2b00","2bff"]},{category:"glagolitic",hexrange:["2c00","2c5f"]},{category:"latin extended-c",hexrange:["2c60","2c7f"]},{category:"coptic",hexrange:["2c80","2cff"]},{category:"georgian supplement",hexrange:["2d00","2d2f"]},{category:"tifinagh",hexrange:["2d30","2d7f"]},{category:"ethiopic extended",hexrange:["2d80","2ddf"]},{category:"cyrillic extended-a",hexrange:["2de0","2dff"]},{category:"supplemental punctuation",hexrange:["2e00","2e7f"]},{category:"cjk radicals supplement",hexrange:["2e80","2eff"]},{category:"kangxi radicals",hexrange:["2f00","2fdf"]},{category:"ideographic description characters",hexrange:["2ff0","2fff"]},{category:"cjk symbols and punctuation",hexrange:["3000","303f"]},{category:"hiragana",hexrange:["3040","309f"]},{category:"katakana",hexrange:["30a0","30ff"]},{category:"bopomofo",hexrange:["3100","312f"]},{category:"hangul compatibility jamo",hexrange:["3130","318f"]},{category:"kanbun",hexrange:["3190","319f"]},{category:"bopomofo extended",hexrange:["31a0","31bf"]},{category:"cjk strokes",hexrange:["31c0","31ef"]},{category:"katakana phonetic extensions",hexrange:["31f0","31ff"]},{category:"enclosed cjk letters and months",hexrange:["3200","32ff"]},{category:"cjk compatibility",hexrange:["3300","33ff"]},{category:"cjk unified ideographs extension a",hexrange:["3400","4dbf"]},{category:"yijing hexagram symbols",hexrange:["4dc0","4dff"]},{category:"cjk unified ideographs",hexrange:["4e00","9fff"]},{category:"yi syllables",hexrange:["a000","a48f"]},{category:"yi radicals",hexrange:["a490","a4cf"]},{category:"lisu",hexrange:["a4d0","a4ff"]},{category:"vai",hexrange:["a500","a63f"]},{category:"cyrillic extended-b",hexrange:["a640","a69f"]},{category:"bamum",hexrange:["a6a0","a6ff"]},{category:"modifier tone letters",hexrange:["a700","a71f"]},{category:"latin extended-d",hexrange:["a720","a7ff"]},{category:"syloti nagri",hexrange:["a800","a82f"]},{category:"common indic number forms",hexrange:["a830","a83f"]},{category:"phags-pa",hexrange:["a840","a87f"]},{category:"saurashtra",hexrange:["a880","a8df"]},{category:"devanagari extended",hexrange:["a8e0","a8ff"]},{category:"kayah li",hexrange:["a900","a92f"]},{category:"rejang",hexrange:["a930","a95f"]},{category:"hangul jamo extended-a",hexrange:["a960","a97f"]},{category:"javanese",hexrange:["a980","a9df"]},{category:"myanmar extended-b",hexrange:["a9e0","a9ff"]},{category:"cham",hexrange:["aa00","aa5f"]},{category:"myanmar extended-a",hexrange:["aa60","aa7f"]},{category:"tai viet",hexrange:["aa80","aadf"]},{category:"meetei mayek extensions",hexrange:["aae0","aaff"]},{category:"ethiopic extended-a",hexrange:["ab00","ab2f"]},{category:"latin extended-e",hexrange:["ab30","ab6f"]},{category:"cherokee supplement",hexrange:["ab70","abbf"]},{category:"meetei mayek",hexrange:["abc0","abff"]},{category:"hangul syllables",hexrange:["ac00","d7af"]},{category:"hangul jamo extended-b",hexrange:["d7b0","d7ff"]},{category:"high surrogates",hexrange:["d800","db7f"]},{category:"high private use surrogates",hexrange:["db80","dbff"]},{category:"low surrogates",hexrange:["dc00","dfff"]},{category:"private use area",hexrange:["e000","f8ff"]},{category:"cjk compatibility ideographs",hexrange:["f900","faff"]},{category:"alphabetic presentation forms",hexrange:["fb00","fb4f"]},{category:"arabic presentation forms-a",hexrange:["fb50","fdff"]},{category:"variation selectors",hexrange:["fe00","fe0f"]},{category:"vertical forms",hexrange:["fe10","fe1f"]},{category:"combining half marks",hexrange:["fe20","fe2f"]},{category:"cjk compatibility forms",hexrange:["fe30","fe4f"]},{category:"small form variants",hexrange:["fe50","fe6f"]},{category:"arabic presentation forms-b",hexrange:["fe70","feff"]},{category:"halfwidth and fullwidth forms",hexrange:["ff00","ffef"]},{category:"specials",hexrange:["fff0","ffff"]},{category:"linear b syllabary",hexrange:["10000","1007f"]},{category:"linear b ideograms",hexrange:["10080","100ff"]},{category:"aegean numbers",hexrange:["10100","1013f"]},{category:"ancient greek numbers",hexrange:["10140","1018f"]},{category:"ancient symbols",hexrange:["10190","101cf"]},{category:"phaistos disc",hexrange:["101d0","101ff"]},{category:"lycian",hexrange:["10280","1029f"]},{category:"carian",hexrange:["102a0","102df"]},{category:"coptic epact numbers",hexrange:["102e0","102ff"]},{category:"old italic",hexrange:["10300","1032f"]},{category:"gothic",hexrange:["10330","1034f"]},{category:"old permic",hexrange:["10350","1037f"]},{category:"ugaritic",hexrange:["10380","1039f"]},{category:"old persian",hexrange:["103a0","103df"]},{category:"deseret",hexrange:["10400","1044f"]},{category:"shavian",hexrange:["10450","1047f"]},{category:"osmanya",hexrange:["10480","104af"]},{category:"osage",hexrange:["104b0","104ff"]},{category:"elbasan",hexrange:["10500","1052f"]},{category:"caucasian albanian",hexrange:["10530","1056f"]},{category:"vithkuqi",hexrange:["10570","105bf"]},{category:"linear a",hexrange:["10600","1077f"]},{category:"latin extended-f",hexrange:["10780","107bf"]},{category:"cypriot syllabary",hexrange:["10800","1083f"]},{category:"imperial aramaic",hexrange:["10840","1085f"]},{category:"palmyrene",hexrange:["10860","1087f"]},{category:"nabataean",hexrange:["10880","108af"]},{category:"hatran",hexrange:["108e0","108ff"]},{category:"phoenician",hexrange:["10900","1091f"]},{category:"lydian",hexrange:["10920","1093f"]},{category:"meroitic hieroglyphs",hexrange:["10980","1099f"]},{category:"meroitic cursive",hexrange:["109a0","109ff"]},{category:"kharoshthi",hexrange:["10a00","10a5f"]},{category:"old south arabian",hexrange:["10a60","10a7f"]},{category:"old north arabian",hexrange:["10a80","10a9f"]},{category:"manichaean",hexrange:["10ac0","10aff"]},{category:"avestan",hexrange:["10b00","10b3f"]},{category:"inscriptional parthian",hexrange:["10b40","10b5f"]},{category:"inscriptional pahlavi",hexrange:["10b60","10b7f"]},{category:"psalter pahlavi",hexrange:["10b80","10baf"]},{category:"old turkic",hexrange:["10c00","10c4f"]},{category:"old hungarian",hexrange:["10c80","10cff"]},{category:"hanifi rohingya",hexrange:["10d00","10d3f"]},{category:"rumi numeral symbols",hexrange:["10e60","10e7f"]},{category:"yezidi",hexrange:["10e80","10ebf"]},{category:"arabic extended-c",hexrange:["10ec0","10eff"]},{category:"old sogdian",hexrange:["10f00","10f2f"]},{category:"sogdian",hexrange:["10f30","10f6f"]},{category:"old uyghur",hexrange:["10f70","10faf"]},{category:"chorasmian",hexrange:["10fb0","10fdf"]},{category:"elymaic",hexrange:["10fe0","10fff"]},{category:"brahmi",hexrange:["11000","1107f"]},{category:"kaithi",hexrange:["11080","110cf"]},{category:"sora sompeng",hexrange:["110d0","110ff"]},{category:"chakma",hexrange:["11100","1114f"]},{category:"mahajani",hexrange:["11150","1117f"]},{category:"sharada",hexrange:["11180","111df"]},{category:"sinhala archaic numbers",hexrange:["111e0","111ff"]},{category:"khojki",hexrange:["11200","1124f"]},{category:"multani",hexrange:["11280","112af"]},{category:"khudawadi",hexrange:["112b0","112ff"]},{category:"grantha",hexrange:["11300","1137f"]},{category:"newa",hexrange:["11400","1147f"]},{category:"tirhuta",hexrange:["11480","114df"]},{category:"siddham",hexrange:["11580","115ff"]},{category:"modi",hexrange:["11600","1165f"]},{category:"mongolian supplement",hexrange:["11660","1167f"]},{category:"takri",hexrange:["11680","116cf"]},{category:"ahom",hexrange:["11700","1174f"]},{category:"dogra",hexrange:["11800","1184f"]},{category:"warang citi",hexrange:["118a0","118ff"]},{category:"dives akuru",hexrange:["11900","1195f"]},{category:"nandinagari",hexrange:["119a0","119ff"]},{category:"zanabazar square",hexrange:["11a00","11a4f"]},{category:"soyombo",hexrange:["11a50","11aaf"]},{category:"unified canadian aboriginal syllabics extended-a",hexrange:["11ab0","11abf"]},{category:"pau cin hau",hexrange:["11ac0","11aff"]},{category:"devanagari extended-a",hexrange:["11b00","11b5f"]},{category:"bhaiksuki",hexrange:["11c00","11c6f"]},{category:"marchen",hexrange:["11c70","11cbf"]},{category:"masaram gondi",hexrange:["11d00","11d5f"]},{category:"gunjala gondi",hexrange:["11d60","11daf"]},{category:"makasar",hexrange:["11ee0","11eff"]},{category:"kawi",hexrange:["11f00","11f5f"]},{category:"lisu supplement",hexrange:["11fb0","11fbf"]},{category:"tamil supplement",hexrange:["11fc0","11fff"]},{category:"cuneiform",hexrange:["12000","123ff"]},{category:"cuneiform numbers and punctuation",hexrange:["12400","1247f"]},{category:"early dynastic cuneiform",hexrange:["12480","1254f"]},{category:"cypro-minoan",hexrange:["12f90","12fff"]},{category:"egyptian hieroglyphs",hexrange:["13000","1342f"]},{category:"egyptian hieroglyph format controls",hexrange:["13430","1345f"]},{category:"anatolian hieroglyphs",hexrange:["14400","1467f"]},{category:"bamum supplement",hexrange:["16800","16a3f"]},{category:"mro",hexrange:["16a40","16a6f"]},{category:"tangsa",hexrange:["16a70","16acf"]},{category:"bassa vah",hexrange:["16ad0","16aff"]},{category:"pahawh hmong",hexrange:["16b00","16b8f"]},{category:"medefaidrin",hexrange:["16e40","16e9f"]},{category:"miao",hexrange:["16f00","16f9f"]},{category:"ideographic symbols and punctuation",hexrange:["16fe0","16fff"]},{category:"tangut",hexrange:["17000","187ff"]},{category:"tangut components",hexrange:["18800","18aff"]},{category:"khitan small script",hexrange:["18b00","18cff"]},{category:"tangut supplement",hexrange:["18d00","18d7f"]},{category:"kana extended-b",hexrange:["1aff0","1afff"]},{category:"kana supplement",hexrange:["1b000","1b0ff"]},{category:"kana extended-a",hexrange:["1b100","1b12f"]},{category:"small kana extension",hexrange:["1b130","1b16f"]},{category:"nushu",hexrange:["1b170","1b2ff"]},{category:"duployan",hexrange:["1bc00","1bc9f"]},{category:"shorthand format controls",hexrange:["1bca0","1bcaf"]},{category:"znamenny musical notation",hexrange:["1cf00","1cfcf"]},{category:"byzantine musical symbols",hexrange:["1d000","1d0ff"]},{category:"musical symbols",hexrange:["1d100","1d1ff"]},{category:"ancient greek musical notation",hexrange:["1d200","1d24f"]},{category:"kaktovik numerals",hexrange:["1d2c0","1d2df"]},{category:"mayan numerals",hexrange:["1d2e0","1d2ff"]},{category:"tai xuan jing symbols",hexrange:["1d300","1d35f"]},{category:"counting rod numerals",hexrange:["1d360","1d37f"]},{category:"mathematical alphanumeric symbols",hexrange:["1d400","1d7ff"]},{category:"sutton signwriting",hexrange:["1d800","1daaf"]},{category:"latin extended-g",hexrange:["1df00","1dfff"]},{category:"glagolitic supplement",hexrange:["1e000","1e02f"]},{category:"cyrillic extended-d",hexrange:["1e030","1e08f"]},{category:"nyiakeng puachue hmong",hexrange:["1e100","1e14f"]},{category:"toto",hexrange:["1e290","1e2bf"]},{category:"wancho",hexrange:["1e2c0","1e2ff"]},{category:"nag mundari",hexrange:["1e4d0","1e4ff"]},{category:"ethiopic extended-b",hexrange:["1e7e0","1e7ff"]},{category:"mende kikakui",hexrange:["1e800","1e8df"]},{category:"adlam",hexrange:["1e900","1e95f"]},{category:"indic siyaq numbers",hexrange:["1ec70","1ecbf"]},{category:"ottoman siyaq numbers",hexrange:["1ed00","1ed4f"]},{category:"arabic mathematical alphabetic symbols",hexrange:["1ee00","1eeff"]},{category:"mahjong tiles",hexrange:["1f000","1f02f"]},{category:"domino tiles",hexrange:["1f030","1f09f"]},{category:"playing cards",hexrange:["1f0a0","1f0ff"]},{category:"enclosed alphanumeric supplement",hexrange:["1f100","1f1ff"]},{category:"enclosed ideographic supplement",hexrange:["1f200","1f2ff"]},{category:"miscellaneous symbols and pictographs",hexrange:["1f300","1f5ff"]},{category:"emoticons (emoji)",hexrange:["1f600","1f64f"]},{category:"ornamental dingbats",hexrange:["1f650","1f67f"]},{category:"transport and map symbols",hexrange:["1f680","1f6ff"]},{category:"alchemical symbols",hexrange:["1f700","1f77f"]},{category:"geometric shapes extended",hexrange:["1f780","1f7ff"]},{category:"supplemental arrows-c",hexrange:["1f800","1f8ff"]},{category:"supplemental symbols and pictographs",hexrange:["1f900","1f9ff"]},{category:"chess symbols",hexrange:["1fa00","1fa6f"]},{category:"symbols and pictographs extended-a",hexrange:["1fa70","1faff"]},{category:"symbols for legacy computing",hexrange:["1fb00","1fbff"]},{category:"cjk unified ideographs extension b",hexrange:["20000","2a6df"]},{category:"cjk unified ideographs extension c",hexrange:["2a700","2b73f"]},{category:"cjk unified ideographs extension d",hexrange:["2b740","2b81f"]},{category:"cjk unified ideographs extension e",hexrange:["2b820","2ceaf"]},{category:"cjk unified ideographs extension f",hexrange:["2ceb0","2ebef"]},{category:"cjk unified ideographs extension i",hexrange:["2ebf0","2ee5f"]},{category:"cjk compatibility ideographs supplement",hexrange:["2f800","2fa1f"]},{category:"cjk unified ideographs extension g",hexrange:["30000","3134f"]},{category:"cjk unified ideographs extension h",hexrange:["31350","323af"]},{category:"tags",hexrange:["e0000","e007f"]},{category:"variation selectors supplement",hexrange:["e0100","e01ef"]},{category:"supplementary private use area-a",hexrange:["f0000","fffff"]},{category:"supplementary private use area-b",hexrange:["100000","10ffff"]}];function cg(r){let t=r.length;for(;--t>=0;)r[t]=0}const Ile=3,kle=258,g8=29,Nle=256,Tle=Nle+1+g8,y8=30,Ale=512,Dle=new Array((Tle+2)*2);cg(Dle);const Fle=new Array(y8*2);cg(Fle);const $le=new Array(Ale);cg($le);const Rle=new Array(kle-Ile+1);cg(Rle);const Ole=new Array(g8);cg(Ole);const Mle=new Array(y8);cg(Mle);const Lle=(r,t,n,s)=>{let i=r&65535|0,a=r>>>16&65535|0,o=0;for(;n!==0;){o=n>2e3?2e3:n,n-=o;do i=i+t[s++]|0,a=a+i|0;while(--o);i%=65521,a%=65521}return i|a<<16|0};var hk=Lle;const Ple=()=>{let r,t=[];for(var n=0;n<256;n++){r=n;for(var s=0;s<8;s++)r=r&1?3988292384^r>>>1:r>>>1;t[n]=r}return t},Ble=new Uint32Array(Ple()),Vle=(r,t,n,s)=>{const i=Ble,a=s+n;r^=-1;for(let o=s;o<a;o++)r=r>>>8^i[(r^t[o])&255];return r^-1};var Ho=Vle,dk={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},b8={Z_NO_FLUSH:0,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_DEFLATED:8};const zle=(r,t)=>Object.prototype.hasOwnProperty.call(r,t);var Ule=function(r){const t=Array.prototype.slice.call(arguments,1);for(;t.length;){const n=t.shift();if(n){if(typeof n!="object")throw new TypeError(n+"must be non-object");for(const s in n)zle(n,s)&&(r[s]=n[s])}}return r},Wle=r=>{let t=0;for(let s=0,i=r.length;s<i;s++)t+=r[s].length;const n=new Uint8Array(t);for(let s=0,i=0,a=r.length;s<a;s++){let o=r[s];n.set(o,i),i+=o.length}return n},x8={assign:Ule,flattenChunks:Wle};let v8=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{v8=!1}const Sb=new Uint8Array(256);for(let r=0;r<256;r++)Sb[r]=r>=252?6:r>=248?5:r>=240?4:r>=224?3:r>=192?2:1;Sb[254]=Sb[254]=1;var Gle=r=>{if(typeof TextEncoder=="function"&&TextEncoder.prototype.encode)return new TextEncoder().encode(r);let t,n,s,i,a,o=r.length,u=0;for(i=0;i<o;i++)n=r.charCodeAt(i),(n&64512)===55296&&i+1<o&&(s=r.charCodeAt(i+1),(s&64512)===56320&&(n=65536+(n-55296<<10)+(s-56320),i++)),u+=n<128?1:n<2048?2:n<65536?3:4;for(t=new Uint8Array(u),a=0,i=0;a<u;i++)n=r.charCodeAt(i),(n&64512)===55296&&i+1<o&&(s=r.charCodeAt(i+1),(s&64512)===56320&&(n=65536+(n-55296<<10)+(s-56320),i++)),n<128?t[a++]=n:n<2048?(t[a++]=192|n>>>6,t[a++]=128|n&63):n<65536?(t[a++]=224|n>>>12,t[a++]=128|n>>>6&63,t[a++]=128|n&63):(t[a++]=240|n>>>18,t[a++]=128|n>>>12&63,t[a++]=128|n>>>6&63,t[a++]=128|n&63);return t};const Hle=(r,t)=>{if(t<65534&&r.subarray&&v8)return String.fromCharCode.apply(null,r.length===t?r:r.subarray(0,t));let n="";for(let s=0;s<t;s++)n+=String.fromCharCode(r[s]);return n};var jle=(r,t)=>{const n=t||r.length;if(typeof TextDecoder=="function"&&TextDecoder.prototype.decode)return new TextDecoder().decode(r.subarray(0,t));let s,i;const a=new Array(n*2);for(i=0,s=0;s<n;){let o=r[s++];if(o<128){a[i++]=o;continue}let u=Sb[o];if(u>4){a[i++]=65533,s+=u-1;continue}for(o&=u===2?31:u===3?15:7;u>1&&s<n;)o=o<<6|r[s++]&63,u--;if(u>1){a[i++]=65533;continue}o<65536?a[i++]=o:(o-=65536,a[i++]=55296|o>>10&1023,a[i++]=56320|o&1023)}return Hle(a,i)},qle=(r,t)=>{t=t||r.length,t>r.length&&(t=r.length);let n=t-1;for(;n>=0&&(r[n]&192)===128;)n--;return n<0||n===0?t:n+Sb[r[n]]>t?n:t},pk={string2buf:Gle,buf2string:jle,utf8border:qle};function Kle(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var Xle=Kle;const d1=16209,Yle=16191;var Zle=function(t,n){let s,i,a,o,u,l,c,h,d,p,f,m,g,y,b,x,w,v,S,E,C,I,_,A;const k=t.state;s=t.next_in,_=t.input,i=s+(t.avail_in-5),a=t.next_out,A=t.output,o=a-(n-t.avail_out),u=a+(t.avail_out-257),l=k.dmax,c=k.wsize,h=k.whave,d=k.wnext,p=k.window,f=k.hold,m=k.bits,g=k.lencode,y=k.distcode,b=(1<<k.lenbits)-1,x=(1<<k.distbits)-1;e:do{m<15&&(f+=_[s++]<<m,m+=8,f+=_[s++]<<m,m+=8),w=g[f&b];t:for(;;){if(v=w>>>24,f>>>=v,m-=v,v=w>>>16&255,v===0)A[a++]=w&65535;else if(v&16){S=w&65535,v&=15,v&&(m<v&&(f+=_[s++]<<m,m+=8),S+=f&(1<<v)-1,f>>>=v,m-=v),m<15&&(f+=_[s++]<<m,m+=8,f+=_[s++]<<m,m+=8),w=y[f&x];r:for(;;){if(v=w>>>24,f>>>=v,m-=v,v=w>>>16&255,v&16){if(E=w&65535,v&=15,m<v&&(f+=_[s++]<<m,m+=8,m<v&&(f+=_[s++]<<m,m+=8)),E+=f&(1<<v)-1,E>l){t.msg="invalid distance too far back",k.mode=d1;break e}if(f>>>=v,m-=v,v=a-o,E>v){if(v=E-v,v>h&&k.sane){t.msg="invalid distance too far back",k.mode=d1;break e}if(C=0,I=p,d===0){if(C+=c-v,v<S){S-=v;do A[a++]=p[C++];while(--v);C=a-E,I=A}}else if(d<v){if(C+=c+d-v,v-=d,v<S){S-=v;do A[a++]=p[C++];while(--v);if(C=0,d<S){v=d,S-=v;do A[a++]=p[C++];while(--v);C=a-E,I=A}}}else if(C+=d-v,v<S){S-=v;do A[a++]=p[C++];while(--v);C=a-E,I=A}for(;S>2;)A[a++]=I[C++],A[a++]=I[C++],A[a++]=I[C++],S-=3;S&&(A[a++]=I[C++],S>1&&(A[a++]=I[C++]))}else{C=a-E;do A[a++]=A[C++],A[a++]=A[C++],A[a++]=A[C++],S-=3;while(S>2);S&&(A[a++]=A[C++],S>1&&(A[a++]=A[C++]))}}else if((v&64)===0){w=y[(w&65535)+(f&(1<<v)-1)];continue r}else{t.msg="invalid distance code",k.mode=d1;break e}break}}else if((v&64)===0){w=g[(w&65535)+(f&(1<<v)-1)];continue t}else if(v&32){k.mode=Yle;break e}else{t.msg="invalid literal/length code",k.mode=d1;break e}break}}while(s<i&&a<u);S=m>>3,s-=S,m-=S<<3,f&=(1<<m)-1,t.next_in=s,t.next_out=a,t.avail_in=s<i?5+(i-s):5-(s-i),t.avail_out=a<u?257+(u-a):257-(a-u),k.hold=f,k.bits=m};const Mf=15,TB=852,AB=592,DB=0,xE=1,FB=2,Jle=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Qle=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),ece=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),tce=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),rce=(r,t,n,s,i,a,o,u)=>{const l=u.bits;let c=0,h=0,d=0,p=0,f=0,m=0,g=0,y=0,b=0,x=0,w,v,S,E,C,I=null,_;const A=new Uint16Array(Mf+1),k=new Uint16Array(Mf+1);let N=null,D,F,P;for(c=0;c<=Mf;c++)A[c]=0;for(h=0;h<s;h++)A[t[n+h]]++;for(f=l,p=Mf;p>=1&&A[p]===0;p--);if(f>p&&(f=p),p===0)return i[a++]=1<<24|64<<16|0,i[a++]=1<<24|64<<16|0,u.bits=1,0;for(d=1;d<p&&A[d]===0;d++);for(f<d&&(f=d),y=1,c=1;c<=Mf;c++)if(y<<=1,y-=A[c],y<0)return-1;if(y>0&&(r===DB||p!==1))return-1;for(k[1]=0,c=1;c<Mf;c++)k[c+1]=k[c]+A[c];for(h=0;h<s;h++)t[n+h]!==0&&(o[k[t[n+h]]++]=h);if(r===DB?(I=N=o,_=20):r===xE?(I=Jle,N=Qle,_=257):(I=ece,N=tce,_=0),x=0,h=0,c=d,C=a,m=f,g=0,S=-1,b=1<<f,E=b-1,r===xE&&b>TB||r===FB&&b>AB)return 1;for(;;){D=c-g,o[h]+1<_?(F=0,P=o[h]):o[h]>=_?(F=N[o[h]-_],P=I[o[h]-_]):(F=96,P=0),w=1<<c-g,v=1<<m,d=v;do v-=w,i[C+(x>>g)+v]=D<<24|F<<16|P|0;while(v!==0);for(w=1<<c-1;x&w;)w>>=1;if(w!==0?(x&=w-1,x+=w):x=0,h++,--A[c]===0){if(c===p)break;c=t[n+o[h]]}if(c>f&&(x&E)!==S){for(g===0&&(g=f),C+=d,m=c-g,y=1<<m;m+g<p&&(y-=A[m+g],!(y<=0));)m++,y<<=1;if(b+=1<<m,r===xE&&b>TB||r===FB&&b>AB)return 1;S=x&E,i[S]=f<<24|m<<16|C-a|0}}return x!==0&&(i[C+x]=c-g<<24|64<<16|0),u.bits=f,0};var Ky=rce;const nce=0,w8=1,S8=2,{Z_FINISH:$B,Z_BLOCK:sce,Z_TREES:p1,Z_OK:Jh,Z_STREAM_END:ice,Z_NEED_DICT:ace,Z_STREAM_ERROR:Ya,Z_DATA_ERROR:C8,Z_MEM_ERROR:_8,Z_BUF_ERROR:oce,Z_DEFLATED:RB}=b8,HS=16180,OB=16181,MB=16182,LB=16183,PB=16184,BB=16185,VB=16186,zB=16187,UB=16188,WB=16189,f2=16190,Fu=16191,vE=16192,GB=16193,wE=16194,HB=16195,jB=16196,qB=16197,KB=16198,f1=16199,m1=16200,XB=16201,YB=16202,ZB=16203,JB=16204,QB=16205,SE=16206,e4=16207,t4=16208,An=16209,E8=16210,I8=16211,uce=852,lce=592,cce=15,hce=cce,r4=r=>(r>>>24&255)+(r>>>8&65280)+((r&65280)<<8)+((r&255)<<24);function dce(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const Od=r=>{if(!r)return 1;const t=r.state;return!t||t.strm!==r||t.mode<HS||t.mode>I8?1:0},k8=r=>{if(Od(r))return Ya;const t=r.state;return r.total_in=r.total_out=t.total=0,r.msg="",t.wrap&&(r.adler=t.wrap&1),t.mode=HS,t.last=0,t.havedict=0,t.flags=-1,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(uce),t.distcode=t.distdyn=new Int32Array(lce),t.sane=1,t.back=-1,Jh},N8=r=>{if(Od(r))return Ya;const t=r.state;return t.wsize=0,t.whave=0,t.wnext=0,k8(r)},T8=(r,t)=>{let n;if(Od(r))return Ya;const s=r.state;return t<0?(n=0,t=-t):(n=(t>>4)+5,t<48&&(t&=15)),t&&(t<8||t>15)?Ya:(s.window!==null&&s.wbits!==t&&(s.window=null),s.wrap=n,s.wbits=t,N8(r))},A8=(r,t)=>{if(!r)return Ya;const n=new dce;r.state=n,n.strm=r,n.window=null,n.mode=HS;const s=T8(r,t);return s!==Jh&&(r.state=null),s},pce=r=>A8(r,hce);let n4=!0,CE,_E;const fce=r=>{if(n4){CE=new Int32Array(512),_E=new Int32Array(32);let t=0;for(;t<144;)r.lens[t++]=8;for(;t<256;)r.lens[t++]=9;for(;t<280;)r.lens[t++]=7;for(;t<288;)r.lens[t++]=8;for(Ky(w8,r.lens,0,288,CE,0,r.work,{bits:9}),t=0;t<32;)r.lens[t++]=5;Ky(S8,r.lens,0,32,_E,0,r.work,{bits:5}),n4=!1}r.lencode=CE,r.lenbits=9,r.distcode=_E,r.distbits=5},D8=(r,t,n,s)=>{let i;const a=r.state;return a.window===null&&(a.wsize=1<<a.wbits,a.wnext=0,a.whave=0,a.window=new Uint8Array(a.wsize)),s>=a.wsize?(a.window.set(t.subarray(n-a.wsize,n),0),a.wnext=0,a.whave=a.wsize):(i=a.wsize-a.wnext,i>s&&(i=s),a.window.set(t.subarray(n-s,n-s+i),a.wnext),s-=i,s?(a.window.set(t.subarray(n-s,n),0),a.wnext=s,a.whave=a.wsize):(a.wnext+=i,a.wnext===a.wsize&&(a.wnext=0),a.whave<a.wsize&&(a.whave+=i))),0},mce=(r,t)=>{let n,s,i,a,o,u,l,c,h,d,p,f,m,g,y=0,b,x,w,v,S,E,C,I;const _=new Uint8Array(4);let A,k;const N=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(Od(r)||!r.output||!r.input&&r.avail_in!==0)return Ya;n=r.state,n.mode===Fu&&(n.mode=vE),o=r.next_out,i=r.output,l=r.avail_out,a=r.next_in,s=r.input,u=r.avail_in,c=n.hold,h=n.bits,d=u,p=l,I=Jh;e:for(;;)switch(n.mode){case HS:if(n.wrap===0){n.mode=vE;break}for(;h<16;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}if(n.wrap&2&&c===35615){n.wbits===0&&(n.wbits=15),n.check=0,_[0]=c&255,_[1]=c>>>8&255,n.check=Ho(n.check,_,2,0),c=0,h=0,n.mode=OB;break}if(n.head&&(n.head.done=!1),!(n.wrap&1)||(((c&255)<<8)+(c>>8))%31){r.msg="incorrect header check",n.mode=An;break}if((c&15)!==RB){r.msg="unknown compression method",n.mode=An;break}if(c>>>=4,h-=4,C=(c&15)+8,n.wbits===0&&(n.wbits=C),C>15||C>n.wbits){r.msg="invalid window size",n.mode=An;break}n.dmax=1<<n.wbits,n.flags=0,r.adler=n.check=1,n.mode=c&512?WB:Fu,c=0,h=0;break;case OB:for(;h<16;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}if(n.flags=c,(n.flags&255)!==RB){r.msg="unknown compression method",n.mode=An;break}if(n.flags&57344){r.msg="unknown header flags set",n.mode=An;break}n.head&&(n.head.text=c>>8&1),n.flags&512&&n.wrap&4&&(_[0]=c&255,_[1]=c>>>8&255,n.check=Ho(n.check,_,2,0)),c=0,h=0,n.mode=MB;case MB:for(;h<32;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}n.head&&(n.head.time=c),n.flags&512&&n.wrap&4&&(_[0]=c&255,_[1]=c>>>8&255,_[2]=c>>>16&255,_[3]=c>>>24&255,n.check=Ho(n.check,_,4,0)),c=0,h=0,n.mode=LB;case LB:for(;h<16;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}n.head&&(n.head.xflags=c&255,n.head.os=c>>8),n.flags&512&&n.wrap&4&&(_[0]=c&255,_[1]=c>>>8&255,n.check=Ho(n.check,_,2,0)),c=0,h=0,n.mode=PB;case PB:if(n.flags&1024){for(;h<16;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}n.length=c,n.head&&(n.head.extra_len=c),n.flags&512&&n.wrap&4&&(_[0]=c&255,_[1]=c>>>8&255,n.check=Ho(n.check,_,2,0)),c=0,h=0}else n.head&&(n.head.extra=null);n.mode=BB;case BB:if(n.flags&1024&&(f=n.length,f>u&&(f=u),f&&(n.head&&(C=n.head.extra_len-n.length,n.head.extra||(n.head.extra=new Uint8Array(n.head.extra_len)),n.head.extra.set(s.subarray(a,a+f),C)),n.flags&512&&n.wrap&4&&(n.check=Ho(n.check,s,f,a)),u-=f,a+=f,n.length-=f),n.length))break e;n.length=0,n.mode=VB;case VB:if(n.flags&2048){if(u===0)break e;f=0;do C=s[a+f++],n.head&&C&&n.length<65536&&(n.head.name+=String.fromCharCode(C));while(C&&f<u);if(n.flags&512&&n.wrap&4&&(n.check=Ho(n.check,s,f,a)),u-=f,a+=f,C)break e}else n.head&&(n.head.name=null);n.length=0,n.mode=zB;case zB:if(n.flags&4096){if(u===0)break e;f=0;do C=s[a+f++],n.head&&C&&n.length<65536&&(n.head.comment+=String.fromCharCode(C));while(C&&f<u);if(n.flags&512&&n.wrap&4&&(n.check=Ho(n.check,s,f,a)),u-=f,a+=f,C)break e}else n.head&&(n.head.comment=null);n.mode=UB;case UB:if(n.flags&512){for(;h<16;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}if(n.wrap&4&&c!==(n.check&65535)){r.msg="header crc mismatch",n.mode=An;break}c=0,h=0}n.head&&(n.head.hcrc=n.flags>>9&1,n.head.done=!0),r.adler=n.check=0,n.mode=Fu;break;case WB:for(;h<32;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}r.adler=n.check=r4(c),c=0,h=0,n.mode=f2;case f2:if(n.havedict===0)return r.next_out=o,r.avail_out=l,r.next_in=a,r.avail_in=u,n.hold=c,n.bits=h,ace;r.adler=n.check=1,n.mode=Fu;case Fu:if(t===sce||t===p1)break e;case vE:if(n.last){c>>>=h&7,h-=h&7,n.mode=SE;break}for(;h<3;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}switch(n.last=c&1,c>>>=1,h-=1,c&3){case 0:n.mode=GB;break;case 1:if(fce(n),n.mode=f1,t===p1){c>>>=2,h-=2;break e}break;case 2:n.mode=jB;break;case 3:r.msg="invalid block type",n.mode=An}c>>>=2,h-=2;break;case GB:for(c>>>=h&7,h-=h&7;h<32;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}if((c&65535)!==(c>>>16^65535)){r.msg="invalid stored block lengths",n.mode=An;break}if(n.length=c&65535,c=0,h=0,n.mode=wE,t===p1)break e;case wE:n.mode=HB;case HB:if(f=n.length,f){if(f>u&&(f=u),f>l&&(f=l),f===0)break e;i.set(s.subarray(a,a+f),o),u-=f,a+=f,l-=f,o+=f,n.length-=f;break}n.mode=Fu;break;case jB:for(;h<14;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}if(n.nlen=(c&31)+257,c>>>=5,h-=5,n.ndist=(c&31)+1,c>>>=5,h-=5,n.ncode=(c&15)+4,c>>>=4,h-=4,n.nlen>286||n.ndist>30){r.msg="too many length or distance symbols",n.mode=An;break}n.have=0,n.mode=qB;case qB:for(;n.have<n.ncode;){for(;h<3;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}n.lens[N[n.have++]]=c&7,c>>>=3,h-=3}for(;n.have<19;)n.lens[N[n.have++]]=0;if(n.lencode=n.lendyn,n.lenbits=7,A={bits:n.lenbits},I=Ky(nce,n.lens,0,19,n.lencode,0,n.work,A),n.lenbits=A.bits,I){r.msg="invalid code lengths set",n.mode=An;break}n.have=0,n.mode=KB;case KB:for(;n.have<n.nlen+n.ndist;){for(;y=n.lencode[c&(1<<n.lenbits)-1],b=y>>>24,x=y>>>16&255,w=y&65535,!(b<=h);){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}if(w<16)c>>>=b,h-=b,n.lens[n.have++]=w;else{if(w===16){for(k=b+2;h<k;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}if(c>>>=b,h-=b,n.have===0){r.msg="invalid bit length repeat",n.mode=An;break}C=n.lens[n.have-1],f=3+(c&3),c>>>=2,h-=2}else if(w===17){for(k=b+3;h<k;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}c>>>=b,h-=b,C=0,f=3+(c&7),c>>>=3,h-=3}else{for(k=b+7;h<k;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}c>>>=b,h-=b,C=0,f=11+(c&127),c>>>=7,h-=7}if(n.have+f>n.nlen+n.ndist){r.msg="invalid bit length repeat",n.mode=An;break}for(;f--;)n.lens[n.have++]=C}}if(n.mode===An)break;if(n.lens[256]===0){r.msg="invalid code -- missing end-of-block",n.mode=An;break}if(n.lenbits=9,A={bits:n.lenbits},I=Ky(w8,n.lens,0,n.nlen,n.lencode,0,n.work,A),n.lenbits=A.bits,I){r.msg="invalid literal/lengths set",n.mode=An;break}if(n.distbits=6,n.distcode=n.distdyn,A={bits:n.distbits},I=Ky(S8,n.lens,n.nlen,n.ndist,n.distcode,0,n.work,A),n.distbits=A.bits,I){r.msg="invalid distances set",n.mode=An;break}if(n.mode=f1,t===p1)break e;case f1:n.mode=m1;case m1:if(u>=6&&l>=258){r.next_out=o,r.avail_out=l,r.next_in=a,r.avail_in=u,n.hold=c,n.bits=h,Zle(r,p),o=r.next_out,i=r.output,l=r.avail_out,a=r.next_in,s=r.input,u=r.avail_in,c=n.hold,h=n.bits,n.mode===Fu&&(n.back=-1);break}for(n.back=0;y=n.lencode[c&(1<<n.lenbits)-1],b=y>>>24,x=y>>>16&255,w=y&65535,!(b<=h);){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}if(x&&(x&240)===0){for(v=b,S=x,E=w;y=n.lencode[E+((c&(1<<v+S)-1)>>v)],b=y>>>24,x=y>>>16&255,w=y&65535,!(v+b<=h);){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}c>>>=v,h-=v,n.back+=v}if(c>>>=b,h-=b,n.back+=b,n.length=w,x===0){n.mode=QB;break}if(x&32){n.back=-1,n.mode=Fu;break}if(x&64){r.msg="invalid literal/length code",n.mode=An;break}n.extra=x&15,n.mode=XB;case XB:if(n.extra){for(k=n.extra;h<k;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}n.length+=c&(1<<n.extra)-1,c>>>=n.extra,h-=n.extra,n.back+=n.extra}n.was=n.length,n.mode=YB;case YB:for(;y=n.distcode[c&(1<<n.distbits)-1],b=y>>>24,x=y>>>16&255,w=y&65535,!(b<=h);){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}if((x&240)===0){for(v=b,S=x,E=w;y=n.distcode[E+((c&(1<<v+S)-1)>>v)],b=y>>>24,x=y>>>16&255,w=y&65535,!(v+b<=h);){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}c>>>=v,h-=v,n.back+=v}if(c>>>=b,h-=b,n.back+=b,x&64){r.msg="invalid distance code",n.mode=An;break}n.offset=w,n.extra=x&15,n.mode=ZB;case ZB:if(n.extra){for(k=n.extra;h<k;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}n.offset+=c&(1<<n.extra)-1,c>>>=n.extra,h-=n.extra,n.back+=n.extra}if(n.offset>n.dmax){r.msg="invalid distance too far back",n.mode=An;break}n.mode=JB;case JB:if(l===0)break e;if(f=p-l,n.offset>f){if(f=n.offset-f,f>n.whave&&n.sane){r.msg="invalid distance too far back",n.mode=An;break}f>n.wnext?(f-=n.wnext,m=n.wsize-f):m=n.wnext-f,f>n.length&&(f=n.length),g=n.window}else g=i,m=o-n.offset,f=n.length;f>l&&(f=l),l-=f,n.length-=f;do i[o++]=g[m++];while(--f);n.length===0&&(n.mode=m1);break;case QB:if(l===0)break e;i[o++]=n.length,l--,n.mode=m1;break;case SE:if(n.wrap){for(;h<32;){if(u===0)break e;u--,c|=s[a++]<<h,h+=8}if(p-=l,r.total_out+=p,n.total+=p,n.wrap&4&&p&&(r.adler=n.check=n.flags?Ho(n.check,i,p,o-p):hk(n.check,i,p,o-p)),p=l,n.wrap&4&&(n.flags?c:r4(c))!==n.check){r.msg="incorrect data check",n.mode=An;break}c=0,h=0}n.mode=e4;case e4:if(n.wrap&&n.flags){for(;h<32;){if(u===0)break e;u--,c+=s[a++]<<h,h+=8}if(n.wrap&4&&c!==(n.total&4294967295)){r.msg="incorrect length check",n.mode=An;break}c=0,h=0}n.mode=t4;case t4:I=ice;break e;case An:I=C8;break e;case E8:return _8;case I8:default:return Ya}return r.next_out=o,r.avail_out=l,r.next_in=a,r.avail_in=u,n.hold=c,n.bits=h,(n.wsize||p!==r.avail_out&&n.mode<An&&(n.mode<SE||t!==$B))&&D8(r,r.output,r.next_out,p-r.avail_out),d-=r.avail_in,p-=r.avail_out,r.total_in+=d,r.total_out+=p,n.total+=p,n.wrap&4&&p&&(r.adler=n.check=n.flags?Ho(n.check,i,p,r.next_out-p):hk(n.check,i,p,r.next_out-p)),r.data_type=n.bits+(n.last?64:0)+(n.mode===Fu?128:0)+(n.mode===f1||n.mode===wE?256:0),(d===0&&p===0||t===$B)&&I===Jh&&(I=oce),I},gce=r=>{if(Od(r))return Ya;let t=r.state;return t.window&&(t.window=null),r.state=null,Jh},yce=(r,t)=>{if(Od(r))return Ya;const n=r.state;return(n.wrap&2)===0?Ya:(n.head=t,t.done=!1,Jh)},bce=(r,t)=>{const n=t.length;let s,i,a;return Od(r)||(s=r.state,s.wrap!==0&&s.mode!==f2)?Ya:s.mode===f2&&(i=1,i=hk(i,t,n,0),i!==s.check)?C8:(a=D8(r,t,n,n),a?(s.mode=E8,_8):(s.havedict=1,Jh))};var xce=N8,vce=T8,wce=k8,Sce=pce,Cce=A8,_ce=mce,Ece=gce,Ice=yce,kce=bce,Nce="pako inflate (from Nodeca project)",Mu={inflateReset:xce,inflateReset2:vce,inflateResetKeep:wce,inflateInit:Sce,inflateInit2:Cce,inflate:_ce,inflateEnd:Ece,inflateGetHeader:Ice,inflateSetDictionary:kce,inflateInfo:Nce};function Tce(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var Ace=Tce;const F8=Object.prototype.toString,{Z_NO_FLUSH:Dce,Z_FINISH:Fce,Z_OK:Cb,Z_STREAM_END:EE,Z_NEED_DICT:IE,Z_STREAM_ERROR:$ce,Z_DATA_ERROR:s4,Z_MEM_ERROR:Rce}=b8;function jS(r){this.options=x8.assign({chunkSize:1024*64,windowBits:15,to:""},r||{});const t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,t.windowBits===0&&(t.windowBits=-15)),t.windowBits>=0&&t.windowBits<16&&!(r&&r.windowBits)&&(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&(t.windowBits&15)===0&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Xle,this.strm.avail_out=0;let n=Mu.inflateInit2(this.strm,t.windowBits);if(n!==Cb)throw new Error(dk[n]);if(this.header=new Ace,Mu.inflateGetHeader(this.strm,this.header),t.dictionary&&(typeof t.dictionary=="string"?t.dictionary=pk.string2buf(t.dictionary):F8.call(t.dictionary)==="[object ArrayBuffer]"&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(n=Mu.inflateSetDictionary(this.strm,t.dictionary),n!==Cb)))throw new Error(dk[n])}jS.prototype.push=function(r,t){const n=this.strm,s=this.options.chunkSize,i=this.options.dictionary;let a,o,u;if(this.ended)return!1;for(t===~~t?o=t:o=t===!0?Fce:Dce,F8.call(r)==="[object ArrayBuffer]"?n.input=new Uint8Array(r):n.input=r,n.next_in=0,n.avail_in=n.input.length;;){for(n.avail_out===0&&(n.output=new Uint8Array(s),n.next_out=0,n.avail_out=s),a=Mu.inflate(n,o),a===IE&&i&&(a=Mu.inflateSetDictionary(n,i),a===Cb?a=Mu.inflate(n,o):a===s4&&(a=IE));n.avail_in>0&&a===EE&&n.state.wrap>0&&r[n.next_in]!==0;)Mu.inflateReset(n),a=Mu.inflate(n,o);switch(a){case $ce:case s4:case IE:case Rce:return this.onEnd(a),this.ended=!0,!1}if(u=n.avail_out,n.next_out&&(n.avail_out===0||a===EE))if(this.options.to==="string"){let l=pk.utf8border(n.output,n.next_out),c=n.next_out-l,h=pk.buf2string(n.output,l);n.next_out=c,n.avail_out=s-c,c&&n.output.set(n.output.subarray(l,l+c),0),this.onData(h)}else this.onData(n.output.length===n.next_out?n.output:n.output.subarray(0,n.next_out));if(!(a===Cb&&u===0)){if(a===EE)return a=Mu.inflateEnd(this.strm),this.onEnd(a),this.ended=!0,!0;if(n.avail_in===0)break}}return!0};jS.prototype.onData=function(r){this.chunks.push(r)};jS.prototype.onEnd=function(r){r===Cb&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=x8.flattenChunks(this.chunks)),this.chunks=[],this.err=r,this.msg=this.strm.msg};function Oce(r,t){const n=new jS(t);if(n.push(r),n.err)throw n.msg||dk[n.err];return n.result}var Mce=Oce,Lce={inflate:Mce};const{inflate:Pce}=Lce;var Bce=Pce;const $8={inflate:Bce};var tt={};tt.parse=function(r){var t=tt.B,n=function(v,S,E,C){var I=tt.T,_={cmap:I.cmap,head:I.head,hhea:I.hhea,maxp:I.maxp,hmtx:I.hmtx,name:I.name,"OS/2":I.OS2,post:I.post,loca:I.loca,kern:I.kern,glyf:I.glyf,"CFF ":I.CFF,GSUB:I.GSUB,CBLC:I.CBLC,CBDT:I.CBDT,"SVG ":I.SVG,COLR:I.colr,CPAL:I.cpal,sbix:I.sbix,fvar:I.fvar,gvar:I.gvar,avar:I.avar,HVAR:I.HVAR},A={_data:v,_index:S,_offset:E};for(var k in _){var N=tt.findTable(v,k,E);if(N){var D=N[0],F=C[D];F==null&&(F=_[k].parseTab(v,D,N[1],A)),A[k]=C[D]=F}}return A};function s(v){var S=t.readUshort(v,12),E=t.readUint(v,16),C=new Uint8Array(E),I=12+S*16;t.writeASCII(C,0,"OTTO"),t.writeUshort(C,4,S);for(var _=44,A=0;A<S;A++){var k=t.readASCII(v,_,4),N=t.readUint(v,_+4),D=t.readUint(v,_+8),F=t.readUint(v,_+12);_+=20;var P=v.slice(N,N+D);D!=F&&(P=$8.inflate(P));var G=12+A*16;t.writeASCII(C,G,k),t.writeUint(C,G+8,I),t.writeUint(C,G+12,F),C.set(P,I),I+=F}return C}var i=new Uint8Array(r);let a;i[0]==119&&(a=i,i=s(i));var o={},u=t.readASCII(i,0,4);if(u=="ttcf"){var l=4;t.readUshort(i,l),l+=2,t.readUshort(i,l),l+=2;var c=t.readUint(i,l);l+=4;for(var h=[],d=0;d<c;d++){var p=t.readUint(i,l);l+=4,h.push(n(i,d,p,o))}return h}var f=n(i,0,0,o);f._compressedData=a;var m=f.fvar;if(m){for(var g=[f],d=0;d<m[1].length;d++){var y=m[1][d],b={};g.push(b);for(var x in f)b[x]=f[x];b._index=d;var w=b.name=JSON.parse(JSON.stringify(b.name));w.fontSubfamily=y[0],y[3]==null&&(y[3]=(w.fontFamily+"-"+w.fontSubfamily).replaceAll(" ","")),w.postScriptName=y[3]}return g}return[f]};tt.findTable=function(r,t,n){for(var s=tt.B,i=s.readUshort(r,n+4),a=n+12,o=0;o<i;o++){var u=s.readASCII(r,a,4);s.readUint(r,a+4);var l=s.readUint(r,a+8),c=s.readUint(r,a+12);if(u==t)return[l,c];a+=16}return null};tt.T={};tt.B={readFixed:function(r,t){return(r[t]<<8|r[t+1])+(r[t+2]<<8|r[t+3])/(256*256+4)},readF2dot14:function(r,t){var n=tt.B.readShort(r,t);return n/16384},readInt:function(r,t){var n=tt.B.t.uint8;return n[0]=r[t+3],n[1]=r[t+2],n[2]=r[t+1],n[3]=r[t],tt.B.t.int32[0]},readInt8:function(r,t){var n=tt.B.t.uint8;return n[0]=r[t],tt.B.t.int8[0]},readShort:function(r,t){var n=tt.B.t.uint16;return n[0]=r[t]<<8|r[t+1],tt.B.t.int16[0]},readUshort:function(r,t){return r[t]<<8|r[t+1]},writeUshort:function(r,t,n){r[t]=n>>8&255,r[t+1]=n&255},readUshorts:function(r,t,n){for(var s=[],i=0;i<n;i++){var a=tt.B.readUshort(r,t+i*2);s.push(a)}return s},readUint:function(r,t){var n=tt.B.t.uint8;return n[3]=r[t],n[2]=r[t+1],n[1]=r[t+2],n[0]=r[t+3],tt.B.t.uint32[0]},writeUint:function(r,t,n){r[t]=n>>24&255,r[t+1]=n>>16&255,r[t+2]=n>>8&255,r[t+3]=n>>0&255},readUint64:function(r,t){return tt.B.readUint(r,t)*4294967296+tt.B.readUint(r,t+4)},readASCII:function(r,t,n){for(var s="",i=0;i<n;i++)s+=String.fromCharCode(r[t+i]);return s},writeASCII:function(r,t,n){for(var s=0;s<n.length;s++)r[t+s]=n.charCodeAt(s)},readUnicode:function(r,t,n){for(var s="",i=0;i<n;i++){var a=r[t++]<<8|r[t++];s+=String.fromCharCode(a)}return s},_tdec:window.TextDecoder?new window.TextDecoder:null,readUTF8:function(r,t,n){var s=tt.B._tdec;return s&&t==0&&n==r.length?s.decode(r):tt.B.readASCII(r,t,n)},readBytes:function(r,t,n){for(var s=[],i=0;i<n;i++)s.push(r[t+i]);return s},readASCIIArray:function(r,t,n){for(var s=[],i=0;i<n;i++)s.push(String.fromCharCode(r[t+i]));return s},t:function(){var r=new ArrayBuffer(8);return{buff:r,int8:new Int8Array(r),uint8:new Uint8Array(r),int16:new Int16Array(r),uint16:new Uint16Array(r),int32:new Int32Array(r),uint32:new Uint32Array(r)}}()};tt.T.CFF={parseTab:function(r,t,n){var s=tt.B,i=tt.T.CFF;r=new Uint8Array(r.buffer,t,n),t=0,r[t],t++,r[t],t++,r[t],t++,r[t],t++;var a=[];t=i.readIndex(r,t,a);for(var o=[],u=0;u<a.length-1;u++)o.push(s.readASCII(r,t+a[u],a[u+1]-a[u]));t+=a[a.length-1];var l=[];t=i.readIndex(r,t,l);for(var c=[],u=0;u<l.length-1;u++)c.push(i.readDict(r,t+l[u],t+l[u+1]));t+=l[l.length-1];var h=c[0],d=[];t=i.readIndex(r,t,d);for(var p=[],u=0;u<d.length-1;u++)p.push(s.readASCII(r,t+d[u],d[u+1]-d[u]));if(t+=d[d.length-1],i.readSubrs(r,t,h),h.CharStrings&&(h.CharStrings=i.readBytes(r,h.CharStrings)),h.ROS){t=h.FDArray;var f=[];t=i.readIndex(r,t,f),h.FDArray=[];for(var u=0;u<f.length-1;u++){var m=i.readDict(r,t+f[u],t+f[u+1]);i._readFDict(r,m,p),h.FDArray.push(m)}t+=f[f.length-1],t=h.FDSelect,h.FDSelect=[];var g=r[t];if(t++,g==3){var y=s.readUshort(r,t);t+=2;for(var u=0;u<y+1;u++)h.FDSelect.push(s.readUshort(r,t),r[t+2]),t+=3}else throw g}return h.charset&&(h.charset=i.readCharset(r,h.charset,h.CharStrings.length)),i._readFDict(r,h,p),h},_readFDict:function(r,t,n){var s=tt.T.CFF,i;t.Private&&(i=t.Private[1],t.Private=s.readDict(r,i,i+t.Private[0]),t.Private.Subrs&&s.readSubrs(r,i+t.Private.Subrs,t.Private));for(var a in t)["FamilyName","FontName","FullName","Notice","version","Copyright"].indexOf(a)!=-1&&(t[a]=n[t[a]-426+35])},readSubrs:function(r,t,n){n.Subrs=tt.T.CFF.readBytes(r,t);var s,i=n.Subrs.length+1;i<1240?s=107:i<33900?s=1131:s=32768,n.Bias=s},readBytes:function(r,t){tt.B;var n=[];t=tt.T.CFF.readIndex(r,t,n);for(var s=[],i=n.length-1,a=r.byteOffset+t,o=0;o<i;o++){var u=n[o];s.push(new Uint8Array(r.buffer,a+u,n[o+1]-u))}return s},tableSE:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],glyphByUnicode:function(r,t){for(var n=0;n<r.charset.length;n++)if(r.charset[n]==t)return n;return-1},glyphBySE:function(r,t){return t<0||t>255?-1:tt.T.CFF.glyphByUnicode(r,tt.T.CFF.tableSE[t])},readCharset:function(r,t,n){var s=tt.B,i=[".notdef"],a=r[t];if(t++,a==0)for(var o=0;o<n;o++){var u=s.readUshort(r,t);t+=2,i.push(u)}else if(a==1||a==2)for(;i.length<n;){var u=s.readUshort(r,t);t+=2;var l=0;a==1?(l=r[t],t++):(l=s.readUshort(r,t),t+=2);for(var o=0;o<=l;o++)i.push(u),u++}else throw"error: format: "+a;return i},readIndex:function(r,t,n){var s=tt.B,i=s.readUshort(r,t)+1;t+=2;var a=r[t];if(t++,a==1)for(var o=0;o<i;o++)n.push(r[t+o]);else if(a==2)for(var o=0;o<i;o++)n.push(s.readUshort(r,t+o*2));else if(a==3)for(var o=0;o<i;o++)n.push(s.readUint(r,t+o*3-1)&16777215);else if(a==4)for(var o=0;o<i;o++)n.push(s.readUint(r,t+o*4));else if(i!=1)throw"unsupported offset size: "+a+", count: "+i;return t+=i*a,t-1},getCharString:function(r,t,n){var s=tt.B,i=r[t],a=r[t+1];r[t+2],r[t+3],r[t+4];var o=1,u=null,l=null;i<=20&&(u=i,o=1),i==12&&(u=i*100+a,o=2),21<=i&&i<=27&&(u=i,o=1),i==28&&(l=s.readShort(r,t+1),o=3),29<=i&&i<=31&&(u=i,o=1),32<=i&&i<=246&&(l=i-139,o=1),247<=i&&i<=250&&(l=(i-247)*256+a+108,o=2),251<=i&&i<=254&&(l=-(i-251)*256-a-108,o=2),i==255&&(l=s.readInt(r,t+1)/65535,o=5),n.val=l??"o"+u,n.size=o},readCharString:function(r,t,n){for(var s=t+n,i=tt.B,a=[];t<s;){var o=r[t],u=r[t+1];r[t+2],r[t+3],r[t+4];var l=1,c=null,h=null;o<=20&&(c=o,l=1),o==12&&(c=o*100+u,l=2),(o==19||o==20)&&(c=o,l=2),21<=o&&o<=27&&(c=o,l=1),o==28&&(h=i.readShort(r,t+1),l=3),29<=o&&o<=31&&(c=o,l=1),32<=o&&o<=246&&(h=o-139,l=1),247<=o&&o<=250&&(h=(o-247)*256+u+108,l=2),251<=o&&o<=254&&(h=-(o-251)*256-u-108,l=2),o==255&&(h=i.readInt(r,t+1)/65535,l=5),a.push(h??"o"+c),t+=l}return a},readDict:function(r,t,n){for(var s=tt.B,i={},a=[];t<n;){var o=r[t],u=r[t+1];r[t+2],r[t+3],r[t+4];var l=1,c=null,h=null;if(o==28&&(h=s.readShort(r,t+1),l=3),o==29&&(h=s.readInt(r,t+1),l=5),32<=o&&o<=246&&(h=o-139,l=1),247<=o&&o<=250&&(h=(o-247)*256+u+108,l=2),251<=o&&o<=254&&(h=-(o-251)*256-u-108,l=2),o==255)throw h=s.readInt(r,t+1)/65535,l=5,"unknown number";if(o==30){var d=[];for(l=1;;){var p=r[t+l];l++;var f=p>>4,m=p&15;if(f!=15&&d.push(f),m!=15&&d.push(m),m==15)break}for(var g="",y=[0,1,2,3,4,5,6,7,8,9,".","e","e-","reserved","-","endOfNumber"],b=0;b<d.length;b++)g+=y[d[b]];h=parseFloat(g)}if(o<=21){var x=["version","Notice","FullName","FamilyName","Weight","FontBBox","BlueValues","OtherBlues","FamilyBlues","FamilyOtherBlues","StdHW","StdVW","escape","UniqueID","XUID","charset","Encoding","CharStrings","Private","Subrs","defaultWidthX","nominalWidthX"];if(c=x[o],l=1,o==12){var x=["Copyright","isFixedPitch","ItalicAngle","UnderlinePosition","UnderlineThickness","PaintType","CharstringType","FontMatrix","StrokeWidth","BlueScale","BlueShift","BlueFuzz","StemSnapH","StemSnapV","ForceBold","","","LanguageGroup","ExpansionFactor","initialRandomSeed","SyntheticBase","PostScript","BaseFontName","BaseFontBlend","","","","","","","ROS","CIDFontVersion","CIDFontRevision","CIDFontType","CIDCount","UIDBase","FDArray","FDSelect","FontName"];c=x[u],l=2}}c!=null?(i[c]=a.length==1?a[0]:a,a=[]):a.push(h),t+=l}return i}};tt.T.cmap={parseTab:function(r,t,n){var s={tables:[],ids:{},off:t};r=new Uint8Array(r.buffer,t,n),t=0;var i=tt.B,a=i.readUshort,o=tt.T.cmap;a(r,t),t+=2;var u=a(r,t);t+=2;for(var l=[],c=0;c<u;c++){var h=a(r,t);t+=2;var d=a(r,t);t+=2;var p=i.readUint(r,t);t+=4;var f="p"+h+"e"+d,m=l.indexOf(p);if(m==-1){m=s.tables.length;var g={};l.push(p);var y=g.format=a(r,p);y==0?g=o.parse0(r,p,g):y==4?g=o.parse4(r,p,g):y==6?g=o.parse6(r,p,g):y==12&&(g=o.parse12(r,p,g)),s.tables.push(g)}s.ids[f]!=null&&console.log("multiple tables for one platform+encoding: "+f),s.ids[f]=m}return s},parse0:function(r,t,n){var s=tt.B;t+=2;var i=s.readUshort(r,t);t+=2,s.readUshort(r,t),t+=2,n.map=[];for(var a=0;a<i-6;a++)n.map.push(r[t+a]);return n},parse4:function(r,t,n){var s=tt.B,i=s.readUshort,a=s.readUshorts,o=t;t+=2;var u=i(r,t);t+=2,i(r,t),t+=2;var l=i(r,t);t+=2;var c=l>>>1;n.searchRange=i(r,t),t+=2,n.entrySelector=i(r,t),t+=2,n.rangeShift=i(r,t),t+=2,n.endCount=a(r,t,c),t+=c*2,t+=2,n.startCount=a(r,t,c),t+=c*2,n.idDelta=[];for(var h=0;h<c;h++)n.idDelta.push(s.readShort(r,t)),t+=2;return n.idRangeOffset=a(r,t,c),t+=c*2,n.glyphIdArray=a(r,t,o+u-t>>1),n},parse6:function(r,t,n){var s=tt.B;t+=2,s.readUshort(r,t),t+=2,s.readUshort(r,t),t+=2,n.firstCode=s.readUshort(r,t),t+=2;var i=s.readUshort(r,t);t+=2,n.glyphIdArray=[];for(var a=0;a<i;a++)n.glyphIdArray.push(s.readUshort(r,t)),t+=2;return n},parse12:function(r,t,n){var s=tt.B,i=s.readUint;t+=4,i(r,t),t+=4,i(r,t),t+=4;var a=i(r,t)*3;t+=4;for(var o=n.groups=new Uint32Array(a),u=0;u<a;u+=3)o[u]=i(r,t+(u<<2)),o[u+1]=i(r,t+(u<<2)+4),o[u+2]=i(r,t+(u<<2)+8);return n}};tt.T.CBLC={parseTab:function(r,t,n){var s=tt.B,i=t;s.readUshort(r,t),t+=2,s.readUshort(r,t),t+=2;var a=s.readUint(r,t);t+=4;for(var o=[],u=0;u<a;u++){var l=s.readUint(r,t);t+=4,s.readUint(r,t),t+=4,s.readUint(r,t),t+=4,t+=4,t+=2*12,s.readUshort(r,t),t+=2,s.readUshort(r,t),t+=2,t+=4;for(var c=i+l,h=0;h<3;h++){var d=s.readUshort(r,c);c+=2;var p=s.readUshort(r,c);c+=2;var f=s.readUint(r,c);c+=4;var m=p-d+1,g=i+l+f,y=s.readUshort(r,g);if(g+=2,y!=1)throw y;var b=s.readUshort(r,g);g+=2;var x=s.readUint(r,g);g+=4;for(var w=[],v=0;v<m;v++){var S=s.readUint(r,g+v*4);w.push(x+S)}o.push([d,p,b,w])}}return o}};tt.T.CBDT={parseTab:function(r,t,n){return tt.B,new Uint8Array(r.buffer,r.byteOffset+t,n)}};tt.T.glyf={parseTab:function(r,t,n,s){for(var i=[],a=s.maxp.numGlyphs,o=0;o<a;o++)i.push(null);return i},_parseGlyf:function(r,t){var n=tt.B,s=r._data,i=r.loca;if(i[t]==i[t+1])return null;var a=tt.findTable(s,"glyf",r._offset)[0]+i[t],o={};if(o.noc=n.readShort(s,a),a+=2,o.xMin=n.readShort(s,a),a+=2,o.yMin=n.readShort(s,a),a+=2,o.xMax=n.readShort(s,a),a+=2,o.yMax=n.readShort(s,a),a+=2,o.xMin>=o.xMax||o.yMin>=o.yMax)return null;if(o.noc>0){o.endPts=[];for(var u=0;u<o.noc;u++)o.endPts.push(n.readUshort(s,a)),a+=2;var l=n.readUshort(s,a);if(a+=2,s.length-a<l)return null;o.instructions=n.readBytes(s,a,l),a+=l;var c=o.endPts[o.noc-1]+1;o.flags=[];for(var u=0;u<c;u++){var h=s[a];if(a++,o.flags.push(h),(h&8)!=0){var d=s[a];a++;for(var p=0;p<d;p++)o.flags.push(h),u++}}o.xs=[];for(var u=0;u<c;u++){var f=(o.flags[u]&2)!=0,m=(o.flags[u]&16)!=0;f?(o.xs.push(m?s[a]:-s[a]),a++):m?o.xs.push(0):(o.xs.push(n.readShort(s,a)),a+=2)}o.ys=[];for(var u=0;u<c;u++){var f=(o.flags[u]&4)!=0,m=(o.flags[u]&32)!=0;f?(o.ys.push(m?s[a]:-s[a]),a++):m?o.ys.push(0):(o.ys.push(n.readShort(s,a)),a+=2)}for(var g=0,y=0,u=0;u<c;u++)g+=o.xs[u],y+=o.ys[u],o.xs[u]=g,o.ys[u]=y}else{var b=1,x=2,w=8,v=32,S=64,E=128,C=256;o.parts=[];var I;do{I=n.readUshort(s,a),a+=2;var _={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(o.parts.push(_),_.glyphIndex=n.readUshort(s,a),a+=2,I&b){var A=n.readShort(s,a);a+=2;var k=n.readShort(s,a);a+=2}else{var A=n.readInt8(s,a);a++;var k=n.readInt8(s,a);a++}I&x?(_.m.tx=A,_.m.ty=k):(_.p1=A,_.p2=k),I&w?(_.m.a=_.m.d=n.readF2dot14(s,a),a+=2):I&S?(_.m.a=n.readF2dot14(s,a),a+=2,_.m.d=n.readF2dot14(s,a),a+=2):I&E&&(_.m.a=n.readF2dot14(s,a),a+=2,_.m.b=n.readF2dot14(s,a),a+=2,_.m.c=n.readF2dot14(s,a),a+=2,_.m.d=n.readF2dot14(s,a),a+=2)}while(I&v);if(I&C){var N=n.readUshort(s,a);a+=2,o.instr=[];for(var u=0;u<N;u++)o.instr.push(s[a]),a++}}return o}};tt.T.head={parseTab:function(r,t,n){var s=tt.B,i={};return s.readFixed(r,t),t+=4,i.fontRevision=s.readFixed(r,t),t+=4,s.readUint(r,t),t+=4,s.readUint(r,t),t+=4,i.flags=s.readUshort(r,t),t+=2,i.unitsPerEm=s.readUshort(r,t),t+=2,i.created=s.readUint64(r,t),t+=8,i.modified=s.readUint64(r,t),t+=8,i.xMin=s.readShort(r,t),t+=2,i.yMin=s.readShort(r,t),t+=2,i.xMax=s.readShort(r,t),t+=2,i.yMax=s.readShort(r,t),t+=2,i.macStyle=s.readUshort(r,t),t+=2,i.lowestRecPPEM=s.readUshort(r,t),t+=2,i.fontDirectionHint=s.readShort(r,t),t+=2,i.indexToLocFormat=s.readShort(r,t),t+=2,i.glyphDataFormat=s.readShort(r,t),t+=2,i}};tt.T.hhea={parseTab:function(r,t,n){var s=tt.B,i={};s.readFixed(r,t),t+=4;for(var a=["ascender","descender","lineGap","advanceWidthMax","minLeftSideBearing","minRightSideBearing","xMaxExtent","caretSlopeRise","caretSlopeRun","caretOffset","res0","res1","res2","res3","metricDataFormat","numberOfHMetrics"],o=0;o<a.length;o++){var u=a[o],l=u=="advanceWidthMax"||u=="numberOfHMetrics"?s.readUshort:s.readShort;i[u]=l(r,t+o*2)}return i}};tt.T.hmtx={parseTab:function(r,t,n,s){for(var i=tt.B,a=[],o=[],u=s.maxp.numGlyphs,l=s.hhea.numberOfHMetrics,c=0,h=0,d=0;d<l;)c=i.readUshort(r,t+(d<<2)),h=i.readShort(r,t+(d<<2)+2),a.push(c),o.push(h),d++;for(;d<u;)a.push(c),o.push(h),d++;return{aWidth:a,lsBearing:o}}};tt.T.kern={parseTab:function(r,t,n,s){var i=tt.B,a=tt.T.kern,o=i.readUshort(r,t);if(o==1)return a.parseV1(r,t,n,s);var u=i.readUshort(r,t+2);t+=4;for(var l={glyph1:[],rval:[]},c=0;c<u;c++){t+=2;var n=i.readUshort(r,t);t+=2;var h=i.readUshort(r,t);t+=2;var d=h>>>8;d&=15,d==0&&(t=a.readFormat0(r,t,l))}return l},parseV1:function(r,t,n,s){var i=tt.B,a=tt.T.kern;i.readFixed(r,t);var o=i.readUint(r,t+4);t+=8;for(var u={glyph1:[],rval:[]},l=0;l<o;l++){i.readUint(r,t),t+=4;var c=i.readUshort(r,t);t+=2,i.readUshort(r,t),t+=2;var h=c&255;h==0&&(t=a.readFormat0(r,t,u))}return u},readFormat0:function(r,t,n){var s=tt.B,i=s.readUshort,a=-1,o=i(r,t);i(r,t+2),i(r,t+4),i(r,t+6),t+=8;for(var u=0;u<o;u++){var l=i(r,t);t+=2;var c=i(r,t);t+=2;var h=s.readShort(r,t);t+=2,l!=a&&(n.glyph1.push(l),n.rval.push({glyph2:[],vals:[]}));var d=n.rval[n.rval.length-1];d.glyph2.push(c),d.vals.push(h),a=l}return t}};tt.T.loca={parseTab:function(r,t,n,s){var i=tt.B,a=[],o=s.head.indexToLocFormat,u=s.maxp.numGlyphs+1;if(o==0)for(var l=0;l<u;l++)a.push(i.readUshort(r,t+(l<<1))<<1);if(o==1)for(var l=0;l<u;l++)a.push(i.readUint(r,t+(l<<2)));return a}};tt.T.maxp={parseTab:function(r,t,n){var s=tt.B,i=s.readUshort,a={};return s.readUint(r,t),t+=4,a.numGlyphs=i(r,t),t+=2,a}};tt.T.name={parseTab:function(r,t,n){var s=tt.B,i={};s.readUshort(r,t),t+=2;var a=s.readUshort(r,t);t+=2;var o=s.readUshort(r,t);t+=2;for(var u=t-6+o,l=["copyright","fontFamily","fontSubfamily","ID","fullName","version","postScriptName","trademark","manufacturer","designer","description","urlVendor","urlDesigner","licence","licenceURL","---","typoFamilyName","typoSubfamilyName","compatibleFull","sampleText","postScriptCID","wwsFamilyName","wwsSubfamilyName","lightPalette","darkPalette"],c=s.readUshort,h=0;h<a;h++){var d=c(r,t);t+=2;var p=c(r,t);t+=2;var f=c(r,t);t+=2;var m=c(r,t);t+=2;var g=c(r,t);t+=2;var y=c(r,t);t+=2;var b=u+y,x;d==0||d==3&&p==0||d==1&&p==25?x=s.readUnicode(r,b,g/2):p==0?x=s.readASCII(r,b,g):p==1||p==3||p==4||p==5||p==10?x=s.readUnicode(r,b,g/2):d==1?(x=s.readASCII(r,b,g),console.log("reading unknown MAC encoding "+p+" as ASCII")):(console.log("unknown encoding "+p+", platformID: "+d),x=s.readASCII(r,b,g));var w="p"+d+","+f.toString(16);i[w]==null&&(i[w]={});var v=l[m];v==null&&(v="_"+m),i[w][v]=x,i[w]._lang=f}var S=tt.T.name.selectOne(i),E="fontFamily";if(S[E]==null)for(var C in i)i[C][E]!=null&&(S[E]=i[C][E]);return S},selectOne:function(r){var t="postScriptName";for(var n in r)if(r[n][t]!=null&&r[n]._lang==1033)return r[n];for(var n in r)if(r[n][t]!=null&&r[n]._lang==0)return r[n];for(var n in r)if(r[n][t]!=null&&r[n]._lang==3084)return r[n];for(var n in r)if(r[n][t]!=null)return r[n];var s;for(var n in r){s=r[n];break}return console.log("returning name table with languageID "+s._lang),s[t]==null&&s.ID!=null&&(s[t]=s.ID),s}};tt.T.OS2={parseTab:function(r,t,n){var s=tt.B,i=s.readUshort(r,t);t+=2;var a=tt.T.OS2,o={};if(i==0)a.version0(r,t,o);else if(i==1)a.version1(r,t,o);else if(i==2||i==3||i==4)a.version2(r,t,o);else if(i==5)a.version5(r,t,o);else throw"unknown OS/2 table version: "+i;return o},version0:function(r,t,n){var s=tt.B;return n.xAvgCharWidth=s.readShort(r,t),t+=2,n.usWeightClass=s.readUshort(r,t),t+=2,n.usWidthClass=s.readUshort(r,t),t+=2,n.fsType=s.readUshort(r,t),t+=2,n.ySubscriptXSize=s.readShort(r,t),t+=2,n.ySubscriptYSize=s.readShort(r,t),t+=2,n.ySubscriptXOffset=s.readShort(r,t),t+=2,n.ySubscriptYOffset=s.readShort(r,t),t+=2,n.ySuperscriptXSize=s.readShort(r,t),t+=2,n.ySuperscriptYSize=s.readShort(r,t),t+=2,n.ySuperscriptXOffset=s.readShort(r,t),t+=2,n.ySuperscriptYOffset=s.readShort(r,t),t+=2,n.yStrikeoutSize=s.readShort(r,t),t+=2,n.yStrikeoutPosition=s.readShort(r,t),t+=2,n.sFamilyClass=s.readShort(r,t),t+=2,n.panose=s.readBytes(r,t,10),t+=10,n.ulUnicodeRange1=s.readUint(r,t),t+=4,n.ulUnicodeRange2=s.readUint(r,t),t+=4,n.ulUnicodeRange3=s.readUint(r,t),t+=4,n.ulUnicodeRange4=s.readUint(r,t),t+=4,n.achVendID=s.readASCII(r,t,4),t+=4,n.fsSelection=s.readUshort(r,t),t+=2,n.usFirstCharIndex=s.readUshort(r,t),t+=2,n.usLastCharIndex=s.readUshort(r,t),t+=2,n.sTypoAscender=s.readShort(r,t),t+=2,n.sTypoDescender=s.readShort(r,t),t+=2,n.sTypoLineGap=s.readShort(r,t),t+=2,n.usWinAscent=s.readUshort(r,t),t+=2,n.usWinDescent=s.readUshort(r,t),t+=2,t},version1:function(r,t,n){var s=tt.B;return t=tt.T.OS2.version0(r,t,n),n.ulCodePageRange1=s.readUint(r,t),t+=4,n.ulCodePageRange2=s.readUint(r,t),t+=4,t},version2:function(r,t,n){var s=tt.B,i=s.readUshort;return t=tt.T.OS2.version1(r,t,n),n.sxHeight=s.readShort(r,t),t+=2,n.sCapHeight=s.readShort(r,t),t+=2,n.usDefault=i(r,t),t+=2,n.usBreak=i(r,t),t+=2,n.usMaxContext=i(r,t),t+=2,t},version5:function(r,t,n){var s=tt.B.readUshort;return t=tt.T.OS2.version2(r,t,n),n.usLowerOpticalPointSize=s(r,t),t+=2,n.usUpperOpticalPointSize=s(r,t),t+=2,t}};tt.T.post={parseTab:function(r,t,n){var s=tt.B,i={};return i.version=s.readFixed(r,t),t+=4,i.italicAngle=s.readFixed(r,t),t+=4,i.underlinePosition=s.readShort(r,t),t+=2,i.underlineThickness=s.readShort(r,t),t+=2,i}};tt.T.SVG={parseTab:function(r,t,n){var s=tt.B,i={entries:[],svgs:[]},a=t;s.readUshort(r,t),t+=2;var o=s.readUint(r,t);t+=4,s.readUint(r,t),t+=4,t=o+a;var u=s.readUshort(r,t);t+=2;for(var l=0;l<u;l++){var c=s.readUshort(r,t);t+=2;var h=s.readUshort(r,t);t+=2;var d=s.readUint(r,t);t+=4;var p=s.readUint(r,t);t+=4;var f=new Uint8Array(r.buffer,a+d+o,p);f[0]==31&&f[1]==139&&f[2]==8&&(f=$8.inflate(f));for(var m=s.readUTF8(f,0,f.length),g=c;g<=h;g++)i.entries[g]=i.svgs.length;i.svgs.push(m)}return i}};tt.T.sbix={parseTab:function(r,t,n,s){for(var i=s.maxp.numGlyphs,a=t,o=tt.B,u=o.readUint(r,t+4),l=[],c=u-1;c<u;c++)for(var h=a+o.readUint(r,t+8+c*4),d=0;d<i;d++){var p=o.readUint(r,h+4+d*4),f=o.readUint(r,h+4+d*4+4);if(p==f){l[d]=null;continue}var m=h+p,g=o.readASCII(r,m+4,4);if(g!="png ")throw g;l[d]=new Uint8Array(r.buffer,r.byteOffset+m+8,f-p-8)}return l}};tt.T.colr={parseTab:function(r,t,n){var s=tt.B,i=t;t+=2;var a=s.readUshort(r,t);t+=2;var o=s.readUint(r,t);t+=4;var u=s.readUint(r,t);t+=4;var l=s.readUshort(r,t);t+=2;for(var c={},h=i+o,d=0;d<a;d++)c["g"+s.readUshort(r,h)]=[s.readUshort(r,h+2),s.readUshort(r,h+4)],h+=6;var p=[];h=i+u;for(var d=0;d<l;d++)p.push(s.readUshort(r,h),s.readUshort(r,h+2)),h+=4;return[c,p]}};tt.T.cpal={parseTab:function(r,t,n){var s=tt.B,i=t,a=s.readUshort(r,t);if(t+=2,a==0){s.readUshort(r,t),t+=2,s.readUshort(r,t),t+=2;var o=s.readUshort(r,t);t+=2;var u=s.readUint(r,t);return t+=4,new Uint8Array(r.buffer,i+u,o*4)}else throw a}};tt.T.GSUB={parseTab:function(r,t,n,s){var i=tt.B,a=i.readUshort;i.readUint;var o=t;a(r,o),o+=2,a(r,o),o+=2,a(r,o),o+=2;var u=a(r,o);o+=2,a(r,o),o+=2,o=t+u;var l={},c=a(r,o);o+=2;for(var h=0;h<c;h++){var d=i.readASCII(r,o,4);o+=4,a(r,o),o+=2,l[d]=!0}return l}};tt.T.fvar={parseTab:function(r,t,n,s){var i=s.name,a=t,o=tt.B,u=[],l=[];a+=8;var c=o.readUshort(r,a);a+=2,a+=2;var h=o.readUshort(r,a);a+=2;var d=o.readUshort(r,a);a+=2;for(var p=0;p<c;p++){var f=o.readASCII(r,a,4),m=o.readFixed(r,a+4),g=o.readFixed(r,a+8),y=o.readFixed(r,a+12),b=o.readUshort(r,a+16),x=o.readUshort(r,a+18);u.push([f,m,g,y,b,i["_"+x]]),a+=20}for(var p=0;p<h;p++){for(var w=o.readUshort(r,a),v=null,b=o.readUshort(r,a+2),S=[],E=0;E<c;E++)S.push(o.readFixed(r,a+4+E*4));a+=4+c*4,(d&3)==2&&(v=o.readUshort(r,a),a+=2),l.push([i["_"+w],b,S,v])}return[u,l]}};tt.T.gvar=function(){var r=32768,t=16384,n=8192,s=128,i=64,a=128,o=32768,u=tt.B;function l(p,f,m){for(var g=[],y=0;y<m;y++)g.push(u.readF2dot14(p,f+y*2));return g}function c(p,f,m,g,y){for(var b=[],x=0;x<m;x++){var w=u.readUshort(p,f);f+=2;var v=u.readUshort(p,f),S=v&61440;v=v&4095,f+=2;var E=null,C=null,I=null;S&r&&(E=l(p,f,g),f+=g*2),S&t&&(C=l(p,f,g),f+=g*2),S&t&&(I=l(p,f,g),f+=g*2),b.push([w,v,S,C,E,I])}return b}function h(p,f,m){var g=p[f];if(f++,g==0)return[[],f];127<g&&(g=(g&127)<<8|p[f++]);for(var y=[],b=0;y.length<g;){var x=p[f];f++;var w=(x&a)!=0;x=(x&127)+1;for(var v=0;v<x;v++){var S=0;w?(S=u.readUshort(p,f),f+=2):(S=p[f],f++),b+=S,y.push(b)}}return[y,f]}function d(p,f,m,g){var y=f+4,b=u.readUshort(p,y);y+=2;var x=u.readUshort(p,y);y+=2;var w=u.readUint(p,y);y+=4;var v=u.readUshort(p,y);y+=2,u.readUshort(p,y),y+=2;var S=u.readUint(p,y);y+=4;for(var E=[],C=0;C<v+1;C++)E.push(u.readUint(p,y+C*4));var I=[],_=[],A=[];y=f+w;for(var C=0;C<x;C++){var k=l(p,y+C*b*2,b),N=[],D=[];I.push(k),_.push(N),A.push(D);for(var F=0;F<b;F++)N[F]=Math.min(k[F],0),D[F]=Math.max(k[F],0)}for(var P=new Int8Array(p.buffer),G=[],C=0;C<v;C++){y=f+S+E[C];var Y=u.readUshort(p,y);y+=2;var Z=Y&o;Y&=4095;var ee=u.readUshort(p,y);y+=2;var se=c(p,y,Y,b),re=[];G.push(re),y=f+S+E[C]+ee;var J=null;if(Z){var le=h(p,y);J=le[0],y=le[1]}for(var he=0;he<Y;he++){var xe=se[he],Fe=y+xe[0],Le=J;if(xe[2]&n){var le=h(p,y);Le=le[0],y=le[1]}for(var Ve=[];y<Fe;){var $e=p[y++],Ae=($e&63)+1;if($e&s)for(var F=0;F<Ae;F++)Ve.push(0);else if($e&i){for(var F=0;F<Ae;F++)Ve.push(u.readShort(p,y+F*2));y+=Ae*2}else{for(var F=0;F<Ae;F++)Ve.push(P[y+F]);y+=Ae}}var Te=xe[1];if(re.push([[xe[3]?xe[3]:_[Te],xe[4]?xe[4]:I[Te],xe[5]?xe[5]:A[Te]],Ve,Le.length==0?null:Le]),Le.length!=0&&Le.length*2!=Ve.length)throw"e"}}return G}return{parseTab:d}}();tt.T.avar={parseTab:function(r,t,n,s){var i=t,a=tt.B,o=[];i+=6;var u=a.readUshort(r,i);i+=2;for(var l=0;l<u;l++){var c=a.readUshort(r,i);i+=2;var h=[];o.push(h);for(var d=0;d<c;d++){var p=a.readF2dot14(r,i),f=a.readF2dot14(r,i+2);i+=4,h.push(p,f)}}return o}};tt.T.HVAR={parseTab:function(r,t,n,s){var i=t,a=t,o=tt.B;i+=4;var u=o.readUint(r,i);i+=4;var l=o.readUint(r,i);i+=4;var c=o.readUint(r,i);i+=4;var h=o.readUint(r,i);if(i+=4,c!=0||h!=0)throw c;i=a+u;var d=i,P=o.readUshort(r,i);if(i+=2,P!=1)throw"e";var p=o.readUint(r,i);i+=4;var f=o.readUshort(r,i);i+=2;for(var m=[],g=0;g<f;g++)m.push(o.readUint(r,i+g*4));i+=f*4,i=d+p;var y=o.readUshort(r,i);i+=2;var b=o.readUshort(r,i);i+=2;for(var x=[],g=0;g<b;g++){var w=[[],[],[]];x.push(w);for(var v=0;v<y;v++)w[0].push(o.readF2dot14(r,i+0)),w[1].push(o.readF2dot14(r,i+2)),w[2].push(o.readF2dot14(r,i+4)),i+=6}for(var S=new Int8Array(r.buffer),E=[],g=0;g<m.length;g++){i=a+u+m[g];var C=[];E.push(C);var I=o.readUshort(r,i);i+=2;var _=o.readUshort(r,i);if(i+=2,_&32768)throw"e";var b=o.readUshort(r,i);i+=2;for(var A=[],v=0;v<b;v++)A.push(o.readUshort(r,i+v*2));i+=b*2;for(var k=0;k<I;k++){for(var N=[],D=0;D<b;D++)N.push(D<_?o.readShort(r,i):S[i]),i+=D<_?2:1;var F=new Array(x.length);F.fill(0),C.push(F);for(var v=0;v<A.length;v++)F[A[v]]=N[v]}}i=a+l;var P=r[i++];if(P!=0)throw"e";var G=r[i++],Y=o.readUshort(r,i);i+=2;for(var Z=15,ee=48,se=((G&ee)>>4)+1,re=[],g=0;g<Y;g++){var J=0;se==1?J=r[i++]:(J=o.readUshort(r,i),i+=2);var le=J>>(G&Z)+1,he=J&(1<<(G&Z)+1)-1;re.push(E[le][he])}return[x,re]}};tt.U=function(){var r={MoveTo:function(I,_,A){I.cmds.push("M"),I.crds.push(_,A)},LineTo:function(I,_,A){I.cmds.push("L"),I.crds.push(_,A)},CurveTo:function(I,_,A,k,N,D,F){I.cmds.push("C"),I.crds.push(_,A,k,N,D,F)},qCurveTo:function(I,_,A,k,N){I.cmds.push("Q"),I.crds.push(_,A,k,N)},ClosePath:function(I){I.cmds.push("Z")}};function t(I,_,A,k){var N=_[A],D=_[A+1],F=I.kern;if(F){var P=F.glyph1.indexOf(N);if(P!=-1){var G=F.rval[P].glyph2.indexOf(D);if(G!=-1)return[0,0,F.rval[P].vals[G],0]}}return[0,0,0,0]}function n(I,_,A){A==null&&(A={}),A.ltr,A.fts;var k=A.axs;I.fvar&&k==null&&(k=I.fvar[1][I._index][2]);var N=I.HVAR;k&&N&&(k=p(I,k));for(var D=[],F=0;F<_.length;F++){var P=_.codePointAt(F);P>65535&&F++,D.push(l(I,P))}for(var G=[],F=0;F<D.length;F++){var Y=t(I,D,F),Z=D[F],ee=I.hmtx.aWidth[Z]+Y[2];if(N&&N[1][Z])for(var se=N[1][Z],re=0;re<N[0].length;re++)ee+=d(N[0][re],k)*se[re];G.push({g:Z,cl:F,dx:0,dy:0,ax:ee,ay:0})}return G}function s(I,_,A){var k={cmds:[],crds:[]},N=0,D=0,F,P;A&&(F=A.clr,P=A.axs);for(var G=0;G<_.length;G++){for(var Y=_[G],Z=c(I,Y.g,!1,P),ee=Z.crds,se=0;se<ee.length;se+=2)k.crds.push(ee[se]+N+Y.dx),k.crds.push(ee[se+1]+D+Y.dy);F&&k.cmds.push(F);for(var se=0;se<Z.cmds.length;se++)k.cmds.push(Z.cmds[se]);var re=k.cmds.length;F&&re!=0&&k.cmds[re-1]!="X"&&k.cmds.push("X"),N+=Y.ax,D+=Y.ay}return{cmds:k.cmds,crds:k.crds}}function i(I,_,A){for(var k=0,N=~~(I.length/_);k+1!=N;){var D=k+(N-k>>>1);I[D*_]<=A?k=D:N=D}return k*_}for(var a=[9,10,11,12,13,32,133,160,5760,6158,8232,8233,8239,8288,12288,65279],o={},u=0;u<a.length;u++)o[a[u]]=1;for(var u=8192;u<=8205;u++)o[u]=1;function l(I,_){if(I._ctab==null){for(var A=I.cmap,k=-1,N=["p3e10","p0e4","p3e1","p1e0","p0e3","p0e1","p3e0","p3e5"],D=0;D<N.length;D++)if(A.ids[N[D]]!=null){k=A.ids[N[D]];break}if(k==-1)throw"no familiar platform and encoding!";I._ctab=A.tables[k]}var F=I._ctab,P=F.format,G=-1;if(P==0)_>=F.map.length?G=0:G=F.map[_];else if(P==4){var Y=F.endCount;if(G=0,_<=Y[Y.length-1]){var Z=i(Y,1,_);if(Y[Z]<_&&Z++,_>=F.startCount[Z]){var ee=0;F.idRangeOffset[Z]!=0?ee=F.glyphIdArray[_-F.startCount[Z]+(F.idRangeOffset[Z]>>1)-(F.idRangeOffset.length-Z)]:ee=_+F.idDelta[Z],G=ee&65535}}}else if(P==6){var se=_-F.firstCode,re=F.glyphIdArray;se<0||se>=re.length?G=0:G=re[se]}else if(P==12){var J=F.groups;if(G=0,_<=J[J.length-2]){var D=i(J,3,_);J[D]<=_&&_<=J[D+1]&&(G=J[D+2]+(_-J[D]))}}else throw"unknown cmap table format "+F.format;var le=I["SVG "],he=I.loca;return G!=0&&I["CFF "]==null&&(le==null||le.entries[G]==null)&&he&&he[G]==he[G+1]&&o[_]==null&&(G=0),G}function c(I,_,A,k){var N={cmds:[],crds:[]};I.fvar&&(k==null&&(k=I.fvar[1][I._index][2]),k=p(I,k));var D=I["SVG "],F=I["CFF "],P=I.COLR,G=I.CBLC,Y=I.CBDT,Z=I.sbix,ee=window.UPNG,se=null;if(G&&ee)for(var re=0;re<G.length;re++)G[re][0]<=_&&_<=G[re][1]&&(se=G[re]);if(se||Z&&Z[_]){if(se&&se[2]!=17)throw"not a PNG";I.__tmp==null&&(I.__tmp={});var J=I.__tmp["g"+_];if(J==null){var le,he;if(Z)le=Z[_],he=le.length;else{var xe=se[3][_-se[0]]+5;he=Y[xe+1]<<16|Y[xe+2]<<8|Y[xe+3],xe+=4,le=new Uint8Array(Y.buffer,Y.byteOffset+xe,he)}for(var Fe="",re=0;re<he;re++)Fe+=String.fromCharCode(le[re]);J=I.__tmp["g"+_]="data:image/png;base64,"+btoa(Fe)}N.cmds.push(J);var Le=I.head.unitsPerEm*1.15,Ve=Math.round(Le),$e=Math.round(Le),Ae=Math.round(-$e*.15);N.crds.push(0,$e+Ae,Ve,$e+Ae,Ve,Ae,0,Ae)}else if(D&&D.entries[_]){var Te=D.entries[_];if(Te!=null){if(typeof Te=="number"){var Ue=D.svgs[Te];if(typeof Ue=="string"){var qe=new DOMParser,Me=qe.parseFromString(Ue,"image/svg+xml");Ue=D.svgs[Te]=Me.getElementsByTagName("svg")[0]}Te=tt.U.SVG.toPath(Ue,_),D.entries[_]=Te}N=Te}}else if(A!=!0&&P&&P[0]["g"+_]&&P[0]["g"+_][1]>1){let Mt=function(it){var kt=it.toString(16);return(kt.length==1?"0":"")+kt};for(var ht=Mt,ie=I.CPAL,K=P[0]["g"+_],re=0;re<K[1];re++){var pe=K[0]+re,_e=P[1][2*pe],We=P[1][2*pe+1]*4,Oe=c(I,_e,_e==_),nt="#"+Mt(ie[We+2])+Mt(ie[We+1])+Mt(ie[We+0]);N.cmds.push(nt),N.cmds=N.cmds.concat(Oe.cmds),N.crds=N.crds.concat(Oe.crds),N.cmds.push("X")}}else if(F){var rt=F.Private,pt={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:rt?rt.defaultWidthX:0,open:!1};if(F.ROS){for(var Et=0;F.FDSelect[Et+2]<=_;)Et+=2;rt=F.FDArray[F.FDSelect[Et+1]].Private}E(F.CharStrings[_],pt,F,rt,N)}else I.glyf&&h(_,I,N,k);return{cmds:N.cmds,crds:N.crds}}function h(I,_,A,k){var N=_.glyf[I];N==null&&(N=_.glyf[I]=tt.T.glyf._parseGlyf(_,I)),N!=null&&(N.noc>-1?m(N,_,I,A,k):g(N,_,I,A,k))}function d(I,_){_.length;for(var A=1,k=I[0],N=I[1],D=I[2],F=0;F<_.length;F++){var P=1;k[F]>N[F]||N[F]>D[F]||k[F]<0&&D[F]>0&&N[F]!=0||N[F]==0?P=1:_[F]<k[F]||_[F]>D[F]?P=0:_[F]==N[F]?P=1:_[F]<N[F]?P=(_[F]-k[F])/(N[F]-k[F]):P=(D[F]-_[F])/(D[F]-N[F]),A=A*P}return A}function p(I,_){for(var A=I.fvar,k=I.avar,N=A?A[0]:null,D=[],F=0;F<N.length;F++){var P=N[F][1],G=N[F][2],Y=N[F][3],Z=Math.max(P,Math.min(Y,_[F]));if(Z<G?D[F]=(G-Z)/(P-G):Z>G?D[F]=(Z-G)/(Y-G):D[F]=0,k&&D[F]!=-1){for(var ee=k[F],se=0;se<ee.length&&!(ee[se]>=D[F]);se+=2);var re=(D[F]-ee[se-2])/(ee[se]-ee[se-2]);D[F]=re*ee[se+1]+(1-re)*ee[se-1]}}return D}function f(I,_,A,k,N){var D=A.length,F=new Array(D*2+8);F.fill(0);for(var P=0;P<D;P++){var G=0,Y=0,Z=_.indexOf(P);if(Z!=-1)G=I[Z],Y=I[_.length+Z];else{for(var ee=0;N[ee]<P;)ee++;for(var se=ee==0?0:N[ee-1]+1,re=N[ee],J=-1,le=-1,he=0;he<_.length;he++){var xe=_[he];xe<se||xe>re||xe>=D||(J=he,le==-1&&(le=he))}for(var he=0;he<_.length;he++){var xe=_[he];if(!(xe<se||xe>re||xe>=D)&&(xe<P&&(J=he),P<xe)){le=he;break}}for(var Fe=0;Fe<2;Fe++){var Le=Fe==0?A:k,Ve=Fe*_.length,$e=0,Ae=Le[_[J]],Te=Le[_[le]],Ue=Le[P],qe=I[Ve+J],Me=I[Ve+le];if(Ae==Te)qe==Me?$e=qe:$e=0;else if(Ue<=Math.min(Ae,Te))Ae<Te?$e=qe:$e=Me;else if(Math.max(Ae,Te)<=Ue)Ae<Te?$e=Me:$e=qe;else{var ie=(Ue-Ae)/(Te-Ae);$e=ie*Me+(1-ie)*qe}Fe==0?G=$e:Y=$e}}F[P]=G,F[D+4+P]=Y}return F}function m(I,_,A,k,N){var D=I.xs,F=I.ys;if(_.fvar&&N){D=D.slice(0),F=F.slice(0);for(var P=_.gvar,G=P?P[A]:null,Y=0;Y<G.length;Y++){var Z=G[Y][0],ee=d(Z,N);if(!(ee<1e-9)){var se=G[Y][1],re=G[Y][2];if(re&&(se=G[Y][1]=f(se,re,D,F,I.endPts),G[Y][2]=null),se.length==D.length*2+8)for(var J=0;J<D.length;J++)D[J]+=ee*se[J],F[J]+=ee*se[J+D.length+4]}}}for(var le=0;le<I.noc;le++){for(var he=le==0?0:I.endPts[le-1]+1,xe=I.endPts[le],J=he;J<=xe;J++){var Fe=J==he?xe:J-1,Le=J==xe?he:J+1,Ve=I.flags[J]&1,$e=I.flags[Fe]&1,Ae=I.flags[Le]&1,Te=D[J],Ue=F[J];if(J==he)if(Ve)if($e)r.MoveTo(k,D[Fe],F[Fe]);else{r.MoveTo(k,Te,Ue);continue}else $e?r.MoveTo(k,D[Fe],F[Fe]):r.MoveTo(k,Math.floor((D[Fe]+Te)*.5),Math.floor((F[Fe]+Ue)*.5));Ve?$e&&r.LineTo(k,Te,Ue):Ae?r.qCurveTo(k,Te,Ue,D[Le],F[Le]):r.qCurveTo(k,Te,Ue,Math.floor((Te+D[Le])*.5),Math.floor((Ue+F[Le])*.5))}r.ClosePath(k)}}function g(I,_,A,k,N){var D=[0,0,0,0,0,0],F=[0,0,0,0,0,0],P=I.parts.length;if(_.fvar&&N)for(var G=_.gvar,Y=G?G[A]:null,Z=0;Z<Y.length;Z++){var ee=Y[Z][0],se=d(ee,N);if(!(se<1e-6)){var re=Y[Z][1],J=Y[Z][2];if(J==null)for(var le=0;le<P;le++)D[le]+=se*re[le],F[le]+=se*re[le+P+4];else for(var he=0;he<J.length;he++){var le=J[he];D[le]+=se*re[0],F[le]+=se*re[0+P]}}}for(var he=0;he<P;he++){var xe={cmds:[],crds:[]},Fe=I.parts[he];h(Fe.glyphIndex,_,xe,N);for(var Le=Fe.m,Ve=Le.tx+D[he],$e=Le.ty+F[he],le=0;le<xe.crds.length;le+=2){var Ae=xe.crds[le],Te=xe.crds[le+1];k.crds.push(Ae*Le.a+Te*Le.c+Ve),k.crds.push(Ae*Le.b+Te*Le.d+$e)}for(var le=0;le<xe.cmds.length;le++)k.cmds.push(xe.cmds[le])}}function y(I,_){var A=I.cmds,k=I.crds;_==null&&(_=5);function N(qe){return parseFloat(qe.toFixed(_))}function D(qe){for(var Me=[],ie=!1,K="",pe=0;pe<qe.length;pe++){var _e=qe[pe],We=typeof _e=="number";if(!We){if(_e==K&&_e.length==1&&_e!="m")continue;K=_e}ie&&We&&_e>=0&&Me.push(" "),Me.push(_e),ie=We}return Me.join("")}for(var F=[],P=0,G={M:2,L:2,Q:4,C:6},Y=0,Z=0,ee=0,se=0,re=0,J=0,le=0;le<A.length;le++){var he=A[le],xe=G[he]?G[he]:0,Fe=[],Le,Ve,$e,Ae;if(he=="L")Le=k[P]-Y,Ve=k[P+1]-Z,$e=N(Le+ee),Ae=N(Ve+se),A[le+1]=="Z"&&k[P]==re&&k[P+1]==J?($e=Le,Ae=Ve):$e==0&&Ae==0||($e==0?Fe.push("v",Ae):Ae==0?Fe.push("h",$e):Fe.push("l",$e,Ae));else{Fe.push(he.toLowerCase());for(var Te=0;Te<xe;Te+=2)Le=k[P+Te]-Y,Ve=k[P+Te+1]-Z,$e=N(Le+ee),Ae=N(Ve+se),Fe.push($e,Ae)}xe!=0&&(ee+=Le-$e,se+=Ve-Ae);for(var Ue=Fe,Te=0;Te<Ue.length;Te++)F.push(Ue[Te]);xe!=0&&(P+=xe,Y=k[P-2],Z=k[P-1]),he=="M"&&(re=Y,J=Z),he=="Z"&&(Y=re,Z=J)}return D(F)}function b(I){var _={cmds:[],crds:[]};return tt.U.SVG.svgToPath(I,_),{cmds:_.cmds,crds:_.crds}}function x(I,_,A,k){for(var N=_>>1,D=A>>1,F=new Uint8Array(N*D*4),P=new Uint32Array(I.buffer),G=new Uint32Array(F.buffer),Y=0;Y<D;Y++)for(var Z=0;Z<N;Z++){var ee=Y*N+Z,se=(Y<<1)*_+(Z<<1),re=P[se],J=P[se+1],le=P[se+_],he=P[se+_+1],xe=re>>>24,Fe=J>>>24,Le=le>>>24,Ve=he>>>24,$e=xe+Fe+Le+Ve;if($e==1020){var Ae=(re>>>0&255)+(J>>>0&255)+(le>>>0&255)+(he>>>0&255)+2>>>2,Te=(re>>>8&255)+(J>>>8&255)+(le>>>8&255)+(he>>>8&255)+2>>>2,Ue=(re>>>16&255)+(J>>>16&255)+(le>>>16&255)+(he>>>16&255)+2>>>2;G[ee]=255<<24|Ue<<16|Te<<8|Ae}else if($e==0)G[ee]=0;else{var Ae=(re>>>0&255)*xe+(J>>>0&255)*Fe+(le>>>0&255)*Le+(he>>>0&255)*Ve,Te=(re>>>8&255)*xe+(J>>>8&255)*Fe+(le>>>8&255)*Le+(he>>>8&255)*Ve,Ue=(re>>>16&255)*xe+(J>>>16&255)*Fe+(le>>>16&255)*Le+(he>>>16&255)*Ve,qe=1/$e;Ae=~~(Ae*qe+.5),Te=~~(Te*qe+.5),Ue=~~(Ue*qe+.5),G[ee]=$e+2>>>2<<24|Ue<<16|Te<<8|Ae}}return{buff:F,w:N,h:D}}var w,v;function S(I,_){for(var A=0,k=I.cmds,N=I.crds,D=0;D<k.length;D++){var F=k[D];if(F=="M")_.moveTo(N[A],N[A+1]),A+=2;else if(F=="L")_.lineTo(N[A],N[A+1]),A+=2;else if(F=="C")_.bezierCurveTo(N[A],N[A+1],N[A+2],N[A+3],N[A+4],N[A+5]),A+=6;else if(F=="Q")_.quadraticCurveTo(N[A],N[A+1],N[A+2],N[A+3]),A+=4;else if(F[0]=="d"){var P=window.UPNG,G=N[A],Y=N[A+1],Z=N[A+2],ee=N[A+3],se=N[A+4],re=N[A+5],J=N[A+6],le=N[A+7];if(A+=8,P==null){_.moveTo(G,Y),_.lineTo(Z,ee),_.lineTo(se,re),_.lineTo(J,le),_.closePath();continue}for(var he=Z-G,xe=ee-Y,Fe=J-G,Le=le-Y,Ve=atob(F.slice(22)),$e=new Uint8Array(Ve.length),Ae=0;Ae<Ve.length;Ae++)$e[Ae]=Ve.charCodeAt(Ae);for(var Te=P.decode($e.buffer),Ue=Te.width,qe=Te.height,Me=new Uint8Array(P.toRGBA8(Te)[0]),ie=_.getTransform(),K=Math.sqrt(Math.abs(ie.a*ie.d-ie.b*ie.c))*Math.sqrt(Fe*Fe+Le*Le)/qe;K<.5;){var pe=x(Me,Ue,qe);Me=pe.buff,Ue=pe.w,qe=pe.h,K*=2}w==null&&(w=document.createElement("canvas"),v=w.getContext("2d")),(w.width!=Ue||w.height!=qe)&&(w.width=Ue,w.height=qe),v.putImageData(new ImageData(new Uint8ClampedArray(Me.buffer),Ue,qe),0,0),_.save(),_.transform(he,xe,Fe,Le,G,Y),_.scale(1/Ue,1/qe),_.drawImage(w,0,0),_.restore()}else if(F.charAt(0)=="#"||F.charAt(0)=="r")_.beginPath(),_.fillStyle=F;else if(F.charAt(0)=="O"&&F!="OX"){_.beginPath();var _e=F.split("-");_.lineWidth=parseFloat(_e[2]),_.lineCap=["butt","round","square"][parseFloat(_e[3])],_.lineJoin=["miter","round","bevel"][parseFloat(_e[4])],_.miterLimit=parseFloat(_e[5]),_.lineDashOffset=parseFloat(_e[6]),_.setLineDash(_e[7].split(",").map(parseFloat)),_.strokeStyle=_e[1]}else F=="Z"?_.closePath():F=="X"?_.fill():F=="OX"&&_.stroke()}}function E(I,_,A,k,N){for(var D=_.stack,F=_.nStems,P=_.haveWidth,G=_.width,Y=_.open,Z=0,ee=_.x,se=_.y,re=0,J=0,le=0,he=0,xe=0,Fe=0,Le=0,Ve=0,$e=0,Ae=0,Te=tt.T.CFF,Ue=k.nominalWidthX,qe={val:0,size:0};Z<I.length;){Te.getCharString(I,Z,qe);var Me=qe.val;if(Z+=qe.size,Me=="o1"||Me=="o18"){var ie;ie=D.length%2!==0,ie&&!P&&(G=D.shift()+Ue),F+=D.length>>1,D.length=0,P=!0}else if(Me=="o3"||Me=="o23"){var ie;ie=D.length%2!==0,ie&&!P&&(G=D.shift()+Ue),F+=D.length>>1,D.length=0,P=!0}else if(Me=="o4")D.length>1&&!P&&(G=D.shift()+Ue,P=!0),Y&&r.ClosePath(N),se+=D.pop(),r.MoveTo(N,ee,se),Y=!0;else if(Me=="o5")for(;D.length>0;)ee+=D.shift(),se+=D.shift(),r.LineTo(N,ee,se);else if(Me=="o6"||Me=="o7")for(var K=D.length,pe=Me=="o6",_e=0;_e<K;_e++){var We=D.shift();pe?ee+=We:se+=We,pe=!pe,r.LineTo(N,ee,se)}else if(Me=="o8"||Me=="o24"){for(var K=D.length,Oe=0;Oe+6<=K;)re=ee+D.shift(),J=se+D.shift(),le=re+D.shift(),he=J+D.shift(),ee=le+D.shift(),se=he+D.shift(),r.CurveTo(N,re,J,le,he,ee,se),Oe+=6;Me=="o24"&&(ee+=D.shift(),se+=D.shift(),r.LineTo(N,ee,se))}else{if(Me=="o11")break;if(Me=="o1234"||Me=="o1235"||Me=="o1236"||Me=="o1237")Me=="o1234"&&(re=ee+D.shift(),J=se,le=re+D.shift(),he=J+D.shift(),$e=le+D.shift(),Ae=he,xe=$e+D.shift(),Fe=he,Le=xe+D.shift(),Ve=se,ee=Le+D.shift(),r.CurveTo(N,re,J,le,he,$e,Ae),r.CurveTo(N,xe,Fe,Le,Ve,ee,se)),Me=="o1235"&&(re=ee+D.shift(),J=se+D.shift(),le=re+D.shift(),he=J+D.shift(),$e=le+D.shift(),Ae=he+D.shift(),xe=$e+D.shift(),Fe=Ae+D.shift(),Le=xe+D.shift(),Ve=Fe+D.shift(),ee=Le+D.shift(),se=Ve+D.shift(),D.shift(),r.CurveTo(N,re,J,le,he,$e,Ae),r.CurveTo(N,xe,Fe,Le,Ve,ee,se)),Me=="o1236"&&(re=ee+D.shift(),J=se+D.shift(),le=re+D.shift(),he=J+D.shift(),$e=le+D.shift(),Ae=he,xe=$e+D.shift(),Fe=he,Le=xe+D.shift(),Ve=Fe+D.shift(),ee=Le+D.shift(),r.CurveTo(N,re,J,le,he,$e,Ae),r.CurveTo(N,xe,Fe,Le,Ve,ee,se)),Me=="o1237"&&(re=ee+D.shift(),J=se+D.shift(),le=re+D.shift(),he=J+D.shift(),$e=le+D.shift(),Ae=he+D.shift(),xe=$e+D.shift(),Fe=Ae+D.shift(),Le=xe+D.shift(),Ve=Fe+D.shift(),Math.abs(Le-ee)>Math.abs(Ve-se)?ee=Le+D.shift():se=Ve+D.shift(),r.CurveTo(N,re,J,le,he,$e,Ae),r.CurveTo(N,xe,Fe,Le,Ve,ee,se));else if(Me=="o14"){if(D.length>0&&D.length!=4&&!P&&(G=D.shift()+A.nominalWidthX,P=!0),D.length==4){var nt=D.shift(),rt=D.shift(),pt=D.shift(),Et=D.shift(),ht=Te.glyphBySE(A,pt),Mt=Te.glyphBySE(A,Et);E(A.CharStrings[ht],_,A,k,N),_.x=nt,_.y=rt,E(A.CharStrings[Mt],_,A,k,N)}Y&&(r.ClosePath(N),Y=!1)}else if(Me=="o19"||Me=="o20"){var ie;ie=D.length%2!==0,ie&&!P&&(G=D.shift()+Ue),F+=D.length>>1,D.length=0,P=!0,Z+=F+7>>3}else if(Me=="o21")D.length>2&&!P&&(G=D.shift()+Ue,P=!0),se+=D.pop(),ee+=D.pop(),Y&&r.ClosePath(N),r.MoveTo(N,ee,se),Y=!0;else if(Me=="o22")D.length>1&&!P&&(G=D.shift()+Ue,P=!0),ee+=D.pop(),Y&&r.ClosePath(N),r.MoveTo(N,ee,se),Y=!0;else if(Me=="o25"){for(;D.length>6;)ee+=D.shift(),se+=D.shift(),r.LineTo(N,ee,se);re=ee+D.shift(),J=se+D.shift(),le=re+D.shift(),he=J+D.shift(),ee=le+D.shift(),se=he+D.shift(),r.CurveTo(N,re,J,le,he,ee,se)}else if(Me=="o26")for(D.length%2&&(ee+=D.shift());D.length>0;)re=ee,J=se+D.shift(),le=re+D.shift(),he=J+D.shift(),ee=le,se=he+D.shift(),r.CurveTo(N,re,J,le,he,ee,se);else if(Me=="o27")for(D.length%2&&(se+=D.shift());D.length>0;)re=ee+D.shift(),J=se,le=re+D.shift(),he=J+D.shift(),ee=le+D.shift(),se=he,r.CurveTo(N,re,J,le,he,ee,se);else if(Me=="o10"||Me=="o29"){var it=Me=="o10"?k:A;if(D.length==0)console.log("error: empty stack");else{var kt=D.pop(),Lt=it.Subrs[kt+it.Bias];_.x=ee,_.y=se,_.nStems=F,_.haveWidth=P,_.width=G,_.open=Y,E(Lt,_,A,k,N),ee=_.x,se=_.y,F=_.nStems,P=_.haveWidth,G=_.width,Y=_.open}}else if(Me=="o30"||Me=="o31"){var K,wn=D.length,Oe=0,Gr=Me=="o31";for(K=wn&-3,Oe+=wn-K;Oe<K;)Gr?(re=ee+D.shift(),J=se,le=re+D.shift(),he=J+D.shift(),se=he+D.shift(),K-Oe==5?(ee=le+D.shift(),Oe++):ee=le,Gr=!1):(re=ee,J=se+D.shift(),le=re+D.shift(),he=J+D.shift(),ee=le+D.shift(),K-Oe==5?(se=he+D.shift(),Oe++):se=he,Gr=!0),r.CurveTo(N,re,J,le,he,ee,se),Oe+=4}else{if((Me+"").charAt(0)=="o")throw console.log("Unknown operation: "+Me,I),Me;D.push(Me)}}}_.x=ee,_.y=se,_.nStems=F,_.haveWidth=P,_.width=G,_.open=Y}function C(I,_){var A=function(k){var N=0;return(k&4294967168)==0?N=1:(k&4294965248)==0?N=2:(k&4294901760)==0?N=3:(k&4292870144)==0&&(N=4),N};fetch(I).then(function(k){return k.arrayBuffer()}).then(function(k){return WebAssembly.instantiate(k)}).then(function(k){console.log("HB ready");var N=k.instance.exports,D=N.memory,F,P,G,Y,Z,ee,se,re,J;tt.U.shapeHB=function(){var le=function(xe){for(var Fe=N.hb_buffer_get_length(xe),Le=[],Ve=N.hb_buffer_get_glyph_infos(xe,0)>>>2,$e=N.hb_buffer_get_glyph_positions(xe,0)>>>2,Ae=0;Ae<Fe;++Ae){var Te=Ve+Ae*5,Ue=$e+Ae*5;Le.push({g:P[Te+0],cl:P[Te+2],ax:G[Ue+0],ay:G[Ue+1],dx:G[Ue+2],dy:G[Ue+3]})}return Le},he;return function(xe,Fe,Le){var Ve=xe._data,$e=xe.name.postScriptName,Ae=Le.ltr,Te=Le.fts,Ue=Le.axs;if(xe.fvar&&Ue==null&&(Ue=xe.fvar[1][xe._index][2]),F=new Uint8Array(D.buffer),P=new Uint32Array(D.buffer),G=new Int32Array(D.buffer),Y=new Float32Array(D.buffer),Z!=$e&&(ee!=null&&(N.hb_blob_destroy(ee),N.free(se),N.hb_face_destroy(re),N.hb_font_destroy(J)),se=N.malloc(Ve.byteLength),F.set(Ve,se),ee=N.hb_blob_create(se,Ve.byteLength,2,0,0),re=N.hb_face_create(ee,xe._index),J=N.hb_font_create(re),Z=$e),window.TextEncoder==null){alert("Your browser is too old. Please, update it.");return}he==null&&(he=new window.TextEncoder("utf8"));var qe=N.hb_buffer_create(),Me=he.encode(Fe),ie=Me.length,K=N.malloc(ie);F.set(Me,K),N.hb_buffer_add_utf8(qe,K,ie,0,ie),N.free(K);var pe=tt.B,_e=0;if(Te){_e=N.malloc(16*Te.length);for(var We=0;We<Te.length;We++){var Oe=Te[We],nt=_e+We*16,rt=nt>>>2;pe.writeASCII(F,nt,Oe[0].split("").reverse().join("")),P[rt+1]=Oe[1],P[rt+2]=Oe[2],P[rt+3]=Oe[3]}}var pt=0;if(Ue&&xe.fvar){var Et=xe.fvar[0];pt=N.malloc(8*Ue.length);for(var We=0;We<Ue.length;We++){var nt=pt+We*8,rt=nt>>>2;pe.writeASCII(F,nt,Et[We][0].split("").reverse().join("")),Y[rt+1]=Ue[We]}}Ue&&N.hb_font_set_variations(J,pt,Ue.length),N.hb_buffer_set_direction(qe,Ae?4:5),N.hb_buffer_guess_segment_properties(qe),N.hb_shape(J,qe,_e,Te?Te.length:0);var ht=le(qe);N.hb_buffer_destroy(qe),Te&&N.free(_e),Ue&&N.free(pt);var Mt=ht.slice(0);Ae||Mt.reverse();for(var it=0,kt=0,We=1;We<Mt.length;We++){for(var Lt=Mt[We],wn=Lt.cl;;){var Gr=Fe.codePointAt(it),lr=A(Gr);if(kt+lr<=wn)kt+=lr,it+=Gr<=65535?1:2;else break}Lt.cl=it}return ht}}(),_()})}return{shape:n,shapeToPath:s,codeToGlyph:l,glyphToPath:c,pathToSVG:y,SVGToPath:b,pathToContext:S,initHB:C}}();var kE={exports:{}},i4;function Vce(){return i4||(i4=1,function(r,t){(function(n,s){r.exports=s()})(self,()=>(()=>{var n={177:(i,a,o)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.BezierPath=void 0;const u=o(558),l=o(188);a.BezierPath=class{constructor(c){this.samples=[],this.segments=c;const h=c.map(y=>y.getTotalLength()),d=[0];for(let y=1;y<h.length;y++)d.push(d[y-1]+h[y-1]);this._totalLength=d[d.length-1]+h[h.length-1];const p=c.map(y=>Math.max(4,Math.ceil(y.getTotalLength()/u.BezierSegment.sampleSpacing()))),f=p.reduce((y,b)=>y+b),m=1/f/10,g=this._totalLength/f;this.samples.push({dist:0,pt:this.segments[0].A,tan:this.segments[0].tangentAtParameter(0),segIdx:0,t:0}),c.forEach((y,b)=>{const x=p[b],w=(0,l.times)(x+1).map(C=>C/x),v=w.map(C=>y.pointAtParameter(C));let S;for(let C=0;C<4;C++){S=(0,l.times)(x).map(A=>Math.hypot(v[A+1].x-v[A].x,v[A+1].y-v[A].y));const I=S.map(A=>A-g);let _=0;for(let A=1;A<w.length-1;A++)_+=I[A-1],w[A]-=m*_,v[A]=y.pointAtParameter(w[A])}let E=0;v.slice(1).forEach((C,I)=>{E+=S[I],this.samples.push({dist:d[b]+E,pt:C,tan:this.segments[b].tangentAtParameter(w[I+1]),segIdx:b,t:w[I+1]})})}),this._jumps=[],this.segmentStartEnds=[{start:0,end:0}];for(let y=1;y<this.samples.length;y++){const b=this.samples[y-1],x=this.samples[y];if(x.segIdx===b.segIdx?this.segmentStartEnds[this.segmentStartEnds.length-1].end=x.dist:this.segmentStartEnds[x.segIdx]={start:x.dist,end:x.dist},b.segIdx!==x.segIdx&&(this.segments[b.segIdx].D.x!==this.segments[x.segIdx].A.x||this.segments[b.segIdx].D.y!==this.segments[x.segIdx].A.y)){const w=(b.dist+x.dist)/2,v={dist:w-1e-8,pt:this.segments[b.segIdx].D,tan:this.segments[b.segIdx].tangentAtParameter(1),segIdx:b.segIdx,t:1},S={dist:w+1e-8,pt:this.segments[x.segIdx].A,tan:this.segments[x.segIdx].tangentAtParameter(0),segIdx:x.segIdx,t:0};this._jumps.push(w),this.samples.splice(y,0,v,S),y+=2}}}jumps(){return[...this._jumps]}getTotalLength(){return this._totalLength}findClosestSampleIdx(c){let h=0,d=this.samples.length-1;for(;h<d;){const p=Math.floor((h+d)/2);if(this.samples[p].dist>c)d=p-1;else{if(!(this.samples[p].dist<c))return p;h=p+1}}return Math.max(0,Math.min(this.samples.length-1,Math.floor((h+d)/2)))}getPointAtLength(c,h=!1){if(c<=0)return this.samples[0].pt;if(c>=this._totalLength)return this.samples[this.samples.length-1].pt;const d=this.findClosestSampleIdx(c),p=this.samples[d].dist<c?Math.min(d+1,this.samples.length-1):Math.max(0,d-1),f=Math.abs(this.samples[p].dist-this.samples[d].dist)<1e-6?0:(c-this.samples[d].dist)/(this.samples[p].dist-this.samples[d].dist);if(h||this.samples[d].segIdx>this.samples[p].segIdx)return{x:(1-f)*this.samples[d].pt.x+f*this.samples[p].pt.x,y:(1-f)*this.samples[d].pt.y+f*this.samples[p].pt.y};if(this.samples[d].segIdx!==this.samples[p].segIdx){if(f<.5){const m=this.segments[this.samples[d].segIdx],g=2*f,y=(1-g)*this.samples[d].t+g;return m.pointAtParameter(y)}{const m=this.segments[this.samples[p].segIdx],g=2*(f-.5)*this.samples[p].t;return m.pointAtParameter(g)}}{const m=this.segments[this.samples[d].segIdx],g=(1-f)*this.samples[d].t+f*this.samples[p].t;return m.pointAtParameter(g)}}getAngleAtLength(c,h=!1){const d=this.getTangentAtLength(c,h);return Math.atan2(d.y,d.x)}getTangentAtLength(c,h=!1){if(c<=0)return this.samples[0].tan;if(c>=this._totalLength)return this.samples[this.samples.length-1].tan;const d=this.findClosestSampleIdx(c),p=this.samples[d].dist<c?Math.min(d+1,this.samples.length-1):Math.max(0,d-1),f=(c-this.samples[d].dist)/(this.samples[p].dist-this.samples[d].dist);if(h||this.samples[d].segIdx>this.samples[p].segIdx){let m=(1-f)*this.samples[d].tan.x+f*this.samples[p].tan.x,g=(1-f)*this.samples[d].tan.y+f*this.samples[p].tan.y;const y=Math.max(Math.hypot(m,g),1e-4);return m/=y,g/=y,{x:m,y:g}}if(this.samples[d].segIdx!==this.samples[p].segIdx){if(f<.5){const m=this.segments[this.samples[d].segIdx],g=2*f,y=(1-g)*this.samples[d].t+g;return m.tangentAtParameter(y)}{const m=this.segments[this.samples[p].segIdx],g=2*(f-.5)*this.samples[p].t;return m.tangentAtParameter(g)}}{const m=this.segments[this.samples[d].segIdx],g=(1-f)*this.samples[d].t+f*this.samples[p].t;return m.tangentAtParameter(g)}}}},558:(i,a,o)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.BezierSegment=void 0;const u=o(188);class l{constructor(h,d,p,f){this._totalLength=void 0,this.A=h,this.B=d,this.C=p,this.D=f}static sampleSpacing(){return 2}tangentAtParameter(h){const d=Math.max(0,Math.min(1,h));if(d===0||d===1){let y,b;d===0?this.A.x===this.B.x&&this.A.y===this.B.y?(y=this.C.x-this.A.x,b=this.C.y-this.A.y):(y=this.B.x-this.A.x,b=this.B.y-this.A.y):this.D.x===this.C.x&&this.D.y===this.C.y?(y=this.D.x-this.B.x,b=this.D.y-this.B.y):(y=this.D.x-this.C.x,b=this.D.y-this.C.y);const x=Math.hypot(y,b);return Math.abs(x)>1e-4&&(y/=x,b/=x),{x:y,y:b}}const p=1-d;let f=3*this.D.x*Math.pow(d,2)-3*this.C.x*Math.pow(d,2)+6*this.C.x*p*d-6*this.B.x*p*d+3*this.B.x*Math.pow(p,2)-3*this.A.x*Math.pow(p,2),m=3*this.D.y*Math.pow(d,2)-3*this.C.y*Math.pow(d,2)+6*this.C.y*p*d-6*this.B.y*p*d+3*this.B.y*Math.pow(p,2)-3*this.A.y*Math.pow(p,2);const g=Math.hypot(f,m);return Math.abs(g)>1e-4&&(f/=g,m/=g),{x:f,y:m}}isLinear(){return this.A.x===this.B.x&&this.A.y===this.B.y&&this.C.x===this.D.x&&this.C.y===this.D.y}pointAtParameter(h){const d=Math.max(0,Math.min(1,h));return{x:Math.pow(1-d,3)*this.A.x+3*Math.pow(1-d,2)*d*this.B.x+3*(1-d)*Math.pow(d,2)*this.C.x+Math.pow(d,3)*this.D.x,y:Math.pow(1-d,3)*this.A.y+3*Math.pow(1-d,2)*d*this.B.y+3*(1-d)*Math.pow(d,2)*this.C.y+Math.pow(d,3)*this.D.y}}getTotalLength(){if(this._totalLength===void 0)if(this.isLinear())this._totalLength=Math.hypot(this.D.x-this.A.x,this.D.y-this.A.y);else{const h=Math.max(10,Math.ceil((Math.hypot(this.B.x-this.A.x,this.B.y-this.A.y)+Math.hypot(this.C.x-this.B.x,this.C.y-this.B.y)+Math.hypot(this.D.x-this.C.x,this.D.y-this.C.y))/l.sampleSpacing())),d=(0,u.times)(h).map(f=>this.pointAtParameter(f/(h-1)));let p=0;for(let f=1;f<d.length;f++)p+=Math.hypot(d[f].x-d[f-1].x,d[f].y-d[f-1].y);this._totalLength=p}return this._totalLength}}a.BezierSegment=l},729:(i,a,o)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.createFromCommands=a.create=a.createFromElement=a.createFromCircle=a.createFromLine=a.createFromPath=void 0;const u=o(821),l=o(558),c={M:["x","y"],m:["dx","dy"],H:["x"],h:["dx"],V:["y"],v:["dy"],L:["x","y"],l:["dx","dy"],Z:[],C:["x1","y1","x2","y2","x","y"],c:["dx1","dy1","dx2","dy2","dx","dy"],S:["x2","y2","x","y"],s:["dx2","dy2","dx","dy"],Q:["x1","y1","x","y"],q:["dx1","dy1","dx","dy"],T:["x","y"],t:["dx","dy"],A:["rx","ry","rotation","large-arc","sweep","x","y"],a:["rx","ry","rotation","large-arc","sweep","dx","dy"]};a.createFromPath=h=>{const d=function(m){const g=m.replace(/[\n\r]/g,"").replace(/-/g," -").replace(/(\d*\.)(\d+)(?=\.)/g,"$1$2 ").replace(/(\d)([A-Za-z])/g,"$1 $2").replace(/([A-Za-z])(\d)/g,"$1 $2").trim().split(/\s*,|\s+/),y=[];let b="",x={};for(;g.length>0;){let w=g.shift();c.hasOwnProperty(w)?b=w:g.unshift(w),x={type:b},c[b].forEach(v=>{w=g.shift(),x[v]=parseFloat(w)}),b==="M"?b="L":b==="m"&&(b="l"),y.push(x)}return y}(h.getAttribute("d"));if(d.length<2)throw new Error(`Path doesn't have enough commands: ${JSON.stringify(d)}`);if(d[0].type!=="M")throw new Error(`Path starts with ${d[0].type} instead of M!`);let p={x:d[0].x,y:d[0].y};d.shift();const f=[];for(;d.length>0;){const m=d.shift();if(m.type==="C")f.push(new l.BezierSegment(p,{x:m.x1,y:m.y1},{x:m.x2,y:m.y2},{x:m.x,y:m.y})),p={x:m.x,y:m.y};else if(m.type==="L")f.push(new l.BezierSegment(p,p,{x:m.x,y:m.y},{x:m.x,y:m.y})),p={x:m.x,y:m.y};else if(m.type==="H")f.push(new l.BezierSegment(p,p,{x:m.x,y:p.y},{x:m.x,y:p.y})),p={x:m.x,y:p.y};else if(m.type==="V")f.push(new l.BezierSegment(p,p,{x:p.x,y:m.y},{x:p.x,y:m.y})),p={x:p.x,y:m.y};else if(m.type!=="Z")throw new Error(`Unsupported path command ${m.type}; use only H, V, M, L, C, Z!`)}return new u.BezierPath(f)},a.createFromLine=h=>{const[d,p,f,m]=["x1","x2","y1","y2"].map(g=>parseFloat(h.getAttribute(g)||"0"));return new u.BezierPath([new l.BezierSegment({x:d,y:f},{x:d,y:f},{x:p,y:m},{x:p,y:m})])},a.createFromCircle=h=>{const[d,p,f]=["cx","cy","r"].map(g=>parseFloat(h.getAttribute(g)||"0")),m=1.3;return new u.BezierPath([new l.BezierSegment({x:d-f,y:p},{x:d-f,y:p-m*f},{x:d+f,y:p-m*f},{x:d+f,y:p}),new l.BezierSegment({x:d+f,y:p},{x:d+f,y:p+m*f},{x:d-f,y:p+m*f},{x:d-f,y:p})])},a.createFromElement=h=>{const d=h.tagName.toLowerCase();if(d==="path")return(0,a.createFromPath)(h);if(d==="line")return(0,a.createFromLine)(h);if(d==="circle")return(0,a.createFromCircle)(h);throw new Error(`Unsupported SVG tag: ${d}`)},a.create=h=>{const d=[];for(let p=1;p<h.length;p++){const f=h[p-1],m=h[p];d.push(new l.BezierSegment(f.pt,f.right||f.pt,m.left||m.pt,m.pt))}return new u.BezierPath(d)},a.createFromCommands=h=>{const d=h.slice();if(d.length<2)throw new Error(`Path doesn't have enough commands: ${JSON.stringify(d)}`);if(d[0].type!=="M")throw new Error(`Path starts with ${d[0].type} instead of M!`);let p={x:d[0].x,y:d[0].y},f=Object.assign({},p);const m=[];for(;d.length>0;){const g=d.shift();if(g.type==="M")f={x:g.x,y:g.y},p=f;else if(g.type==="C")m.push(new l.BezierSegment(p,{x:g.x1,y:g.y1},{x:g.x2,y:g.y2},{x:g.x,y:g.y})),p={x:g.x,y:g.y};else if(g.type==="L")g.x===p.x&&g.y===p.y||m.push(new l.BezierSegment(p,p,{x:g.x,y:g.y},{x:g.x,y:g.y})),p={x:g.x,y:g.y};else if(g.type==="H")g.x!==p.x&&m.push(new l.BezierSegment(p,p,{x:g.x,y:p.y},{x:g.x,y:p.y})),p={x:g.x,y:p.y};else if(g.type==="V")g.y!==p.y&&m.push(new l.BezierSegment(p,p,{x:p.x,y:g.y},{x:p.x,y:g.y})),p={x:p.x,y:g.y};else if(g.type==="Q")m.push(new l.BezierSegment(p,{x:p.x+.6666666666666666*(g.x1-p.x),y:p.y+.6666666666666666*(g.y1-p.y)},{x:g.x+.6666666666666666*(g.x1-g.x),y:g.y+.6666666666666666*(g.y1-g.y)},{x:g.x,y:g.y})),p={x:g.x,y:g.y};else{if(g.type!=="Z")throw new Error(`Unsupported path command ${g.type}; use only H, V, M, L, C, Z!`);Math.hypot(p.x-f.x,p.y-f.y)>0&&m.push(new l.BezierSegment(p,p,f,f))}}return new u.BezierPath(m)}},821:function(i,a,o){var u=this&&this.__createBinding||(Object.create?function(c,h,d,p){p===void 0&&(p=d);var f=Object.getOwnPropertyDescriptor(h,d);f&&!("get"in f?!h.__esModule:f.writable||f.configurable)||(f={enumerable:!0,get:function(){return h[d]}}),Object.defineProperty(c,p,f)}:function(c,h,d,p){p===void 0&&(p=d),c[p]=h[d]}),l=this&&this.__exportStar||function(c,h){for(var d in c)d==="default"||Object.prototype.hasOwnProperty.call(h,d)||u(h,c,d)};Object.defineProperty(a,"__esModule",{value:!0}),l(o(177),a),l(o(558),a),l(o(729),a),l(o(856),a)},856:(i,a)=>{Object.defineProperty(a,"__esModule",{value:!0})},188:(i,a)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.times=void 0,a.times=function(o){const u=[];for(let l=0;l<o;l++)u.push(l);return u}}},s={};return function i(a){var o=s[a];if(o!==void 0)return o.exports;var u=s[a]={exports:{}};return n[a].call(u.exports,u,u.exports,i),u.exports}(821)})())}(kE)),kE.exports}var zce=Vce();const a4={M:2,L:2,C:6,Q:4},R8=["ttf","otf","woff"],Uce=new RegExp(`\\.(${R8.join("|")})`,"i"),Wce=new RegExp(`([^/]+)(\\.(?:${R8.join("|")}))`,"i"),O8="Sorry, only TTF, OTF and WOFF files are supported.",Gce=["weight","stretch","style"];class iA{constructor(t,n,s,i,a){if(!(n instanceof FontFace))throw Error("FontFace is required");this._pInst=t,this.name=s,this.path=i,this.data=a,this.face=n}static hasGlyphData(t){let{font:n}=t;return typeof n=="object"&&typeof n.data<"u"}fontBounds(t,n,s,i,a,o){var l;({width:i,height:a,options:o}=this._parseArgs(i,a,o));let u=((l=o==null?void 0:o.graphics)==null?void 0:l._renderer)||this._pInst._renderer;if(!u)throw Error("p5 or graphics required for fontBounds()");return u.fontBounds(t,n,s,i,a)}textBounds(t,n,s,i,a,o){var l;({width:i,height:a,options:o}=this._parseArgs(i,a,o));let u=((l=o==null?void 0:o.graphics)==null?void 0:l._renderer)||this._pInst._renderer;if(!u)throw Error("p5 or graphics required for fontBounds()");return u.textBounds(t,n,s,i,a)}textToPaths(t,n,s,i,a,o){if({width:i,height:a,options:o}=this._parseArgs(i,a,o),!this.data)throw Error('No font data available for "'+this.name+`"
Try downloading a local copy of the font file`);return this._lineateAndPathify(t,n,s,i,a,o).map(c=>c.glyphs).flat().map(c=>c.path.commands).flat()}textToPoints(t,n,s,i,a,o){return this.textToContours(t,n,s,i,a,o).reduce((l,c)=>(l.push(...c),l),[])}textToContours(t,n=0,s=0,i,a,o){({width:i,height:a,options:o}=this._parseArgs(i,a,o));const u=this.textToPaths(t,n,s,i,a,o),l=[];for(const c of u)c[0]==="M"&&l.push([]),l[l.length-1].push(c);return l.map(c=>qce(c,o,this))}textToModel(t,n,s,i,a,o){({width:i,height:a,options:o}=this._parseArgs(i,a,o));const u=(o==null?void 0:o.extrude)||0,l=this.textToContours(t,n,s,i,a,o),c=this._pInst.buildGeometry(()=>{if(u===0){this._pInst.beginShape(),this._pInst.normal(0,0,1);for(const h of l){this._pInst.beginContour();for(const{x:d,y:p}of h)this._pInst.vertex(d,p);this._pInst.endContour(this._pInst.CLOSE)}this._pInst.endShape()}else{for(const h of[1,-1]){this._pInst.beginShape();for(const d of l){this._pInst.beginContour();for(const{x:p,y:f}of d)this._pInst.vertex(p,f,h*u*.5);this._pInst.endContour(this._pInst.CLOSE)}this._pInst.endShape(),this._pInst.beginShape()}for(const h of l){this._pInst.beginShape(this._pInst.QUAD_STRIP);for(const d of h)for(const p of[-1,1])this._pInst.vertex(d.x,d.y,p*u*.5);this._pInst.endShape()}}});if(u!==0){c.computeNormals();for(const h of c.faces)if(h.every(d=>c.vertices[d].z<=-u*.5+.1)){for(const d of h)c.vertexNormals[d].set(0,0,-1);h.reverse()}}return c}variations(){var n;let t={};if(this.data){let s=(n=this.face)==null?void 0:n.axes;s&&s.forEach(i=>{t[i.tag]=i.value})}return Gce.forEach(s=>{let i=this.face[s];i!=="normal"&&(t[s]=t[s]||i)}),t}metadata(){var n;let t=((n=this.data)==null?void 0:n.name)||{};for(let s in this.face)/^load/.test(s)||(t[s]=t[s]||this.face[s]);return t}static async list(t=!1){if(t){console.log("There are",document.fonts.size,`font-faces
`);let n=0;for(let s of document.fonts.values()){console.log("FontFace: {");for(let i in s)console.log("  "+i+": "+s[i]);console.log(`}
`),s.status==="loaded"&&n++}console.log(n+" loaded")}return await Array.from(document.fonts)}_verticalAlign(t){var c,h,d;const{sCapHeight:n}=((c=this.data)==null?void 0:c["OS/2"])||{},{unitsPerEm:s=1e3}=((h=this.data)==null?void 0:h.head)||{},{ascender:i=0,descender:a=0}=((d=this.data)==null?void 0:d.hhea)||{},o=i/2;return((n||i+a)/2-o)*t/s}_lineateAndPathify(t,n,s,i,a,o={}){var g,y,b;let u=((g=o==null?void 0:o.graphics)==null?void 0:g._renderer)||this._pInst._renderer,l=u.drawingContext.textBaseline,{lines:c,bounds:h}=u._computeBounds(Vi._FONT_BOUNDS,t,n,s,i,a,{ignoreRectMode:!0,...o});c=this._position(u,c,h,i,a);let d=((b=(y=this.data)==null?void 0:y.head)==null?void 0:b.unitsPerEm)||1e3,p=u.states.textSize/d;const f=this._currentAxes(u);let m=c.map(x=>this._lineToGlyphs(x,{scale:p,axs:f}));return u.drawingContext.textBaseline=l,m}_currentAxes(t){var s,i;let n;return(((i=(s=this.data)==null?void 0:s.fvar)==null?void 0:i.length)??0)>0&&(n=this.data.fvar[0].map(([o,u,l,c,h,d])=>{if(!t)return l;if(o==="wght")return t.states.fontWeight;if(o==="wdth")return 100;if(t.textCanvas().style.fontVariationSettings){const p=new RegExp(`\\b${o}s+(d+)`).exec(t.textCanvas().style.fontVariationSettings);return p?parseInt(p[1]):l}else return l})),n}_textToPathPoints(t,n,s,i,a,o){({width:i,height:a,options:o}=this._parseArgs(i,a,o));let u=this.textToPaths(t,n,s,i,a,o);const l=(p,f,m,g)=>{if(fn.dist(f.x,f.y,m.x,m.y)>g){let y={x:(f.x+m.x)/2,y:(f.y+m.y)/2};p.push(y),l(p,f,y,g),l(p,y,m,g)}};let c=[],{textSize:h}=this._pInst._renderer.states,d=h/this.data.head.unitsPerEm*500;for(let p=0;p<u.length;p++){let{type:f,data:m}=u[p];if(f!=="Z"){let g={x:m[m.length-2],y:m[m.length-1]};f==="L"&&c.length&&!(o!=null&&o.nodivide)>0&&l(c,c[c.length-1],g,d),c.push(g)}}return c}_parseArgs(t,n,s={}){return typeof t=="object"?(s=t,t=n=void 0):typeof n=="object"&&(s=n,n=void 0),{width:t,height:n,options:s}}_position(t,n,s,i,a){let{textAlign:o,textLeading:u}=t.states,c=this._measureTextDefault(t,"X").fontBoundingBoxAscent,h=(d,p)=>{let f=s.x,m=s.y+p*u+c,g=t._fontWidthSingle(d);if(o===Ki?f+=(s.w-g)/2:o===Ow&&(f+=s.w-g),typeof i<"u")switch(t.states.rectMode){case Ki:f-=i/2,m-=a/2;break;case rb:f-=i,m-=a;break}return{text:d,x:f,y:m}};return n.map(h)}_lineToGlyphs(t,{scale:n=1,axs:s}={}){if(!this.data)throw Error('No font data available for "'+this.name+`"
Try downloading a local copy of the font file`);let i=tt.U.shape(this.data,t.text,{axs:s});return t.glyphShapes=i,t.glyphs=this._shapeToPaths(i,t,{scale:n,axs:s}),t}_positionGlyphs(t,n){var l;let s=((l=n==null?void 0:n.graphics)==null?void 0:l._renderer)||this._pInst._renderer;const i=this._currentAxes(s),a=tt.U.shape(this.data,t,{axs:i}),o=[];let u=0;for(const c of a)o.push({x:u,index:c.g,shape:c}),u+=c.ax;return o}_singleShapeToPath(t,{scale:n=1,x:s=0,y:i=0,lineX:a=0,lineY:o=0,axs:u}={}){let l=this.data,c=0,{g:h,ax:d,ay:p,dx:f,dy:m}=t,{crds:g,cmds:y}=tt.U.glyphToPath(l,h,!0,u),b={path:{commands:[]}};for(let x=0;x<y.length;x++){let w=y[x],v=[w];if(w in a4){let S=a4[w];for(let E=0;E<S;E+=2){let C=g[E+c]+s+f,I=g[E+c+1]+i+m,_=a+C*n,A=o+I*-n;v.push(_),v.push(A)}c+=S}b.path.commands.push(v)}return{glyph:b,ax:d,ay:p}}_shapeToPaths(t,n,{scale:s=1,axs:i}={}){let a=0,o=0,u=[];if(t.length!==n.text.length)throw Error("Invalid shape data");for(let l=0;l<t.length;l++){const{glyph:c,ax:h,ay:d}=this._singleShapeToPath(t[l],{scale:s,x:a,y:o,lineX:n.x,lineY:n.y,axs:i});u.push(c),a+=h,o+=d}return u}_measureTextDefault(t,n){let{textAlign:s,textBaseline:i}=t.states,a=t.textDrawingContext();a.textAlign="left",a.textBaseline="alphabetic";let o=a.measureText(n);return a.textAlign=s,a.textBaseline=i,o}drawPaths(t,n,s){t.strokeStyle=(s==null?void 0:s.stroke)||t.strokeStyle,t.fillStyle=(s==null?void 0:s.fill)||t.fillStyle,t.beginPath(),n.forEach(([i,...a])=>{i==="M"?t.moveTo(...a):i==="L"?t.lineTo(...a):i==="C"?t.bezierCurveTo(...a):i==="Q"?t.quadraticCurveTo(...a):i==="Z"&&t.closePath()}),s!=null&&s.fill&&t.fill(),s!=null&&s.stroke&&t.stroke()}_pathsToCommands(t,n){let s=[];for(let i=0;i<t.length;i++){let a=t[i],{x:o,y:u,path:l}=a,{crds:c,cmds:h}=l;for(let d=0,p=0;p<h.length;p++){let f=h[p],m={type:f,data:[]};if(f=="M"||f=="L")m.data.push(o+c[d]*n,u+c[d+1]*-n),d+=2;else if(f=="C"){for(let g=0;g<6;g+=2)m.data.push(o+c[d+g]*n,u+c[d+g+1]*-n);d+=6}else if(f=="Q"){for(let g=0;g<4;g+=2)m.data.push(o+c[d+g]*n,u+c[d+g+1]*-n);d+=4}s.push(m)}}return s}}async function g1(r,t,n,s,i){let a=Hce(t,n,s,i);return a.status!=="loaded"&&await a.load(),document.fonts.add(a),new iA(r,a,t,n,i)}function Hce(r,t,n,s){var o;r.includes(" ")&&(r="'"+r+"'");let i=(s==null?void 0:s._compressedData)??(s==null?void 0:s._data);if(!i){if(!Uce.test(t))throw Error(O8);t.startsWith("url(")||(t="url("+t+")"),i=t}if((((o=s==null?void 0:s.fvar)==null?void 0:o.length)??0)>0){n=n||{};for(const[u,l,c,h,d,p]of s.fvar[0])u==="wght"?n.weight=`${l} ${h}`:u==="wdth"&&(n.stretch=`${l}% ${h}%`)}let a=new FontFace(r,i,n);if(a.status==="error")throw Error('Failed to create FontFace for "'+r+'"');return a}function jce(r,t){let n,s=r==null?void 0:r.name;if(s){if(s.fullName)return s.fullName;s.familyName&&(n=s.familyName)}if(!n){let i=Wce.exec(t);i&&i.length>=3?n=i[1]:n=t}return n.includes(" ")&&(n=n.replace(/ /g,"_")),n}function qce(r,t,n){const s=(p,f)=>{if(typeof p!="object")p=f;else for(const m in f)typeof p[m]>"u"&&(p[m]=f[m]);return p},i=(p,f)=>{const m=p.length;return p[f<0?f%m+m:f%m]},a=(p,f)=>{f=f||0;let m=0;for(let g=p.length-1;p.length>3&&g>=0;--g)collinear(i(p,g-1),i(p,g),i(p,g+1),f)&&(p.splice(g%p.length,1),m++);return m},o=zce.createFromCommands(L8(r));let u=s(t,{sampleFactor:.1,simplifyThreshold:0});const l=Math.max(1,Math.ceil(o.getTotalLength()*u.sampleFactor));let c=[];const h=n._pInst.angleMode(),d=n._pInst.DEGREES;for(let p=0;p<l;p++){const f=o.getTotalLength()*(l===1?0:p/(l-1));c.push({...o.getPointAtLength(f),get angle(){const m=o.getAngleAtLength(f);return h===d?m*180/Math.PI:m},get alpha(){return this.angle}})}return u.simplifyThreshold&&a(c,u.simplifyThreshold),c}function Kce(r){return(r.startsWith('"')||r.startsWith("'"))&&r.at(0)===r.at(-1)?r.slice(1,-1).replace(/\/(['"])/g,"$1"):r}function Xce(...r){let t=r.shift();(typeof t!="string"||t.length===0)&&p5._friendlyError(O8,"p5.loadFont");let n;typeof r[0]=="string"&&(n=r.shift());let s,i,a;for(let o=0;o<r.length;o++){const u=r[o];typeof u=="function"?s?i=u:s=u:typeof u=="object"&&(a=u)}return{path:t,name:n,success:s,error:i,options:a}}function M8(r,t){r.Font=iA,t.parseFontData=async function(n){let s=n instanceof Uint8Array?n:await t.loadBytes(n);if(!s)throw Error("Failed to load font data");let i=tt.parse(s);if(i.length===0||i[0].cmap===void 0)throw Error("parsing font data");return i[0]},t.loadFont=async function(...n){var d;let{path:s,name:i,success:a,error:o,options:{sets:u,...l}={}}=Xce(...n),c=s.includes("@font-face");if(c||(d=(await fetch(s,{method:"HEAD"})).headers.get("content-type"))!=null&&d.startsWith("text/css")&&(c=!0,s=await fetch(s).then(m=>m.text())),c){const p=new CSSStyleSheet;await p.replace(s);const f=[];for(const S of p.cssRules)if(S instanceof CSSFontFaceRule){const E=S.style;let C=Kce(E.getPropertyValue("font-family"));const I=E.getPropertyValue("src"),_={...l||{}};for(const A of E){if(A==="font-family"||A==="src")continue;const k=A.replace(/^font-/,"").split("-").map((N,D)=>D===0?N:`${N[0].toUpperCase()}${N.slice(1)}`).join("");_[k]=E.getPropertyValue(A)}f.push({name:C,src:I,fontDescriptors:_,loadWithData:async()=>{let A;try{const k=/url\(([^\)]+)\)/.exec(I);if(k){let N=k[1];/^['"]/.exec(N)&&N.at(0)===N.at(-1)&&(N=N.slice(1,-1)),A=await t.parseFontData(N)}}catch{}return g1(this,C,I,_,A)},loadWithoutData:()=>g1(this,C,I,_)})}u=u||["latin"];const m=(u instanceof Array?u:[u]).map(S=>S.toLowerCase()),g=Ele.filter(S=>m.some(E=>S.category.includes(E)&&S.category.includes("ext")===E.includes("ext"))),y=new Set(NB.UnicodeRange.parse(g.map(S=>`U+${S.hexrange[0]}-${S.hexrange[1]}`)));let b=0,x=0,w;for(const S of f){if(!S.fontDescriptors.unicodeRange)continue;const C=[...new Set(NB.UnicodeRange.parse(S.fontDescriptors.unicodeRange.split(/,\s*/g))).values()].filter(A=>y.has(A)).length,I={style:"normal",weight:400,...l},_=Object.keys(S.fontDescriptors).filter(A=>S.fontDescriptors[A]===I[A]).length;(_>x||_===x&&C>=b)&&(x=_,b=C,w=S)}const v=w||f.at(-1);for(const S of f)S!==v&&S.loadWithoutData();return v==null?void 0:v.loadWithData()}let h;try{const p=await t.parseFontData(s);i=i||jce(p,s),h=await g1(this,i,s,l,p)}catch{let f=i||s.substring(s.lastIndexOf("/")+1).replace(/\.[^/.]+$/,"");console.warn(`WARN: No glyph data for '${f}', retrying as FontFace`);try{h=await g1(this,f,s,l)}catch(m){if(o)return o(m);throw m}}return a?a(h):h}}const L8=r=>r.map(t=>{const n=t[0];switch(n){case"Z":return{type:n};case"M":case"L":{const[,s,i]=t;return{type:n,x:s,y:i}}case"Q":{const[,s,i,a,o]=t;return{type:n,x1:s,y1:i,x:a,y:o}}case"C":{const[,s,i,a,o,u,l]=t;return{type:n,x1:s,y1:i,x2:a,y2:o,x:u,y:l}}default:throw new Error(`Unexpected path command: ${n}`)}});typeof p5<"u"&&M8(p5,p5.prototype);function Yce(r,t){Kt.prototype.maxCachedGlyphs=function(){return 200},iA.prototype._getFontInfo=function(m){this._fontInfos=this._fontInfos||{};const g=JSON.stringify(m);if(this._fontInfos[g])return this._fontInfos[g];{const y=new f(this,{axs:m});return this._fontInfos[g]=y,y}};const n=9,s=n,i=64,a=64,o=64,u=64,l=64,c=64;class h{constructor(g,y){this.width=g,this.height=y,this.infos=[]}findImage(g){const y=this.width*this.height;if(g>y)throw new Error("font is too complex to render in 3D");let b,x;for(let v=this.infos.length-1;v>=0;--v){const S=this.infos[v];if(S.index+g<y){b=S,x=S.imageData;break}}if(!b){try{x=new ImageData(this.width,this.height)}catch{let S=document.getElementsByTagName("canvas")[0];const E=!S;S||(S=document.createElement("canvas"),S.style.display="none",document.body.appendChild(S));const C=S.getContext("2d");C&&(x=C.createImageData(this.width,this.height)),E&&document.body.removeChild(S)}b={index:0,imageData:x},this.infos.push(b)}const w=b.index;return b.index+=g,x._dirty=!0,{imageData:x,index:w}}}function d(m,g,y,b,x){const v=m.imageData.data;let S=m.index++*4;v[S++]=g,v[S++]=y,v[S++]=b,v[S++]=x}const p=Math.sqrt(3);class f{constructor(g,{axs:y}={}){this.font=g,this.axs=y,this.strokeImageInfos=new h(i,a),this.colDimImageInfos=new h(o,u),this.rowDimImageInfos=new h(o,u),this.colCellImageInfos=new h(l,c),this.rowCellImageInfos=new h(l,c),this.glyphInfos={}}getGlyphInfo(g){let y=this.glyphInfos[g.index];if(y)return y;const b=this.axs,{glyph:{path:{commands:x}}}=this.font._singleShapeToPath(g.shape,{axs:b});let w=1/0,v=-1/0,S=1/0,E=-1/0;for(const $e of x)for(let Ae=1;Ae<$e.length;Ae+=2)w=Math.min(w,$e[Ae]),v=Math.max(v,$e[Ae]),S=Math.min(S,$e[Ae+1]),E=Math.max(E,$e[Ae+1]);if(w>=v||S>=E||!x.length)return this.glyphInfos[g.index]={};const C=v-w,I=E-S,_=L8(x);let A;const k=[],N=[],D=[];for(A=n-1;A>=0;--A)D.push([]);for(A=s-1;A>=0;--A)N.push([]);function F($e,Ae,Te){const Ue=k.length;k.push(Te);function qe(nt,rt,pt){for(let Et=nt.length;Et-- >0;){const ht=nt[Et];rt>ht&&(rt=ht),pt<ht&&(pt=ht)}return{min:rt,max:pt}}const Me=.5,ie=qe($e,1,0),K=Math.max(Math.floor(ie.min*n-Me),0),pe=Math.min(Math.ceil(ie.max*n+Me),n);for(let nt=K;nt<pe;++nt)D[nt].push(Ue);const _e=qe(Ae,1,0),We=Math.max(Math.floor(_e.min*s-Me),0),Oe=Math.min(Math.ceil(_e.max*s+Me),s);for(let nt=We;nt<Oe;++nt)N[nt].push(Ue)}function P($e,Ae,Te){return $e<Ae?Ae:$e>Te?Te:$e}function G($e){return P(255*$e,0,255)}class Y{constructor(Ae,Te,Ue,qe){this.p0=Ae,this.c0=Te,this.c1=Ue,this.p1=qe}toQuadratic(){return{x:this.p0.x,y:this.p0.y,x1:this.p1.x,y1:this.p1.y,cx:((this.c0.x+this.c1.x)*3-(this.p0.x+this.p1.x))/4,cy:((this.c0.y+this.c1.y)*3-(this.p0.y+this.p1.y))/4}}quadError(){return De.sub(De.sub(this.p1,this.p0),De.mult(De.sub(this.c1,this.c0),3)).mag()/2}split(Ae){const Te=De.lerp(this.p0,this.c0,Ae),Ue=De.lerp(this.c0,this.c1,Ae),qe=De.lerp(Te,Ue,Ae);this.c1=De.lerp(this.c1,this.p1,Ae),this.c0=De.lerp(Ue,this.c1,Ae);const Me=De.lerp(qe,this.c0,Ae),ie=new Y(this.p0,Te,qe,Me);return this.p0=Me,ie}splitInflections(){const Ae=De.sub(this.c0,this.p0),Te=De.sub(De.sub(this.c1,this.c0),Ae),Ue=De.sub(De.sub(De.sub(this.p1,this.c1),Ae),De.mult(Te,2)),qe=[];let Me=Te.x*Ue.y-Te.y*Ue.x;if(Me!==0){let ie=Ae.x*Ue.y-Ae.y*Ue.x,K=Ae.x*Te.y-Ae.y*Te.x;const pe=ie*ie-4*Me*K;if(pe>=0){Me<0&&(Me=-Me,ie=-ie,K=-K);const _e=Math.sqrt(pe),We=(-ie-_e)/(2*Me);let Oe=(-ie+_e)/(2*Me);We>0&&We<1&&(qe.push(this.split(We)),Oe=1-(1-Oe)/(1-We)),Oe>0&&Oe<1&&qe.push(this.split(Oe))}}return qe.push(this),qe}}function Z($e,Ae,Te,Ue,qe,Me,ie,K){const pe=new Y(new De($e,Ae),new De(Te,Ue),new De(qe,Me),new De(ie,K)).splitInflections(),_e=[],We=30/p;for(let Oe of pe){const nt=[];let rt;for(;rt=We/Oe.quadError(),!(rt>=.5*.5*.5);){const pt=Math.pow(rt,1/3),Et=Oe.split(pt),ht=Oe.split(1-pt/(1-pt));_e.push(Et),nt.push(Oe),Oe=ht}rt<1&&_e.push(Oe.split(.5)),_e.push(Oe),Array.prototype.push.apply(_e,nt.reverse())}return _e}function ee($e,Ae,Te,Ue){const qe=($e+Te)/2,Me=(Ae+Ue)/2;F([$e,Te],[Ae,Ue],{x:$e,y:Ae,cx:qe,cy:Me})}function se($e,Ae,Te,Ue){return Math.abs(Te-$e)<1e-5&&Math.abs(Ue-Ae)<1e-5}let re,J,le,he;for(const $e of _){const Ae=($e.x-w)/C,Te=($e.y-S)/I;if(!se(re,J,Ae,Te)){switch($e.type){case"M":{le=Ae,he=Te;break}case"L":{ee(re,J,Ae,Te);break}case"Q":{const Ue=($e.x1-w)/C,qe=($e.y1-S)/I;F([re,Ae,Ue],[J,Te,qe],{x:re,y:J,cx:Ue,cy:qe});break}case"Z":{se(re,J,le,he)?k.push({x:re,y:J}):(ee(re,J,le,he),k.push({x:le,y:he}));break}case"C":{const Ue=($e.x1-w)/C,qe=($e.y1-S)/I,Me=($e.x2-w)/C,ie=($e.y2-S)/I,K=Z(re,J,Ue,qe,Me,ie,Ae,Te);for(let pe=0;pe<K.length;pe++){const _e=K[pe].toQuadratic();F([_e.x,_e.x1,_e.cx],[_e.y,_e.y1,_e.cy],_e)}break}default:throw new Error(`unknown command type: ${$e.type}`)}re=Ae,J=Te}}const xe=k.length,Fe=this.strokeImageInfos.findImage(xe),Le=Fe.index;for(let $e=0;$e<xe;++$e){const Ae=k[$e];d(Fe,G(Ae.x),G(Ae.y),G(Ae.cx),G(Ae.cy))}function Ve($e,Ae,Te){const Ue=$e.length,qe=Ae.findImage(Ue),Me=qe.index;let ie=0;for(let pe=0;pe<Ue;++pe)ie+=$e[pe].length;const K=Te.findImage(ie);for(let pe=0;pe<Ue;++pe){const _e=$e[pe],We=_e.length,Oe=K.index;d(qe,Oe>>7,Oe&127,We>>7,We&127);for(let nt=0;nt<We;++nt){const rt=_e[nt]+Le;d(K,rt>>7,rt&127,0,0)}}return{cellImageInfo:K,dimOffset:Me,dimImageInfo:qe}}return y=this.glyphInfos[g.index]={glyph:g,uGlyphRect:[w,S,v,E],strokeImageInfo:Fe,strokes:k,colInfo:Ve(D,this.colDimImageInfos,this.colCellImageInfos),rowInfo:Ve(N,this.rowDimImageInfos,this.rowCellImageInfos)},y.uGridOffset=[y.colInfo.dimOffset,y.rowInfo.dimOffset],y}}Kt.prototype._renderText=function(m,g,y,b,x){var G,Y;if(!this.states.textFont||typeof this.states.textFont=="string"){console.log("WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.");return}if(y>=b||!this.states.fillColor)return;if(!r.Font.hasGlyphData(this.states.textFont)){console.log("WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts with glyph data are supported");return}this.push();const w=this.states.strokeColor,v=this.states.drawMode;this.states.setValue("strokeColor",null),this.states.setValue("drawMode",Bw);const{font:S}=this.states.textFont;if(!S)throw new Error("In WebGL mode, textFont() needs to be given the result of loadFont() instead of a font family name.");const E=S._currentAxes(this);let C=S._getFontInfo(E);const I={x:g,y},A=this.states.textSize/(((Y=(G=S.data)==null?void 0:G.head)==null?void 0:Y.unitsPerEm)||1e3);this.translate(I.x,I.y,0),this.scale(A,A,1);const k=this.GL,N=!this._defaultFontShader,D=this._getFontShader();D.init(),D.bindShader(),N&&(D.setUniform("uGridImageSize",[o,u]),D.setUniform("uCellsImageSize",[l,c]),D.setUniform("uStrokeImageSize",[i,a]),D.setUniform("uGridSize",[n,s]));const F=this.states.fillSet?this.states.curFillColor:[0,0,0,255];this._setGlobalUniforms(D),this._applyColorBlend(F);let P=this.geometryBufferCache.getGeometryByID("glyph");P||(P=this._textGeom=new ks(1,1,function(){for(let Z=0;Z<=1;Z++)for(let ee=0;ee<=1;ee++)this.vertices.push(new De(ee,Z,0)),this.uvs.push(ee,Z)},this),P.gid="glyph",P.computeFaces().computeNormals(),this.geometryBufferCache.ensureCached(P));for(const Z of this.buffers.text)Z._prepareBuffer(P,D);this._bindBuffer(this.geometryBufferCache.cache.glyph.indexBuffer,k.ELEMENT_ARRAY_BUFFER),D.setUniform("uMaterialColor",F),k.pixelStorei(k.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),this.glyphDataCache=this.glyphDataCache||new Set;try{const Z=S._positionGlyphs(m);for(const ee of Z){const se=C.getGlyphInfo(ee);if(se.uGlyphRect){const re=se.rowInfo,J=se.colInfo,le=[se.strokeImageInfo.imageData,re.cellImageInfo.imageData,re.dimImageInfo.imageData,J.cellImageInfo.imageData,J.dimImageInfo.imageData];for(const he of le)this.glyphDataCache.delete(he),this.glyphDataCache.add(he);for(;this.glyphDataCache.size>this.maxCachedGlyphs();){const he=this.glyphDataCache.values().next().value;this.glyphDataCache.delete(he);const xe=this.textures.get(he);xe&&(xe.remove(),this.textures.delete(he))}D.setUniform("uSamplerStrokes",se.strokeImageInfo.imageData),D.setUniform("uSamplerRowStrokes",re.cellImageInfo.imageData),D.setUniform("uSamplerRows",re.dimImageInfo.imageData),D.setUniform("uSamplerColStrokes",J.cellImageInfo.imageData),D.setUniform("uSamplerCols",J.dimImageInfo.imageData),D.setUniform("uGridOffset",se.uGridOffset),D.setUniform("uGlyphRect",se.uGlyphRect),D.setUniform("uGlyphOffset",ee.x),D.bindTextures(),k.drawElements(k.TRIANGLES,6,this.GL.UNSIGNED_SHORT,0)}}}finally{D.unbindShader(),this.states.setValue("strokeColor",w),this.states.setValue("drawMode",v),k.pixelStorei(k.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),this.pop()}}}var NE={},TE={},o4;function Zce(){return o4||(o4=1,function(r){(function t(n){var s,i,a,o,u,l;function c(S){var E={},C,I;for(C in S)S.hasOwnProperty(C)&&(I=S[C],typeof I=="object"&&I!==null?E[C]=c(I):E[C]=I);return E}function h(S,E){var C,I,_,A;for(I=S.length,_=0;I;)C=I>>>1,A=_+C,E(S[A])?I=C:(_=A+1,I-=C+1);return _}s={AssignmentExpression:"AssignmentExpression",AssignmentPattern:"AssignmentPattern",ArrayExpression:"ArrayExpression",ArrayPattern:"ArrayPattern",ArrowFunctionExpression:"ArrowFunctionExpression",AwaitExpression:"AwaitExpression",BlockStatement:"BlockStatement",BinaryExpression:"BinaryExpression",BreakStatement:"BreakStatement",CallExpression:"CallExpression",CatchClause:"CatchClause",ChainExpression:"ChainExpression",ClassBody:"ClassBody",ClassDeclaration:"ClassDeclaration",ClassExpression:"ClassExpression",ComprehensionBlock:"ComprehensionBlock",ComprehensionExpression:"ComprehensionExpression",ConditionalExpression:"ConditionalExpression",ContinueStatement:"ContinueStatement",DebuggerStatement:"DebuggerStatement",DirectiveStatement:"DirectiveStatement",DoWhileStatement:"DoWhileStatement",EmptyStatement:"EmptyStatement",ExportAllDeclaration:"ExportAllDeclaration",ExportDefaultDeclaration:"ExportDefaultDeclaration",ExportNamedDeclaration:"ExportNamedDeclaration",ExportSpecifier:"ExportSpecifier",ExpressionStatement:"ExpressionStatement",ForStatement:"ForStatement",ForInStatement:"ForInStatement",ForOfStatement:"ForOfStatement",FunctionDeclaration:"FunctionDeclaration",FunctionExpression:"FunctionExpression",GeneratorExpression:"GeneratorExpression",Identifier:"Identifier",IfStatement:"IfStatement",ImportExpression:"ImportExpression",ImportDeclaration:"ImportDeclaration",ImportDefaultSpecifier:"ImportDefaultSpecifier",ImportNamespaceSpecifier:"ImportNamespaceSpecifier",ImportSpecifier:"ImportSpecifier",Literal:"Literal",LabeledStatement:"LabeledStatement",LogicalExpression:"LogicalExpression",MemberExpression:"MemberExpression",MetaProperty:"MetaProperty",MethodDefinition:"MethodDefinition",ModuleSpecifier:"ModuleSpecifier",NewExpression:"NewExpression",ObjectExpression:"ObjectExpression",ObjectPattern:"ObjectPattern",PrivateIdentifier:"PrivateIdentifier",Program:"Program",Property:"Property",PropertyDefinition:"PropertyDefinition",RestElement:"RestElement",ReturnStatement:"ReturnStatement",SequenceExpression:"SequenceExpression",SpreadElement:"SpreadElement",Super:"Super",SwitchStatement:"SwitchStatement",SwitchCase:"SwitchCase",TaggedTemplateExpression:"TaggedTemplateExpression",TemplateElement:"TemplateElement",TemplateLiteral:"TemplateLiteral",ThisExpression:"ThisExpression",ThrowStatement:"ThrowStatement",TryStatement:"TryStatement",UnaryExpression:"UnaryExpression",UpdateExpression:"UpdateExpression",VariableDeclaration:"VariableDeclaration",VariableDeclarator:"VariableDeclarator",WhileStatement:"WhileStatement",WithStatement:"WithStatement",YieldExpression:"YieldExpression"},a={AssignmentExpression:["left","right"],AssignmentPattern:["left","right"],ArrayExpression:["elements"],ArrayPattern:["elements"],ArrowFunctionExpression:["params","body"],AwaitExpression:["argument"],BlockStatement:["body"],BinaryExpression:["left","right"],BreakStatement:["label"],CallExpression:["callee","arguments"],CatchClause:["param","body"],ChainExpression:["expression"],ClassBody:["body"],ClassDeclaration:["id","superClass","body"],ClassExpression:["id","superClass","body"],ComprehensionBlock:["left","right"],ComprehensionExpression:["blocks","filter","body"],ConditionalExpression:["test","consequent","alternate"],ContinueStatement:["label"],DebuggerStatement:[],DirectiveStatement:[],DoWhileStatement:["body","test"],EmptyStatement:[],ExportAllDeclaration:["source"],ExportDefaultDeclaration:["declaration"],ExportNamedDeclaration:["declaration","specifiers","source"],ExportSpecifier:["exported","local"],ExpressionStatement:["expression"],ForStatement:["init","test","update","body"],ForInStatement:["left","right","body"],ForOfStatement:["left","right","body"],FunctionDeclaration:["id","params","body"],FunctionExpression:["id","params","body"],GeneratorExpression:["blocks","filter","body"],Identifier:[],IfStatement:["test","consequent","alternate"],ImportExpression:["source"],ImportDeclaration:["specifiers","source"],ImportDefaultSpecifier:["local"],ImportNamespaceSpecifier:["local"],ImportSpecifier:["imported","local"],Literal:[],LabeledStatement:["label","body"],LogicalExpression:["left","right"],MemberExpression:["object","property"],MetaProperty:["meta","property"],MethodDefinition:["key","value"],ModuleSpecifier:[],NewExpression:["callee","arguments"],ObjectExpression:["properties"],ObjectPattern:["properties"],PrivateIdentifier:[],Program:["body"],Property:["key","value"],PropertyDefinition:["key","value"],RestElement:["argument"],ReturnStatement:["argument"],SequenceExpression:["expressions"],SpreadElement:["argument"],Super:[],SwitchStatement:["discriminant","cases"],SwitchCase:["test","consequent"],TaggedTemplateExpression:["tag","quasi"],TemplateElement:[],TemplateLiteral:["quasis","expressions"],ThisExpression:[],ThrowStatement:["argument"],TryStatement:["block","handler","finalizer"],UnaryExpression:["argument"],UpdateExpression:["argument"],VariableDeclaration:["declarations"],VariableDeclarator:["id","init"],WhileStatement:["test","body"],WithStatement:["object","body"],YieldExpression:["argument"]},o={},u={},l={},i={Break:o,Skip:u,Remove:l};function d(S,E){this.parent=S,this.key=E}d.prototype.replace=function(E){this.parent[this.key]=E},d.prototype.remove=function(){return Array.isArray(this.parent)?(this.parent.splice(this.key,1),!0):(this.replace(null),!1)};function p(S,E,C,I){this.node=S,this.path=E,this.wrap=C,this.ref=I}function f(){}f.prototype.path=function(){var E,C,I,_,A,k;function N(D,F){if(Array.isArray(F))for(I=0,_=F.length;I<_;++I)D.push(F[I]);else D.push(F)}if(!this.__current.path)return null;for(A=[],E=2,C=this.__leavelist.length;E<C;++E)k=this.__leavelist[E],N(A,k.path);return N(A,this.__current.path),A},f.prototype.type=function(){var S=this.current();return S.type||this.__current.wrap},f.prototype.parents=function(){var E,C,I;for(I=[],E=1,C=this.__leavelist.length;E<C;++E)I.push(this.__leavelist[E].node);return I},f.prototype.current=function(){return this.__current.node},f.prototype.__execute=function(E,C){var I,_;return _=void 0,I=this.__current,this.__current=C,this.__state=null,E&&(_=E.call(this,C.node,this.__leavelist[this.__leavelist.length-1].node)),this.__current=I,_},f.prototype.notify=function(E){this.__state=E},f.prototype.skip=function(){this.notify(u)},f.prototype.break=function(){this.notify(o)},f.prototype.remove=function(){this.notify(l)},f.prototype.__initialize=function(S,E){this.visitor=E,this.root=S,this.__worklist=[],this.__leavelist=[],this.__current=null,this.__state=null,this.__fallback=null,E.fallback==="iteration"?this.__fallback=Object.keys:typeof E.fallback=="function"&&(this.__fallback=E.fallback),this.__keys=a,E.keys&&(this.__keys=Object.assign(Object.create(this.__keys),E.keys))};function m(S){return S==null?!1:typeof S=="object"&&typeof S.type=="string"}function g(S,E){return(S===s.ObjectExpression||S===s.ObjectPattern)&&E==="properties"}function y(S,E){for(var C=S.length-1;C>=0;--C)if(S[C].node===E)return!0;return!1}f.prototype.traverse=function(E,C){var I,_,A,k,N,D,F,P,G,Y,Z,ee;for(this.__initialize(E,C),ee={},I=this.__worklist,_=this.__leavelist,I.push(new p(E,null,null,null)),_.push(new p(null,null,null,null));I.length;){if(A=I.pop(),A===ee){if(A=_.pop(),D=this.__execute(C.leave,A),this.__state===o||D===o)return;continue}if(A.node){if(D=this.__execute(C.enter,A),this.__state===o||D===o)return;if(I.push(ee),_.push(A),this.__state===u||D===u)continue;if(k=A.node,N=k.type||A.wrap,Y=this.__keys[N],!Y)if(this.__fallback)Y=this.__fallback(k);else throw new Error("Unknown node type "+N+".");for(P=Y.length;(P-=1)>=0;)if(F=Y[P],Z=k[F],!!Z){if(Array.isArray(Z)){for(G=Z.length;(G-=1)>=0;)if(Z[G]&&!y(_,Z[G])){if(g(N,Y[P]))A=new p(Z[G],[F,G],"Property",null);else if(m(Z[G]))A=new p(Z[G],[F,G],null,null);else continue;I.push(A)}}else if(m(Z)){if(y(_,Z))continue;I.push(new p(Z,F,null,null))}}}}},f.prototype.replace=function(E,C){var I,_,A,k,N,D,F,P,G,Y,Z,ee,se;function re(J){var le,he,xe,Fe;if(J.ref.remove()){for(he=J.ref.key,Fe=J.ref.parent,le=I.length;le--;)if(xe=I[le],xe.ref&&xe.ref.parent===Fe){if(xe.ref.key<he)break;--xe.ref.key}}}for(this.__initialize(E,C),Z={},I=this.__worklist,_=this.__leavelist,ee={root:E},D=new p(E,null,null,new d(ee,"root")),I.push(D),_.push(D);I.length;){if(D=I.pop(),D===Z){if(D=_.pop(),N=this.__execute(C.leave,D),N!==void 0&&N!==o&&N!==u&&N!==l&&D.ref.replace(N),(this.__state===l||N===l)&&re(D),this.__state===o||N===o)return ee.root;continue}if(N=this.__execute(C.enter,D),N!==void 0&&N!==o&&N!==u&&N!==l&&(D.ref.replace(N),D.node=N),(this.__state===l||N===l)&&(re(D),D.node=null),this.__state===o||N===o)return ee.root;if(A=D.node,!!A&&(I.push(Z),_.push(D),!(this.__state===u||N===u))){if(k=A.type||D.wrap,G=this.__keys[k],!G)if(this.__fallback)G=this.__fallback(A);else throw new Error("Unknown node type "+k+".");for(F=G.length;(F-=1)>=0;)if(se=G[F],Y=A[se],!!Y)if(Array.isArray(Y)){for(P=Y.length;(P-=1)>=0;)if(Y[P]){if(g(k,G[F]))D=new p(Y[P],[se,P],"Property",new d(Y,P));else if(m(Y[P]))D=new p(Y[P],[se,P],null,new d(Y,P));else continue;I.push(D)}}else m(Y)&&I.push(new p(Y,se,null,new d(A,se)))}}return ee.root};function b(S,E){var C=new f;return C.traverse(S,E)}function x(S,E){var C=new f;return C.replace(S,E)}function w(S,E){var C;return C=h(E,function(_){return _.range[0]>S.range[0]}),S.extendedRange=[S.range[0],S.range[1]],C!==E.length&&(S.extendedRange[1]=E[C].range[0]),C-=1,C>=0&&(S.extendedRange[0]=E[C].range[1]),S}function v(S,E,C){var I=[],_,A,k,N;if(!S.range)throw new Error("attachComments needs range information");if(!C.length){if(E.length){for(k=0,A=E.length;k<A;k+=1)_=c(E[k]),_.extendedRange=[0,S.range[0]],I.push(_);S.leadingComments=I}return S}for(k=0,A=E.length;k<A;k+=1)I.push(w(c(E[k]),C));return N=0,b(S,{enter:function(D){for(var F;N<I.length&&(F=I[N],!(F.extendedRange[1]>D.range[0]));)F.extendedRange[1]===D.range[0]?(D.leadingComments||(D.leadingComments=[]),D.leadingComments.push(F),I.splice(N,1)):N+=1;if(N===I.length)return i.Break;if(I[N].extendedRange[0]>D.range[1])return i.Skip}}),N=0,b(S,{leave:function(D){for(var F;N<I.length&&(F=I[N],!(D.range[1]<F.extendedRange[0]));)D.range[1]===F.extendedRange[0]?(D.trailingComments||(D.trailingComments=[]),D.trailingComments.push(F),I.splice(N,1)):N+=1;if(N===I.length)return i.Break;if(I[N].extendedRange[0]>D.range[1])return i.Skip}}),S}return n.Syntax=s,n.traverse=b,n.replace=x,n.attachComments=v,n.VisitorKeys=a,n.VisitorOption=i,n.Controller=f,n.cloneEnvironment=function(){return t({})},n})(r)}(TE)),TE}var ly={},AE={exports:{}},u4;function Jce(){return u4||(u4=1,function(){function r(o){if(o==null)return!1;switch(o.type){case"ArrayExpression":case"AssignmentExpression":case"BinaryExpression":case"CallExpression":case"ConditionalExpression":case"FunctionExpression":case"Identifier":case"Literal":case"LogicalExpression":case"MemberExpression":case"NewExpression":case"ObjectExpression":case"SequenceExpression":case"ThisExpression":case"UnaryExpression":case"UpdateExpression":return!0}return!1}function t(o){if(o==null)return!1;switch(o.type){case"DoWhileStatement":case"ForInStatement":case"ForStatement":case"WhileStatement":return!0}return!1}function n(o){if(o==null)return!1;switch(o.type){case"BlockStatement":case"BreakStatement":case"ContinueStatement":case"DebuggerStatement":case"DoWhileStatement":case"EmptyStatement":case"ExpressionStatement":case"ForInStatement":case"ForStatement":case"IfStatement":case"LabeledStatement":case"ReturnStatement":case"SwitchStatement":case"ThrowStatement":case"TryStatement":case"VariableDeclaration":case"WhileStatement":case"WithStatement":return!0}return!1}function s(o){return n(o)||o!=null&&o.type==="FunctionDeclaration"}function i(o){switch(o.type){case"IfStatement":return o.alternate!=null?o.alternate:o.consequent;case"LabeledStatement":case"ForStatement":case"ForInStatement":case"WhileStatement":case"WithStatement":return o.body}return null}function a(o){var u;if(o.type!=="IfStatement"||o.alternate==null)return!1;u=o.consequent;do{if(u.type==="IfStatement"&&u.alternate==null)return!0;u=i(u)}while(u);return!1}AE.exports={isExpression:r,isStatement:n,isIterationStatement:t,isSourceElement:s,isProblematicIfStatement:a,trailingStatement:i}}()),AE.exports}var DE={exports:{}},l4;function P8(){return l4||(l4=1,function(){var r,t,n,s,i,a;t={NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,NonAsciiIdentifierPart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/},r={NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,NonAsciiIdentifierPart:/[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/};function o(y){return 48<=y&&y<=57}function u(y){return 48<=y&&y<=57||97<=y&&y<=102||65<=y&&y<=70}function l(y){return y>=48&&y<=55}n=[5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279];function c(y){return y===32||y===9||y===11||y===12||y===160||y>=5760&&n.indexOf(y)>=0}function h(y){return y===10||y===13||y===8232||y===8233}function d(y){if(y<=65535)return String.fromCharCode(y);var b=String.fromCharCode(Math.floor((y-65536)/1024)+55296),x=String.fromCharCode((y-65536)%1024+56320);return b+x}for(s=new Array(128),a=0;a<128;++a)s[a]=a>=97&&a<=122||a>=65&&a<=90||a===36||a===95;for(i=new Array(128),a=0;a<128;++a)i[a]=a>=97&&a<=122||a>=65&&a<=90||a>=48&&a<=57||a===36||a===95;function p(y){return y<128?s[y]:t.NonAsciiIdentifierStart.test(d(y))}function f(y){return y<128?i[y]:t.NonAsciiIdentifierPart.test(d(y))}function m(y){return y<128?s[y]:r.NonAsciiIdentifierStart.test(d(y))}function g(y){return y<128?i[y]:r.NonAsciiIdentifierPart.test(d(y))}DE.exports={isDecimalDigit:o,isHexDigit:u,isOctalDigit:l,isWhiteSpace:c,isLineTerminator:h,isIdentifierStartES5:p,isIdentifierPartES5:f,isIdentifierStartES6:m,isIdentifierPartES6:g}}()),DE.exports}var FE={exports:{}},c4;function Qce(){return c4||(c4=1,function(){var r=P8();function t(p){switch(p){case"implements":case"interface":case"package":case"private":case"protected":case"public":case"static":case"let":return!0;default:return!1}}function n(p,f){return!f&&p==="yield"?!1:s(p,f)}function s(p,f){if(f&&t(p))return!0;switch(p.length){case 2:return p==="if"||p==="in"||p==="do";case 3:return p==="var"||p==="for"||p==="new"||p==="try";case 4:return p==="this"||p==="else"||p==="case"||p==="void"||p==="with"||p==="enum";case 5:return p==="while"||p==="break"||p==="catch"||p==="throw"||p==="const"||p==="yield"||p==="class"||p==="super";case 6:return p==="return"||p==="typeof"||p==="delete"||p==="switch"||p==="export"||p==="import";case 7:return p==="default"||p==="finally"||p==="extends";case 8:return p==="function"||p==="continue"||p==="debugger";case 10:return p==="instanceof";default:return!1}}function i(p,f){return p==="null"||p==="true"||p==="false"||n(p,f)}function a(p,f){return p==="null"||p==="true"||p==="false"||s(p,f)}function o(p){return p==="eval"||p==="arguments"}function u(p){var f,m,g;if(p.length===0||(g=p.charCodeAt(0),!r.isIdentifierStartES5(g)))return!1;for(f=1,m=p.length;f<m;++f)if(g=p.charCodeAt(f),!r.isIdentifierPartES5(g))return!1;return!0}function l(p,f){return(p-55296)*1024+(f-56320)+65536}function c(p){var f,m,g,y,b;if(p.length===0)return!1;for(b=r.isIdentifierStartES6,f=0,m=p.length;f<m;++f){if(g=p.charCodeAt(f),55296<=g&&g<=56319){if(++f,f>=m||(y=p.charCodeAt(f),!(56320<=y&&y<=57343)))return!1;g=l(g,y)}if(!b(g))return!1;b=r.isIdentifierPartES6}return!0}function h(p,f){return u(p)&&!i(p,f)}function d(p,f){return c(p)&&!a(p,f)}FE.exports={isKeywordES5:n,isKeywordES6:s,isReservedWordES5:i,isReservedWordES6:a,isRestrictedWord:o,isIdentifierNameES5:u,isIdentifierNameES6:c,isIdentifierES5:h,isIdentifierES6:d}}()),FE.exports}var h4;function ehe(){return h4||(h4=1,function(){ly.ast=Jce(),ly.code=P8(),ly.keyword=Qce()}()),ly}var cy={},$E={},y1={},b1={},d4;function the(){if(d4)return b1;d4=1;var r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");return b1.encode=function(t){if(0<=t&&t<r.length)return r[t];throw new TypeError("Must be between 0 and 63: "+t)},b1.decode=function(t){var n=65,s=90,i=97,a=122,o=48,u=57,l=43,c=47,h=26,d=52;return n<=t&&t<=s?t-n:i<=t&&t<=a?t-i+h:o<=t&&t<=u?t-o+d:t==l?62:t==c?63:-1},b1}var p4;function B8(){if(p4)return y1;p4=1;var r=the(),t=5,n=1<<t,s=n-1,i=n;function a(u){return u<0?(-u<<1)+1:(u<<1)+0}function o(u){var l=(u&1)===1,c=u>>1;return l?-c:c}return y1.encode=function(l){var c="",h,d=a(l);do h=d&s,d>>>=t,d>0&&(h|=i),c+=r.encode(h);while(d>0);return c},y1.decode=function(l,c,h){var d=l.length,p=0,f=0,m,g;do{if(c>=d)throw new Error("Expected more digits in base 64 VLQ value.");if(g=r.decode(l.charCodeAt(c++)),g===-1)throw new Error("Invalid base64 digit: "+l.charAt(c-1));m=!!(g&i),g&=s,p=p+(g<<f),f+=t}while(m);h.value=o(p),h.rest=c},y1}var RE={},f4;function gx(){return f4||(f4=1,function(r){function t(v,S,E){if(S in v)return v[S];if(arguments.length===3)return E;throw new Error('"'+S+'" is a required argument.')}r.getArg=t;var n=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,s=/^data:.+\,.+$/;function i(v){var S=v.match(n);return S?{scheme:S[1],auth:S[2],host:S[3],port:S[4],path:S[5]}:null}r.urlParse=i;function a(v){var S="";return v.scheme&&(S+=v.scheme+":"),S+="//",v.auth&&(S+=v.auth+"@"),v.host&&(S+=v.host),v.port&&(S+=":"+v.port),v.path&&(S+=v.path),S}r.urlGenerate=a;function o(v){var S=v,E=i(v);if(E){if(!E.path)return v;S=E.path}for(var C=r.isAbsolute(S),I=S.split(/\/+/),_,A=0,k=I.length-1;k>=0;k--)_=I[k],_==="."?I.splice(k,1):_===".."?A++:A>0&&(_===""?(I.splice(k+1,A),A=0):(I.splice(k,2),A--));return S=I.join("/"),S===""&&(S=C?"/":"."),E?(E.path=S,a(E)):S}r.normalize=o;function u(v,S){v===""&&(v="."),S===""&&(S=".");var E=i(S),C=i(v);if(C&&(v=C.path||"/"),E&&!E.scheme)return C&&(E.scheme=C.scheme),a(E);if(E||S.match(s))return S;if(C&&!C.host&&!C.path)return C.host=S,a(C);var I=S.charAt(0)==="/"?S:o(v.replace(/\/+$/,"")+"/"+S);return C?(C.path=I,a(C)):I}r.join=u,r.isAbsolute=function(v){return v.charAt(0)==="/"||n.test(v)};function l(v,S){v===""&&(v="."),v=v.replace(/\/$/,"");for(var E=0;S.indexOf(v+"/")!==0;){var C=v.lastIndexOf("/");if(C<0||(v=v.slice(0,C),v.match(/^([^\/]+:\/)?\/*$/)))return S;++E}return Array(E+1).join("../")+S.substr(v.length+1)}r.relative=l;var c=function(){var v=Object.create(null);return!("__proto__"in v)}();function h(v){return v}function d(v){return f(v)?"$"+v:v}r.toSetString=c?h:d;function p(v){return f(v)?v.slice(1):v}r.fromSetString=c?h:p;function f(v){if(!v)return!1;var S=v.length;if(S<9||v.charCodeAt(S-1)!==95||v.charCodeAt(S-2)!==95||v.charCodeAt(S-3)!==111||v.charCodeAt(S-4)!==116||v.charCodeAt(S-5)!==111||v.charCodeAt(S-6)!==114||v.charCodeAt(S-7)!==112||v.charCodeAt(S-8)!==95||v.charCodeAt(S-9)!==95)return!1;for(var E=S-10;E>=0;E--)if(v.charCodeAt(E)!==36)return!1;return!0}function m(v,S,E){var C=y(v.source,S.source);return C!==0||(C=v.originalLine-S.originalLine,C!==0)||(C=v.originalColumn-S.originalColumn,C!==0||E)||(C=v.generatedColumn-S.generatedColumn,C!==0)||(C=v.generatedLine-S.generatedLine,C!==0)?C:y(v.name,S.name)}r.compareByOriginalPositions=m;function g(v,S,E){var C=v.generatedLine-S.generatedLine;return C!==0||(C=v.generatedColumn-S.generatedColumn,C!==0||E)||(C=y(v.source,S.source),C!==0)||(C=v.originalLine-S.originalLine,C!==0)||(C=v.originalColumn-S.originalColumn,C!==0)?C:y(v.name,S.name)}r.compareByGeneratedPositionsDeflated=g;function y(v,S){return v===S?0:v===null?1:S===null?-1:v>S?1:-1}function b(v,S){var E=v.generatedLine-S.generatedLine;return E!==0||(E=v.generatedColumn-S.generatedColumn,E!==0)||(E=y(v.source,S.source),E!==0)||(E=v.originalLine-S.originalLine,E!==0)||(E=v.originalColumn-S.originalColumn,E!==0)?E:y(v.name,S.name)}r.compareByGeneratedPositionsInflated=b;function x(v){return JSON.parse(v.replace(/^\)]}'[^\n]*\n/,""))}r.parseSourceMapInput=x;function w(v,S,E){if(S=S||"",v&&(v[v.length-1]!=="/"&&S[0]!=="/"&&(v+="/"),S=v+S),E){var C=i(E);if(!C)throw new Error("sourceMapURL could not be parsed");if(C.path){var I=C.path.lastIndexOf("/");I>=0&&(C.path=C.path.substring(0,I+1))}S=u(a(C),S)}return o(S)}r.computeSourceURL=w}(RE)),RE}var OE={},m4;function V8(){if(m4)return OE;m4=1;var r=gx(),t=Object.prototype.hasOwnProperty,n=typeof Map<"u";function s(){this._array=[],this._set=n?new Map:Object.create(null)}return s.fromArray=function(a,o){for(var u=new s,l=0,c=a.length;l<c;l++)u.add(a[l],o);return u},s.prototype.size=function(){return n?this._set.size:Object.getOwnPropertyNames(this._set).length},s.prototype.add=function(a,o){var u=n?a:r.toSetString(a),l=n?this.has(a):t.call(this._set,u),c=this._array.length;(!l||o)&&this._array.push(a),l||(n?this._set.set(a,c):this._set[u]=c)},s.prototype.has=function(a){if(n)return this._set.has(a);var o=r.toSetString(a);return t.call(this._set,o)},s.prototype.indexOf=function(a){if(n){var o=this._set.get(a);if(o>=0)return o}else{var u=r.toSetString(a);if(t.call(this._set,u))return this._set[u]}throw new Error('"'+a+'" is not in the set.')},s.prototype.at=function(a){if(a>=0&&a<this._array.length)return this._array[a];throw new Error("No element indexed by "+a)},s.prototype.toArray=function(){return this._array.slice()},OE.ArraySet=s,OE}var ME={},g4;function rhe(){if(g4)return ME;g4=1;var r=gx();function t(s,i){var a=s.generatedLine,o=i.generatedLine,u=s.generatedColumn,l=i.generatedColumn;return o>a||o==a&&l>=u||r.compareByGeneratedPositionsInflated(s,i)<=0}function n(){this._array=[],this._sorted=!0,this._last={generatedLine:-1,generatedColumn:0}}return n.prototype.unsortedForEach=function(i,a){this._array.forEach(i,a)},n.prototype.add=function(i){t(this._last,i)?(this._last=i,this._array.push(i)):(this._sorted=!1,this._array.push(i))},n.prototype.toArray=function(){return this._sorted||(this._array.sort(r.compareByGeneratedPositionsInflated),this._sorted=!0),this._array},ME.MappingList=n,ME}var y4;function z8(){if(y4)return $E;y4=1;var r=B8(),t=gx(),n=V8().ArraySet,s=rhe().MappingList;function i(a){a||(a={}),this._file=t.getArg(a,"file",null),this._sourceRoot=t.getArg(a,"sourceRoot",null),this._skipValidation=t.getArg(a,"skipValidation",!1),this._sources=new n,this._names=new n,this._mappings=new s,this._sourcesContents=null}return i.prototype._version=3,i.fromSourceMap=function(o){var u=o.sourceRoot,l=new i({file:o.file,sourceRoot:u});return o.eachMapping(function(c){var h={generated:{line:c.generatedLine,column:c.generatedColumn}};c.source!=null&&(h.source=c.source,u!=null&&(h.source=t.relative(u,h.source)),h.original={line:c.originalLine,column:c.originalColumn},c.name!=null&&(h.name=c.name)),l.addMapping(h)}),o.sources.forEach(function(c){var h=c;u!==null&&(h=t.relative(u,c)),l._sources.has(h)||l._sources.add(h);var d=o.sourceContentFor(c);d!=null&&l.setSourceContent(c,d)}),l},i.prototype.addMapping=function(o){var u=t.getArg(o,"generated"),l=t.getArg(o,"original",null),c=t.getArg(o,"source",null),h=t.getArg(o,"name",null);this._skipValidation||this._validateMapping(u,l,c,h),c!=null&&(c=String(c),this._sources.has(c)||this._sources.add(c)),h!=null&&(h=String(h),this._names.has(h)||this._names.add(h)),this._mappings.add({generatedLine:u.line,generatedColumn:u.column,originalLine:l!=null&&l.line,originalColumn:l!=null&&l.column,source:c,name:h})},i.prototype.setSourceContent=function(o,u){var l=o;this._sourceRoot!=null&&(l=t.relative(this._sourceRoot,l)),u!=null?(this._sourcesContents||(this._sourcesContents=Object.create(null)),this._sourcesContents[t.toSetString(l)]=u):this._sourcesContents&&(delete this._sourcesContents[t.toSetString(l)],Object.keys(this._sourcesContents).length===0&&(this._sourcesContents=null))},i.prototype.applySourceMap=function(o,u,l){var c=u;if(u==null){if(o.file==null)throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);c=o.file}var h=this._sourceRoot;h!=null&&(c=t.relative(h,c));var d=new n,p=new n;this._mappings.unsortedForEach(function(f){if(f.source===c&&f.originalLine!=null){var m=o.originalPositionFor({line:f.originalLine,column:f.originalColumn});m.source!=null&&(f.source=m.source,l!=null&&(f.source=t.join(l,f.source)),h!=null&&(f.source=t.relative(h,f.source)),f.originalLine=m.line,f.originalColumn=m.column,m.name!=null&&(f.name=m.name))}var g=f.source;g!=null&&!d.has(g)&&d.add(g);var y=f.name;y!=null&&!p.has(y)&&p.add(y)},this),this._sources=d,this._names=p,o.sources.forEach(function(f){var m=o.sourceContentFor(f);m!=null&&(l!=null&&(f=t.join(l,f)),h!=null&&(f=t.relative(h,f)),this.setSourceContent(f,m))},this)},i.prototype._validateMapping=function(o,u,l,c){if(u&&typeof u.line!="number"&&typeof u.column!="number")throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");if(!(o&&"line"in o&&"column"in o&&o.line>0&&o.column>=0&&!u&&!l&&!c)){if(o&&"line"in o&&"column"in o&&u&&"line"in u&&"column"in u&&o.line>0&&o.column>=0&&u.line>0&&u.column>=0&&l)return;throw new Error("Invalid mapping: "+JSON.stringify({generated:o,source:l,original:u,name:c}))}},i.prototype._serializeMappings=function(){for(var o=0,u=1,l=0,c=0,h=0,d=0,p="",f,m,g,y,b=this._mappings.toArray(),x=0,w=b.length;x<w;x++){if(m=b[x],f="",m.generatedLine!==u)for(o=0;m.generatedLine!==u;)f+=";",u++;else if(x>0){if(!t.compareByGeneratedPositionsInflated(m,b[x-1]))continue;f+=","}f+=r.encode(m.generatedColumn-o),o=m.generatedColumn,m.source!=null&&(y=this._sources.indexOf(m.source),f+=r.encode(y-d),d=y,f+=r.encode(m.originalLine-1-c),c=m.originalLine-1,f+=r.encode(m.originalColumn-l),l=m.originalColumn,m.name!=null&&(g=this._names.indexOf(m.name),f+=r.encode(g-h),h=g)),p+=f}return p},i.prototype._generateSourcesContent=function(o,u){return o.map(function(l){if(!this._sourcesContents)return null;u!=null&&(l=t.relative(u,l));var c=t.toSetString(l);return Object.prototype.hasOwnProperty.call(this._sourcesContents,c)?this._sourcesContents[c]:null},this)},i.prototype.toJSON=function(){var o={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return this._file!=null&&(o.file=this._file),this._sourceRoot!=null&&(o.sourceRoot=this._sourceRoot),this._sourcesContents&&(o.sourcesContent=this._generateSourcesContent(o.sources,o.sourceRoot)),o},i.prototype.toString=function(){return JSON.stringify(this.toJSON())},$E.SourceMapGenerator=i,$E}var hy={},LE={},b4;function nhe(){return b4||(b4=1,function(r){r.GREATEST_LOWER_BOUND=1,r.LEAST_UPPER_BOUND=2;function t(n,s,i,a,o,u){var l=Math.floor((s-n)/2)+n,c=o(i,a[l],!0);return c===0?l:c>0?s-l>1?t(l,s,i,a,o,u):u==r.LEAST_UPPER_BOUND?s<a.length?s:-1:l:l-n>1?t(n,l,i,a,o,u):u==r.LEAST_UPPER_BOUND?l:n<0?-1:n}r.search=function(s,i,a,o){if(i.length===0)return-1;var u=t(-1,i.length,s,i,a,o||r.GREATEST_LOWER_BOUND);if(u<0)return-1;for(;u-1>=0&&a(i[u],i[u-1],!0)===0;)--u;return u}}(LE)),LE}var PE={},x4;function she(){if(x4)return PE;x4=1;function r(s,i,a){var o=s[i];s[i]=s[a],s[a]=o}function t(s,i){return Math.round(s+Math.random()*(i-s))}function n(s,i,a,o){if(a<o){var u=t(a,o),l=a-1;r(s,u,o);for(var c=s[o],h=a;h<o;h++)i(s[h],c)<=0&&(l+=1,r(s,l,h));r(s,l+1,h);var d=l+1;n(s,i,a,d-1),n(s,i,d+1,o)}}return PE.quickSort=function(s,i){n(s,i,0,s.length-1)},PE}var v4;function ihe(){if(v4)return hy;v4=1;var r=gx(),t=nhe(),n=V8().ArraySet,s=B8(),i=she().quickSort;function a(c,h){var d=c;return typeof c=="string"&&(d=r.parseSourceMapInput(c)),d.sections!=null?new l(d,h):new o(d,h)}a.fromSourceMap=function(c,h){return o.fromSourceMap(c,h)},a.prototype._version=3,a.prototype.__generatedMappings=null,Object.defineProperty(a.prototype,"_generatedMappings",{configurable:!0,enumerable:!0,get:function(){return this.__generatedMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__generatedMappings}}),a.prototype.__originalMappings=null,Object.defineProperty(a.prototype,"_originalMappings",{configurable:!0,enumerable:!0,get:function(){return this.__originalMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__originalMappings}}),a.prototype._charIsMappingSeparator=function(h,d){var p=h.charAt(d);return p===";"||p===","},a.prototype._parseMappings=function(h,d){throw new Error("Subclasses must implement _parseMappings")},a.GENERATED_ORDER=1,a.ORIGINAL_ORDER=2,a.GREATEST_LOWER_BOUND=1,a.LEAST_UPPER_BOUND=2,a.prototype.eachMapping=function(h,d,p){var f=d||null,m=p||a.GENERATED_ORDER,g;switch(m){case a.GENERATED_ORDER:g=this._generatedMappings;break;case a.ORIGINAL_ORDER:g=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}var y=this.sourceRoot;g.map(function(b){var x=b.source===null?null:this._sources.at(b.source);return x=r.computeSourceURL(y,x,this._sourceMapURL),{source:x,generatedLine:b.generatedLine,generatedColumn:b.generatedColumn,originalLine:b.originalLine,originalColumn:b.originalColumn,name:b.name===null?null:this._names.at(b.name)}},this).forEach(h,f)},a.prototype.allGeneratedPositionsFor=function(h){var d=r.getArg(h,"line"),p={source:r.getArg(h,"source"),originalLine:d,originalColumn:r.getArg(h,"column",0)};if(p.source=this._findSourceIndex(p.source),p.source<0)return[];var f=[],m=this._findMapping(p,this._originalMappings,"originalLine","originalColumn",r.compareByOriginalPositions,t.LEAST_UPPER_BOUND);if(m>=0){var g=this._originalMappings[m];if(h.column===void 0)for(var y=g.originalLine;g&&g.originalLine===y;)f.push({line:r.getArg(g,"generatedLine",null),column:r.getArg(g,"generatedColumn",null),lastColumn:r.getArg(g,"lastGeneratedColumn",null)}),g=this._originalMappings[++m];else for(var b=g.originalColumn;g&&g.originalLine===d&&g.originalColumn==b;)f.push({line:r.getArg(g,"generatedLine",null),column:r.getArg(g,"generatedColumn",null),lastColumn:r.getArg(g,"lastGeneratedColumn",null)}),g=this._originalMappings[++m]}return f},hy.SourceMapConsumer=a;function o(c,h){var d=c;typeof c=="string"&&(d=r.parseSourceMapInput(c));var p=r.getArg(d,"version"),f=r.getArg(d,"sources"),m=r.getArg(d,"names",[]),g=r.getArg(d,"sourceRoot",null),y=r.getArg(d,"sourcesContent",null),b=r.getArg(d,"mappings"),x=r.getArg(d,"file",null);if(p!=this._version)throw new Error("Unsupported version: "+p);g&&(g=r.normalize(g)),f=f.map(String).map(r.normalize).map(function(w){return g&&r.isAbsolute(g)&&r.isAbsolute(w)?r.relative(g,w):w}),this._names=n.fromArray(m.map(String),!0),this._sources=n.fromArray(f,!0),this._absoluteSources=this._sources.toArray().map(function(w){return r.computeSourceURL(g,w,h)}),this.sourceRoot=g,this.sourcesContent=y,this._mappings=b,this._sourceMapURL=h,this.file=x}o.prototype=Object.create(a.prototype),o.prototype.consumer=a,o.prototype._findSourceIndex=function(c){var h=c;if(this.sourceRoot!=null&&(h=r.relative(this.sourceRoot,h)),this._sources.has(h))return this._sources.indexOf(h);var d;for(d=0;d<this._absoluteSources.length;++d)if(this._absoluteSources[d]==c)return d;return-1},o.fromSourceMap=function(h,d){var p=Object.create(o.prototype),f=p._names=n.fromArray(h._names.toArray(),!0),m=p._sources=n.fromArray(h._sources.toArray(),!0);p.sourceRoot=h._sourceRoot,p.sourcesContent=h._generateSourcesContent(p._sources.toArray(),p.sourceRoot),p.file=h._file,p._sourceMapURL=d,p._absoluteSources=p._sources.toArray().map(function(E){return r.computeSourceURL(p.sourceRoot,E,d)});for(var g=h._mappings.toArray().slice(),y=p.__generatedMappings=[],b=p.__originalMappings=[],x=0,w=g.length;x<w;x++){var v=g[x],S=new u;S.generatedLine=v.generatedLine,S.generatedColumn=v.generatedColumn,v.source&&(S.source=m.indexOf(v.source),S.originalLine=v.originalLine,S.originalColumn=v.originalColumn,v.name&&(S.name=f.indexOf(v.name)),b.push(S)),y.push(S)}return i(p.__originalMappings,r.compareByOriginalPositions),p},o.prototype._version=3,Object.defineProperty(o.prototype,"sources",{get:function(){return this._absoluteSources.slice()}});function u(){this.generatedLine=0,this.generatedColumn=0,this.source=null,this.originalLine=null,this.originalColumn=null,this.name=null}o.prototype._parseMappings=function(h,d){for(var p=1,f=0,m=0,g=0,y=0,b=0,x=h.length,w=0,v={},S={},E=[],C=[],I,_,A,k,N;w<x;)if(h.charAt(w)===";")p++,w++,f=0;else if(h.charAt(w)===",")w++;else{for(I=new u,I.generatedLine=p,k=w;k<x&&!this._charIsMappingSeparator(h,k);k++);if(_=h.slice(w,k),A=v[_],A)w+=_.length;else{for(A=[];w<k;)s.decode(h,w,S),N=S.value,w=S.rest,A.push(N);if(A.length===2)throw new Error("Found a source, but no line and column");if(A.length===3)throw new Error("Found a source and line, but no column");v[_]=A}I.generatedColumn=f+A[0],f=I.generatedColumn,A.length>1&&(I.source=y+A[1],y+=A[1],I.originalLine=m+A[2],m=I.originalLine,I.originalLine+=1,I.originalColumn=g+A[3],g=I.originalColumn,A.length>4&&(I.name=b+A[4],b+=A[4])),C.push(I),typeof I.originalLine=="number"&&E.push(I)}i(C,r.compareByGeneratedPositionsDeflated),this.__generatedMappings=C,i(E,r.compareByOriginalPositions),this.__originalMappings=E},o.prototype._findMapping=function(h,d,p,f,m,g){if(h[p]<=0)throw new TypeError("Line must be greater than or equal to 1, got "+h[p]);if(h[f]<0)throw new TypeError("Column must be greater than or equal to 0, got "+h[f]);return t.search(h,d,m,g)},o.prototype.computeColumnSpans=function(){for(var h=0;h<this._generatedMappings.length;++h){var d=this._generatedMappings[h];if(h+1<this._generatedMappings.length){var p=this._generatedMappings[h+1];if(d.generatedLine===p.generatedLine){d.lastGeneratedColumn=p.generatedColumn-1;continue}}d.lastGeneratedColumn=1/0}},o.prototype.originalPositionFor=function(h){var d={generatedLine:r.getArg(h,"line"),generatedColumn:r.getArg(h,"column")},p=this._findMapping(d,this._generatedMappings,"generatedLine","generatedColumn",r.compareByGeneratedPositionsDeflated,r.getArg(h,"bias",a.GREATEST_LOWER_BOUND));if(p>=0){var f=this._generatedMappings[p];if(f.generatedLine===d.generatedLine){var m=r.getArg(f,"source",null);m!==null&&(m=this._sources.at(m),m=r.computeSourceURL(this.sourceRoot,m,this._sourceMapURL));var g=r.getArg(f,"name",null);return g!==null&&(g=this._names.at(g)),{source:m,line:r.getArg(f,"originalLine",null),column:r.getArg(f,"originalColumn",null),name:g}}}return{source:null,line:null,column:null,name:null}},o.prototype.hasContentsOfAllSources=function(){return this.sourcesContent?this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some(function(h){return h==null}):!1},o.prototype.sourceContentFor=function(h,d){if(!this.sourcesContent)return null;var p=this._findSourceIndex(h);if(p>=0)return this.sourcesContent[p];var f=h;this.sourceRoot!=null&&(f=r.relative(this.sourceRoot,f));var m;if(this.sourceRoot!=null&&(m=r.urlParse(this.sourceRoot))){var g=f.replace(/^file:\/\//,"");if(m.scheme=="file"&&this._sources.has(g))return this.sourcesContent[this._sources.indexOf(g)];if((!m.path||m.path=="/")&&this._sources.has("/"+f))return this.sourcesContent[this._sources.indexOf("/"+f)]}if(d)return null;throw new Error('"'+f+'" is not in the SourceMap.')},o.prototype.generatedPositionFor=function(h){var d=r.getArg(h,"source");if(d=this._findSourceIndex(d),d<0)return{line:null,column:null,lastColumn:null};var p={source:d,originalLine:r.getArg(h,"line"),originalColumn:r.getArg(h,"column")},f=this._findMapping(p,this._originalMappings,"originalLine","originalColumn",r.compareByOriginalPositions,r.getArg(h,"bias",a.GREATEST_LOWER_BOUND));if(f>=0){var m=this._originalMappings[f];if(m.source===p.source)return{line:r.getArg(m,"generatedLine",null),column:r.getArg(m,"generatedColumn",null),lastColumn:r.getArg(m,"lastGeneratedColumn",null)}}return{line:null,column:null,lastColumn:null}},hy.BasicSourceMapConsumer=o;function l(c,h){var d=c;typeof c=="string"&&(d=r.parseSourceMapInput(c));var p=r.getArg(d,"version"),f=r.getArg(d,"sections");if(p!=this._version)throw new Error("Unsupported version: "+p);this._sources=new n,this._names=new n;var m={line:-1,column:0};this._sections=f.map(function(g){if(g.url)throw new Error("Support for url field in sections not implemented.");var y=r.getArg(g,"offset"),b=r.getArg(y,"line"),x=r.getArg(y,"column");if(b<m.line||b===m.line&&x<m.column)throw new Error("Section offsets must be ordered and non-overlapping.");return m=y,{generatedOffset:{generatedLine:b+1,generatedColumn:x+1},consumer:new a(r.getArg(g,"map"),h)}})}return l.prototype=Object.create(a.prototype),l.prototype.constructor=a,l.prototype._version=3,Object.defineProperty(l.prototype,"sources",{get:function(){for(var c=[],h=0;h<this._sections.length;h++)for(var d=0;d<this._sections[h].consumer.sources.length;d++)c.push(this._sections[h].consumer.sources[d]);return c}}),l.prototype.originalPositionFor=function(h){var d={generatedLine:r.getArg(h,"line"),generatedColumn:r.getArg(h,"column")},p=t.search(d,this._sections,function(m,g){var y=m.generatedLine-g.generatedOffset.generatedLine;return y||m.generatedColumn-g.generatedOffset.generatedColumn}),f=this._sections[p];return f?f.consumer.originalPositionFor({line:d.generatedLine-(f.generatedOffset.generatedLine-1),column:d.generatedColumn-(f.generatedOffset.generatedLine===d.generatedLine?f.generatedOffset.generatedColumn-1:0),bias:h.bias}):{source:null,line:null,column:null,name:null}},l.prototype.hasContentsOfAllSources=function(){return this._sections.every(function(h){return h.consumer.hasContentsOfAllSources()})},l.prototype.sourceContentFor=function(h,d){for(var p=0;p<this._sections.length;p++){var f=this._sections[p],m=f.consumer.sourceContentFor(h,!0);if(m)return m}if(d)return null;throw new Error('"'+h+'" is not in the SourceMap.')},l.prototype.generatedPositionFor=function(h){for(var d=0;d<this._sections.length;d++){var p=this._sections[d];if(p.consumer._findSourceIndex(r.getArg(h,"source"))!==-1){var f=p.consumer.generatedPositionFor(h);if(f){var m={line:f.line+(p.generatedOffset.generatedLine-1),column:f.column+(p.generatedOffset.generatedLine===f.line?p.generatedOffset.generatedColumn-1:0)};return m}}}return{line:null,column:null}},l.prototype._parseMappings=function(h,d){this.__generatedMappings=[],this.__originalMappings=[];for(var p=0;p<this._sections.length;p++)for(var f=this._sections[p],m=f.consumer._generatedMappings,g=0;g<m.length;g++){var y=m[g],b=f.consumer._sources.at(y.source);b=r.computeSourceURL(f.consumer.sourceRoot,b,this._sourceMapURL),this._sources.add(b),b=this._sources.indexOf(b);var x=null;y.name&&(x=f.consumer._names.at(y.name),this._names.add(x),x=this._names.indexOf(x));var w={source:b,generatedLine:y.generatedLine+(f.generatedOffset.generatedLine-1),generatedColumn:y.generatedColumn+(f.generatedOffset.generatedLine===y.generatedLine?f.generatedOffset.generatedColumn-1:0),originalLine:y.originalLine,originalColumn:y.originalColumn,name:x};this.__generatedMappings.push(w),typeof w.originalLine=="number"&&this.__originalMappings.push(w)}i(this.__generatedMappings,r.compareByGeneratedPositionsDeflated),i(this.__originalMappings,r.compareByOriginalPositions)},hy.IndexedSourceMapConsumer=l,hy}var BE={},w4;function ahe(){if(w4)return BE;w4=1;var r=z8().SourceMapGenerator,t=gx(),n=/(\r?\n)/,s=10,i="$$$isSourceNode$$$";function a(o,u,l,c,h){this.children=[],this.sourceContents={},this.line=o??null,this.column=u??null,this.source=l??null,this.name=h??null,this[i]=!0,c!=null&&this.add(c)}return a.fromStringWithSourceMap=function(u,l,c){var h=new a,d=u.split(n),p=0,f=function(){var x=v(),w=v()||"";return x+w;function v(){return p<d.length?d[p++]:void 0}},m=1,g=0,y=null;return l.eachMapping(function(x){if(y!==null)if(m<x.generatedLine)b(y,f()),m++,g=0;else{var w=d[p]||"",v=w.substr(0,x.generatedColumn-g);d[p]=w.substr(x.generatedColumn-g),g=x.generatedColumn,b(y,v),y=x;return}for(;m<x.generatedLine;)h.add(f()),m++;if(g<x.generatedColumn){var w=d[p]||"";h.add(w.substr(0,x.generatedColumn)),d[p]=w.substr(x.generatedColumn),g=x.generatedColumn}y=x},this),p<d.length&&(y&&b(y,f()),h.add(d.splice(p).join(""))),l.sources.forEach(function(x){var w=l.sourceContentFor(x);w!=null&&(c!=null&&(x=t.join(c,x)),h.setSourceContent(x,w))}),h;function b(x,w){if(x===null||x.source===void 0)h.add(w);else{var v=c?t.join(c,x.source):x.source;h.add(new a(x.originalLine,x.originalColumn,v,w,x.name))}}},a.prototype.add=function(u){if(Array.isArray(u))u.forEach(function(l){this.add(l)},this);else if(u[i]||typeof u=="string")u&&this.children.push(u);else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+u);return this},a.prototype.prepend=function(u){if(Array.isArray(u))for(var l=u.length-1;l>=0;l--)this.prepend(u[l]);else if(u[i]||typeof u=="string")this.children.unshift(u);else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+u);return this},a.prototype.walk=function(u){for(var l,c=0,h=this.children.length;c<h;c++)l=this.children[c],l[i]?l.walk(u):l!==""&&u(l,{source:this.source,line:this.line,column:this.column,name:this.name})},a.prototype.join=function(u){var l,c,h=this.children.length;if(h>0){for(l=[],c=0;c<h-1;c++)l.push(this.children[c]),l.push(u);l.push(this.children[c]),this.children=l}return this},a.prototype.replaceRight=function(u,l){var c=this.children[this.children.length-1];return c[i]?c.replaceRight(u,l):typeof c=="string"?this.children[this.children.length-1]=c.replace(u,l):this.children.push("".replace(u,l)),this},a.prototype.setSourceContent=function(u,l){this.sourceContents[t.toSetString(u)]=l},a.prototype.walkSourceContents=function(u){for(var l=0,c=this.children.length;l<c;l++)this.children[l][i]&&this.children[l].walkSourceContents(u);for(var h=Object.keys(this.sourceContents),l=0,c=h.length;l<c;l++)u(t.fromSetString(h[l]),this.sourceContents[h[l]])},a.prototype.toString=function(){var u="";return this.walk(function(l){u+=l}),u},a.prototype.toStringWithSourceMap=function(u){var l={code:"",line:1,column:0},c=new r(u),h=!1,d=null,p=null,f=null,m=null;return this.walk(function(g,y){l.code+=g,y.source!==null&&y.line!==null&&y.column!==null?((d!==y.source||p!==y.line||f!==y.column||m!==y.name)&&c.addMapping({source:y.source,original:{line:y.line,column:y.column},generated:{line:l.line,column:l.column},name:y.name}),d=y.source,p=y.line,f=y.column,m=y.name,h=!0):h&&(c.addMapping({generated:{line:l.line,column:l.column}}),d=null,h=!1);for(var b=0,x=g.length;b<x;b++)g.charCodeAt(b)===s?(l.line++,l.column=0,b+1===x?(d=null,h=!1):h&&c.addMapping({source:y.source,original:{line:y.line,column:y.column},generated:{line:l.line,column:l.column},name:y.name})):l.column++}),this.walkSourceContents(function(g,y){c.setSourceContent(g,y)}),{code:l.code,map:c}},BE.SourceNode=a,BE}var S4;function ohe(){return S4||(S4=1,cy.SourceMapGenerator=z8().SourceMapGenerator,cy.SourceMapConsumer=ihe().SourceMapConsumer,cy.SourceNode=ahe().SourceNode),cy}const uhe="2.1.0",lhe={version:uhe};var C4;function che(){return C4||(C4=1,function(r){(function(){var t,n,s,i,a,o,u,l,c,h,d,p,f,m,g,y,b,x,w,v,S,E,C,I,_,A;a=Zce(),o=ehe(),t=a.Syntax;function k($){return ve.Expression.hasOwnProperty($.type)}function N($){return ve.Statement.hasOwnProperty($.type)}n={Sequence:0,Yield:1,Assignment:1,Conditional:2,ArrowFunction:2,Coalesce:3,LogicalOR:4,LogicalAND:5,BitwiseOR:6,BitwiseXOR:7,BitwiseAND:8,Equality:9,Relational:10,BitwiseSHIFT:11,Additive:12,Multiplicative:13,Exponentiation:14,Await:15,Unary:15,Postfix:16,OptionalChaining:17,Call:18,New:19,TaggedTemplate:20,Member:21,Primary:22},s={"??":n.Coalesce,"||":n.LogicalOR,"&&":n.LogicalAND,"|":n.BitwiseOR,"^":n.BitwiseXOR,"&":n.BitwiseAND,"==":n.Equality,"!=":n.Equality,"===":n.Equality,"!==":n.Equality,is:n.Equality,isnt:n.Equality,"<":n.Relational,">":n.Relational,"<=":n.Relational,">=":n.Relational,in:n.Relational,instanceof:n.Relational,"<<":n.BitwiseSHIFT,">>":n.BitwiseSHIFT,">>>":n.BitwiseSHIFT,"+":n.Additive,"-":n.Additive,"*":n.Multiplicative,"%":n.Multiplicative,"/":n.Multiplicative,"**":n.Exponentiation};var D=1,F=2,P=4,G=8,Y=16,Z=32,ee=64,se=F|P,re=D|F,J=D|F|P,le=D,he=P,xe=D|P,Fe=D,Le=D|Z,Ve=0,$e=D|Y,Ae=D|G;function Te(){return{indent:null,base:null,parse:null,comment:!1,format:{indent:{style:"    ",base:0,adjustMultilineComment:!1},newline:`
`,space:" ",json:!1,renumber:!1,hexadecimal:!1,quotes:"single",escapeless:!1,compact:!1,parentheses:!0,semicolons:!0,safeConcatenation:!1,preserveBlankLines:!1},moz:{comprehensionExpressionStartsWithAssignment:!1,starlessGenerator:!1},sourceMap:null,sourceMapRoot:null,sourceMapWithCode:!1,directive:!1,raw:!0,verbatim:null,sourceCode:null}}function Ue($,B){var z="";for(B|=0;B>0;B>>>=1,$+=$)B&1&&(z+=$);return z}function qe($){return/[\r\n]/g.test($)}function Me($){var B=$.length;return B&&o.code.isLineTerminator($.charCodeAt(B-1))}function ie($,B){var z;for(z in B)B.hasOwnProperty(z)&&($[z]=B[z]);return $}function K($,B){var z,W;function X(ze){return typeof ze=="object"&&ze instanceof Object&&!(ze instanceof RegExp)}for(z in B)B.hasOwnProperty(z)&&(W=B[z],X(W)?X($[z])?K($[z],W):$[z]=K({},W):$[z]=W);return $}function pe($){var B,z,W,X,ze;if($!==$)throw new Error("Numeric literal whose value is NaN");if($<0||$===0&&1/$<0)throw new Error("Numeric literal whose value is negative");if($===1/0)return c?"null":h?"1e400":"1e+400";if(B=""+$,!h||B.length<3)return B;for(z=B.indexOf("."),!c&&B.charCodeAt(0)===48&&z===1&&(z=0,B=B.slice(1)),W=B,B=B.replace("e+","e"),X=0,(ze=W.indexOf("e"))>0&&(X=+W.slice(ze+1),W=W.slice(0,ze)),z>=0&&(X-=W.length-z-1,W=+(W.slice(0,z)+W.slice(z+1))+""),ze=0;W.charCodeAt(W.length+ze-1)===48;)--ze;return ze!==0&&(X-=ze,W=W.slice(0,ze)),X!==0&&(W+="e"+X),(W.length<B.length||d&&$>1e12&&Math.floor($)===$&&(W="0x"+$.toString(16)).length<B.length)&&+W===$&&(B=W),B}function _e($,B){return($&-2)===8232?(B?"u":"\\u")+($===8232?"2028":"2029"):$===10||$===13?(B?"":"\\")+($===10?"n":"r"):String.fromCharCode($)}function We($){var B,z,W,X,ze,Ge,Ye,Je;if(z=$.toString(),$.source){if(B=z.match(/\/([^/]*)$/),!B)return z;for(W=B[1],z="",Ye=!1,Je=!1,X=0,ze=$.source.length;X<ze;++X)Ge=$.source.charCodeAt(X),Je?(z+=_e(Ge,Je),Je=!1):(Ye?Ge===93&&(Ye=!1):Ge===47?z+="\\":Ge===91&&(Ye=!0),z+=_e(Ge,Je),Je=Ge===92);return"/"+z+"/"+W}return z}function Oe($,B){var z;return $===8?"\\b":$===12?"\\f":$===9?"\\t":(z=$.toString(16).toUpperCase(),c||$>255?"\\u"+"0000".slice(z.length)+z:$===0&&!o.code.isDecimalDigit(B)?"\\0":$===11?"\\x0B":"\\x"+"00".slice(z.length)+z)}function nt($){if($===92)return"\\\\";if($===10)return"\\n";if($===13)return"\\r";if($===8232)return"\\u2028";if($===8233)return"\\u2029";throw new Error("Incorrectly classified character")}function rt($){var B,z,W,X;for(X=p==="double"?'"':"'",B=0,z=$.length;B<z;++B)if(W=$.charCodeAt(B),W===39){X='"';break}else if(W===34){X="'";break}else W===92&&++B;return X+$+X}function pt($){var B="",z,W,X,ze=0,Ge=0,Ye,Je;for(z=0,W=$.length;z<W;++z){if(X=$.charCodeAt(z),X===39)++ze;else if(X===34)++Ge;else if(X===47&&c)B+="\\";else if(o.code.isLineTerminator(X)||X===92){B+=nt(X);continue}else if(!o.code.isIdentifierPartES5(X)&&(c&&X<32||!c&&!f&&(X<32||X>126))){B+=Oe(X,$.charCodeAt(z+1));continue}B+=String.fromCharCode(X)}if(Ye=!(p==="double"||p==="auto"&&Ge<ze),Je=Ye?"'":'"',!(Ye?ze:Ge))return Je+B+Je;for($=B,B=Je,z=0,W=$.length;z<W;++z)X=$.charCodeAt(z),(X===39&&Ye||X===34&&!Ye)&&(B+="\\"),B+=String.fromCharCode(X);return B+Je}function Et($){var B,z,W,X="";for(B=0,z=$.length;B<z;++B)W=$[B],X+=Array.isArray(W)?Et(W):W;return X}function ht($,B){if(!E)return Array.isArray($)?Et($):$;if(B==null){if($ instanceof i)return $;B={}}return B.loc==null?new i(null,null,E,$,B.name||null):new i(B.loc.start.line,B.loc.start.column,E===!0?B.loc.source||null:E,$,B.name||null)}function Mt(){return g||" "}function it($,B){var z,W,X,ze;return z=ht($).toString(),z.length===0?[B]:(W=ht(B).toString(),W.length===0?[$]:(X=z.charCodeAt(z.length-1),ze=W.charCodeAt(0),(X===43||X===45)&&X===ze||o.code.isIdentifierPartES5(X)&&o.code.isIdentifierPartES5(ze)||X===47&&ze===105?[$,Mt(),B]:o.code.isWhiteSpace(X)||o.code.isLineTerminator(X)||o.code.isWhiteSpace(ze)||o.code.isLineTerminator(ze)?[$,B]:[$,g,B]))}function kt($){return[u,$]}function Lt($){var B;B=u,u+=l,$(u),u=B}function wn($){var B;for(B=$.length-1;B>=0&&!o.code.isLineTerminator($.charCodeAt(B));--B);return $.length-1-B}function Gr($,B){var z,W,X,ze,Ge,Ye,Je,At;for(z=$.split(/\r\n|[\r\n]/),Ye=Number.MAX_VALUE,W=1,X=z.length;W<X;++W){for(ze=z[W],Ge=0;Ge<ze.length&&o.code.isWhiteSpace(ze.charCodeAt(Ge));)++Ge;Ye>Ge&&(Ye=Ge)}for(typeof B<"u"?(Je=u,z[1][Ye]==="*"&&(B+=" "),u=B):(Ye&1&&--Ye,Je=u),W=1,X=z.length;W<X;++W)At=ht(kt(z[W].slice(Ye))),z[W]=E?At.join(""):At;return u=Je,z.join(`
`)}function lr($,B){if($.type==="Line"){if(Me($.value))return"//"+$.value;var z="//"+$.value;return I||(z+=`
`),z}return v.format.indent.adjustMultilineComment&&/[\n\r]/.test($.value)?Gr("/*"+$.value+"*/",B):"/*"+$.value+"*/"}function Pr($,B){var z,W,X,ze,Ge,Ye,Je,At,Er,br,Vn,Ia,Tu,Ur;if($.leadingComments&&$.leadingComments.length>0){if(ze=B,I){for(X=$.leadingComments[0],B=[],At=X.extendedRange,Er=X.range,Vn=C.substring(At[0],Er[0]),Ur=(Vn.match(/\n/g)||[]).length,Ur>0?(B.push(Ue(`
`,Ur)),B.push(kt(lr(X)))):(B.push(Vn),B.push(lr(X))),br=Er,z=1,W=$.leadingComments.length;z<W;z++)X=$.leadingComments[z],Er=X.range,Ia=C.substring(br[1],Er[0]),Ur=(Ia.match(/\n/g)||[]).length,B.push(Ue(`
`,Ur)),B.push(kt(lr(X))),br=Er;Tu=C.substring(Er[1],At[1]),Ur=(Tu.match(/\n/g)||[]).length,B.push(Ue(`
`,Ur))}else for(X=$.leadingComments[0],B=[],x&&$.type===t.Program&&$.body.length===0&&B.push(`
`),B.push(lr(X)),Me(ht(B).toString())||B.push(`
`),z=1,W=$.leadingComments.length;z<W;++z)X=$.leadingComments[z],Je=[lr(X)],Me(ht(Je).toString())||Je.push(`
`),B.push(kt(Je));B.push(kt(ze))}if($.trailingComments)if(I)X=$.trailingComments[0],At=X.extendedRange,Er=X.range,Vn=C.substring(At[0],Er[0]),Ur=(Vn.match(/\n/g)||[]).length,Ur>0?(B.push(Ue(`
`,Ur)),B.push(kt(lr(X)))):(B.push(Vn),B.push(lr(X)));else for(Ge=!Me(ht(B).toString()),Ye=Ue(" ",wn(ht([u,B,l]).toString())),z=0,W=$.trailingComments.length;z<W;++z)X=$.trailingComments[z],Ge?(z===0?B=[B,l]:B=[B,Ye],B.push(lr(X,Ye))):B=[B,kt(lr(X))],z!==W-1&&!Me(ht(B).toString())&&(B=[B,`
`]);return B}function V($,B,z){var W,X=0;for(W=$;W<B;W++)C[W]===`
`&&X++;for(W=1;W<X;W++)z.push(m)}function H($,B,z){return B<z?["(",$,")"]:$}function ae($){var B,z,W;for(W=$.split(/\r\n|\n/),B=1,z=W.length;B<z;B++)W[B]=m+u+W[B];return W}function ce($,B){var z,W,X;return z=$[v.verbatim],typeof z=="string"?W=H(ae(z),n.Sequence,B):(W=ae(z.content),X=z.precedence!=null?z.precedence:n.Sequence,W=H(W,X,B)),ht(W,$)}function ve(){}ve.prototype.maybeBlock=function($,B){var z,W,X=this;return W=!v.comment||!$.leadingComments,$.type===t.BlockStatement&&W?[g,this.generateStatement($,B)]:$.type===t.EmptyStatement&&W?";":(Lt(function(){z=[m,kt(X.generateStatement($,B))]}),z)},ve.prototype.maybeBlockSuffix=function($,B){var z=Me(ht(B).toString());return $.type===t.BlockStatement&&(!v.comment||!$.leadingComments)&&!z?[B,g]:z?[B,u]:[B,m,u]};function He($){return ht($.name,$)}function Ze($,B){return $.async?"async"+(B?Mt():g):""}function dt($){var B=$.generator&&!v.moz.starlessGenerator;return B?"*"+g:""}function Bt($){var B=$.value,z="";return B.async&&(z+=Ze(B,!$.computed)),B.generator&&(z+=dt(B)?"*":""),z}ve.prototype.generatePattern=function($,B,z){return $.type===t.Identifier?He($):this.generateExpression($,B,z)},ve.prototype.generateFunctionParams=function($){var B,z,W,X;if(X=!1,$.type===t.ArrowFunctionExpression&&!$.rest&&(!$.defaults||$.defaults.length===0)&&$.params.length===1&&$.params[0].type===t.Identifier)W=[Ze($,!0),He($.params[0])];else{for(W=$.type===t.ArrowFunctionExpression?[Ze($,!1)]:[],W.push("("),$.defaults&&(X=!0),B=0,z=$.params.length;B<z;++B)X&&$.defaults[B]?W.push(this.generateAssignment($.params[B],$.defaults[B],"=",n.Assignment,J)):W.push(this.generatePattern($.params[B],n.Assignment,J)),B+1<z&&W.push(","+g);$.rest&&($.params.length&&W.push(","+g),W.push("..."),W.push(He($.rest))),W.push(")")}return W},ve.prototype.generateFunctionBody=function($){var B,z;return B=this.generateFunctionParams($),$.type===t.ArrowFunctionExpression&&(B.push(g),B.push("=>")),$.expression?(B.push(g),z=this.generateExpression($.body,n.Assignment,J),z.toString().charAt(0)==="{"&&(z=["(",z,")"]),B.push(z)):B.push(this.maybeBlock($.body,Ae)),B},ve.prototype.generateIterationForStatement=function($,B,z){var W=["for"+(B.await?Mt()+"await":"")+g+"("],X=this;return Lt(function(){B.left.type===t.VariableDeclaration?Lt(function(){W.push(B.left.kind+Mt()),W.push(X.generateStatement(B.left.declarations[0],Ve))}):W.push(X.generateExpression(B.left,n.Call,J)),W=it(W,$),W=[it(W,X.generateExpression(B.right,n.Assignment,J)),")"]}),W.push(this.maybeBlock(B.body,z)),W},ve.prototype.generatePropertyKey=function($,B){var z=[];return B&&z.push("["),z.push(this.generateExpression($,n.Assignment,J)),B&&z.push("]"),z},ve.prototype.generateAssignment=function($,B,z,W,X){return n.Assignment<W&&(X|=D),H([this.generateExpression($,n.Call,X),g+z+g,this.generateExpression(B,n.Assignment,X)],n.Assignment,W)},ve.prototype.semicolon=function($){return!b&&$&Z?"":";"},ve.Statement={BlockStatement:function($,B){var z,W,X=["{",m],ze=this;return Lt(function(){$.body.length===0&&I&&(z=$.range,z[1]-z[0]>2&&(W=C.substring(z[0]+1,z[1]-1),W[0]===`
`&&(X=["{"]),X.push(W)));var Ge,Ye,Je,At;for(At=Fe,B&G&&(At|=Y),Ge=0,Ye=$.body.length;Ge<Ye;++Ge)I&&(Ge===0&&($.body[0].leadingComments&&(z=$.body[0].leadingComments[0].extendedRange,W=C.substring(z[0],z[1]),W[0]===`
`&&(X=["{"])),$.body[0].leadingComments||V($.range[0],$.body[0].range[0],X)),Ge>0&&!$.body[Ge-1].trailingComments&&!$.body[Ge].leadingComments&&V($.body[Ge-1].range[1],$.body[Ge].range[0],X)),Ge===Ye-1&&(At|=Z),$.body[Ge].leadingComments&&I?Je=ze.generateStatement($.body[Ge],At):Je=kt(ze.generateStatement($.body[Ge],At)),X.push(Je),Me(ht(Je).toString())||I&&Ge<Ye-1&&$.body[Ge+1].leadingComments||X.push(m),I&&Ge===Ye-1&&($.body[Ge].trailingComments||V($.body[Ge].range[1],$.range[1],X))}),X.push(kt("}")),X},BreakStatement:function($,B){return $.label?"break "+$.label.name+this.semicolon(B):"break"+this.semicolon(B)},ContinueStatement:function($,B){return $.label?"continue "+$.label.name+this.semicolon(B):"continue"+this.semicolon(B)},ClassBody:function($,B){var z=["{",m],W=this;return Lt(function(X){var ze,Ge;for(ze=0,Ge=$.body.length;ze<Ge;++ze)z.push(X),z.push(W.generateExpression($.body[ze],n.Sequence,J)),ze+1<Ge&&z.push(m)}),Me(ht(z).toString())||z.push(m),z.push(u),z.push("}"),z},ClassDeclaration:function($,B){var z,W;return z=["class"],$.id&&(z=it(z,this.generateExpression($.id,n.Sequence,J))),$.superClass&&(W=it("extends",this.generateExpression($.superClass,n.Unary,J)),z=it(z,W)),z.push(g),z.push(this.generateStatement($.body,Le)),z},DirectiveStatement:function($,B){return v.raw&&$.raw?$.raw+this.semicolon(B):rt($.directive)+this.semicolon(B)},DoWhileStatement:function($,B){var z=it("do",this.maybeBlock($.body,Fe));return z=this.maybeBlockSuffix($.body,z),it(z,["while"+g+"(",this.generateExpression($.test,n.Sequence,J),")"+this.semicolon(B)])},CatchClause:function($,B){var z,W=this;return Lt(function(){var X;$.param?(z=["catch"+g+"(",W.generateExpression($.param,n.Sequence,J),")"],$.guard&&(X=W.generateExpression($.guard,n.Sequence,J),z.splice(2,0," if ",X))):z=["catch"]}),z.push(this.maybeBlock($.body,Fe)),z},DebuggerStatement:function($,B){return"debugger"+this.semicolon(B)},EmptyStatement:function($,B){return";"},ExportDefaultDeclaration:function($,B){var z=["export"],W;return W=B&Z?Le:Fe,z=it(z,"default"),N($.declaration)?z=it(z,this.generateStatement($.declaration,W)):z=it(z,this.generateExpression($.declaration,n.Assignment,J)+this.semicolon(B)),z},ExportNamedDeclaration:function($,B){var z=["export"],W,X=this;return W=B&Z?Le:Fe,$.declaration?it(z,this.generateStatement($.declaration,W)):($.specifiers&&($.specifiers.length===0?z=it(z,"{"+g+"}"):$.specifiers[0].type===t.ExportBatchSpecifier?z=it(z,this.generateExpression($.specifiers[0],n.Sequence,J)):(z=it(z,"{"),Lt(function(ze){var Ge,Ye;for(z.push(m),Ge=0,Ye=$.specifiers.length;Ge<Ye;++Ge)z.push(ze),z.push(X.generateExpression($.specifiers[Ge],n.Sequence,J)),Ge+1<Ye&&z.push(","+m)}),Me(ht(z).toString())||z.push(m),z.push(u+"}")),$.source?z=it(z,["from"+g,this.generateExpression($.source,n.Sequence,J),this.semicolon(B)]):z.push(this.semicolon(B))),z)},ExportAllDeclaration:function($,B){return["export"+g,"*"+g,"from"+g,this.generateExpression($.source,n.Sequence,J),this.semicolon(B)]},ExpressionStatement:function($,B){var z,W;function X(Ye){var Je;return Ye.slice(0,5)!=="class"?!1:(Je=Ye.charCodeAt(5),Je===123||o.code.isWhiteSpace(Je)||o.code.isLineTerminator(Je))}function ze(Ye){var Je;return Ye.slice(0,8)!=="function"?!1:(Je=Ye.charCodeAt(8),Je===40||o.code.isWhiteSpace(Je)||Je===42||o.code.isLineTerminator(Je))}function Ge(Ye){var Je,At,Er;if(Ye.slice(0,5)!=="async"||!o.code.isWhiteSpace(Ye.charCodeAt(5)))return!1;for(At=6,Er=Ye.length;At<Er&&o.code.isWhiteSpace(Ye.charCodeAt(At));++At);return At===Er||Ye.slice(At,At+8)!=="function"?!1:(Je=Ye.charCodeAt(At+8),Je===40||o.code.isWhiteSpace(Je)||Je===42||o.code.isLineTerminator(Je))}return z=[this.generateExpression($.expression,n.Sequence,J)],W=ht(z).toString(),W.charCodeAt(0)===123||X(W)||ze(W)||Ge(W)||w&&B&Y&&$.expression.type===t.Literal&&typeof $.expression.value=="string"?z=["(",z,")"+this.semicolon(B)]:z.push(this.semicolon(B)),z},ImportDeclaration:function($,B){var z,W,X=this;return $.specifiers.length===0?["import",g,this.generateExpression($.source,n.Sequence,J),this.semicolon(B)]:(z=["import"],W=0,$.specifiers[W].type===t.ImportDefaultSpecifier&&(z=it(z,[this.generateExpression($.specifiers[W],n.Sequence,J)]),++W),$.specifiers[W]&&(W!==0&&z.push(","),$.specifiers[W].type===t.ImportNamespaceSpecifier?z=it(z,[g,this.generateExpression($.specifiers[W],n.Sequence,J)]):(z.push(g+"{"),$.specifiers.length-W===1?(z.push(g),z.push(this.generateExpression($.specifiers[W],n.Sequence,J)),z.push(g+"}"+g)):(Lt(function(ze){var Ge,Ye;for(z.push(m),Ge=W,Ye=$.specifiers.length;Ge<Ye;++Ge)z.push(ze),z.push(X.generateExpression($.specifiers[Ge],n.Sequence,J)),Ge+1<Ye&&z.push(","+m)}),Me(ht(z).toString())||z.push(m),z.push(u+"}"+g)))),z=it(z,["from"+g,this.generateExpression($.source,n.Sequence,J),this.semicolon(B)]),z)},VariableDeclarator:function($,B){var z=B&D?J:se;return $.init?[this.generateExpression($.id,n.Assignment,z),g,"=",g,this.generateExpression($.init,n.Assignment,z)]:this.generatePattern($.id,n.Assignment,z)},VariableDeclaration:function($,B){var z,W,X,ze,Ge,Ye=this;z=[$.kind],Ge=B&D?Fe:Ve;function Je(){for(ze=$.declarations[0],v.comment&&ze.leadingComments?(z.push(`
`),z.push(kt(Ye.generateStatement(ze,Ge)))):(z.push(Mt()),z.push(Ye.generateStatement(ze,Ge))),W=1,X=$.declarations.length;W<X;++W)ze=$.declarations[W],v.comment&&ze.leadingComments?(z.push(","+m),z.push(kt(Ye.generateStatement(ze,Ge)))):(z.push(","+g),z.push(Ye.generateStatement(ze,Ge)))}return $.declarations.length>1?Lt(Je):Je(),z.push(this.semicolon(B)),z},ThrowStatement:function($,B){return[it("throw",this.generateExpression($.argument,n.Sequence,J)),this.semicolon(B)]},TryStatement:function($,B){var z,W,X,ze;if(z=["try",this.maybeBlock($.block,Fe)],z=this.maybeBlockSuffix($.block,z),$.handlers)for(W=0,X=$.handlers.length;W<X;++W)z=it(z,this.generateStatement($.handlers[W],Fe)),($.finalizer||W+1!==X)&&(z=this.maybeBlockSuffix($.handlers[W].body,z));else{for(ze=$.guardedHandlers||[],W=0,X=ze.length;W<X;++W)z=it(z,this.generateStatement(ze[W],Fe)),($.finalizer||W+1!==X)&&(z=this.maybeBlockSuffix(ze[W].body,z));if($.handler)if(Array.isArray($.handler))for(W=0,X=$.handler.length;W<X;++W)z=it(z,this.generateStatement($.handler[W],Fe)),($.finalizer||W+1!==X)&&(z=this.maybeBlockSuffix($.handler[W].body,z));else z=it(z,this.generateStatement($.handler,Fe)),$.finalizer&&(z=this.maybeBlockSuffix($.handler.body,z))}return $.finalizer&&(z=it(z,["finally",this.maybeBlock($.finalizer,Fe)])),z},SwitchStatement:function($,B){var z,W,X,ze,Ge,Ye=this;if(Lt(function(){z=["switch"+g+"(",Ye.generateExpression($.discriminant,n.Sequence,J),")"+g+"{"+m]}),$.cases)for(Ge=Fe,X=0,ze=$.cases.length;X<ze;++X)X===ze-1&&(Ge|=Z),W=kt(this.generateStatement($.cases[X],Ge)),z.push(W),Me(ht(W).toString())||z.push(m);return z.push(kt("}")),z},SwitchCase:function($,B){var z,W,X,ze,Ge,Ye=this;return Lt(function(){for($.test?z=[it("case",Ye.generateExpression($.test,n.Sequence,J)),":"]:z=["default:"],X=0,ze=$.consequent.length,ze&&$.consequent[0].type===t.BlockStatement&&(W=Ye.maybeBlock($.consequent[0],Fe),z.push(W),X=1),X!==ze&&!Me(ht(z).toString())&&z.push(m),Ge=Fe;X<ze;++X)X===ze-1&&B&Z&&(Ge|=Z),W=kt(Ye.generateStatement($.consequent[X],Ge)),z.push(W),X+1!==ze&&!Me(ht(W).toString())&&z.push(m)}),z},IfStatement:function($,B){var z,W,X,ze=this;return Lt(function(){z=["if"+g+"(",ze.generateExpression($.test,n.Sequence,J),")"]}),X=B&Z,W=Fe,X&&(W|=Z),$.alternate?(z.push(this.maybeBlock($.consequent,Fe)),z=this.maybeBlockSuffix($.consequent,z),$.alternate.type===t.IfStatement?z=it(z,["else ",this.generateStatement($.alternate,W)]):z=it(z,it("else",this.maybeBlock($.alternate,W)))):z.push(this.maybeBlock($.consequent,W)),z},ForStatement:function($,B){var z,W=this;return Lt(function(){z=["for"+g+"("],$.init?$.init.type===t.VariableDeclaration?z.push(W.generateStatement($.init,Ve)):(z.push(W.generateExpression($.init,n.Sequence,se)),z.push(";")):z.push(";"),$.test&&(z.push(g),z.push(W.generateExpression($.test,n.Sequence,J))),z.push(";"),$.update&&(z.push(g),z.push(W.generateExpression($.update,n.Sequence,J))),z.push(")")}),z.push(this.maybeBlock($.body,B&Z?Le:Fe)),z},ForInStatement:function($,B){return this.generateIterationForStatement("in",$,B&Z?Le:Fe)},ForOfStatement:function($,B){return this.generateIterationForStatement("of",$,B&Z?Le:Fe)},LabeledStatement:function($,B){return[$.label.name+":",this.maybeBlock($.body,B&Z?Le:Fe)]},Program:function($,B){var z,W,X,ze,Ge;for(ze=$.body.length,z=[x&&ze>0?`
`:""],Ge=$e,X=0;X<ze;++X)!x&&X===ze-1&&(Ge|=Z),I&&(X===0&&($.body[0].leadingComments||V($.range[0],$.body[X].range[0],z)),X>0&&!$.body[X-1].trailingComments&&!$.body[X].leadingComments&&V($.body[X-1].range[1],$.body[X].range[0],z)),W=kt(this.generateStatement($.body[X],Ge)),z.push(W),X+1<ze&&!Me(ht(W).toString())&&(I&&$.body[X+1].leadingComments||z.push(m)),I&&X===ze-1&&($.body[X].trailingComments||V($.body[X].range[1],$.range[1],z));return z},FunctionDeclaration:function($,B){return[Ze($,!0),"function",dt($)||Mt(),$.id?He($.id):"",this.generateFunctionBody($)]},ReturnStatement:function($,B){return $.argument?[it("return",this.generateExpression($.argument,n.Sequence,J)),this.semicolon(B)]:["return"+this.semicolon(B)]},WhileStatement:function($,B){var z,W=this;return Lt(function(){z=["while"+g+"(",W.generateExpression($.test,n.Sequence,J),")"]}),z.push(this.maybeBlock($.body,B&Z?Le:Fe)),z},WithStatement:function($,B){var z,W=this;return Lt(function(){z=["with"+g+"(",W.generateExpression($.object,n.Sequence,J),")"]}),z.push(this.maybeBlock($.body,B&Z?Le:Fe)),z}},ie(ve.prototype,ve.Statement),ve.Expression={SequenceExpression:function($,B,z){var W,X,ze;for(n.Sequence<B&&(z|=D),W=[],X=0,ze=$.expressions.length;X<ze;++X)W.push(this.generateExpression($.expressions[X],n.Assignment,z)),X+1<ze&&W.push(","+g);return H(W,n.Sequence,B)},AssignmentExpression:function($,B,z){return this.generateAssignment($.left,$.right,$.operator,B,z)},ArrowFunctionExpression:function($,B,z){return H(this.generateFunctionBody($),n.ArrowFunction,B)},ConditionalExpression:function($,B,z){return n.Conditional<B&&(z|=D),H([this.generateExpression($.test,n.Coalesce,z),g+"?"+g,this.generateExpression($.consequent,n.Assignment,z),g+":"+g,this.generateExpression($.alternate,n.Assignment,z)],n.Conditional,B)},LogicalExpression:function($,B,z){return $.operator==="??"&&(z|=ee),this.BinaryExpression($,B,z)},BinaryExpression:function($,B,z){var W,X,ze,Ge,Ye,Je;return Ge=s[$.operator],X=$.operator==="**"?n.Postfix:Ge,ze=$.operator==="**"?Ge:Ge+1,Ge<B&&(z|=D),Ye=this.generateExpression($.left,X,z),Je=Ye.toString(),Je.charCodeAt(Je.length-1)===47&&o.code.isIdentifierPartES5($.operator.charCodeAt(0))?W=[Ye,Mt(),$.operator]:W=it(Ye,$.operator),Ye=this.generateExpression($.right,ze,z),$.operator==="/"&&Ye.toString().charAt(0)==="/"||$.operator.slice(-1)==="<"&&Ye.toString().slice(0,3)==="!--"?(W.push(Mt()),W.push(Ye)):W=it(W,Ye),$.operator==="in"&&!(z&D)?["(",W,")"]:($.operator==="||"||$.operator==="&&")&&z&ee?["(",W,")"]:H(W,Ge,B)},CallExpression:function($,B,z){var W,X,ze;for(W=[this.generateExpression($.callee,n.Call,re)],$.optional&&W.push("?."),W.push("("),X=0,ze=$.arguments.length;X<ze;++X)W.push(this.generateExpression($.arguments[X],n.Assignment,J)),X+1<ze&&W.push(","+g);return W.push(")"),z&F?H(W,n.Call,B):["(",W,")"]},ChainExpression:function($,B,z){n.OptionalChaining<B&&(z|=F);var W=this.generateExpression($.expression,n.OptionalChaining,z);return H(W,n.OptionalChaining,B)},NewExpression:function($,B,z){var W,X,ze,Ge,Ye;if(X=$.arguments.length,Ye=z&P&&!y&&X===0?xe:le,W=it("new",this.generateExpression($.callee,n.New,Ye)),!(z&P)||y||X>0){for(W.push("("),ze=0,Ge=X;ze<Ge;++ze)W.push(this.generateExpression($.arguments[ze],n.Assignment,J)),ze+1<Ge&&W.push(","+g);W.push(")")}return H(W,n.New,B)},MemberExpression:function($,B,z){var W,X;return W=[this.generateExpression($.object,n.Call,z&F?re:le)],$.computed?($.optional&&W.push("?."),W.push("["),W.push(this.generateExpression($.property,n.Sequence,z&F?J:xe)),W.push("]")):(!$.optional&&$.object.type===t.Literal&&typeof $.object.value=="number"&&(X=ht(W).toString(),X.indexOf(".")<0&&!/[eExX]/.test(X)&&o.code.isDecimalDigit(X.charCodeAt(X.length-1))&&!(X.length>=2&&X.charCodeAt(0)===48)&&W.push(" ")),W.push($.optional?"?.":"."),W.push(He($.property))),H(W,n.Member,B)},MetaProperty:function($,B,z){var W;return W=[],W.push(typeof $.meta=="string"?$.meta:He($.meta)),W.push("."),W.push(typeof $.property=="string"?$.property:He($.property)),H(W,n.Member,B)},UnaryExpression:function($,B,z){var W,X,ze,Ge,Ye;return X=this.generateExpression($.argument,n.Unary,J),g===""?W=it($.operator,X):(W=[$.operator],$.operator.length>2?W=it(W,X):(Ge=ht(W).toString(),Ye=Ge.charCodeAt(Ge.length-1),ze=X.toString().charCodeAt(0),((Ye===43||Ye===45)&&Ye===ze||o.code.isIdentifierPartES5(Ye)&&o.code.isIdentifierPartES5(ze))&&W.push(Mt()),W.push(X))),H(W,n.Unary,B)},YieldExpression:function($,B,z){var W;return $.delegate?W="yield*":W="yield",$.argument&&(W=it(W,this.generateExpression($.argument,n.Yield,J))),H(W,n.Yield,B)},AwaitExpression:function($,B,z){var W=it($.all?"await*":"await",this.generateExpression($.argument,n.Await,J));return H(W,n.Await,B)},UpdateExpression:function($,B,z){return $.prefix?H([$.operator,this.generateExpression($.argument,n.Unary,J)],n.Unary,B):H([this.generateExpression($.argument,n.Postfix,J),$.operator],n.Postfix,B)},FunctionExpression:function($,B,z){var W=[Ze($,!0),"function"];return $.id?(W.push(dt($)||Mt()),W.push(He($.id))):W.push(dt($)||g),W.push(this.generateFunctionBody($)),W},ArrayPattern:function($,B,z){return this.ArrayExpression($,B,z,!0)},ArrayExpression:function($,B,z,W){var X,ze,Ge=this;return $.elements.length?(ze=W?!1:$.elements.length>1,X=["[",ze?m:""],Lt(function(Ye){var Je,At;for(Je=0,At=$.elements.length;Je<At;++Je)$.elements[Je]?(X.push(ze?Ye:""),X.push(Ge.generateExpression($.elements[Je],n.Assignment,J))):(ze&&X.push(Ye),Je+1===At&&X.push(",")),Je+1<At&&X.push(","+(ze?m:g))}),ze&&!Me(ht(X).toString())&&X.push(m),X.push(ze?u:""),X.push("]"),X):"[]"},RestElement:function($,B,z){return"..."+this.generatePattern($.argument)},ClassExpression:function($,B,z){var W,X;return W=["class"],$.id&&(W=it(W,this.generateExpression($.id,n.Sequence,J))),$.superClass&&(X=it("extends",this.generateExpression($.superClass,n.Unary,J)),W=it(W,X)),W.push(g),W.push(this.generateStatement($.body,Le)),W},MethodDefinition:function($,B,z){var W,X;return $.static?W=["static"+g]:W=[],$.kind==="get"||$.kind==="set"?X=[it($.kind,this.generatePropertyKey($.key,$.computed)),this.generateFunctionBody($.value)]:X=[Bt($),this.generatePropertyKey($.key,$.computed),this.generateFunctionBody($.value)],it(W,X)},Property:function($,B,z){return $.kind==="get"||$.kind==="set"?[$.kind,Mt(),this.generatePropertyKey($.key,$.computed),this.generateFunctionBody($.value)]:$.shorthand?$.value.type==="AssignmentPattern"?this.AssignmentPattern($.value,n.Sequence,J):this.generatePropertyKey($.key,$.computed):$.method?[Bt($),this.generatePropertyKey($.key,$.computed),this.generateFunctionBody($.value)]:[this.generatePropertyKey($.key,$.computed),":"+g,this.generateExpression($.value,n.Assignment,J)]},ObjectExpression:function($,B,z){var W,X,ze,Ge=this;return $.properties.length?(W=$.properties.length>1,Lt(function(){ze=Ge.generateExpression($.properties[0],n.Sequence,J)}),!W&&!qe(ht(ze).toString())?["{",g,ze,g,"}"]:(Lt(function(Ye){var Je,At;if(X=["{",m,Ye,ze],W)for(X.push(","+m),Je=1,At=$.properties.length;Je<At;++Je)X.push(Ye),X.push(Ge.generateExpression($.properties[Je],n.Sequence,J)),Je+1<At&&X.push(","+m)}),Me(ht(X).toString())||X.push(m),X.push(u),X.push("}"),X)):"{}"},AssignmentPattern:function($,B,z){return this.generateAssignment($.left,$.right,"=",B,z)},ObjectPattern:function($,B,z){var W,X,ze,Ge,Ye,Je=this;if(!$.properties.length)return"{}";if(Ge=!1,$.properties.length===1)Ye=$.properties[0],Ye.type===t.Property&&Ye.value.type!==t.Identifier&&(Ge=!0);else for(X=0,ze=$.properties.length;X<ze;++X)if(Ye=$.properties[X],Ye.type===t.Property&&!Ye.shorthand){Ge=!0;break}return W=["{",Ge?m:""],Lt(function(At){var Er,br;for(Er=0,br=$.properties.length;Er<br;++Er)W.push(Ge?At:""),W.push(Je.generateExpression($.properties[Er],n.Sequence,J)),Er+1<br&&W.push(","+(Ge?m:g))}),Ge&&!Me(ht(W).toString())&&W.push(m),W.push(Ge?u:""),W.push("}"),W},ThisExpression:function($,B,z){return"this"},Super:function($,B,z){return"super"},Identifier:function($,B,z){return He($)},ImportDefaultSpecifier:function($,B,z){return He($.id||$.local)},ImportNamespaceSpecifier:function($,B,z){var W=["*"],X=$.id||$.local;return X&&W.push(g+"as"+Mt()+He(X)),W},ImportSpecifier:function($,B,z){var W=$.imported,X=[W.name],ze=$.local;return ze&&ze.name!==W.name&&X.push(Mt()+"as"+Mt()+He(ze)),X},ExportSpecifier:function($,B,z){var W=$.local,X=[W.name],ze=$.exported;return ze&&ze.name!==W.name&&X.push(Mt()+"as"+Mt()+He(ze)),X},Literal:function($,B,z){var W;if($.hasOwnProperty("raw")&&S&&v.raw)try{if(W=S($.raw).body[0].expression,W.type===t.Literal&&W.value===$.value)return $.raw}catch{}return $.regex?"/"+$.regex.pattern+"/"+$.regex.flags:typeof $.value=="bigint"?$.value.toString()+"n":$.bigint?$.bigint+"n":$.value===null?"null":typeof $.value=="string"?pt($.value):typeof $.value=="number"?pe($.value):typeof $.value=="boolean"?$.value?"true":"false":We($.value)},GeneratorExpression:function($,B,z){return this.ComprehensionExpression($,B,z)},ComprehensionExpression:function($,B,z){var W,X,ze,Ge,Ye=this;return W=$.type===t.GeneratorExpression?["("]:["["],v.moz.comprehensionExpressionStartsWithAssignment&&(Ge=this.generateExpression($.body,n.Assignment,J),W.push(Ge)),$.blocks&&Lt(function(){for(X=0,ze=$.blocks.length;X<ze;++X)Ge=Ye.generateExpression($.blocks[X],n.Sequence,J),X>0||v.moz.comprehensionExpressionStartsWithAssignment?W=it(W,Ge):W.push(Ge)}),$.filter&&(W=it(W,"if"+g),Ge=this.generateExpression($.filter,n.Sequence,J),W=it(W,["(",Ge,")"])),v.moz.comprehensionExpressionStartsWithAssignment||(Ge=this.generateExpression($.body,n.Assignment,J),W=it(W,Ge)),W.push($.type===t.GeneratorExpression?")":"]"),W},ComprehensionBlock:function($,B,z){var W;return $.left.type===t.VariableDeclaration?W=[$.left.kind,Mt(),this.generateStatement($.left.declarations[0],Ve)]:W=this.generateExpression($.left,n.Call,J),W=it(W,$.of?"of":"in"),W=it(W,this.generateExpression($.right,n.Sequence,J)),["for"+g+"(",W,")"]},SpreadElement:function($,B,z){return["...",this.generateExpression($.argument,n.Assignment,J)]},TaggedTemplateExpression:function($,B,z){var W=re;z&F||(W=le);var X=[this.generateExpression($.tag,n.Call,W),this.generateExpression($.quasi,n.Primary,he)];return H(X,n.TaggedTemplate,B)},TemplateElement:function($,B,z){return $.value.raw},TemplateLiteral:function($,B,z){var W,X,ze;for(W=["`"],X=0,ze=$.quasis.length;X<ze;++X)W.push(this.generateExpression($.quasis[X],n.Primary,J)),X+1<ze&&(W.push("${"+g),W.push(this.generateExpression($.expressions[X],n.Sequence,J)),W.push(g+"}"));return W.push("`"),W},ModuleSpecifier:function($,B,z){return this.Literal($,B,z)},ImportExpression:function($,B,z){return H(["import(",this.generateExpression($.source,n.Assignment,J),")"],n.Call,B)}},ie(ve.prototype,ve.Expression),ve.prototype.generateExpression=function($,B,z){var W,X;return X=$.type||t.Property,v.verbatim&&$.hasOwnProperty(v.verbatim)?ce($,B):(W=this[X]($,B,z),v.comment&&(W=Pr($,W)),ht(W,$))},ve.prototype.generateStatement=function($,B){var z,W;return z=this[$.type]($,B),v.comment&&(z=Pr($,z)),W=ht(z).toString(),$.type===t.Program&&!x&&m===""&&W.charAt(W.length-1)===`
`&&(z=E?ht(z).replaceRight(/\s+$/,""):W.replace(/\s+$/,"")),ht(z,$)};function Ut($){var B;if(B=new ve,N($))return B.generateStatement($,Fe);if(k($))return B.generateExpression($,n.Sequence,J);throw new Error("Unknown node type: "+$.type)}function Tr($,B){var z=Te(),W,X;return B!=null?(typeof B.indent=="string"&&(z.format.indent.style=B.indent),typeof B.base=="number"&&(z.format.indent.base=B.base),B=K(z,B),l=B.format.indent.style,typeof B.base=="string"?u=B.base:u=Ue(l,B.format.indent.base)):(B=z,l=B.format.indent.style,u=Ue(l,B.format.indent.base)),c=B.format.json,h=B.format.renumber,d=c?!1:B.format.hexadecimal,p=c?"double":B.format.quotes,f=B.format.escapeless,m=B.format.newline,g=B.format.space,B.format.compact&&(m=g=l=u=""),y=B.format.parentheses,b=B.format.semicolons,x=B.format.safeConcatenation,w=B.directive,S=c?null:B.parse,E=B.sourceMap,C=B.sourceCode,I=B.format.preserveBlankLines&&C!==null,v=B,E&&(r.browser?i=jI.sourceMap.SourceNode:i=ohe().SourceNode),W=Ut($),E?(X=W.toStringWithSourceMap({file:B.file,sourceRoot:B.sourceMapRoot}),B.sourceContent&&X.map.setSourceContent(B.sourceMap,B.sourceContent),B.sourceMapWithCode?X:X.map.toString()):(X={code:W.toString(),map:null},B.sourceMapWithCode?X:X.code)}_={indent:{style:"",base:0},renumber:!0,hexadecimal:!0,quotes:"auto",escapeless:!0,compact:!0,parentheses:!1,semicolons:!1},A=Te().format,r.version=lhe.version,r.generate=Tr,r.attachComments=a.attachComments,r.Precedence=K({},n),r.browser=!1,r.FORMAT_MINIFY=_,r.FORMAT_DEFAULTS=A})()}(NE)),NE}var hhe=che();const dhe=AT(hhe);function U8(r,t){let n,s;const i=r.Shader.prototype.modify;r.Shader.prototype.modify=function(ie,K={parser:!0,srcLocations:!1}){if(ie instanceof Function){let pe;if(K.parser){const Oe=ie.toString(),nt=YW(Oe,{ecmaVersion:2021,locations:K.srcLocations});cle(nt,u,void 0,{varyings:{}});const rt=dhe.generate(nt);pe=new Function(rt.slice(rt.indexOf("{")+1,rt.lastIndexOf("}")).replaceAll(";",""))}else pe=ie;const We=new le(pe,this,K.srcLocations).generate();return i.call(this,We)}else return i.call(this,ie)};function a(ie){switch(ie){case"+":return"add";case"-":return"sub";case"*":return"mult";case"/":return"div";case"%":return"mod";case"==":case"===":return"equalTo";case">":return"greaterThan";case">=":return"greaterThanEqualTo";case"<":return"lessThan";case"&&":return"and";case"||":return"or"}}function o(ie){var K,pe;return ie.type==="CallExpression"&&((K=ie.callee)==null?void 0:K.type)==="Identifier"&&((pe=ie.callee)==null?void 0:pe.name.startsWith("uniform"))}const u={UnaryExpression(ie,K,pe){if(pe.some(o))return;const _e={type:"Literal",value:ie.operator},We=Oe=>{Oe.type="CallExpression",Oe.callee={type:"Identifier",name:"unaryNode"},Oe.arguments=[Oe.argument,_e]};if(ie.type==="MemberExpression"){const Oe=ie.argument.property.name;[["x","y","z","w"],["r","g","b","a"],["s","t","p","q"]].some(pt=>[...Oe].every(Et=>pt.includes(Et)))&&ie.argument.type==="MemberExpression"?(ie.type="MemberExpression",ie.object={type:"CallExpression",callee:{type:"Identifier",name:"unaryNode"},arguments:[ie.argument.object,_e]},ie.property={type:"Identifier",name:Oe}):We(ie)}else We(ie);delete ie.argument,delete ie.operator},VariableDeclarator(ie,K,pe){var _e,We;if(ie.init.callee&&((_e=ie.init.callee.name)!=null&&_e.startsWith("uniform"))){const Oe={type:"Literal",value:ie.id.name};ie.init.arguments.unshift(Oe)}if(ie.init.callee&&((We=ie.init.callee.name)!=null&&We.startsWith("varying"))){const Oe={type:"Literal",value:ie.id.name};ie.init.arguments.unshift(Oe),K.varyings[ie.id.name]=Oe}},Identifier(ie,K,pe){K.varyings[ie.name]&&!pe.some(_e=>_e.type==="AssignmentExpression"&&_e.left===ie)&&(ie.type="ExpressionStatement",ie.expression={type:"CallExpression",callee:{type:"MemberExpression",object:{type:"Identifier",name:ie.name},property:{type:"Identifier",name:"getValue"}},arguments:[]})},ArrayExpression(ie,K,pe){const _e=JSON.parse(JSON.stringify(ie));ie.type="CallExpression",ie.callee={type:"Identifier",name:"dynamicNode"},ie.arguments=[_e]},AssignmentExpression(ie,K,pe){if(ie.operator!=="="){const _e=a(ie.operator.replace("=","")),We={type:"CallExpression",callee:{type:"MemberExpression",object:ie.left,property:{type:"Identifier",name:_e}},arguments:[ie.right]};ie.operator="=",ie.right=We}K.varyings[ie.left.name]&&(ie.type="ExpressionStatement",ie.expression={type:"CallExpression",callee:{type:"MemberExpression",object:{type:"Identifier",name:ie.left.name},property:{type:"Identifier",name:"bridge"}},arguments:[ie.right]})},BinaryExpression(ie,K,pe){if(pe.some(o))return;if(["Literal","ArrayExpression","Identifier"].includes(ie.left.type)){const We={type:"CallExpression",callee:{type:"Identifier",name:"dynamicNode"},arguments:[ie.left]};ie.left=We}ie.type="CallExpression",ie.callee={type:"MemberExpression",object:ie.left,property:{type:"Identifier",name:a(ie.operator)}},ie.arguments=[ie.right]}};class l{constructor(K,pe){if(new.target===l)throw new TypeError("Cannot construct BaseNode instances directly. This is an abstract class.");if(this.type=pe,this.componentNames=[],this.componentsChanged=!1,this.isInternal=K,this.usedIn=[],this.dependsOn=[],this.srcLine=null,this.usedInConditional=!1,n.srcLocations===!0&&K===!1)try{throw new Error("StackCapture")}catch(_e){const We=_e.stack.split(`
`);let Oe=5;F(this)&&Oe--,this.srcLine=We[Oe].trim()}}addVectorComponents(){if(this.type.startsWith("vec")){const K=parseInt(this.type.slice(3));this.componentNames=["x","y","z","w"].slice(0,K);const pe=this;for(let _e of this.componentNames){let We=new m(pe,_e,"float",!0);Object.defineProperty(this,_e,{get(){return We},set(Oe){this.componentsChanged=!0,re(this)?this.node.value=Oe:We=Oe}})}}}forceTemporaryVariable(){(!(N(this)&&se(this.parent))||!P(this))&&(this.useTemp=!0)}assertUsedInConditional(K){this.usedInConditional=!0,this.usedIn.push(K),this.forceTemporaryVariable()}isUsedInConditional(){return this.usedInConditional}checkConditionalDependencies(K){K.ifs.forEach(pe=>{const _e=()=>pe.usedInSatisfied.length>=1,We=()=>pe.dependsOn.length===pe.dependsOnSatisfied.length;pe.insertionPoint>-1||!pe.usedIn.length||(pe.dependsOn.some(Oe=>Oe.node===this)&&!pe.dependsOnSatisfied.includes(this)&&pe.dependsOnSatisfied.push(this),pe.usedIn.includes(this)&&!pe.usedInSatisfied.includes(this)&&pe.usedInSatisfied.push(this),We()&&_e()&&pe.saveState(K,We(),_e()))})}toGLSLBase(K){let pe;if(this.shouldUseTemporaryVariable()){let _e=K.declarations.length;pe=this.getTemporaryVariable(K);let We=K.declarations.length-1-_e;We=We>0?We:void 0,this.dependsOn.forEach(Oe=>{if(Oe.isVector){const nt=Oe.originalComponents.map((rt,pt)=>rt===Oe.currentComponents[pt]);K.updateComponents(Oe.node,We,nt)}else K.updateComponents(Oe.node,We)})}else pe=this.toGLSL(K);return this.checkConditionalDependencies(K),pe}shouldUseTemporaryVariable(){if(this.componentsChanged||Y(this)||this.useTemp)return!0;if(this.isInternal||P(this)||G(this)||this.type==="sampler2D")return!1;let K=0;return K+=ee(this)*2,K+=F(this)*2,K+=D(this)*3,K+=this.usedIn.length,K>=4}getTemporaryVariable(K){if(!this.temporaryVariable){this.temporaryVariable=`temp_${K.getNextID()}`;let pe="";this.srcLine&&(pe+=`
// From ${this.srcLine}
`),pe+="  "+this.type+" "+this.temporaryVariable+" = "+this.toGLSL(K)+";",K.declarations.push(pe)}return this.temporaryVariable}add(K){return Ae(this,this.enforceType(K),"+")}sub(K){return Ae(this,this.enforceType(K),"-")}mult(K){return Ae(this,this.enforceType(K),"*")}div(K){return Ae(this,this.enforceType(K),"/")}mod(K){return Ae(this,this.enforceType(K),"%")}enforceType(K){if(_(K)){if(!J(K.type))throw new TypeError(`You've tried to perform an operation on a struct of type: ${K.type}. Try accessing a member on that struct with '.'`);if(!J(K.type))throw new TypeError(`You've tried to perform an operation on a struct of type: ${K.type}. Try accessing a member on that struct with '.'`);return(k(this)||D(this))&&A(K)?new h(K):K}else return typeof K=="number"?A(this)?new c(K):new h(K):Array.isArray(K)?qe.dynamicVector(K):qe[this.type](K)}toFloat(){if(k(this))return this;if(A(this))return new h(this)}toGLSL(K){throw new TypeError("Not supposed to call this function on BaseNode, which is an abstract class.")}}class c extends l{constructor(K=0,pe=!1){super(pe,"int"),this.x=K}toGLSL(K){if(_(this.x)){let pe=this.x.toGLSLBase(K);return A(this.x.type)?pe:`int(${pe})`}else return typeof this.x=="number"?`${Math.floor(this.x)}`:`int(${this.x})`}}class h extends l{constructor(K=0,pe=!1,_e=!1){if(super(pe,"float"),Array.isArray(K)&&(K=K[0]),_e){const{parent:We,name:Oe}=_e;this.name=Oe,this.parent=We}this.x=K}toGLSL(K){if(_(this.x)){let pe=this.x.toGLSLBase(K);return k(this.x)?pe:`float(${pe})`}else return typeof this.x=="number"?`${this.x.toFixed(4)}`:`float(${this.x})`}}class d extends l{constructor(K,pe,_e=!1){super(_e,pe),this.originalValues=Fe(K,parseInt(pe.slice(3))),this.componentNames=["x","y","z","w"].slice(0,this.originalValues.length)}addVectorComponents(){const K=this.originalValues;this.componentsChanged=!1,this.componentNames.forEach((pe,_e)=>{const We={name:pe,parent:this};let Oe=N(K[_e])?K[_e]:new h(K[_e],!0,We);Object.defineProperty(this,pe,{get(){return Oe},set(nt){this.componentsChanged=!0,re(this)?this.node.value=nt:Oe=N(nt)?nt:new h(nt,!0,We)}})}),this.originalValues=this.componentNames.map(pe=>this[pe])}toGLSL(K){if((!this.componentsChanged||!this.defined)&&!this.oldName){let pe=this.componentNames.map((_e,We)=>this.originalValues[We].toGLSLBase(K)).join(", ");return this.defined=!0,`${this.type}(${pe})`}else return this.temporaryVariable}}class p extends l{constructor(K,pe,_e,We=!1){let Oe;const nt=rt=>{let pt,Et=0;const ht=pe.every((Mt,it)=>{const kt=C(Mt);let Lt=rt.args[it];return Lt==="genType"&&((pt===void 0||pt==="float"&&kt.startsWith("vec"))&&(pt=kt),Lt=pt),Et+=kt===Lt,kt===Lt||kt==="float"&&Lt.startsWith("vec")});return{...rt,valid:ht,similarity:Et,genType:pt}};if(Array.isArray(_e)){let rt=_e.filter(Et=>Et.args.length===pe.length);if(rt.length===0){const Et=new Set,ht=[];_e.forEach(it=>Et.add(it.args.length)),Et.forEach(it=>ht.push(`${it}`));const Mt=ht.join(" or ");throw new Error(`Function '${K}' has ${_e.length} variants which expect ${Mt} arguments, but ${pe.length} arguments were provided.`)}const pt=function(Et,ht){return ht=nt(ht),ht.valid&&(!Et||ht.similarity>Et.similarity)&&(Et=ht),Et};Oe=rt.reduce(pt,null)}else Oe=nt(_e);if(!Oe||!Oe.valid){const rt=ht=>`(${ht.map(Mt=>Mt).join(", ")})`,pt=Array.isArray(_e)?_e.map(ht=>rt(ht.args)).join(" or "):rt(_e.args),Et=rt(pe.map(ht=>C(ht)));throw new Error(`Function '${K}' was called with wrong arguments. Most likely, you provided mixed lengths vectors as arguments.
Expected argument types: ${pt}
Provided argument types: ${Et}
All of the arguments with expected type 'genType' should have a matching type. If one of those is different, try to find where it was created.
        `)}if(pe.length!==Oe.args.length)throw new Error(`Function '${K}' expects ${Oe.args.length} arguments, but ${pe.length} were provided.`);pe=pe.map((rt,pt)=>{if(_(rt))k(rt)&&Oe.args[pt]==="genType"&&Oe.genType!=="float"&&(rt=qe[Oe.genType](rt));else{const Et=Oe.args[pt]==="genType"?Oe.genType:Oe.args[pt];rt=qe[Et](rt)}return rt}),Oe.returnType==="genType"&&(Oe.returnType=Oe.genType),super(We,Oe.returnType),this.name=K,this.args=pe,this.argumentTypes=Oe.args}deconstructArgs(K){return this.args.map((_e,We)=>(A(_e)&&this.argumentTypes[We]!="float"&&(_e=_e.toFloat()),_e.toGLSLBase(K),_e.toGLSLBase(K))).join(", ")}toGLSL(K){return`${this.name}(${this.deconstructArgs(K)})`}}class f extends l{constructor(K,pe,_e=!1){super(_e,pe),this.name=K}toGLSL(K){return`${this.name}`}}class m extends l{constructor(K,pe,_e,We=!1){super(We,_e),this.parent=K,this.componentName=pe,this.type=_e}toGLSL(K){let pe=this.parent.toGLSLBase(K);return!P(this.parent)&&!Y(this.parent)&&(pe=`(${pe})`),`${pe}.${this.componentName}`}}class g extends f{constructor(K,pe,_e=!1){super(K,pe,_e),this.timesChanged=0,this.tempVars=0}getValue(){const K=n.context;if(!K.varyings[this.name]||!this.timesChanged)return this;let pe=K.varyings[this.name].splice(0,this.timesChanged),_e;return pe.forEach((We,Oe)=>{let{value:nt}=We;if(K.declarations.push(`  ${this.name} = ${nt.toGLSLBase(K)};`),Oe===pe.length-1){const rt=`${this.name}_${this.tempVars++}`;_e=$e(new f(rt,this.type,!0)),K.declarations.push(`  ${this.type} ${rt} = ${this.name};`)}}),this.timesChanged=0,_e}bridge(K){(!_(K)||this.type.startsWith("vec")&&C(K)==="float")&&(K=qe[this.type](K)),n.registerVarying(this,K),this.timesChanged+=1}}class y extends l{constructor(K,pe,_e,We=!1){super(We,null),this.operator=_e,this.left=K,this.right=pe;for(const Oe of[K,pe])Oe.usedIn.push(this);this.type=this.determineType()}determineType(){if(["==",">",">=","<","<=","||","!","&&"].includes(this.operator))return"bool";if(this.left.type===this.right.type)return this.left.type;if(D(this.left)&&k(this.right))return this.left.type;if(D(this.right)&&k(this.left))return this.right.type;if(k(this.left)&&A(this.right)||A(this.left)&&k(this.right))return"float";throw new Error("Incompatible types for binary operator")}processOperand(K,pe){if(K.temporaryVariable)return K.temporaryVariable;let _e=K.toGLSLBase(pe);return F(K)&&!K.temporaryVariable&&(_e=`(${_e})`),this.type==="float"&&A(K)&&(_e=`float(${_e})`),_e}toGLSL(K){const pe=this.processOperand(this.left,K),_e=this.processOperand(this.right,K);return`${pe} ${this.operator} ${_e}`}}class b extends y{constructor(K,pe,_e){super(K,pe,_e)}toGLSL(K){return D(this)||k(this)?`mod(${this.left.toGLSLBase(K)}, ${this.right.toGLSLBase(K)})`:`${this.processOperand(K,this.left)} % ${this.processOperand(K,this.right)}`}}class x extends l{constructor(K,pe,_e=!1){super(_e,K.type),this.node=K,this.operator=pe}toGLSL(K){let pe=this.node.toGLSLBase(K);return!P(this.node)&&!Y(this.node)&&!Z(this.node)&&(pe=`(${pe})`),`${this.operator}${pe}`}}l.prototype.equalTo=function(ie){return Ae(this,this.enforceType(ie),"==")},l.prototype.greaterThan=function(ie){return Ae(this,this.enforceType(ie),">")},l.prototype.greaterThanEqualTo=function(ie){return Ae(this,this.enforceType(ie),">=")},l.prototype.lessThan=function(ie){return Ae(this,this.enforceType(ie),"<")},l.prototype.lessThanEqualTo=function(ie){return Ae(this,this.enforceType(ie),"<=")},l.prototype.not=function(){return new x(this.condition,"!",!0)},l.prototype.or=function(ie){return new Ae(this,this.enforceType(ie),"||",!0)},l.prototype.and=function(ie){return new Ae(this,this.enforceType(ie),"&&",!0)};function w(ie){const K=new S;return ie(),s=null,K}class v{constructor(K,pe){this.dependsOn=[],this.usedIn=[],this.dependsOnSatisfied=[],this.usedInSatisfied=[],this.states=[],this.if(K,pe),this.insertionPoint=-1,this.elseIfs=[],this.elseBranch=null,n.context.ifs.push(this)}if(K,pe){this.condition=K,this.conditionString=K.toGLSL(n.context),this.ifBranch=w(pe),this.ifBranch.parent=this}elseIf(K,pe){let _e=w(pe);return pe.parent=this,this.elseIfs.push({condition:K,elseBranch:_e}),this}else(K){return this.elseBranch=w(K),this.elseBranch.parent=this,this}thenDiscard(){return new E(this.condition)}saveState(K,pe,_e){this.states.push({line:K.declarations.length,usedInSatisfied:pe,dependsOnSatisfied:_e}),this.insertionPoint=K.declarations.length-1}toGLSL(K){const pe=K.declarations.length;this.dependsOn.forEach(nt=>K.updateComponents(nt.node));const We=K.declarations.length-pe;this.insertionPoint+=We;let Oe=[`
  if (${this.conditionString}) {`,`
    ${this.ifBranch.toGLSL(K)}`,`
  }`];return this.elseIfs.length&&this.elseIfs.forEach(nt=>{let{condition:rt,elseBranch:pt}=nt;Oe.push(` else if (${rt.toGLSL(K)}) {`),Oe.push(`
    ${pt.toGLSL(K)}`),Oe.push(`
  }`)}),this.elseBranch&&(Oe.push(" else {"),Oe.push(`
    ${this.elseBranch.toGLSL(K)}`),Oe.push(`
  }
`)),Oe.push(`
`),Oe.flat().join("")}}t.assign=function(ie,K){if(!s)throw new error('assign() is supposed to be used inside of conditional branchs. Use the "=" operator as normal otherwise.');s.assign(ie,K)};class S{constructor(){s=this,this.statements=[],this.assignments=[],this.dependsOn=[],this.declarations=[];let K=null;Object.defineProperty(this,"parent",{get(){return K},set(pe){pe.dependsOn.push(...this.dependsOn),K=pe}})}assign(K,pe){!_(pe)||pe.type!==K.type?(pe=qe[K.type](pe),this.declarations.push(pe),this.assignments.push({node:K})):this.assignments.push({node:K,value:pe}),K=K.parent?K.parent:K,pe=pe.parent?pe.parent:pe,![K,pe].some(_e=>this.dependsOn.some(We=>We.node===_e))&&(K.assertUsedInConditional(this),this.dependsOn.push(he(K)),pe.shouldUseTemporaryVariable()&&(pe.assertUsedInConditional(this),this.dependsOn.push(he(pe))))}toGLSL(K){let pe=0;return this.assignments.forEach(({node:_e,value:We})=>{let Oe,nt;if(We)nt=We.toGLSLBase(K);else{let rt=this.declarations[pe];pe++,rt.temporaryVariable=`temp_${K.getNextID()}`,this.statements.push(`${rt.type} ${rt.temporaryVariable} = ${rt.toGLSL(K)};`),nt=rt.toGLSLBase(K)}P(_e)||Y(_e)?Oe=`${_e.toGLSLBase(K)} = ${nt};`:N(_e)&&_e.name?Oe=`${_e.parent.toGLSLBase(K)}.${_e.name} = ${nt};`:(_e.temporaryVariable=`temp_${K.getNextID()}`,Oe=`${_e.type} ${_e.toGLSLBase(K)} = ${nt};`),this.statements.push(Oe)}),this.statements.join(`
    `)}}class E{constructor(K){this.condition=K}toGLSL(K){K.discardConditions.push(`if (${this.condition}{discard;})`)}}function C(ie){if(_(ie))return ie.type;if(Array.isArray(ie)&&ie.length>1)return`vec${ie.length}`;if(typeof ie=="number"||Array.isArray(ie)&&ie.length===1)return"float"}function I(ie){let K=0;if(Array.isArray(ie))for(let pe of ie)D(pe)?K+=parseInt(pe.type.slice(3)):K+=1;else D(ie)&&(K+=parseInt(val.type.slice(3)));if(![2,3,4].includes(K))throw new Error(`You have attempted to construct a vector with ${K} values. Only vec2, vec3, and vec4 types are supported.`);return K}t.dynamicNode=function(ie){if(_(ie))return ie;if(typeof ie=="number")return new h(ie);if(Array.isArray(ie))return qe.dynamicVector(ie)},t.unaryNode=function(ie,K){return ie=dynamicNode(ie),$e(new x(ie,K))};function _(ie){return ie instanceof l}function A(ie){return _(ie)&&ie.type==="int"}function k(ie){return _(ie)&&ie.type==="float"}function N(ie){return ie instanceof h}function D(ie){return _(ie)&&(ie.type==="vec2"||ie.type==="vec3"||ie.type==="vec4")}function F(ie){return ie instanceof y}function P(ie){return ie instanceof f||ie instanceof m}function G(ie){return ie instanceof v||ie instanceof S}function Y(ie){return ie.temporaryVariable}function Z(ie){return ie instanceof h||ie instanceof c||ie instanceof d}function ee(ie){return ie instanceof p}function se(ie){return ie instanceof d}function re(ie){return ie instanceof x}function J(ie){return["int","float","vec2","vec3","vec4","sampler2D"].includes(ie)}class le{constructor(K,pe,_e){n=this,this.userCallback=K,this.srcLocations=_e,this.cleanup=()=>{},this.generateHookOverrides(pe),this.output={vertexDeclarations:new Set,fragmentDeclarations:new Set,uniforms:{}},this.uniformNodes=[],this.resetGLSLContext(),this.isGenerating=!1}generate(){const K=r.disableFriendlyErrors;return r.disableFriendlyErrors=!0,this.isGenerating=!0,this.userCallback(),this.output.vertexDeclarations=[...this.output.vertexDeclarations].join(`
`),this.output.fragmentDeclarations=[...this.output.fragmentDeclarations].join(`
`),this.isGenerating=!1,this.cleanup(),r.disableFriendlyErrors=K,this.output}generateHookOverrides(K){const pe={...K.hooks.vertex,...K.hooks.fragment},_e={};Object.keys(pe).forEach(We=>{const Oe=K.hookTypes(We);this[Oe.name]=function(nt){const rt=[],pt=[];Oe.parameters.forEach(kt=>{if(J(kt.type.typeName))rt.push(Te(kt.name,kt.type.typeName,!0));else{const wn={};kt.type.properties.forEach(Gr=>{wn[Gr.name]=Te(`${kt.name}.${Gr.name}`,Gr.type.typeName,!0)}),rt.push(wn)}const Lt=kt.type.qualifiers.length>0?kt.type.qualifiers.join(" "):"";pt.push(`${Lt} ${kt.type.typeName} ${kt.name}`.trim())});let Et=nt(...rt);const ht=Oe.returnType,Mt={};J(ht.typeName)?(_(Et)?k(Et)&&ht.typeName.startsWith("vec")&&(Et=qe[ht.typeName](Et)):Et=qe[ht.typeName](Et),Mt.notAProperty=Et.toGLSLBase(this.context),this.context.updateComponents(Et)):Object.entries(Et).forEach(([kt,Lt])=>{Lt=dynamicNode(Lt),Mt[kt]=Lt.toGLSLBase(this.context),this.context.updateComponents(Lt)}),this.context.ifs.forEach(kt=>{if(kt.usedIn.length===0)return;const Lt=kt.toGLSL(this.context);this.context.declarations.splice(kt.insertionPoint,0,Lt)});let it=[`(${pt.join(", ")}) {`,...this.context.declarations,`
  ${Oe.returnType.typeName} finalReturnValue;`];Object.entries(Mt).forEach(([kt,Lt])=>{const wn=ht.properties?`.${kt}`:"";it.push(`  finalReturnValue${wn} = ${Lt};`)}),this.context.declarations=[];for(let kt in this.context.varyings){const Lt=this.context.varyings[kt],wn=[];Lt.forEach(Gr=>{const{node:lr,value:Pr}=Gr;wn.push(`  ${lr.name} = ${Pr.toGLSLBase(this.context)};`),wn.unshift(...this.context.declarations),lr.timesChanged=0}),it.push(...wn)}it.push("  return finalReturnValue;","}"),this.output[We]=it.join(`
`),this.resetGLSLContext()},_e[Oe.name]=window[Oe.name],window[Oe.name]=function(nt){n[Oe.name](nt)}}),this.cleanup=()=>{for(const We in _e)window[We]=_e[We]}}registerVarying(K,pe){Array.isArray(this.context.varyings[K.name])||(this.context.varyings[K.name]=[]),this.context.varyings[K.name].push({node:K,value:pe}),this.output.vertexDeclarations.add(`OUT ${K.type} ${K.name};`),this.output.fragmentDeclarations.add(`IN ${K.type} ${K.name};`)}resetGLSLContext(){this.uniformNodes.forEach(K=>{K.usedIn=[],K.temporaryVariable=void 0}),this.context={id:0,getNextID(){return this.id++},declarations:[],varyings:[],ifs:[],updateComponents:function(K,pe,_e){if(K.componentsChanged){_e||(_e=K.componentNames.map(()=>!0));const We=[];if(se(K))K.componentNames.forEach((Oe,nt)=>{if(_e[nt]&&K[Oe]!==K.originalValues[nt]){const rt=qe.float(K[Oe]),pt=`  ${K.temporaryVariable}.${Oe} = ${rt.toGLSLBase(this)};`;We.push(pt)}});else{const Oe=K.componentNames.map(pt=>K[pt]),nt=qe[K.type](Oe),rt=`  ${K.temporaryVariable} = ${nt.toGLSLBase(this)};`;We.push(rt)}pe?this.declarations.splice(pe,0,...We):this.declarations.push(...We),K.componentsChanged=!1}}},this.uniformNodes=[]}}function he(ie){return D(ie)?{node:ie,isVector:!0,originalComponents:[...ie.componentNames.map(K=>ie[K])],get currentComponents(){return ie.componentNames.map(K=>ie[K])}}:{node:ie,isVector:!1}}function xe(ie){return ie.map(K=>he(K))}function Fe(ie,K){return Array.isArray(ie)||(ie=[ie]),ie=ie.flat(),ie=ie.map(pe=>D(pe)?pe.componentNames.map(We=>pe[We]):pe).flat(),ie.length===1&&!se(ie[0])&&(ie=Array(K).fill(ie[0])),ie}function Le(ie){const K=[["x","y","z","w"],["r","g","b","a"],["s","t","p","q"]].map(pe=>pe.slice(0,ie));return{get(pe,_e,We){if(_e in pe)return Reflect.get(...arguments);for(const Oe of K)if([..._e].every(nt=>Oe.includes(nt))){if(_e.length===1)return pe[K[0][Oe.indexOf(_e[0])]];const nt=[..._e].map(pt=>{const Et=Oe.indexOf(pt),ht=K[0][Et];return pe[ht]}),rt=`vec${_e.length}`;return qe[rt](nt)}},set(pe,_e,We,Oe){for(const nt of K){const rt=[..._e];if(rt.every(pt=>nt.includes(pt))){const pt=Array.isArray(We)?We:Array(_e.length).fill(We);return rt.forEach((Et,ht)=>{const Mt=nt.indexOf(Et),it=K[0][Mt];Reflect.set(pe,it,pt[ht],Oe)}),!0}}return Reflect.set(...arguments)}}}t.If=function(ie,K){return new v(ie,K)},t.instanceID=function(){return Te("gl_InstanceID","int")},t.getTexture=function(...ie){return Ue("getTexture",ie,{args:["sampler2D","vec2"],returnType:"vec4",isp5Function:!0})};const Ve={int:"Int",float:"Float",vec2:"Vector2",vec3:"Vector3",vec4:"Vector4",sampler2D:"Texture"};function $e(ie,K){if(ie.type.startsWith("vec")||K){const pe=parseInt(ie.type.slice(3));ie=new Proxy(ie,Le(pe)),ie.addVectorComponents()}return ie}function Ae(ie,K,pe,_e){let We;return pe==="%"?We=new b(ie,K):We=new y(ie,K,pe,_e),$e(We)}function Te(ie,K,pe){const _e=new f(ie,K,pe);return $e(_e)}function Ue(ie,K,pe,_e){let We=new p(ie,K,pe,_e);return We=$e(We),We.dependsOn=xe(We.args),We.args.map(nt=>nt.usedIn.filter(pt=>G(pt)).map(pt=>pt instanceof S?pt.parent:pt)).flat().forEach(nt=>nt.usedIn.push(We)),We}const qe={int:ie=>new c(ie),float:ie=>new h(ie),vec2:ie=>$e(new d(ie,"vec2")),vec3:ie=>$e(new d(ie,"vec3")),vec4:ie=>$e(new d(ie,"vec4")),dynamicVector:function(ie){const K=I(ie);return this[`vec${K}`](ie)}};for(const ie in Ve){const K=Ve[ie],pe=`uniform${K}`;if(le.prototype[pe]=function(...Oe){let[nt,...rt]=Oe;ie.startsWith("vec")&&!(rt[0]instanceof Function)?(rt=Fe(rt,parseInt(ie.slice(3))),this.output.uniforms[`${ie} ${nt}`]=rt):this.output.uniforms[`${ie} ${nt}`]=rt[0];const pt=Te(nt,ie,!1);return this.uniformNodes.push(pt),pt},t[pe]=function(...Oe){return n[pe](...Oe)},ie==="sampler2D")continue;const _e=`varying${K}`;le.prototype[_e]=function(Oe){return $e(new g(Oe,ie,!1))},t[_e]=function(Oe){return n[_e](Oe)};const We=t[ie];t[ie]=function(...Oe){if(n!=null&&n.isGenerating)return ie.startsWith("vec")?Oe=Fe(Oe,parseInt(ie.slice(3))):Oe=Oe[0],qe[ie](Oe);if(We)return We.apply(this,Oe);r._friendlyError(`It looks like you've called ${ie} outside of a shader's modify() function.`)}}Object.entries({acos:{args:["genType"],returnType:"genType",isp5Function:!0},acosh:{args:["genType"],returnType:"genType",isp5Function:!1},asin:{args:["genType"],returnType:"genType",isp5Function:!0},asinh:{args:["genType"],returnType:"genType",isp5Function:!1},atan:[{args:["genType"],returnType:"genType",isp5Function:!1},{args:["genType","genType"],returnType:"genType",isp5Function:!1}],atanh:{args:["genType"],returnType:"genType",isp5Function:!1},cos:{args:["genType"],returnType:"genType",isp5Function:!0},cosh:{args:["genType"],returnType:"genType",isp5Function:!1},degrees:{args:["genType"],returnType:"genType",isp5Function:!0},radians:{args:["genType"],returnType:"genType",isp5Function:!0},sin:{args:["genType"],returnType:"genType",isp5Function:!0},sinh:{args:["genType"],returnType:"genType",isp5Function:!1},tan:{args:["genType"],returnType:"genType",isp5Function:!0},tanh:{args:["genType"],returnType:"genType",isp5Function:!1},abs:{args:["genType"],returnType:"genType",isp5Function:!0},ceil:{args:["genType"],returnType:"genType",isp5Function:!0},clamp:{args:["genType","genType","genType"],returnType:"genType",isp5Function:!1},dFdx:{args:["genType"],returnType:"genType",isp5Function:!1},dFdy:{args:["genType"],returnType:"genType",isp5Function:!1},exp:{args:["genType"],returnType:"genType",isp5Function:!0},exp2:{args:["genType"],returnType:"genType",isp5Function:!1},floor:{args:["genType"],returnType:"genType",isp5Function:!0},fma:{args:["genType","genType","genType"],returnType:"genType",isp5Function:!1},fract:{args:["genType"],returnType:"genType",isp5Function:!0},fwidth:{args:["genType"],returnType:"genType",isp5Function:!1},inversesqrt:{args:["genType"],returnType:"genType",isp5Function:!0},log:{args:["genType"],returnType:"genType",isp5Function:!0},log2:{args:["genType"],returnType:"genType",isp5Function:!1},max:[{args:["genType","genType"],returnType:"genType",isp5Function:!0},{args:["genType","float"],returnType:"genType",isp5Function:!0}],min:[{args:["genType","genType"],returnType:"genType",isp5Function:!0},{args:["genType","float"],returnType:"genType",isp5Function:!0}],mix:[{args:["genType","genType","genType"],returnType:"genType",isp5Function:!1},{args:["genType","genType","float"],returnType:"genType",isp5Function:!1}],pow:{args:["genType","genType"],returnType:"genType",isp5Function:!0},round:{args:["genType"],returnType:"genType",isp5Function:!0},roundEven:{args:["genType"],returnType:"genType",isp5Function:!1},smoothstep:[{args:["genType","genType","genType"],returnType:"genType",isp5Function:!1},{args:["float","float","genType"],returnType:"genType",isp5Function:!1}],sqrt:{args:["genType"],returnType:"genType",isp5Function:!0},step:{args:["genType","genType"],returnType:"genType",isp5Function:!1},trunc:{args:["genType"],returnType:"genType",isp5Function:!1},cross:{args:["vec3","vec3"],returnType:"vec3",isp5Function:!0},distance:{args:["genType","genType"],returnType:"float",isp5Function:!0},dot:{args:["genType","genType"],returnType:"float",isp5Function:!0},faceforward:{args:["genType","genType","genType"],returnType:"genType",isp5Function:!1},length:{args:["genType"],returnType:"float",isp5Function:!1},normalize:{args:["genType"],returnType:"genType",isp5Function:!0},reflect:{args:["genType","genType"],returnType:"genType",isp5Function:!1},refract:{args:["genType","genType","float"],returnType:"genType",isp5Function:!1},texture:{args:["sampler2D","vec2"],returnType:"vec4",isp5Function:!0}}).forEach(([ie,K])=>{if(Array.isArray(K)?K[0].isp5Function:K.isp5Function){const _e=t[ie];t[ie]=function(...We){return n!=null&&n.isGenerating?Ue(ie,We,K):_e.apply(this,We)}}else t[ie]=function(..._e){if(n!=null&&n.isGenerating)return new Ue(ie,_e,K);r._friendlyError(`It looks like you've called ${ie} outside of a shader's modify() function.`)}})}typeof p5<"u"&&p5.registerAddon(U8);function phe(r){B6(r,r.prototype),jT(r,r.prototype),p8(r,r.prototype),qT(r,r.prototype),f8(r,r.prototype),z6(r,r.prototype),Yce(r,r.prototype),S6(r,r.prototype),w6(r,r.prototype),b6(r,r.prototype),v6(r,r.prototype),E6(r,r.prototype),H6(r,r.prototype),x6(r,r.prototype),WT(r,r.prototype),KT(r,r.prototype),U8(r,r.prototype)}function fhe(r){r.registerAddon(m8),r.registerAddon(M8)}const mhe=()=>{if(typeof window._setupDone<"u"){console.warn("p5.js seems to have been imported multiple times. Please remove the duplicate import");return}if(!window.mocha){const r=new Event("p5Ready");window.dispatchEvent(r),(window.setup&&typeof window.setup=="function"||window.draw&&typeof window.draw=="function")&&!Zr.instance&&new Zr}},ghe=()=>new Promise((r,t)=>{document.readyState==="complete"?r():window.addEventListener("load",r,!1)}),yhe=typeof IS_MINIFIED>"u"?qoe():Promise.resolve();loe(Zr);hoe(Zr);doe(Zr);dle(Zr);ple(Zr);fle(Zr);gle(Zr);yle(Zr);vle(Zr);wle(Zr);Sle(Zr);phe(Zr);fhe(Zr);Promise.all([ghe(),yhe]).then(mhe);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bhe=1e-7,xhe=1e-4;class W8{constructor(t,n){this.backend=t,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,n){this.dataIdsCount++,this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class aA{refCount(t){return Li("refCount")}incRef(t){return Li("incRef")}timerAvailable(){return!0}time(t){return Li("time")}read(t){return Li("read")}readSync(t){return Li("readSync")}readToGPU(t,n){return Li("readToGPU")}numDataIds(){return Li("numDataIds")}disposeData(t,n){return Li("disposeData")}write(t,n,s){return Li("write")}move(t,n,s,i,a){return Li("move")}createTensorFromGPUData(t,n,s){return Li("createTensorFromGPUData")}memory(){return Li("memory")}floatPrecision(){return Li("floatPrecision")}epsilon(){return this.floatPrecision()===32?bhe:xhe}dispose(){return Li("dispose")}}function Li(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G8(r){let t=r.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Uu(r,t,n)}function vhe(r,t){if(r.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${t.length}`);let n=r.length,s=0;for(;n>0;)s=Math.random()*n|0,n--,Uu(r,n,s),Uu(t,n,s)}function _b(r,t,n){return Math.max(r,Math.min(t,n))}function qS(r){return r%2===0?r:r+1}function Uu(r,t,n){const s=r[t];r[t]=r[n],r[n]=s}function H8(r){let t=0;for(let n=0;n<r.length;n++)t+=r[n];return t}function whe(r,t){const n=Math.random();return t*n+(1-n)*r}function She(r,t){let n=0;for(let s=0;s<r.length;s++){const i=Number(r[s])-Number(t[s]);n+=i*i}return n}function oe(r,t){if(!r)throw new Error(typeof t=="string"?t:t())}function Gs(r,t,n=""){oe(En(r,t),()=>n+` Shapes ${r} and ${t} must match`)}function Md(r){oe(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function lt(r){if(r.length===0)return 1;let t=r[0];for(let n=1;n<r.length;n++)t*=r[n];return t}function Che(r){return r.length===0}function j8(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let n=0;n<r.length;n++)if(r[n]!==null&&t[n]!==null&&r[n]!==t[n])return!1;return!0}function En(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let n=0;n<r.length;n++)if(r[n]!==t[n])return!1;return!0}function Qh(r){return r%1===0}function _he(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{const t=Math.exp(2*r);return(t-1)/(t+1)}}function m2(r){const t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function Ehe(r){const t=new Uint32Array(r);for(let n=0;n<r;++n)t[n]=n;return G8(t),t}function Fh(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function fk(r,t=i=>0,n,s){return new Promise((i,a)=>{let o=0;const u=()=>{if(r()){i();return}o++;const l=t(o);if(n!=null&&o>=n){a();return}s!=null?s(u,l):setTimeout(u,l)};u()})}function q8(r,t){let n=1,s=-1;for(let a=0;a<r.length;++a)if(r[a]>=0)n*=r[a];else if(r[a]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${a}`);s=a}else if(r[a]<0)throw Error(`Shapes can not be < 0. Found ${r[a]} at dim ${a}`);if(s===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(n===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const i=r.slice();return i[s]=t/n,i}function ls(r,t){const n=t.length;return r=r==null?t.map((s,i)=>i):[].concat(r),oe(r.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${r}`),oe(r.every(s=>Qh(s)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(s=>s<0?n+s:s)}function ml(r,t){const n=[],s=[],i=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||i?null:ls(t,r).sort();let o=0;for(let u=0;u<r.length;++u){if(a!=null){if(a[o]===u&&r[u]!==1)throw new Error(`Can't squeeze axis ${u} since its dim '${r[u]}' is not 1`);(a[o]==null||a[o]>u)&&r[u]===1&&(n.push(r[u]),s.push(u)),a[o]<=u&&o++}r[u]!==1&&(n.push(r[u]),s.push(u))}return{newShape:n,keptDims:s}}function ul(r,t){return rs(r,t)}function rs(r,t){let n=null;if(r==null||r==="float32")n=new Float32Array(t);else if(r==="int32")n=new Int32Array(t);else if(r==="bool")n=new Uint8Array(t);else if(r==="string")n=new Array(t);else throw new Error(`Unknown data type ${r}`);return n}function K8(r,t){for(let n=0;n<r.length;n++){const s=r[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function X8(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function Y8(r,t){return!(t==="complex64"||t==="float32"&&r!=="complex64"||t==="int32"&&r!=="float32"&&r!=="complex64"||t==="bool"&&r==="bool")}function Eb(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function Z8(r){if(r==null)return 0;let t=0;return r.forEach(n=>t+=n.length),t}function Xu(r){return typeof r=="string"||r instanceof String}function J8(r){return typeof r=="boolean"}function Q8(r){return typeof r=="number"}function hg(r){return Array.isArray(r)?hg(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":Q8(r)?"float32":Xu(r)?"string":J8(r)?"bool":"float32"}function uc(r){return!!(r&&r.constructor&&r.call&&r.apply)}function g2(r,t){for(let n=t;n<r;++n)if(r%n===0)return n;return r}function ws(r){const t=r.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=r[t-1];for(let s=t-3;s>=0;--s)n[s]=n[s+1]*r[s+1];return n}function eG(r,t,n,s=!1){const i=new Array;if(t.length===1){const a=t[0]*(s?2:1);for(let o=0;o<a;o++)i[o]=n[r+o]}else{const a=t[0],o=t.slice(1),u=o.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<a;l++)i[l]=eG(r+l*u,o,n,s)}return i}function $h(r,t,n=!1){if(r.length===0)return t[0];const s=r.reduce((i,a)=>i*a)*(n?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return eG(0,r,t,n)}function Ihe(r,t){if(Array.isArray(r))return r;if(t==="float32")return r instanceof Float32Array?r:new Float32Array(r);if(t==="int32")return r instanceof Int32Array?r:new Int32Array(r);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(r));throw new Error(`Unknown dtype ${t}`)}function oA(r,t){const n=ll(r,t);for(let s=0;s<n.length;s++)n[s]=1;return n}function ll(r,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function khe(r,t){const n=r.reduce((s,i)=>s*i,1);if(t==null||t==="float32")return $h(r,new Float32Array(n));if(t==="int32")return $h(r,new Int32Array(n));if(t==="bool")return $h(r,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function aa(r){r.forEach(t=>{oe(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function y2(r,t,n){if(t===0)return 0;if(t===1)return r[0];let s=r[r.length-1];for(let i=0;i<r.length-1;++i)s+=n[i]*r[i];return s}function KS(r,t,n){if(t===0)return[];if(t===1)return[r];const s=new Array(t);for(let i=0;i<s.length-1;++i)s[i]=Math.floor(r/n[i]),r-=s[i]*n[i];return s[s.length-1]=r,s}function lc(r){return r&&r.then&&typeof r.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _4="tfjsflags";class tG{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Nhe,this.populateURLFlags()}setPlatform(t,n){this.platform!=null&&(Be().getBool("IS_TEST")||Be().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,s){if(this.flagRegistry[t]={evaluationFn:n,setHook:s},this.urlFlags[t]!=null){const i=this.urlFlags[t];Be().getBool("IS_TEST")||Be().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${i}.`),this.set(t,i)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if(lc(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);_4 in t&&t[_4].split(",").forEach(s=>{const[i,a]=s.split(":");this.urlFlags[i]=Ahe(i,a)})}}function Nhe(r){const t={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>(The(t,s[0],s[1]),s.join("="))),t}function The(r,t,n){r[decodeURIComponent(t)]=decodeURIComponent(n||"")}function Ahe(r,t){const n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function Be(){return uA}let uA=null;function Dhe(r){uA=r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let VE;function rG(){if(VE==null){let r;if(typeof window<"u")r=window;else if(typeof global<"u")r=global;else if(typeof process<"u")r=process;else if(typeof self<"u")r=self;else throw new Error("Could not find a global object");VE=r}return VE}function Fhe(){const r=rG();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function lA(r,t){const n=Fhe();if(n.has(r))return n.get(r);{const s=t();return n.set(r,s),n.get(r)}}const cA="Abs",hA="Acos",dA="Acosh",XS="Add",pA="AddN",fA="All",mA="Any",gA="ArgMax",yA="ArgMin",bA="Asin",xA="Asinh",vA="Atan",wA="Atanh",SA="Atan2",CA="AvgPool",nG="AvgPoolGrad",_A="AvgPool3D",sG="AvgPool3DGrad",EA="BatchMatMul",IA="BatchToSpaceND",kA="Bincount",NA="BitwiseAnd",$he="BroadcastTo",TA="BroadcastArgs",YS="Cast",AA="Ceil",DA="ClipByValue",FA="Complex",$A="ComplexAbs",RA="Concat",OA="Conv2D",MA="Conv2DBackpropFilter",LA="Conv2DBackpropInput",PA="Conv3D",iG="Conv3DBackpropFilterV2",BA="Conv3DBackpropInputV2",VA="Cos",zA="Cosh",UA="Cumprod",WA="Cumsum",GA="CropAndResize",HA="DenseBincount",jA="DepthToSpace",qA="DepthwiseConv2dNative",KA="DepthwiseConv2dNativeBackpropFilter",XA="DepthwiseConv2dNativeBackpropInput",YA="Diag",ZA="Dilation2D",Rhe="Dilation2DBackpropInput",Ohe="Dilation2DBackpropFilter",JA="Draw",QA="RealDiv",eD="Einsum",tD="Elu",aG="EluGrad",rD="Erf",nD="Equal",sD="Exp",iD="ExpandDims",aD="Expm1",oD="FFT",uD="Fill",lD="FlipLeftRight",cD="Floor",hD="FloorDiv",dD="FusedBatchNorm",pD="GatherV2",fD="GatherNd",mD="Greater",gD="GreaterEqual",ZS="Identity",yD="IFFT",bD="Imag",xD="IsFinite",vD="IsInf",wD="IsNan",SD="LeakyRelu",CD="Less",_D="LessEqual",ED="LinSpace",ID="Log",kD="Log1p",ND="LogicalAnd",TD="LogicalNot",AD="LogicalOr",Mhe="LogicalXor",Lhe="LogSoftmax",Phe="LowerBound",DD="LRN",oG="LRNGrad",Bhe="MatrixBandPart",FD="Max",$D="Maximum",RD="MaxPool",uG="MaxPoolGrad",OD="MaxPool3D",lG="MaxPool3DGrad",MD="MaxPoolWithArgmax",LD="Mean",PD="Min",BD="Minimum",VD="MirrorPad",zD="Mod",UD="Multinomial",WD="Multiply",GD="Neg",HD="NotEqual",jD="NonMaxSuppressionV3",qD="NonMaxSuppressionV4",KD="NonMaxSuppressionV5",XD="OnesLike",YD="OneHot",ZD="Pack",JD="PadV2",Vhe="Pool",QD="Pow",eF="Prelu",tF="Prod",rF="RaggedGather",nF="RaggedRange",sF="RaggedTensorToTensor",iF="Range",aF="Real",oF="Reciprocal",uF="Relu",lF="Reshape",cF="ResizeNearestNeighbor",cG="ResizeNearestNeighborGrad",hF="ResizeBilinear",hG="ResizeBilinearGrad",dF="Relu6",pF="Reverse",fF="Round",mF="Rsqrt",gF="ScatterNd",yF="TensorScatterUpdate",bF="SearchSorted",xF="Select",vF="Selu",wF="Slice",SF="Sin",CF="Sinh",_F="Sign",EF="Sigmoid",IF="Softplus",kF="Sqrt",NF="Sum",TF="SpaceToBatchND",AF="SplitV",DF="Softmax",FF="SparseFillEmptyRows",$F="SparseReshape",RF="SparseSegmentMean",OF="SparseSegmentSum",MF="SparseToDense",LF="SquaredDifference",dG="Square",PF="StaticRegexReplace",BF="StridedSlice",VF="StringNGrams",zF="StringSplit",UF="StringToHashBucketFast",WF="Sub",GF="Tan",HF="Tanh",JS="Tile",jF="TopK",qF="Transform",Xy="Transpose",KF="Unique",XF="Unpack",YF="UnsortedSegmentSum",zhe="UpperBound",ZF="ZerosLike",JF="Step",b2="FromPixels",QF="RotateWithOffset",x2="_FusedMatMul",v2="FusedConv2D",w2="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wa(...r){Be().getBool("IS_TEST")||Be().getBool("PROD")||console.warn(...r)}function Uhe(...r){Be().getBool("IS_TEST")||Be().getBool("PROD")||console.log(...r)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fm=lA("kernelRegistry",()=>new Map),Ib=lA("gradRegistry",()=>new Map);function kb(r,t){const n=t$(r,t);return Fm.get(n)}function mk(r){return Ib.get(r)}function S2(r){const t=Fm.entries(),n=[];for(;;){const{done:s,value:i}=t.next();if(s)break;const[a,o]=i,[u]=a.split("_");u===r&&n.push(o)}return n}function e$(r){const{kernelName:t,backendName:n}=r,s=t$(t,n);Fm.has(s)&&Wa(`The kernel '${t}' for backend '${n}' is already registered`),Fm.set(s,r)}function Whe(r){const{kernelName:t}=r;Ib.has(t)&&Be().getBool("DEBUG")&&Wa(`Overriding the gradient for '${t}'`),Ib.set(t,r)}function Ghe(r,t){const n=t$(r,t);if(!Fm.has(n))throw new Error(`The kernel '${r}' for backend '${t}' is not registered`);Fm.delete(n)}function Hhe(r){if(!Ib.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);Ib.delete(r)}function jhe(r,t){S2(r).forEach(s=>{const i=Object.assign({},s,{backendName:t});e$(i)})}function t$(r,t){return`${t}_${r}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pG(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}var zE,E4;function qhe(){if(E4)return zE;E4=1,zE=t;var r=null;try{r=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(A,k,N){this.low=A|0,this.high=k|0,this.unsigned=!!N}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function n(A){return(A&&A.__isLong__)===!0}t.isLong=n;var s={},i={};function a(A,k){var N,D,F;return k?(A>>>=0,(F=0<=A&&A<256)&&(D=i[A],D)?D:(N=u(A,(A|0)<0?-1:0,!0),F&&(i[A]=N),N)):(A|=0,(F=-128<=A&&A<128)&&(D=s[A],D)?D:(N=u(A,A<0?-1:0,!1),F&&(s[A]=N),N))}t.fromInt=a;function o(A,k){if(isNaN(A))return k?x:b;if(k){if(A<0)return x;if(A>=m)return C}else{if(A<=-9223372036854776e3)return I;if(A+1>=g)return E}return A<0?o(-A,k).neg():u(A%f|0,A/f|0,k)}t.fromNumber=o;function u(A,k,N){return new t(A,k,N)}t.fromBits=u;var l=Math.pow;function c(A,k,N){if(A.length===0)throw Error("empty string");if(A==="NaN"||A==="Infinity"||A==="+Infinity"||A==="-Infinity")return b;if(typeof k=="number"?(N=k,k=!1):k=!!k,N=N||10,N<2||36<N)throw RangeError("radix");var D;if((D=A.indexOf("-"))>0)throw Error("interior hyphen");if(D===0)return c(A.substring(1),k,N).neg();for(var F=o(l(N,8)),P=b,G=0;G<A.length;G+=8){var Y=Math.min(8,A.length-G),Z=parseInt(A.substring(G,G+Y),N);if(Y<8){var ee=o(l(N,Y));P=P.mul(ee).add(o(Z))}else P=P.mul(F),P=P.add(o(Z))}return P.unsigned=k,P}t.fromString=c;function h(A,k){return typeof A=="number"?o(A,k):typeof A=="string"?c(A,k):u(A.low,A.high,typeof k=="boolean"?k:A.unsigned)}t.fromValue=h;var d=65536,p=1<<24,f=d*d,m=f*f,g=m/2,y=a(p),b=a(0);t.ZERO=b;var x=a(0,!0);t.UZERO=x;var w=a(1);t.ONE=w;var v=a(1,!0);t.UONE=v;var S=a(-1);t.NEG_ONE=S;var E=u(-1,2147483647,!1);t.MAX_VALUE=E;var C=u(-1,-1,!0);t.MAX_UNSIGNED_VALUE=C;var I=u(0,-2147483648,!1);t.MIN_VALUE=I;var _=t.prototype;return _.toInt=function(){return this.unsigned?this.low>>>0:this.low},_.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},_.toString=function(k){if(k=k||10,k<2||36<k)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(I)){var N=o(k),D=this.div(N),F=D.mul(N).sub(this);return D.toString(k)+F.toInt().toString(k)}else return"-"+this.neg().toString(k);for(var P=o(l(k,6),this.unsigned),G=this,Y="";;){var Z=G.div(P),ee=G.sub(Z.mul(P)).toInt()>>>0,se=ee.toString(k);if(G=Z,G.isZero())return se+Y;for(;se.length<6;)se="0"+se;Y=""+se+Y}},_.getHighBits=function(){return this.high},_.getHighBitsUnsigned=function(){return this.high>>>0},_.getLowBits=function(){return this.low},_.getLowBitsUnsigned=function(){return this.low>>>0},_.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var k=this.high!=0?this.high:this.low,N=31;N>0&&(k&1<<N)==0;N--);return this.high!=0?N+33:N+1},_.isZero=function(){return this.high===0&&this.low===0},_.eqz=_.isZero,_.isNegative=function(){return!this.unsigned&&this.high<0},_.isPositive=function(){return this.unsigned||this.high>=0},_.isOdd=function(){return(this.low&1)===1},_.isEven=function(){return(this.low&1)===0},_.equals=function(k){return n(k)||(k=h(k)),this.unsigned!==k.unsigned&&this.high>>>31===1&&k.high>>>31===1?!1:this.high===k.high&&this.low===k.low},_.eq=_.equals,_.notEquals=function(k){return!this.eq(k)},_.neq=_.notEquals,_.ne=_.notEquals,_.lessThan=function(k){return this.comp(k)<0},_.lt=_.lessThan,_.lessThanOrEqual=function(k){return this.comp(k)<=0},_.lte=_.lessThanOrEqual,_.le=_.lessThanOrEqual,_.greaterThan=function(k){return this.comp(k)>0},_.gt=_.greaterThan,_.greaterThanOrEqual=function(k){return this.comp(k)>=0},_.gte=_.greaterThanOrEqual,_.ge=_.greaterThanOrEqual,_.compare=function(k){if(n(k)||(k=h(k)),this.eq(k))return 0;var N=this.isNegative(),D=k.isNegative();return N&&!D?-1:!N&&D?1:this.unsigned?k.high>>>0>this.high>>>0||k.high===this.high&&k.low>>>0>this.low>>>0?-1:1:this.sub(k).isNegative()?-1:1},_.comp=_.compare,_.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(w)},_.neg=_.negate,_.add=function(k){n(k)||(k=h(k));var N=this.high>>>16,D=this.high&65535,F=this.low>>>16,P=this.low&65535,G=k.high>>>16,Y=k.high&65535,Z=k.low>>>16,ee=k.low&65535,se=0,re=0,J=0,le=0;return le+=P+ee,J+=le>>>16,le&=65535,J+=F+Z,re+=J>>>16,J&=65535,re+=D+Y,se+=re>>>16,re&=65535,se+=N+G,se&=65535,u(J<<16|le,se<<16|re,this.unsigned)},_.subtract=function(k){return n(k)||(k=h(k)),this.add(k.neg())},_.sub=_.subtract,_.multiply=function(k){if(this.isZero())return b;if(n(k)||(k=h(k)),r){var N=r.mul(this.low,this.high,k.low,k.high);return u(N,r.get_high(),this.unsigned)}if(k.isZero())return b;if(this.eq(I))return k.isOdd()?I:b;if(k.eq(I))return this.isOdd()?I:b;if(this.isNegative())return k.isNegative()?this.neg().mul(k.neg()):this.neg().mul(k).neg();if(k.isNegative())return this.mul(k.neg()).neg();if(this.lt(y)&&k.lt(y))return o(this.toNumber()*k.toNumber(),this.unsigned);var D=this.high>>>16,F=this.high&65535,P=this.low>>>16,G=this.low&65535,Y=k.high>>>16,Z=k.high&65535,ee=k.low>>>16,se=k.low&65535,re=0,J=0,le=0,he=0;return he+=G*se,le+=he>>>16,he&=65535,le+=P*se,J+=le>>>16,le&=65535,le+=G*ee,J+=le>>>16,le&=65535,J+=F*se,re+=J>>>16,J&=65535,J+=P*ee,re+=J>>>16,J&=65535,J+=G*Z,re+=J>>>16,J&=65535,re+=D*se+F*ee+P*Z+G*Y,re&=65535,u(le<<16|he,re<<16|J,this.unsigned)},_.mul=_.multiply,_.divide=function(k){if(n(k)||(k=h(k)),k.isZero())throw Error("division by zero");if(r){if(!this.unsigned&&this.high===-2147483648&&k.low===-1&&k.high===-1)return this;var N=(this.unsigned?r.div_u:r.div_s)(this.low,this.high,k.low,k.high);return u(N,r.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?x:b;var D,F,P;if(this.unsigned){if(k.unsigned||(k=k.toUnsigned()),k.gt(this))return x;if(k.gt(this.shru(1)))return v;P=x}else{if(this.eq(I)){if(k.eq(w)||k.eq(S))return I;if(k.eq(I))return w;var G=this.shr(1);return D=G.div(k).shl(1),D.eq(b)?k.isNegative()?w:S:(F=this.sub(k.mul(D)),P=D.add(F.div(k)),P)}else if(k.eq(I))return this.unsigned?x:b;if(this.isNegative())return k.isNegative()?this.neg().div(k.neg()):this.neg().div(k).neg();if(k.isNegative())return this.div(k.neg()).neg();P=b}for(F=this;F.gte(k);){D=Math.max(1,Math.floor(F.toNumber()/k.toNumber()));for(var Y=Math.ceil(Math.log(D)/Math.LN2),Z=Y<=48?1:l(2,Y-48),ee=o(D),se=ee.mul(k);se.isNegative()||se.gt(F);)D-=Z,ee=o(D,this.unsigned),se=ee.mul(k);ee.isZero()&&(ee=w),P=P.add(ee),F=F.sub(se)}return P},_.div=_.divide,_.modulo=function(k){if(n(k)||(k=h(k)),r){var N=(this.unsigned?r.rem_u:r.rem_s)(this.low,this.high,k.low,k.high);return u(N,r.get_high(),this.unsigned)}return this.sub(this.div(k).mul(k))},_.mod=_.modulo,_.rem=_.modulo,_.not=function(){return u(~this.low,~this.high,this.unsigned)},_.and=function(k){return n(k)||(k=h(k)),u(this.low&k.low,this.high&k.high,this.unsigned)},_.or=function(k){return n(k)||(k=h(k)),u(this.low|k.low,this.high|k.high,this.unsigned)},_.xor=function(k){return n(k)||(k=h(k)),u(this.low^k.low,this.high^k.high,this.unsigned)},_.shiftLeft=function(k){return n(k)&&(k=k.toInt()),(k&=63)===0?this:k<32?u(this.low<<k,this.high<<k|this.low>>>32-k,this.unsigned):u(0,this.low<<k-32,this.unsigned)},_.shl=_.shiftLeft,_.shiftRight=function(k){return n(k)&&(k=k.toInt()),(k&=63)===0?this:k<32?u(this.low>>>k|this.high<<32-k,this.high>>k,this.unsigned):u(this.high>>k-32,this.high>=0?0:-1,this.unsigned)},_.shr=_.shiftRight,_.shiftRightUnsigned=function(k){if(n(k)&&(k=k.toInt()),k&=63,k===0)return this;var N=this.high;if(k<32){var D=this.low;return u(D>>>k|N<<32-k,N>>>k,this.unsigned)}else return k===32?u(N,0,this.unsigned):u(N>>>k-32,0,this.unsigned)},_.shru=_.shiftRightUnsigned,_.shr_u=_.shiftRightUnsigned,_.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},_.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},_.toBytes=function(k){return k?this.toBytesLE():this.toBytesBE()},_.toBytesLE=function(){var k=this.high,N=this.low;return[N&255,N>>>8&255,N>>>16&255,N>>>24,k&255,k>>>8&255,k>>>16&255,k>>>24]},_.toBytesBE=function(){var k=this.high,N=this.low;return[k>>>24,k>>>16&255,k>>>8&255,k&255,N>>>24,N>>>16&255,N>>>8&255,N&255]},t.fromBytes=function(k,N,D){return D?t.fromBytesLE(k,N):t.fromBytesBE(k,N)},t.fromBytesLE=function(k,N){return new t(k[0]|k[1]<<8|k[2]<<16|k[3]<<24,k[4]|k[5]<<8|k[6]<<16|k[7]<<24,N)},t.fromBytesBE=function(k,N){return new t(k[4]<<24|k[5]<<16|k[6]<<8|k[7],k[0]<<24|k[1]<<16|k[2]<<8|k[3],N)},zE}var fG=qhe();const mG=AT(fG),Khe=nse({__proto__:null,default:mG},[fG]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xh=mG||Khe;function yx(r){return xh.fromString(r,!0,16)}const gG=yx("c3a5c85c97cb3127"),dh=yx("b492b66fbe98f273"),Qs=yx("9ae16a3b2f90404f");function gk(r){return r.xor(r.shru(47))}function yG(r,t,n){const s=r.slice(t,t+n);return xh.fromBytes(Array.from(s),!0,!0)}function gn(r,t){return yG(r,t,8)}function I4(r,t){return yG(r,t,4)}function fs(r,t){return t===0?r:r.shru(t).or(r.shl(64-t))}function tc(r,t,n=yx("9ddfea08eb382d69")){let s=r.xor(t).mul(n);s=s.xor(s.shru(47));let i=t.xor(s).mul(n);return i=i.xor(i.shru(47)),i=i.mul(n),i}function Xhe(r,t,n,s,i,a){i=i.add(r),a=fs(a.add(i).add(s),21);const o=i;return i=i.add(t),i=i.add(n),a=a.add(fs(i,44)),[i.add(s),a.add(o)]}function x1(r,t,n,s){return Xhe(gn(r,t),gn(r,t+8),gn(r,t+16),gn(r,t+24),n,s)}function Yhe(r,t=r.length){if(t>=8){const n=Qs.add(t*2),s=gn(r,0).add(Qs),i=gn(r,t-8),a=fs(i,37).mul(n).add(s),o=fs(s,25).add(i).mul(n);return tc(a,o,n)}if(t>=4){const n=Qs.add(t*2),s=I4(r,0);return tc(s.shl(3).add(t),I4(r,t-4),n)}if(t>0){const n=r[0],s=r[t>>1],i=r[t-1],a=n+(s<<8),o=t+(i<<2);return gk(Qs.mul(a).xor(gG.mul(o))).mul(Qs)}return Qs}function Zhe(r,t=r.length){const n=Qs.add(t*2),s=gn(r,0).mul(dh),i=gn(r,8),a=gn(r,t-8).mul(n),o=gn(r,t-16).mul(Qs);return tc(fs(s.add(i),43).add(fs(a,30)).add(o),s.add(fs(i.add(Qs),18)).add(a),n)}function Jhe(r,t=r.length){const n=Qs.add(t*2),s=gn(r,0).mul(Qs),i=gn(r,8),a=gn(r,t-8).mul(n),o=gn(r,t-16).mul(Qs),u=fs(s.add(i),43).add(fs(a,30)).add(o),l=tc(u,s.add(fs(i.add(Qs),18)).add(a),n),c=gn(r,16).mul(n),h=gn(r,24),d=u.add(gn(r,t-32)).mul(n),p=l.add(gn(r,t-24)).mul(n);return tc(fs(c.add(h),43).add(fs(d,30)).add(p),c.add(fs(h.add(s),18)).add(d),n)}function bG(r,t=r.length){const n=xh.fromNumber(81,!0);if(t<=32)return t<=16?Yhe(r,t):Zhe(r,t);if(t<=64)return Jhe(r,t);let s=n,i=n.mul(dh).add(113),a=gk(i.mul(Qs).add(113)).mul(Qs),o=[xh.UZERO,xh.UZERO],u=[xh.UZERO,xh.UZERO];s=s.mul(Qs).add(gn(r,0));let l=0;const c=(t-1>>6)*64,h=c+(t-1&63)-63;do s=fs(s.add(i).add(o[0]).add(gn(r,l+8)),37).mul(dh),i=fs(i.add(o[1]).add(gn(r,l+48)),42).mul(dh),s=s.xor(u[1]),i=i.add(o[0]).add(gn(r,l+40)),a=fs(a.add(u[0]),33).mul(dh),o=x1(r,l,o[1].mul(dh),s.add(u[0])),u=x1(r,l+32,a.add(u[1]),i.add(gn(r,l+16))),[a,s]=[s,a],l+=64;while(l!==c);const d=dh.add(a.and(255).shl(1));return l=h,u[0]=u[0].add(t-1&63),o[0]=o[0].add(u[0]),u[0]=u[0].add(o[0]),s=fs(s.add(i).add(o[0]).add(gn(r,l+8)),37).mul(d),i=fs(i.add(o[1]).add(gn(r,l+48)),42).mul(d),s=s.xor(u[1].mul(9)),i=i.add(o[0].mul(9).add(gn(r,l+40))),a=fs(a.add(u[0]),33).mul(d),o=x1(r,l,o[1].mul(d),s.add(u[0])),u=x1(r,l+32,a.add(u[1]),i.add(gn(r,l+16))),[a,s]=[s,a],tc(tc(o[0],u[0],d).add(gk(i).mul(gG)).add(a),tc(o[1],u[1],d).add(s),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ld(r,t){return t==="string"?Zu(r):bx([r],t)}function Qhe(r,t){return r instanceof Float32Array&&t==="float32"||r instanceof Int32Array&&t==="int32"||r instanceof Uint8Array&&t==="bool"}function bx(r,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=hu(r)),Be().getBool("DEBUG")&&K8(r,t),Qhe(r,t))return r;if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool"){const n=new Uint8Array(r.length);for(let s=0;s<n.length;++s)Math.round(r[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${t}`)}function Ba(){return Be().platform.now()}function ede(r,t){return Be().platform.fetch(r,t)}function Zu(r,t="utf-8"){return t=t||"utf-8",Be().platform.encode(r,t)}function ed(r,t="utf-8"){return t=t||"utf-8",Be().platform.decode(r,t)}function ms(r){return Be().platform.isTypedArray!=null?Be().platform.isTypedArray(r):pG(r)}function hu(r,t=[],n=!1){if(t==null&&(t=[]),typeof r=="boolean"||typeof r=="number"||typeof r=="string"||lc(r)||r==null||ms(r)&&n)t.push(r);else if(Array.isArray(r)||ms(r))for(let s=0;s<r.length;++s)hu(r[s],t,n);else{let s=-1;for(const i of Object.keys(r))/^([1-9]+[0-9]*|0)$/.test(i)&&(s=Math.max(s,Number(i)));for(let i=0;i<=s;i++)hu(r[i],t,n)}return t}const tde=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:En,arraysEqualWithNull:j8,assert:oe,assertNonNegativeIntegerDimensions:aa,assertNonNull:Md,assertShapesMatch:Gs,bytesFromStringArray:Z8,bytesPerElement:Eb,checkConversionForErrors:K8,clamp:_b,computeStrides:ws,convertBackendValuesAndArrayBuffer:Ihe,createScalarValue:Ld,createShuffledIndices:Ehe,decodeString:ed,distSquared:She,encodeString:Zu,fetch:ede,fingerPrint64:bG,flatten:hu,getArrayFromDType:rs,getTypedArrayFromDType:ul,hasEncodingLoss:Y8,hexToLong:yx,indexToLoc:KS,inferDtype:hg,inferFromImplicitShape:q8,isBoolean:J8,isFunction:uc,isInt:Qh,isNumber:Q8,isPromise:lc,isScalarShape:Che,isString:Xu,isTypedArray:ms,isValidDtype:X8,locToIndex:y2,makeOnesTypedArray:oA,makeZerosNestedTypedArray:khe,makeZerosTypedArray:ll,nearestDivisor:g2,nearestLargerEven:qS,now:Ba,parseAxisParam:ls,randUniform:whe,repeatedTry:fk,rightPad:Fh,shuffle:G8,shuffleCombo:vhe,sizeFromShape:lt,sizeToSquarishShape:m2,squeezeShape:ml,sum:H8,swap:Uu,tanh:_he,toNestedArray:$h,toTypedArray:bx},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rde{constructor(t,n){this.backendTimer=t,this.logger=n,n==null&&(this.logger=new sde)}profileKernel(t,n,s){let i;const a=()=>{i=s()};let o;const u=Ba();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const c of i)c.dataSync();o=Promise.resolve({kernelMs:Ba()-u})}if(Be().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<i.length;c++){const h=i[c];h.data().then(d=>{nde(d,h.dtype,t)})}return{kernelName:t,outputs:i,inputs:n,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:n,outputs:s,timeMs:i,inputs:a,extraInfo:o}=t;s.forEach(u=>{Promise.all([u.data(),i,o]).then(l=>{this.logger.logKernelProfile(n,u,l[0],l[1],a,l[2])})})}}function nde(r,t,n){if(t!=="float32")return!1;for(let s=0;s<r.length;s++){const i=r[s];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${n}'`),!0}return!1}class sde{logKernelProfile(t,n,s,i,a,o){const u=typeof i=="number"?Fh(`${i}ms`,9):i.error,l=Fh(t,25),c=n.rank,h=n.size,d=Fh(n.shape.toString(),14);let p="";for(const f in a){const m=a[f];if(m!=null){const g=m.shape||n.shape,y=g.length;p+=`${f}: ${y}D ${y>0?g:""} `}}console.log(`%c${l}	%c${u}	%c${c}D ${d}	%c${h}	%c${p}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ide(r,t,n){const s={},i={};for(let l=0;l<t.length;l++)s[t[l].id]=!0;for(let l=0;l<r.length;l++){const c=r[l],h=c.inputs;for(const d in h){const p=h[d];let f=!1;for(let m=0;m<t.length;m++)if(s[p.id]){c.outputs.forEach(g=>s[g.id]=!0),f=!0,i[c.id]=!0;break}if(f)break}}const a={};a[n.id]=!0;const o={};for(let l=r.length-1;l>=0;l--){const c=r[l],h=c.inputs;for(let d=0;d<c.outputs.length;d++)if(a[c.outputs[d].id]){for(const p in h)a[h[p].id]=!0,o[c.id]=!0;break}}const u=[];for(let l=0;l<r.length;l++){const c=r[l];if(i[c.id]&&o[c.id]){const h={};for(const p in c.inputs){const f=c.inputs[p];s[f.id]&&(h[p]=f)}const d=Object.assign({},c);d.inputs=h,d.outputs=c.outputs,u.push(d)}}return u}function ade(r,t,n,s){for(let i=t.length-1;i>=0;i--){const a=t[i],o=[];if(a.outputs.forEach(l=>{const c=r[l.id];c!=null?o.push(c):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const u=a.gradient(o);for(const l in a.inputs){if(!(l in u))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(u)}.`);const c=n(()=>u[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const h=a.inputs[l];if(!En(c.shape,h.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${h.shape}'`);if(r[h.id]==null)r[h.id]=c;else{const d=r[h.id];r[h.id]=s(d,c),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k4=20,dy=3,UE=7;function ode(r,t,n,s){const i=ws(t),a=ude(r,t,n,i),o=t.length,u=fw(r,t,n,i,a),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(u.map(c=>"    "+c).join(`
`)),l.join(`
`)}function ude(r,t,n,s){const i=lt(t),a=s[s.length-1],o=new Array(a).fill(0),u=t.length,l=n==="complex64"?ky(r):r;if(u>1)for(let c=0;c<i/a;c++){const h=c*a;for(let d=0;d<a;d++)o[d]=Math.max(o[d],Iy(l[h+d],0,n).length)}return o}function Iy(r,t,n){let s;return Array.isArray(r)?s=`${parseFloat(r[0].toFixed(UE))} + ${parseFloat(r[1].toFixed(UE))}j`:Xu(r)?s=`'${r}'`:n==="bool"?s=xG(r):s=parseFloat(r.toFixed(UE)).toString(),Fh(s,t)}function xG(r){return r===0?"false":"true"}function fw(r,t,n,s,i,a=!0){const o=n==="complex64"?2:1,u=t[0],l=t.length;if(l===0){if(n==="complex64"){const g=ky(r);return[Iy(g[0],0,n)]}return n==="bool"?[xG(r[0])]:[r[0].toString()]}if(l===1){if(u>k4){const y=dy*o;let b=Array.from(r.slice(0,y)),x=Array.from(r.slice((u-dy)*o,u*o));return n==="complex64"&&(b=ky(b),x=ky(x)),["["+b.map((w,v)=>Iy(w,i[v],n)).join(", ")+", ..., "+x.map((w,v)=>Iy(w,i[u-dy+v],n)).join(", ")+"]"]}return["["+(n==="complex64"?ky(r):Array.from(r)).map((y,b)=>Iy(y,i[b],n)).join(", ")+"]"]}const c=t.slice(1),h=s.slice(1),d=s[0]*o,p=[];if(u>k4){for(let g=0;g<dy;g++){const y=g*d,b=y+d;p.push(...fw(r.slice(y,b),c,n,h,i,!1))}p.push("...");for(let g=u-dy;g<u;g++){const y=g*d,b=y+d;p.push(...fw(r.slice(y,b),c,n,h,i,g===u-1))}}else for(let g=0;g<u;g++){const y=g*d,b=y+d;p.push(...fw(r.slice(y,b),c,n,h,i,g===u-1))}const f=l===2?",":"";p[0]="["+(u>0?p[0]+f:"");for(let g=1;g<p.length-1;g++)p[g]=" "+p[g]+f;let m=`,
`;for(let g=2;g<l;g++)m+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":m),p}function ky(r){const t=[];for(let n=0;n<r.length;n+=2)t.push([r[n],r[n+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class td{constructor(t,n,s){if(this.dtype=n,this.shape=t.slice(),this.size=lt(t),s!=null){const i=s.length;oe(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||rs(n,this.size),this.strides=ws(t)}set(t,...n){n.length===0&&(n=[0]),oe(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(const i of t){if(i<0||i>=this.shape[n]){const a=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let s=t[t.length-1];for(let i=0;i<t.length-1;++i)s+=this.strides[i]*t[i];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let s=0;s<t.length-1;++s)n+=this.strides[s]*t[s];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(t/this.strides[s]),t-=n[s]*this.strides[s];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return bo().makeTensor(this.values,this.shape,this.dtype)}}let bo=null,Gf=null;function lde(r){bo=r}function cde(r){Gf=r}class Xr{constructor(t,n,s,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=lt(t),this.strides=ws(t),this.dataId=s,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Gf.buffer(this.shape,this.dtype,t)}bufferSync(){return Gf.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return $h(this.shape,t,this.dtype==="complex64")}arraySync(){return $h(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=bo().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map(s=>ed(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),bo().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=bo().readSync(this.dataId);if(this.dtype==="string")try{return t.map(n=>ed(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await bo().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),bo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Gf.print(this,t)}clone(){return this.throwIfDisposed(),Gf.clone(this)}toString(t=!1){const n=this.dataSync();return ode(n,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Gf.cast(this,t)}variable(t=!0,n,s){return this.throwIfDisposed(),bo().makeVariable(this,t,n,s)}}Object.defineProperty(Xr,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function vG(){return lA("Tensor",()=>Xr)}vG();class Nb extends Xr{constructor(t,n,s,i){super(t.shape,t.dtype,t.dataId,i),this.trainable=n,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!En(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);bo().disposeTensor(this),this.dataId=t.dataId,bo().incRef(this,null)}dispose(){bo().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Nb,Symbol.hasInstance,{value:r=>r instanceof Xr&&r.assign!=null&&r.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var yk;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(yk||(yk={}));var bk;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(bk||(bk={}));var xk;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(xk||(xk={}));var vk;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(vk||(vk={}));var wk;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(wk||(wk={}));const hde={float32:vk,int32:bk,bool:xk,complex64:wk};function Fo(r,t){if(r==="string"||t==="string"){if(r==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${r} with ${t}`)}return hde[r][t]}function QS(r){return Fo(r,"int32")}function wG(r){return r!=null&&typeof r=="object"&&"texture"in r&&r.texture instanceof WebGLTexture}function SG(r){return typeof GPUBuffer<"u"&&r!=null&&typeof r=="object"&&"buffer"in r&&r.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ln(r,t){if(r.dtype===t.dtype)return[r,t];const n=Fo(r.dtype,t.dtype);return[r.cast(n),t.cast(n)]}function CG(r,t){oe(r.dtype===t.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${t.dtype}) input must match`)}function dde(r,t){return t.some(n=>n.id===r.id)}function r$(r){const t=[];return _G(r,t,new Set),t}function _G(r,t,n){if(r==null)return;if(r instanceof Xr){t.push(r);return}if(!pde(r))return;const s=r;for(const i in s){const a=s[i];n.has(a)||(n.add(a),_G(a,t,n))}}function pde(r){return Array.isArray(r)||typeof r=="object"}const fde=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:CG,getTensorsInContainer:r$,isTensorInList:dde,makeTypesMatch:Ln},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WE(r){return r.kernelName!=null}class N4{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class $m{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new N4}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,s=1){return t in this.registryFactory?(Wa(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(t);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new rde(this.backendInstance),!0}setupRegisteredKernels(){S2(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){S2(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=n.factory();if(s&&!(s instanceof aA)&&typeof s.then=="function"){const i=++this.pendingBackendInitId,a=s.then(o=>i<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,Wa(`Initialization of backend ${t} failed`),Wa(o.stack||o.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return Wa(`Initialization of backend ${t} failed`),Wa(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n],{success:i,asyncInit:a}=this.initializeBackend(s);if(a||i)return{name:s,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const s=this.state.tensorInfo.get(n),i=s.backend,a=this.readSync(n),o=i.refCount(n);i.disposeData(n,!0),s.backend=t,t.move(n,a,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let s=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let i;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=n(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(t,n,s){t();try{const i=s();return n(),i}catch(i){throw n(),i}}nextTensorId(){return $m.nextTensorId++}nextVariableId(){return $m.nextVariableId++}clone(t){const n=Ce.runKernel(ZS,{x:t}),s={x:t},i=o=>({x:()=>{const u="float32",l={x:o},c={dtype:u};return Ce.runKernel(YS,l,c)}}),a=[];return this.addTapeNode(this.state.activeScope.name,s,[n],i,a,{}),n}runKernel(t,n,s){if(this.backendName==null&&this.backend,!(kb(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,s){const i=this.backend.numDataIds();let a=0;s.forEach(l=>{a+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],u=i-n-a-o;if(u>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${u} data ids) after running '${t}'`)}runKernelFunc(t){let n,s=[];const i=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let u;this.backendName==null&&this.backend;let l;const c=WE(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(WE(t)){const{kernelName:m,inputs:g,attrs:y}=t;this.backendName==null&&this.backend;const b=kb(m,this.backendName);oe(b!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),u=()=>{const x=this.backend.numDataIds();l=b.kernelFunc({inputs:g,attrs:y,backend:this.backend});const w=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,x,w);const v=w.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(i){const S=this.getTensorsForGradient(m,g,v);s=this.saveTensorsForBackwardMode(S)}return v}}else{const{forwardFunc:m}=t,g=y=>{i&&(s=y.map(b=>this.keep(this.clone(b))))};u=()=>{const y=this.backend.numDataIds();l=this.tidy(()=>m(this.backend,g));const b=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,b),b}}const{inputs:h,attrs:d}=t,p=WE(t)?null:t.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=u():(f=this.profiler.profileKernel(c,h,()=>u()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),n=f.outputs)}),i&&this.addTapeNode(c,h,n,p,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(m=>h[m]!=null?h[m].shape:null),outputShapes:n.map(m=>m.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,n,s){const i=mk(t);if(i!=null){const a=i.inputsToSave||[],o=i.outputsToSave||[];let u;i.saveAllInputs?(oe(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),u=Object.keys(n).map(c=>n[c])):u=a.map(c=>n[c]);const l=s.filter((c,h)=>o[h]);return u.concat(l)}return[]}makeTensor(t,n,s,i){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",i=i||this.backend;let a=t;s==="string"&&Xu(t[0])&&(a=t.map(l=>Zu(l)));const o=i.write(a,n,s),u=new Xr(n,s,o,this.nextTensorId());if(this.trackTensor(u,i),s==="string"){const l=this.state.tensorInfo.get(o),c=Z8(a);this.state.numBytes+=c-l.bytes,l.bytes=c}return u}makeTensorFromDataId(t,n,s,i){s=s||"float32";const a={dataId:t,shape:n,dtype:s};return this.makeTensorFromTensorInfo(a,i)}makeTensorFromTensorInfo(t,n){const{dataId:s,shape:i,dtype:a}=t,o=new Xr(i,a,s,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(t,n=!0,s,i){s=s||this.nextVariableId().toString(),i!=null&&i!==t.dtype&&(t=t.cast(i));const a=new Nb(t,n,s,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*Eb(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof Nb||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*Eb(t.dtype);this.state.numBytes-=s}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,s,i,a,o){const u={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:s,saved:a},l=mk(t);l!=null&&(i=l.gradFunc),i!=null&&(u.gradient=c=>(c=c.map((h,d)=>{if(h==null){const p=s[d],f=ll(p.size,p.dtype);return this.makeTensor(f,p.shape,p.dtype)}return h}),i(c.length>1?c:c[0],a,o))),this.state.activeTape.push(u)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=r$(t),s=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const o=this.state.activeScope.track[a];!o.kept&&!s.has(o.id)&&o.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===i.id&&this.track(a)})}gradients(t,n,s,i=!1){if(oe(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));oe(a instanceof Xr,()=>"The result y returned by f() must be a tensor.");const o=ide(this.state.activeTape,n,a);if(!i&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const u={};u[a.id]=s??mde(a.shape),ade(u,o,c=>this.tidy(c),gde);const l=n.map(c=>u[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const h of c.saved)h.dispose()}),this.state.activeTape=null),{value:a,grads:l}})}customGrad(t){return oe(uc(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{oe(n.every(u=>u instanceof Xr),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const i={};n.forEach((u,l)=>{i[l]=u});const a=(u,l)=>(s=t(...n,l),oe(s.value instanceof Xr,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),oe(uc(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(u,l)=>{const c=s.gradFunc(u,l),h=Array.isArray(c)?c:[c];oe(h.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),oe(h.every(p=>p instanceof Xr),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return h.forEach((p,f)=>{d[f]=()=>p}),d};return this.runKernelFunc({forwardFunc:a,backwardsFunc:o,inputs:i})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){const n=Ba(),s=await this.backend.time(t);return s.wallMs=Ba()-n,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new N4;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}$m.nextTensorId=0;$m.nextVariableId=0;function mde(r){const t=oA(lt(r),"float32");return Ce.makeTensor(t,r,"float32")}function EG(){const r=rG();if(r._tfengine==null){const t=new tG(r);r._tfengine=new $m(t)}return Dhe(r._tfengine.ENV),lde(()=>r._tfengine),r._tfengine}const Ce=EG();function gde(r,t){const n={a:r,b:t};return Ce.runKernel(XS,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yde(){return typeof navigator<"u"&&navigator!=null}let Sk;function bde(r){Sk=r}function n$(r){if(Sk!==void 0)return Sk;if(r||yde()){if(r||(r=navigator),r.product==="ReactNative")return!0;const t=r.userAgent||r.vendor||(typeof window<"u"?window.opera:"");if(!t){const n=r;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function s$(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const xde=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:s$,isMobile:n$,mockIsMobile:bde},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ki=Be();ki.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ki.registerFlag("IS_BROWSER",()=>s$());ki.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ki.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ki.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));ki.registerFlag("PROD",()=>!1);ki.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ki.getBool("DEBUG"));ki.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ki.registerFlag("IS_TEST",()=>!1);ki.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ki.getBool("DEBUG"));ki.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ki.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ki.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function du(r,t){let n=r;if(ms(r))return t==="string"?[]:[r.length];if(wG(r)){const i=r.channels||"RGBA";return[r.height,r.width*i.length]}else if(SG(r))return[r.buffer.size/(t==null?4:Eb(t))];if(!Array.isArray(r))return[];const s=[];for(;Array.isArray(n)||ms(n)&&t!=="string";)s.push(n.length),n=n[0];return Array.isArray(r)&&Be().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&IG(r,s,[]),s}function IG(r,t,n){if(n=n||[],!Array.isArray(r)&&!ms(r)){oe(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}oe(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${r.length} elements`),oe(r.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${r.length} elements`);const s=t.slice(1);for(let i=0;i<r.length;++i)IG(r[i],s,n.concat(i))}function T4(r,t,n,s){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==t||r==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${r} tensor, but got ${t} tensor`)}}function ne(r,t,n,s="numeric"){if(r instanceof vG())return T4(s,r.dtype,t,n),r;let i=hg(r);if(i!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(i=s),T4(s,i,t,n),r==null||!ms(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){const l=r==null?"null":r.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const a=du(r,i);!ms(r)&&!Array.isArray(r)&&(r=[r]);const u=i!=="string"?bx(r,i):hu(r,[],!0);return Ce.makeTensor(u,a,i)}function Tb(r,t,n,s="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((a,o)=>ne(a,`${t}[${o}]`,n,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i$="__op";function we(r){const t=Object.keys(r);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const s=r[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+i$;const i=(...a)=>{Ce.startScope(n);try{const o=s(...a);return lc(o)&&console.error("Cannot return a Promise inside of tidy."),Ce.endScope(o),o}catch(o){throw Ce.endScope(null),o}};return Object.defineProperty(i,"name",{value:n,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vde(r,t){const n=ne(r,"real","complex"),s=ne(t,"imag","complex");Gs(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const i={real:n,imag:s};return Ce.runKernel(FA,i)}const cl=we({complex_:vde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dc(r,t,n,s){if(s==null)s=hg(r);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(SG(r)||wG(r)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return Ce.backend.createTensorFromGPUData(r,t||n,s)}if(!ms(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){aa(t);const i=lt(t),a=lt(n);oe(i===a,()=>`Based on the provided shape, [${t}], the tensor should have ${i} values but has ${a}`);for(let o=0;o<n.length;++o){const u=n[o],l=o===n.length-1?u!==lt(t.slice(o)):!0;oe(n[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!ms(r)&&!Array.isArray(r)&&(r=[r]),t=t||n,r=s!=="string"?bx(r,s):hu(r,[],!0),Ce.makeTensor(r,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qa(r,t,n){const s=du(r,n);return Dc(r,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rd={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Bo{static join(t){return new Bo(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>ms(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let s=0;s<t.length;s++){const i=t[s];s!==t.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=n+i.byteLength;this.shards.push({buffer:i,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);const i=n-t,a=new ArrayBuffer(i),o=new Uint8Array(a);let u=0;for(let l=s;l<this.shards.length;l++){const c=this.shards[l],d=t+u-c.start,p=u,m=Math.min(n,c.end)-c.start,g=new Uint8Array(c.buffer,d,m-d);if(o.set(g,p),u+=g.length,n<c.end)break}return a}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(i){return t<i.start?-1:t>=i.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=wde(this.shards,n);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function wde(r,t){let n=0,s=r.length;for(;n<=s;){const i=Math.floor((s-n)/2)+n,a=t(r[i]);if(a===0)return i;a<0?s=i:n=i+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sde(){Be().set("PROD",!0)}function Cde(){Be().set("DEBUG",!0)}function _de(){Be().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Ede(r){Be().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Ide(){Ce.disposeVariables()}function mo(){return Ce}function kde(){return Ce.memory()}function Nde(r){return Ce.profile(r)}function qt(r,t){return Ce.tidy(r,t)}function ii(r){r$(r).forEach(n=>n.dispose())}function Co(r){return Ce.keep(r)}function Tde(r){return Ce.time(r)}function Ade(r){return Ce.setBackend(r)}function Dde(){return Ce.ready()}function a$(){return Ce.backendName}function Fde(r){Ce.removeBackend(r)}function $de(r){return Ce.findBackend(r)}function Rde(r){return Ce.findBackendFactory(r)}function kG(r,t,n=1){return Ce.registerBackend(r,t,n)}function o$(){return Ce.backend}function Ode(r,t){Be().setPlatform(r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cc=4;async function Mde(r,t){const n=[],s=[],i=Array.isArray(r)?r.map(o=>o.name):Object.keys(r);for(let o=0;o<i.length;++o){const u=i[o],l=Array.isArray(r)?r[o].tensor:r[u];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${u}': ${l.dtype}`);const c={name:u,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const h=new Promise(async d=>{const p=await l.bytes(),f=p.reduce((y,b)=>y+b.length,0)+cc*p.length,m=new Uint8Array(f);let g=0;for(let y=0;y<p.length;y++){const b=p[y],x=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(x,g),g+=cc,m.set(b,g),g+=b.length}d(m)});s.push(h)}else s.push(l.data());t!=null&&(c.group=t),n.push(c)}const a=await Promise.all(s);return{data:Bde(a),specs:n}}function NG(r,t){const n=new Bo(r),s={};let i=0;for(const a of t){const o=Lde(a,(u,l)=>n.slice(i+u,i+l));s[a.name]=TG(a,n.slice(i,i+o)),i+=o}return s}function Lde(r,t){const n=lt(r.shape);let s;if("quantization"in r){const i=r.quantization;s=rd[i.dtype]}else if(r.dtype==="string"){let i=0;for(let a=0;a<n;a++)i+=cc+new Uint32Array(t(i,i+cc))[0];return i}else s=rd[r.dtype];return n*s}async function Pde(r,t){const n=lt(r.shape);let s;if("quantization"in r){const i=r.quantization;s=rd[i.dtype]}else if(r.dtype==="string"){let i=0;for(let a=0;a<n;a++)i+=cc+new Uint32Array(await t(i,i+cc))[0];return i}else s=rd[r.dtype];return n*s}function TG(r,t){const n=r.name,s=r.dtype,i=r.shape,a=lt(i);let o,u=0;if("quantization"in r){const l=r.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${r.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${r.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${r.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=rd[l.dtype],h=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){o=new Float32Array(h.length);for(let d=0;d<h.length;d++){const p=h[d];o[d]=p*l.scale+l.min}}else if(l.dtype==="float16")o=jde()(h);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);o=new Int32Array(h.length);for(let d=0;d<h.length;d++){const p=h[d];o[d]=Math.round(p*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);u+=a*c}else if(s==="string"){const l=lt(r.shape);o=[];for(let c=0;c<l;c++){const h=new Uint32Array(t.slice(u,u+cc))[0];u+=cc;const d=new Uint8Array(t.slice(u,u+h));o.push(d),u+=h}}else{const l=rd[s];if(s==="float32")o=new Float32Array(t);else if(s==="int32")o=new Int32Array(t);else if(s==="bool")o=new Uint8Array(t);else if(s==="complex64"){o=new Float32Array(t);const c=new Float32Array(o.length/2),h=new Float32Array(o.length/2);for(let m=0;m<c.length;m++)c[m]=o[m*2],h[m]=o[m*2+1];const d=qa(c,i,"float32"),p=qa(h,i,"float32"),f=cl(d,p);return d.dispose(),p.dispose(),f}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);u+=a*l}return qa(o,i,s)}async function A4(r,t,n){let s=new Uint8Array(t);for(;s.byteLength<n;){const{done:i,value:a}=await r.read();if(i&&a==null){const u=n-s.byteLength;throw new Error(`Reader is done but ${u} bytes are still expected`)}const o=new Uint8Array(s.length+a.byteLength);o.set(s,0),o.set(new Uint8Array(a),s.length),s=o}return s.buffer}async function AG(r,t){const n={},s=r.getReader();let i=new ArrayBuffer(0);for(const a of t){const o=await Pde(a,async(c,h)=>(i=await A4(s,i,h),i.slice(c,h)));i=await A4(s,i,o);const u=i.slice(0,o);i=i.slice(o);const l=TG(a,u);if(n[a.name]=l,a$()==="webgpu"){const c=o$();"uploadToGPU"in c&&lt(l.shape)>=Be().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return n}function Bde(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let t=0;const n=[];r.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const s=new Uint8Array(t);let i=0;return n.forEach(a=>{s.set(new Uint8Array(a.buffer),i),i+=a.byteLength}),s.buffer}const u$=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function D4(r){return u$?Buffer.byteLength(r,"utf8"):new Blob([r]).size}function Vde(r){if(u$)return Buffer.from(r).toString("base64");const t=new Uint8Array(r);let n="";for(let s=0,i=t.length;s<i;s++)n+=String.fromCharCode(t[s]);return btoa(n)}function zde(r){if(u$){const s=Buffer.from(r,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(r),n=new Uint8Array(t.length);for(let s=0;s<t.length;++s)n.set([t.charCodeAt(s)],s);return n.buffer}function Ude(r){return Bo.join(r)}function F4(r){const t="/";for(r=r.trim();r.endsWith(t);)r=r.slice(0,r.length-1);const n=r.split(t);return n[n.length-1]}function DG(r,t){const n={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:t};return r.signature!=null&&(n.signature=r.signature),r.userDefinedMetadata!=null&&(n.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(n.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(n.initializerSignature=r.initializerSignature),r.trainingConfig!=null&&(n.trainingConfig=r.trainingConfig),n}function FG(r,t,n){const s={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(s.trainingConfig=r.trainingConfig),r.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=n}return r.signature!=null&&(s.signature=r.signature),r.userDefinedMetadata!=null&&(s.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(s.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(s.initializerSignature=r.initializerSignature),s}async function l$(r,t){let n,s;return r.weightsManifest!=null&&([n,s]=await t(r.weightsManifest)),FG(r,n,s)}function xx(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:D4(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:D4(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:new Bo(r.weightData).byteLength}}function Ck(r){const t=[];for(const n of r)t.push(...n.weights);return t}function Wde(){const r=n=>{let s=n<<13,i=0;for(;(s&8388608)===0;)i-=8388608,s<<=1;return s&=-8388609,i+=947912704,s|i},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=r(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function Gde(){const r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let t=1;t<31;t++)r[t]=t<<23;for(let t=33;t<63;t++)r[t]=2147483648+(t-32<<23);return r}function Hde(){const r=new Uint32Array(64);for(let t=0;t<64;t++)r[t]=1024;return r[0]=r[32]=0,r}function jde(){const r=Wde(),t=Gde(),n=Hde();return s=>{const i=new ArrayBuffer(4*s.length),a=new Uint32Array(i);for(let o=0;o<s.length;o++){const u=s[o],l=r[n[u>>10]+(u&1023)]+t[u>>10];a[o]=l}return new Float32Array(i)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Fn.instance==null&&(Fn.instance=new Fn),Fn.instance}static registerSaveRouter(t){Fn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Fn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Fn.getHandlers(t,"save")}static getLoadHandlers(t,n){return Fn.getHandlers(t,"load",n)}static getHandlers(t,n,s){const i=[];return(n==="load"?Fn.getInstance().loadRouters:Fn.getInstance().saveRouters).forEach(o=>{const u=o(t,s);u!==null&&i.push(u)}),i}}const qde=r=>Fn.registerSaveRouter(r),Kde=r=>Fn.registerLoadRouter(r),Xde=r=>Fn.getSaveHandlers(r),Yde=(r,t)=>Fn.getLoadHandlers(r,t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _k="tensorflowjs",Ek=1,Th="models_store",jl="model_info_store";function $G(){if(!Be().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const r=typeof window>"u"?self:window,t=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Ik(r){const t=r.result;t.createObjectStore(Th,{keyPath:"modelPath"}),t.createObjectStore(jl,{keyPath:"modelPath"})}class nd{constructor(t){if(this.indexedDB=$G(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((s,i)=>{const a=this.indexedDB.open(_k,Ek);a.onupgradeneeded=()=>Ik(a),a.onsuccess=()=>{const o=a.result;if(n==null){const u=o.transaction(Th,"readonly"),c=u.objectStore(Th).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=h=>(o.close(),i(c.error)),u.oncomplete=()=>o.close()}else{n.weightData=Bo.join(n.weightData);const u=xx(n),l=o.transaction(jl,"readwrite");let c=l.objectStore(jl),h;try{h=c.put({modelPath:this.modelPath,modelArtifactsInfo:u})}catch(p){return i(p)}let d;h.onsuccess=()=>{d=o.transaction(Th,"readwrite");const p=d.objectStore(Th);let f;try{f=p.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:u})}catch(m){return i(m)}f.onsuccess=()=>s({modelArtifactsInfo:u}),f.onerror=m=>{c=l.objectStore(jl);const g=c.delete(this.modelPath);g.onsuccess=()=>(o.close(),i(f.error)),g.onerror=y=>(o.close(),i(f.error))}},h.onerror=p=>(o.close(),i(h.error)),l.oncomplete=()=>{d==null?o.close():d.oncomplete=()=>o.close()}}},a.onerror=o=>i(a.error)})}}nd.URL_SCHEME="indexeddb://";const RG=r=>Be().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(nd.URL_SCHEME)?Zde(r.slice(nd.URL_SCHEME.length)):null;Fn.registerSaveRouter(RG);Fn.registerLoadRouter(RG);function Zde(r){return new nd(r)}function Jde(r){return r.startsWith(nd.URL_SCHEME)?r.slice(nd.URL_SCHEME.length):r}class Qde{constructor(){this.indexedDB=$G()}async listModels(){return new Promise((t,n)=>{const s=this.indexedDB.open(_k,Ek);s.onupgradeneeded=()=>Ik(s),s.onsuccess=()=>{const i=s.result,a=i.transaction(jl,"readonly"),u=a.objectStore(jl).getAll();u.onsuccess=()=>{const l={};for(const c of u.result)l[c.modelPath]=c.modelArtifactsInfo;t(l)},u.onerror=l=>(i.close(),n(u.error)),a.oncomplete=()=>i.close()},s.onerror=i=>n(s.error)})}async removeModel(t){return t=Jde(t),new Promise((n,s)=>{const i=this.indexedDB.open(_k,Ek);i.onupgradeneeded=()=>Ik(i),i.onsuccess=()=>{const a=i.result,o=a.transaction(jl,"readwrite"),u=o.objectStore(jl),l=u.get(t);let c;l.onsuccess=()=>{if(l.result==null)return a.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const h=u.delete(t),d=()=>{c=a.transaction(Th,"readwrite");const f=c.objectStore(Th).delete(t);f.onsuccess=()=>n(l.result.modelArtifactsInfo),f.onerror=m=>s(l.error)};h.onsuccess=d,h.onerror=p=>(d(),a.close(),s(l.error))}},l.onerror=h=>(a.close(),s(l.error)),o.oncomplete=()=>{c==null?a.close():c.oncomplete=()=>a.close()}},i.onerror=a=>s(i.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wu="/",Hf="tensorflowjs_models",OG="info",epe="model_topology",tpe="weight_specs",rpe="weight_data",npe="model_metadata";function MG(r){return{info:[Hf,r,OG].join(Wu),topology:[Hf,r,epe].join(Wu),weightSpecs:[Hf,r,tpe].join(Wu),weightData:[Hf,r,rpe].join(Wu),modelMetadata:[Hf,r,npe].join(Wu)}}function LG(r){for(const t of Object.values(r))window.localStorage.removeItem(t)}function spe(r){const t=r.split(Wu);if(t.length<3)throw new Error(`Invalid key format: ${r}`);return t.slice(1,t.length-1).join(Wu)}function ipe(r){return r.startsWith(sd.URL_SCHEME)?r.slice(sd.URL_SCHEME.length):r}class sd{constructor(t){if(!Be().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=MG(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),i=xx(t),a=Bo.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,Vde(a));const o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:i}}catch{throw LG(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=s;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=i;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const u=JSON.parse(a);n.format=u.format,n.generatedBy=u.generatedBy,n.convertedBy=u.convertedBy,u.signature!=null&&(n.signature=u.signature),u.userDefinedMetadata!=null&&(n.userDefinedMetadata=u.userDefinedMetadata),u.modelInitializer!=null&&(n.modelInitializer=u.modelInitializer),u.initializerSignature!=null&&(n.initializerSignature=u.initializerSignature),u.trainingConfig!=null&&(n.trainingConfig=u.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=zde(o),n}}sd.URL_SCHEME="localstorage://";const PG=r=>Be().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(sd.URL_SCHEME)?ape(r.slice(sd.URL_SCHEME.length)):null;Fn.registerSaveRouter(PG);Fn.registerLoadRouter(PG);function ape(r){return new sd(r)}class ope{constructor(){oe(Be().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),oe(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},n=Hf+Wu,s=Wu+OG;for(let i=0;i<this.LS.length;++i){const a=this.LS.key(i);if(a.startsWith(n)&&a.endsWith(s)){const o=spe(a);t[o]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){t=ipe(t);const n=MG(t);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(n.info));return LG(n),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cm="://";class Zs{constructor(){this.managers={}}static getInstance(){return Zs.instance==null&&(Zs.instance=new Zs),Zs.instance}static registerManager(t,n){oe(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(cm)&&(t=t.slice(0,t.indexOf(cm))),oe(t.length>0,()=>"scheme must not be an empty string.");const s=Zs.getInstance();oe(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=n}static getManager(t){const n=Zs.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(Zs.getInstance().managers)}}function mw(r){if(r.indexOf(cm)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Zs.getSchemes().join(",")}`);return{scheme:r.split(cm)[0],path:r.split(cm)[1]}}async function BG(r,t,n=!1){oe(r!==t,()=>`Old path and new path are the same: '${r}'`);const s=Fn.getLoadHandlers(r);oe(s.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),oe(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${r}.`);const i=s[0],a=Fn.getSaveHandlers(t);oe(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),oe(a.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`);const o=a[0],u=mw(r).scheme,l=mw(r).path,c=u===mw(r).scheme,h=await i.load();n&&c&&await Zs.getManager(u).removeModel(l);const d=await o.save(h);return n&&!c&&await Zs.getManager(u).removeModel(l),d.modelArtifactsInfo}async function upe(){const r=Zs.getSchemes(),t={};for(const n of r){const s=await Zs.getManager(n).listModels();for(const i in s){const a=n+cm+i;t[a]=s[i]}}return t}async function lpe(r){const t=mw(r);return Zs.getManager(t.scheme).removeModel(t.path)}async function cpe(r,t){return BG(r,t,!1)}async function hpe(r,t){return BG(r,t,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dpe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(typeof window>"u"||!Be().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const i=this.functionRefs[s.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return pG(t)}}if(Be().get("IS_BROWSER")){Be().setPlatform("browser",new dpe);try{Zs.registerManager(sd.URL_SCHEME,new ope)}catch{}try{Zs.registerManager(nd.URL_SCHEME,new Qde)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ppe={importFetch:()=>require("node-fetch")};let GE;class fpe{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return Be().global.fetch!=null?Be().global.fetch(t,n):(GE==null&&(GE=ppe.importFetch()),GE(t,n))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(t)}decode(t,n){return t.length===0?"":new this.util.TextDecoder(n).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}Be().get("IS_NODE")&&!Be().get("IS_BROWSER")&&Be().setPlatform("node",new fpe);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tn(r,t="float32",n){return t=t||"float32",aa(r),new td(r,t,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mpe(r,t){const n=ne(r,"x","cast");if(!X8(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:n},i={dtype:t};return Ce.runKernel(YS,s,i)}const Or=we({cast_:mpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gpe(r){const n={x:ne(r,"x","clone","string_or_numeric")};return Ce.runKernel(ZS,n)}const Ju=we({clone_:gpe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c$(r,t=!1){console.log(r.toString(t))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */EG();const ype={buffer:Tn,cast:Or,clone:Ju,print:c$};cde(ype);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bpe(r,t){let n=ne(r,"a","add"),s=ne(t,"b","add");[n,s]=Ln(n,s);const i={a:n,b:s};return Ce.runKernel(XS,i)}const jt=we({add_:bpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xpe(r,t){let n=ne(r,"a","floorDiv"),s=ne(t,"b","floorDiv");[n,s]=Ln(n,s);const i={a:n,b:s};return Ce.runKernel(hD,i)}const h$=we({floorDiv_:xpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vpe(r,t){let n=ne(r,"a","div"),s=ne(t,"b","div");if([n,s]=Ln(n,s),n.dtype==="int32"&&s.dtype==="int32")return h$(n,s);const i={a:n,b:s},a={};return Ce.runKernel(QA,i,a)}const hn=we({div_:vpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wpe(r,t){let n=ne(r,"a","mul"),s=ne(t,"b","mul");[n,s]=Ln(n,s);const i={a:n,b:s};return Ce.runKernel(WD,i)}const xt=we({mul_:wpe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Spe(r){const t=ne(r,"x","abs");if(t.dtype==="complex64"){const n={x:t};return Ce.runKernel($A,n)}else{const n={x:t};return Ce.runKernel(cA,n)}}const qi=we({abs_:Spe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cpe(r){const n={x:ne(r,"x","acos")};return Ce.runKernel(hA,n)}const VG=we({acos_:Cpe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _pe(r){const n={x:ne(r,"x","acosh")};return Ce.runKernel(dA,n)}const zG=we({acosh_:_pe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Epe(r){oe(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),oe(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);const t=r.map((i,a)=>ne(i,`tensors${a}`,"addN")),n=t[0];t.forEach(i=>{if(i.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(i=>{if(!En(i.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=t;return Ce.runKernel(pA,s)}const UG=we({addN_:Epe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ipe(r,t=null,n=!1){const i={x:ne(r,"x","all","bool")},a={axis:t,keepDims:n};return Ce.runKernel(fA,i,a)}const WG=we({all_:Ipe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kpe(r,t=null,n=!1){const i={x:ne(r,"x","any","bool")},a={axis:t,keepDims:n};return Ce.runKernel(mA,i,a)}const GG=we({any_:kpe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Npe(r,t=0){const s={x:ne(r,"x","argMax")},i={axis:t};return Ce.runKernel(gA,s,i)}const d$=we({argMax_:Npe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tpe(r,t=0){const s={x:ne(r,"x","argMin")},i={axis:t};return Ce.runKernel(yA,s,i)}const HG=we({argMin_:Tpe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ape(r){const n={x:ne(r,"x","asin")};return Ce.runKernel(bA,n)}const jG=we({asin_:Ape});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dpe(r){const n={x:ne(r,"x","asinh")};return Ce.runKernel(xA,n)}const qG=we({asinh_:Dpe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fpe(r){const n={x:ne(r,"x","atan")};return Ce.runKernel(vA,n)}const KG=we({atan_:Fpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $pe(r,t){let n=ne(r,"a","atan2"),s=ne(t,"b","atan2");[n,s]=Ln(n,s);const i={a:n,b:s};return Ce.runKernel(SA,i)}const XG=we({atan2_:$pe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rpe(r){const n={x:ne(r,"x","atanh")};return Ce.runKernel(wA,n)}const YG=we({atanh_:Rpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZG(r,t,n,s,i="NHWC",a){const o=r[3],u=[...t,o],l=dg(i);return Ca(r,u,n,a,s,null,null,l)}function Pd(r,t,n,s,i,a,o="channelsLast"){const[u,l]=Ab(t);let c;if(o==="channelsLast")c=[u,l,r[3],r[3]];else if(o==="channelsFirst")c=[u,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${o}`);return Ca(r,c,n,s,i,a,!1,o)}function vx(r,t,n,s,i,a,o="NDHWC"){const[u,l,c]=kk(t);let h,d;if(o==="NDHWC")d="channelsLast",h=[u,l,c,r[4],r[4]];else if(o==="NCDHW")d="channelsFirst",h=[u,l,c,r[1],r[1]];else throw new Error(`Unknown dataFormat ${o}`);return wx(r,h,n,s,i,!1,d,a)}function Ca(r,t,n,s,i,a,o=!1,u="channelsLast"){let[l,c,h,d]=[-1,-1,-1,-1];if(u==="channelsLast")[l,c,h,d]=r;else if(u==="channelsFirst")[l,d,c,h]=r;else throw new Error(`Unknown dataFormat ${u}`);const[p,f,,m]=t,[g,y]=Ab(n),[b,x]=Ab(s),w=hm(p,b),v=hm(f,x),{padInfo:S,outHeight:E,outWidth:C}=Lpe(i,c,h,g,y,w,v,a,u),I=o?m*d:m;let _;return u==="channelsFirst"?_=[l,I,E,C]:u==="channelsLast"&&(_=[l,E,C,I]),{batchSize:l,dataFormat:u,inHeight:c,inWidth:h,inChannels:d,outHeight:E,outWidth:C,outChannels:I,padInfo:S,strideHeight:g,strideWidth:y,filterHeight:p,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:x,inShape:r,outShape:_,filterShape:t}}function wx(r,t,n,s,i,a=!1,o="channelsLast",u){let[l,c,h,d,p]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,h,d,p]=r;else if(o==="channelsFirst")[l,p,c,h,d]=r;else throw new Error(`Unknown dataFormat ${o}`);const[f,m,g,,y]=t,[b,x,w]=kk(n),[v,S,E]=kk(s),C=hm(f,v),I=hm(m,S),_=hm(g,E),{padInfo:A,outDepth:k,outHeight:N,outWidth:D}=Ppe(i,c,h,d,b,x,w,C,I,_,u),F=a?y*p:y;let P;return o==="channelsFirst"?P=[l,F,k,N,D]:o==="channelsLast"&&(P=[l,k,N,D,F]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:h,inWidth:d,inChannels:p,outDepth:k,outHeight:N,outWidth:D,outChannels:F,padInfo:A,strideDepth:b,strideHeight:x,strideWidth:w,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:C,effectiveFilterHeight:I,effectiveFilterWidth:_,dilationDepth:v,dilationHeight:S,dilationWidth:E,inShape:r,outShape:P,filterShape:t}}function Ope(r,t,n,s,i){s==null&&(s=p$(r,t,n));const a=r[0],o=r[1],u=Db((a-t+2*s)/n+1,i),l=Db((o-t+2*s)/n+1,i);return[u,l]}function Mpe(r,t,n,s,i,a){i==null&&(i=p$(r,t[0],s[0]));const o=[0,0,0,n];for(let u=0;u<3;u++)r[u]+2*i>=t[u]&&(o[u]=Db((r[u]-t[u]+2*i)/s[u]+1,a));return o}function p$(r,t,n,s=1){const i=hm(t,s);return Math.floor((r[0]*(n-1)-n+i)/2)}function Ab(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function kk(r){return typeof r=="number"?[r,r,r]:r}function hm(r,t){return t<=1?r:r+(r-1)*(t-1)}function Lpe(r,t,n,s,i,a,o,u,l){let c,h,d;if(typeof r=="number"){c={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};const f=Ope([t,n],a,s,r,u);h=f[0],d=f[1]}else if(r==="same"){h=Math.ceil(t/s),d=Math.ceil(n/i);const p=Math.max(0,(h-1)*s+a-t),f=Math.max(0,(d-1)*i+o-n),m=Math.floor(p/2),g=p-m,y=Math.floor(f/2),b=f-y;c={top:m,bottom:g,left:y,right:b,type:"SAME"}}else if(r==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-a+1)/s),d=Math.ceil((n-o+1)/i);else if(typeof r=="object"){const p=l==="channelsLast"?r[1][0]:r[2][0],f=l==="channelsLast"?r[1][1]:r[2][1],m=l==="channelsLast"?r[2][0]:r[3][0],g=l==="channelsLast"?r[2][1]:r[3][1];c={top:p,bottom:f,left:m,right:g,type:p===0&&f===0&&m===0&&g===0?"VALID":"EXPLICIT"},h=Db((t-a+p+f)/s+1,u),d=Db((n-o+m+g)/i+1,u)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:c,outHeight:h,outWidth:d}}function Ppe(r,t,n,s,i,a,o,u,l,c,h){let d,p,f,m;if(r==="valid"&&(r=0),typeof r=="number"){d={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};const y=Mpe([t,n,s,1],[u,l,c],1,[i,a,o],r,h);p=y[0],f=y[1],m=y[2]}else if(r==="same"){p=Math.ceil(t/i),f=Math.ceil(n/a),m=Math.ceil(s/o);const g=(p-1)*i+u-t,y=(f-1)*a+l-n,b=(m-1)*o+c-s,x=Math.floor(g/2),w=g-x,v=Math.floor(y/2),S=y-v,E=Math.floor(b/2),C=b-E;d={top:v,bottom:S,left:E,right:C,front:x,back:w,type:"SAME"}}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:d,outDepth:p,outHeight:f,outWidth:m}}function Db(r,t){if(!t)return Math.trunc(r);switch(t){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${t}`)}}function Fb(r){const[t,n,s]=Ab(r);return t===1&&n===1&&s===1}function oa(r,t){return Fb(r)||Fb(t)}function id(r){return Ab(r).every(t=>t>0)}function dg(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function to(r,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")oe(Qh(t),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(i=>{oe(Qh(i),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${n} but got pad ${i}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${t}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bpe(r,t){const s={x:ne(r,"x","reshape","string_or_numeric")},i={shape:t};return Ce.runKernel(lF,s,i)}const Qe=we({reshape_:Bpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vpe(r,t,n,s,i){const a=ne(r,"x","avgPool","float32"),o=1;oe(oa(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let u=a,l=!1;a.rank===3&&(l=!0,u=Qe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),oe(u.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${u.rank}.`),to("avgPool",s,i);const c={x:u},h={filterSize:t,strides:n,pad:s,dimRoundingMode:i};let d=Ce.runKernel(CA,c,h);return d=Or(d,a.dtype),l?Qe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const f$=we({avgPool_:Vpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zpe(r,t,n,s,i,a="NDHWC"){const o=ne(r,"x","avgPool3d","float32");let u=o,l=!1;o.rank===4&&(l=!0,u=Qe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),oe(u.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${u.rank}.`),oe(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),oe(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),to("avgPool3d",s,i);const c={x:u},h={filterSize:t,strides:n,pad:s,dimRoundingMode:i,dataFormat:a};let d=Ce.runKernel(_A,c,h);return d=Or(d,u.dtype),l?Qe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const JG=we({avgPool3d_:zpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Upe(r,t=0){oe(r.length>=1,()=>"Pass at least one tensor to concat");const n=Tb(r,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return Ju(n[0]);const s=n,i={axis:t};return Ce.runKernel(RA,s,i)}const zs=we({concat_:Upe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wpe(r,t,n=!1,s=!1){let i=ne(r,"a","matMul"),a=ne(t,"b","matMul");[i,a]=Ln(i,a);const o={a:i,b:a},u={transposeA:n,transposeB:s};return Ce.runKernel(EA,o,u)}const Vr=we({matMul_:Wpe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gpe(r){const n={x:ne(r,"x","sigmoid","float32")};return Ce.runKernel(EF,n)}const iu=we({sigmoid_:Gpe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hpe(r,t,n){const s=ne(r,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const i={x:s},a={begin:t,size:n};return Ce.runKernel(wF,i,a)}const en=we({slice_:Hpe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jpe(r){const n={x:ne(r,"x","tanh","float32")};return Ce.runKernel(HF,n)}const C2=we({tanh_:jpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qpe(r,t,n,s,i,a){const o=ne(r,"forgetBias","basicLSTMCell"),u=ne(t,"lstmKernel","basicLSTMCell"),l=ne(n,"lstmBias","basicLSTMCell"),c=ne(s,"data","basicLSTMCell"),h=ne(i,"c","basicLSTMCell"),d=ne(a,"h","basicLSTMCell"),p=zs([c,d],1),f=Vr(p,u),m=jt(f,l),g=m.shape[0],y=m.shape[1]/4,b=[g,y],x=en(m,[0,0],b),w=en(m,[0,y],b),v=en(m,[0,y*2],b),S=en(m,[0,y*3],b),E=jt(xt(iu(x),C2(w)),xt(h,iu(jt(o,v)))),C=xt(C2(E),iu(S));return[E,C]}const QG=we({basicLSTMCell_:qpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kpe(r,t,n){const s=ne(r,"x","batchToSpaceND"),i=t.reduce((u,l)=>u*l);oe(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),oe(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),oe(s.shape[0]%i===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${i}`);const a={x:s},o={blockShape:t,crops:n};return Ce.runKernel(IA,a,o)}const m$=we({batchToSpaceND_:Kpe});function Xpe(r){let t;return r.rank===0||r.rank===1?t=Qe(r,[1,1,1,r.size]):r.rank===2?t=Qe(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?t=Qe(r,[1,r.shape[0],r.shape[1],r.shape[2]]):t=r,t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ype(r,t,n,s,i,a){a==null&&(a=.001);const o=ne(r,"x","batchNorm"),u=ne(t,"mean","batchNorm"),l=ne(n,"variance","batchNorm");let c;i!=null&&(c=ne(i,"scale","batchNorm"));let h;s!=null&&(h=ne(s,"offset","batchNorm")),oe(u.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),oe(h==null||u.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),oe(c==null||u.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:Xpe(o),scale:c,offset:h,mean:u,variance:l},f={varianceEpsilon:a},m=Ce.runKernel(dD,p,f);return Qe(m,o.shape)}const Sx=we({batchNorm_:Ype});function Zpe(r,t,n,s,i,a){const o=ne(r,"x","batchNorm"),u=ne(t,"mean","batchNorm"),l=ne(n,"variance","batchNorm");let c;i!=null&&(c=ne(i,"scale","batchNorm"));let h;return s!=null&&(h=ne(s,"offset","batchNorm")),oe(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),oe(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`),oe(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&oe(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&oe(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),Sx(o,u,l,h,c,a)}const eH=we({batchNorm2d_:Zpe});function Jpe(r,t,n,s,i,a){const o=ne(r,"x","batchNorm"),u=ne(t,"mean","batchNorm"),l=ne(n,"variance","batchNorm");let c;i!=null&&(c=ne(i,"scale","batchNorm"));let h;return s!=null&&(h=ne(s,"offset","batchNorm")),oe(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),oe(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`),oe(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&oe(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&oe(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),Sx(o,u,l,h,c,a)}const tH=we({batchNorm3d_:Jpe});function Qpe(r,t,n,s,i,a){const o=ne(r,"x","batchNorm"),u=ne(t,"mean","batchNorm"),l=ne(n,"variance","batchNorm");let c;i!=null&&(c=ne(i,"scale","batchNorm"));let h;return s!=null&&(h=ne(s,"offset","batchNorm")),oe(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),oe(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`),oe(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&oe(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&oe(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),Sx(o,u,l,h,c,a)}const rH=we({batchNorm4d_:Qpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function efe(r,t,n){const s=ne(r,"x","bincount"),i=ne(t,"weights","bincount");oe(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),oe(n>=0,()=>`size must be non-negative, but got ${n}.`),oe(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);const a={x:s,weights:i},o={size:n};return Ce.runKernel(kA,a,o)}const g$=we({bincount_:efe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tfe(r,t){const n=ne(r,"x","bitwiseAnd"),s=ne(t,"y","bitwiseAnd");if(!En(n.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${s.shape}`);if(n.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${s.dtype}`);const i={a:n,b:s};return Ce.runKernel(NA,i)}const nH=we({bitwiseAnd_:tfe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rfe(r,t){const n=ne(r,"s0","broadcastArgs","int32"),s=ne(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const i={s0:n,s1:s};return Ce.runKernel(TA,i)}const sH=we({broadcastArgs_:rfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nfe(r,t){let n=ne(r,"broadcastTo","x");const s=n.shape;if(aa(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const c=n.shape.slice();for(;c.length<t.length;)c.unshift(1);n=Qe(n,c)}const i=n.shape,a=Array.from(t);for(let c=t.length-1;c>=0;c--)if(i[c]===t[c])a[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(a.map((c,h)=>c>1?h:-1).filter(c=>c>=0).length===0)return Ju(n);const u={x:n},l={reps:a};return Ce.runKernel(JS,u,l)}const dm=we({broadcastTo_:nfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sfe(r){const n={x:ne(r,"x","ceil","float32")};return Ce.runKernel(AA,n)}const iH=we({ceil_:sfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pg(r,t,n){aa(r),n=n||hg(t);const s={shape:r,value:t,dtype:n};return Ce.runKernel(uD,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ife(r,t,n){const s=ne(r,"x","clipByValue");if(oe(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return pg(s.shape,t,s.dtype);const i={x:s},a={clipValueMin:t,clipValueMax:n};return Ce.runKernel(DA,i,a)}const aH=we({clipByValue_:ife});function afe(r){return zs(r,0)}const oH=we({concat1d_:afe});function ofe(r,t){return zs(r,t)}const uH=we({concat2d_:ofe});function ufe(r,t){return zs(r,t)}const lH=we({concat3d_:ufe});function lfe(r,t){return zs(r,t)}const cH=we({concat4d_:lfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cfe(r,t,n,s,i="NHWC",a=[1,1],o){const u=ne(r,"x","conv2d","float32"),l=ne(t,"filter","conv2d","float32");let c=u,h=!1;u.rank===3&&(h=!0,c=Qe(u,[1,u.shape[0],u.shape[1],u.shape[2]])),oe(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),oe(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),to("conv2d",s,o);const d=i==="NHWC"?c.shape[3]:c.shape[1];oe(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),oe(oa(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),oe(id(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),oe(id(n),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:c,filter:l},f={strides:n,pad:s,dataFormat:i,dilations:a,dimRoundingMode:o},m=Ce.runKernel(OA,p,f);return h?Qe(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const Cx=we({conv2d_:cfe});function hfe(r,t,n,s,i="NWC",a=1,o){const u=ne(r,"x","conv1d"),l=ne(t,"filter","conv1d");let c=u,h=!1;u.rank===2&&(h=!0,c=Qe(u,[1,u.shape[0],u.shape[1]])),oe(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),oe(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),to("conv1d",s,o),oe(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),oe(oa(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),oe(id(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),oe(id(n),()=>"Error in conv1D: Stride should be larger than 0."),oe(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const d=Qe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=Qe(c,[c.shape[0],1,c.shape[1],c.shape[2]]),y=Cx(p,d,[1,n],s,"NHWC",[1,a],o);return h?Qe(y,[y.shape[2],y.shape[3]]):Qe(y,[y.shape[0],y.shape[2],y.shape[3]])}const hH=we({conv1d_:hfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dfe(r,t,n,s,i,a="NHWC",o){oe(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let u=r,l=t,c=!1;t.rank===3&&(c=!0,l=Qe(t,[1,t.shape[0],t.shape[1],t.shape[2]]),u=[1,r[0],r[1],r[2]]),oe(u.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${u.length}.`),oe(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),oe(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const h=a==="NHWC"?u[3]:u[1],d=a==="NHWC"?l.shape[3]:l.shape[1];oe(h===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[2]}.`),oe(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),to("conv2dDerInput",i,o);const p={dy:l,filter:n},f={strides:s,pad:i,dataFormat:a,dimRoundingMode:o,inputShape:u},m=Ce.runKernel(LA,p,f);return c?Qe(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const dH=we({conv2DBackpropInput_:dfe});function pfe(r,t,n,s,i,a){const o=ne(r,"x","conv2dTranspose"),u=ne(t,"filter","conv2dTranspose");return dH(n,o,u,s,i,"NHWC",a)}const pH=we({conv2dTranspose_:pfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ffe(r,t,n,s,i="NDHWC",a=[1,1,1]){const o=ne(r,"x","conv3d"),u=ne(t,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=Qe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),oe(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),oe(u.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${u.rank}.`),oe(l.shape[4]===u.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${u.shape[3]}.`),oe(oa(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),oe(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),oe(id(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),oe(id(n),()=>"Error in conv3D: Strides should be larger than 0.");const h={x:l,filter:u},d={strides:n,pad:s,dataFormat:i,dilations:a},p=Ce.runKernel(PA,h,d);return c?Qe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const fH=we({conv3d_:ffe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mfe(r,t,n,s,i){oe(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let a=r,o=t,u=!1;t.rank===4&&(u=!0,o=Qe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,r[0],r[1],r[2],r[3]]);const l=a[4],c=o.shape[4];oe(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),oe(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),oe(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),oe(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),oe(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const h={dy:o,filter:n},d={pad:i,strides:s,inputShape:a},p=Ce.runKernel(BA,h,d);return u?Qe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const gfe=we({conv3DBackpropInput_:mfe});function yfe(r,t,n,s,i){const a=ne(r,"x","conv3dTranspose"),o=ne(t,"filter","conv3dTranspose");return gfe(n,a,o,s,i)}const mH=we({conv3dTranspose_:yfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bfe(r){const n={x:ne(r,"x","cos","float32")};return Ce.runKernel(VA,n)}const gH=we({cos_:bfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xfe(r){const n={x:ne(r,"x","cosh","float32")};return Ce.runKernel(zA,n)}const yH=we({cosh_:xfe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vfe(r,t=0,n=!1,s=!1){const a={x:ne(r,"x","cumprod")},o={axis:t,exclusive:n,reverse:s};return Ce.runKernel(UA,a,o)}const bH=we({cumprod_:vfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wfe(r,t=0,n=!1,s=!1){const a={x:ne(r,"x","cumsum")},o={axis:t,exclusive:n,reverse:s};return Ce.runKernel(WA,a,o)}const xH=we({cumsum_:wfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sfe(r,t,n,s=!1){const i=ne(r,"x","denseBincount"),a=ne(t,"weights","denseBincount");oe(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),oe(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),oe(n>=0,()=>`size must be non-negative, but got ${n}.`),oe(a.size===i.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${a.shape}.`);const o={x:i,weights:a},u={size:n,binaryOutput:s};return Ce.runKernel(HA,o,u)}const vH=we({denseBincount_:Sfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cfe(r,t,n="NHWC"){const s=ne(r,"x","depthToSpace","float32"),i=n==="NHWC"?s.shape[1]:s.shape[2],a=n==="NHWC"?s.shape[2]:s.shape[3],o=n==="NHWC"?s.shape[3]:s.shape[1];oe(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),oe(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t}  for depthToSpace with input shape
    ${s.shape}`),oe(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${s.shape}`),oe(o%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`);const u={x:s},l={blockSize:t,dataFormat:n};return Ce.runKernel(jA,u,l)}const wH=we({depthToSpace_:Cfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _fe(r,t,n,s,i="NHWC",a=[1,1],o){const u=ne(r,"x","depthwiseConv2d","float32"),l=ne(t,"filter","depthwiseConv2d","float32");let c=u,h=!1;u.rank===3&&(h=!0,c=Qe(u,[1,u.shape[0],u.shape[1],u.shape[2]])),oe(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),oe(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=i==="NHWC"?c.shape[3]:c.shape[1];oe(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),to("depthwiseConv2d",s,o);const p={x:c,filter:l},f={strides:n,pad:s,dataFormat:i,dilations:a,dimRoundingMode:o},m=Ce.runKernel(qA,p,f);return h?Qe(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const eC=we({depthwiseConv2d_:_fe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Efe(r){const n={x:ne(r,"x","diag")};return Ce.runKernel(YA,n)}const SH=we({diag_:Efe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ife(r,t,n,s,i=[1,1],a="NHWC"){const o=ne(r,"x","dilation2d"),u=ne(t,"filter","dilation2d");oe(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),oe(u.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${u.rank}.`),oe(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=o,c=!1;o.rank===3&&(l=Qe(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),oe(l.shape[3]===u.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${u.shape[2]}`);const h={x:l,filter:u},d={strides:n,pad:s,dilations:i},p=Ce.runKernel(ZA,h,d);return c?Qe(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const CH=we({dilation2d_:Ife});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $b(r,t){const n=r.length,s=[];for(let i=0;i<n;i++){const a=n-1-i,o=r[a]||1;(t[t.length-1-i]||1)>1&&o===1&&s.unshift(a)}return s}function y$(r,t){const n=[];for(let s=0;s<t.length;s++){const i=r[r.length-s-1],a=t.length-s-1,o=t[a];(i==null||i===1&&o>1)&&n.unshift(a)}return n}function Fr(r,t){const n=Math.max(r.length,t.length),s=new Array(n);for(let i=0;i<n;i++){let a=r[r.length-i-1];a==null&&(a=1);let o=t[t.length-i-1];if(o==null&&(o=1),a===1)s[n-i-1]=o;else if(o===1)s[n-i-1]=a;else if(a!==o){const u=`Operands could not be broadcast together with shapes ${r} and ${t}.`;throw Error(u)}else s[n-i-1]=a}return s}const kfe=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:Fr,getBroadcastDims:$b,getReductionAxes:y$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nfe(r,t){let n=ne(r,"a","equal","string_or_numeric"),s=ne(t,"b","equal","string_or_numeric");[n,s]=Ln(n,s),Fr(n.shape,s.shape);const i={a:n,b:s};return Ce.runKernel(nD,i)}const _x=we({equal_:Nfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tfe(r,t,n){const s=ne(t,"a","where"),i=ne(n,"b","where"),a=ne(r,"condition","where","bool"),o=Fr(Fr(a.shape,s.shape),i.shape),u=dm(a,o),l=dm(s,o),c=dm(i,o),h={condition:u,t:l,e:c};return Ce.runKernel(xF,h)}const Qu=we({where_:Tfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Afe(r){const n={x:ne(r,"x","zerosLike")};return Ce.runKernel(ZF,n)}const Ji=we({zerosLike_:Afe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dfe(r,t){let n=ne(r,"a","div"),s=ne(t,"b","div");[n,s]=Ln(n,s);const i=hn(n,s),a=Ji(i),o=_x(s,a);return Qu(o,a,i)}const _H=we({divNoNan_:Dfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ffe(r,t){const n=ne(r,"t1","dot"),s=ne(t,"t2","dot");oe((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const i=n.rank===1?n.size:n.shape[1],a=s.rank===1?s.size:s.shape[0];if(oe(i===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${a}.`),n.rank===1&&s.rank===1){const o=Qe(n,[1,-1]),u=Qe(s,[-1,1]),l=Vr(o,u);return Qe(l,[])}else if(n.rank===1&&s.rank===2){const o=Qe(n,[1,-1]),u=Qe(s,[s.shape[0],s.shape[1]]),l=Vr(o,u);return Qe(l,[l.size])}else if(n.rank===2&&s.rank===1){const o=Qe(s,[-1,1]),u=Vr(n,o);return Qe(u,[u.size])}else{const o=Qe(s,[s.shape[0],s.shape[1]]);return Vr(n,o)}}const EH=we({dot_:Ffe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $fe(r,...t){const n=t.map((i,a)=>ne(i,`tensors${a}`,"einsum")),s={equation:r};return Ce.runKernel(eD,n,s)}const vh=we({einsum_:$fe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rfe(r){const n={x:ne(r,"x","elu","float32")};return Ce.runKernel(tD,n)}const b$=we({elu_:Rfe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ofe(r,t){const n=ne(r,"x","ensureShape","string_or_numeric");if(!j8(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return r}const IH=we({ensureShape_:Ofe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mfe(r){let t=ne(r,"x","erf");oe(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Or(t,"float32"));const n={x:t};return Ce.runKernel(rD,n)}const kH=we({erf_:Mfe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x$(r,t){for(let n=0;n<r.length;++n)if(r[r.length-n-1]!==t-1-n)return!1;return!0}function NH(r,t,n){const s=r.length+t.length,i=[];let a=0,o=0;for(let u=0;u<s;u++)n.indexOf(u)===-1?i.push(r[a++]):i.push(t[o++]);return i}function _u(r,t){const n=[],s=r.length;for(let a=0;a<s;a++)t.indexOf(a)===-1&&n.push(r[a]);const i=t.map(a=>r[a]);return[n,i]}function _a(r,t){const n=t.map(s=>1);return NH(r,n,t)}function Vo(r,t,n){oe(x$(t,n),()=>`${r} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function ro(r,t){if(x$(r,t))return null;const n=[];for(let s=0;s<t;++s)r.indexOf(s)===-1&&n.push(s);return r.forEach(s=>n.push(s)),n}function v$(r){return r.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function no(r,t){const n=[];for(let s=t-r;s<t;++s)n.push(s);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lfe(r,t=null,n=!1){const i={x:ne(r,"x","max")},a={reductionIndices:t,keepDims:n};return Ce.runKernel(FD,i,a)}const Rh=we({max_:Lfe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pfe(r,t=null,n=!1){const i={x:ne(r,"x","min")},a={axis:t,keepDims:n};return Ce.runKernel(PD,i,a)}const _2=we({min_:Pfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bfe(r,t){let n=ne(r,"base","pow"),s=ne(t,"exp","pow");[n,s]=Ln(n,s);const i={a:n,b:s};return Ce.runKernel(QD,i)}const Rm=we({pow_:Bfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mr(r,t){if((ms(r)&&t!=="string"||Array.isArray(r))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&ms(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Dc(r,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vfe(r){const n={x:ne(r,"x","sqrt","float32")};return Ce.runKernel(kF,n)}const pu=we({sqrt_:Vfe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zfe(r){const t=ne(r,"x","square"),n={};return Ce.runKernel("Square",{x:t},n)}const Ka=we({square_:zfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ufe(r,t=null,n=!1){let s=ne(r,"x","sum");s.dtype==="bool"&&(s=Or(s,"int32"));const i={x:s},a={axis:t,keepDims:n};return Ce.runKernel(NF,i,a)}const bn=we({sum_:Ufe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wfe(r,t="euclidean",n=null,s=!1){r=ne(r,"x","norm");const i=TH(r,t,n);let a=i.shape;if(s){const o=ls(n,r.shape);a=_a(i.shape,o)}return Qe(i,a)}function TH(r,t,n=null){if(r.rank===0)return qi(r);if(r.rank!==1&&n===null)return TH(Qe(r,[-1]),t,n);if(r.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return bn(qi(r),n);if(t===1/0)return Rh(qi(r),n);if(t===-1/0)return _2(qi(r),n);if(t==="euclidean"||t===2)return pu(bn(Rm(qi(r),mr(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Rh(bn(qi(r),n[0]),n[1]-1);if(t===1/0)return Rh(bn(qi(r),n[1]),n[0]);if(t===-1/0)return _2(bn(qi(r),n[1]),n[0]);if(t==="fro"||t==="euclidean")return pu(bn(Ka(r),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Ex=we({norm_:Wfe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gfe(r,t=null,n=!1){return Ex(r,"euclidean",t,n)}const AH=we({euclideanNorm_:Gfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hfe(r){const n={x:ne(r,"x","exp")};return Ce.runKernel(sD,n)}const hc=we({exp_:Hfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jfe(r,t=0){const n=ne(r,"x","expandDims","string_or_numeric");oe(t<=n.rank,()=>"Axis must be <= rank of the tensor");const s={input:n},i={dim:t};return Ce.runKernel(iD,s,i)}const vi=we({expandDims_:jfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qfe(r){const n={x:ne(r,"x","expm1")};return Ce.runKernel(aD,n)}const DH=we({expm1_:qfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kfe(r,t){const n=ne(r,"x","tile","string_or_numeric");oe(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const s={x:n},i={reps:t};return Ce.runKernel(JS,s,i)}const pm=we({tile_:Kfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xfe(r,t,n,s="float32"){t==null&&(t=r);const i=Tn([r,t],s),a=r<=t?r:t;for(let u=0;u<a;++u)i.set(1,u,u);const o=Qe(i.toTensor(),[r,t]);if(n==null)return o;if(n.length===1)return pm(vi(o,0),[n[0],1,1]);if(n.length===2)return pm(vi(vi(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return pm(vi(vi(vi(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const w$=we({eye_:Xfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yfe(r){const n={x:ne(r,"x","floor","float32")};return Ce.runKernel(cD,n)}const S$=we({floor_:Yfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zfe(r,t,n=0,s=0){const i=ne(r,"x","gather"),a=ne(t,"indices","gather","int32"),o={x:i,indices:a},u={axis:n,batchDims:s};return Ce.runKernel(pD,o,u)}const C$=we({gather_:Zfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jfe(r,t){let n=ne(r,"a","greater","string_or_numeric"),s=ne(t,"b","greater","string_or_numeric");[n,s]=Ln(n,s),Fr(n.shape,s.shape);const i={a:n,b:s};return Ce.runKernel(mD,i)}const fg=we({greater_:Jfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qfe(r,t){let n=ne(r,"a","greaterEqual","string_or_numeric"),s=ne(t,"b","greaterEqual","string_or_numeric");[n,s]=Ln(n,s),Fr(n.shape,s.shape);const i={a:n,b:s};return Ce.runKernel(gD,i)}const _$=we({greaterEqual_:Qfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eme(r){const n={input:ne(r,"input","imag")};return Ce.runKernel(bD,n)}const Ix=we({imag_:eme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tme(r){const n={x:ne(r,"x","isFinite")};return Ce.runKernel(xD,n)}const FH=we({isFinite_:tme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rme(r){const n={x:ne(r,"x","isInf")};return Ce.runKernel(vD,n)}const $H=we({isInf_:rme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nme(r){const n={x:ne(r,"x","isNaN")};return Ce.runKernel(wD,n)}const RH=we({isNaN_:nme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sme(r,t=.2){const s={x:ne(r,"x","leakyRelu")},i={alpha:t};return Ce.runKernel(SD,s,i)}const E$=we({leakyRelu_:sme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ime(r,t){let n=ne(r,"a","less","string_or_numeric"),s=ne(t,"b","less","string_or_numeric");[n,s]=Ln(n,s),Fr(n.shape,s.shape);const i={a:n,b:s};return Ce.runKernel(CD,i)}const E2=we({less_:ime});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ame(r,t){let n=ne(r,"a","lessEqual","string_or_numeric"),s=ne(t,"b","lessEqual","string_or_numeric");[n,s]=Ln(n,s),Fr(n.shape,s.shape);const i={a:n,b:s};return Ce.runKernel(_D,i)}const tC=we({lessEqual_:ame});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OH(r,t,n){if(n<=0)throw new Error("The number of values should be positive.");const s={start:r,stop:t,num:n};return Ce.runKernel(ED,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ome(r,t=5,n=1,s=1,i=.5){const a=ne(r,"x","localResponseNormalization");oe(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),oe(Qh(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=a,u=!1;a.rank===3&&(u=!0,o=Qe(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:o},c={depthRadius:t,bias:n,alpha:s,beta:i},h=Ce.runKernel(DD,l,c);return u?Qe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const MH=we({localResponseNormalization_:ome});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ume(r){const n={x:ne(r,"x","log","float32")};return Ce.runKernel(ID,n)}const Om=we({log_:ume});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lme(r){const n={x:ne(r,"x","log1p")};return Ce.runKernel(kD,n)}const I$=we({log1p_:lme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cme(r){return oe(uc(r),()=>"The f passed in grad(f) must be a function"),(t,n)=>{const s=ne(t,"x","tf.grad","string_or_numeric"),i=n!=null?ne(n,"dy","tf.grad"):null;return Ce.tidy(()=>{const{value:a,grads:o}=Ce.gradients(()=>r(s),[s],i);return i!=null&&Gs(a.shape,i.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),rC(o),o[0]})}}function hme(r){return oe(uc(r),()=>"The f passed in grads(f) must be a function"),(t,n)=>{oe(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=Tb(t,"args","tf.grads","string_or_numeric"),i=n!=null?ne(n,"dy","tf.grads"):null;return Ce.tidy(()=>{const{value:a,grads:o}=Ce.gradients(()=>r(...s),s,i);return i!=null&&Gs(a.shape,i.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),rC(o),o})}}function dme(r){return oe(uc(r),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{oe(t instanceof Xr,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),oe(n==null||n instanceof Xr,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:i}=Ce.gradients(()=>r(t),[t],n);return rC(s),{grad:s[0],value:i}}}function pme(r){return oe(uc(r),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{oe(Array.isArray(t)&&t.every(i=>i instanceof Xr),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),oe(n==null||n instanceof Xr,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=Ce.gradients(()=>r(...t),t,n);return n!=null&&Gs(s.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),rC(s.grads),s}}function LH(r,t){oe(uc(r),()=>"The f passed in variableGrads(f) must be a function"),oe(t==null||Array.isArray(t)&&t.every(c=>c instanceof Nb),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=t!=null;if(!n){t=[];for(const c in Ce.registeredVariables)t.push(Ce.registeredVariables[c])}const s=n?t.filter(c=>!c.trainable):null,i=t.length;t=t.filter(c=>c.trainable),oe(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const a=!0,{value:o,grads:u}=Ce.gradients(r,t,null,a);oe(u.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),oe(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return t.forEach((c,h)=>{u[h]!=null&&(l[c.name]=u[h])}),s!=null&&s.forEach(c=>l[c.name]=null),{value:o,grads:l}}function fu(r){return Ce.customGrad(r)}function rC(r){if(r.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fme(r){const n={x:ne(r,"x","neg")};return Ce.runKernel(GD,n)}const ko=we({neg_:fme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mme(r){const n={x:ne(r,"x","softplus")};return Ce.runKernel(IF,n)}const k$=we({softplus_:mme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gme(r){const t=ne(r,"x","logSigmoid");return fu(s=>({value:ko(k$(ko(s))),gradFunc:o=>xt(o,iu(ko(s)))}))(t)}const PH=we({logSigmoid_:gme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yme(r,t){let n=ne(r,"a","sub"),s=ne(t,"b","sub");[n,s]=Ln(n,s);const i={a:n,b:s};return Ce.runKernel(WF,i)}const hr=we({sub_:yme});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bme(r,t=-1){const n=ne(r,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return fu((i,a)=>{const u=Rh(i,t,!0),l=hr(i,u),c=hr(Or(l,"float32"),Om(bn(hc(l),t,!0)));return a([c]),{value:c,gradFunc:(d,p)=>{const[f]=p,m=!0,g=hc(f);return hr(d,xt(bn(d,t,m),g))}}})(n)}const BH=we({logSoftmax_:bme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xme(r,t=null,n=!1){const s=ne(r,"x","logSumExp"),i=ls(t,s.shape),a=Rh(s,i,!0),o=hr(s,a),u=hc(o),l=bn(u,i),c=Om(l),h=jt(Qe(a,c.shape),c);if(n){const d=_a(h.shape,i);return Qe(h,d)}return h}const N$=we({logSumExp_:xme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vme(r,t){const n=ne(r,"a","logicalAnd","bool"),s=ne(t,"b","logicalAnd","bool");Fr(n.shape,s.shape);const i={a:n,b:s};return Ce.runKernel(ND,i)}const Rb=we({logicalAnd_:vme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wme(r){const n={x:ne(r,"x","logicalNot","bool")};return Ce.runKernel(TD,n)}const T$=we({logicalNot_:wme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sme(r,t){const n=ne(r,"a","logicalOr","bool"),s=ne(t,"b","logicalOr","bool");Fr(n.shape,s.shape);const i={a:n,b:s};return Ce.runKernel(AD,i)}const A$=we({logicalOr_:Sme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cme(r,t){const n=ne(r,"a","logicalXor","bool"),s=ne(t,"b","logicalXor","bool");return Fr(n.shape,s.shape),Rb(A$(r,t),T$(Rb(r,t)))}const VH=we({logicalXor_:Cme});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v1=2147483648;function _me(r,t,n="left"){const s=ne(r,"sortedSequence","searchSorted"),i=ne(t,"values","searchSorted"),a=s.shape[s.shape.length-1],o=i.shape[i.shape.length-1],u=Qe(s,[-1,a]),l=Qe(i,[-1,o]);if(u.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(u.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(lt(l.shape)>=v1)throw new Error(`values tensor size must less than ${v1}`);if(u.shape[1]>=v1)throw new Error(`trailing dim_size must less than ${v1} for int32 output type, was ${u.shape[1]}`);const c={sortedSequence:u,values:l},h={side:n};return Ce.runKernel(bF,c,h)}const nC=we({searchSorted_:_me});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zH(r,t){return nC(r,t,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eme(r,t,n,s,i){const a=ne(r,"x","maxPool"),o=1;let u=a,l=!1;a.rank===3&&(l=!0,u=Qe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),oe(u.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${u.rank}.`),oe(oa(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),to("maxPool",s,i);const c={x:u},h={filterSize:t,strides:n,pad:s,dimRoundingMode:i},d=Ce.runKernel(RD,c,h);return l?Qe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const D$=we({maxPool_:Eme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ime(r,t=[1,1,1],n,s,i,a="NDHWC"){const o=ne(r,"x","maxPool3d");let u=o,l=!1;o.rank===4&&(l=!0,u=Qe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),oe(u.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${u.rank}.`),oe(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),to("maxPool3d",s,i);const c={x:u},h={filterSize:t,strides:n,pad:s,dimRoundingMode:i,dataFormat:a},d=Ce.runKernel(OD,c,h);return l?Qe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const UH=we({maxPool3d_:Ime});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kme(r,t,n,s,i=!1){const o={x:ne(r,"x","maxPoolWithArgmax")},u={filterSize:t,strides:n,pad:s,includeBatchInIndex:i},l=Ce.runKernel(MD,o,u);return{result:l[0],indexes:l[1]}}const WH=we({maxPoolWithArgmax_:kme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nme(r,t){let n=ne(r,"a","maximum"),s=ne(t,"b","maximum");[n,s]=Ln(n,s),n.dtype==="bool"&&(n=Or(n,"int32"),s=Or(s,"int32")),Fr(n.shape,s.shape);const i={a:n,b:s};return Ce.runKernel($D,i)}const F$=we({maximum_:Nme});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tme(r,t=null,n=!1){const i={x:ne(r,"x","mean")},a={axis:t,keepDims:n};return Ce.runKernel(LD,i,a)}const Ob=we({mean_:Tme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dc(r,t="float32"){if(aa(r),t==="complex64"){const s=dc(r,"float32"),i=dc(r,"float32");return cl(s,i)}const n=ll(lt(r),t);return Ce.makeTensor(n,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ql(r,t="float32"){if(aa(r),t==="complex64"){const s=ql(r,"float32"),i=dc(r,"float32");return cl(s,i)}const n=oA(lt(r),t);return Ce.makeTensor(n,r,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GH(r,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(r===void 0)return[];let s=ne(r,"x","meshgrid",r instanceof Xr?r.dtype:"float32");if(t===void 0)return[s];let i=ne(t,"y","meshgrid",t instanceof Xr?t.dtype:"float32");const a=lt(s.shape),o=lt(i.shape);return n==="xy"?(s=Qe(s,[1,-1]),i=Qe(i,[-1,1]),[Vr(ql([o,1],s.dtype),s),Vr(i,ql([1,a],i.dtype))]):(s=Qe(s,[-1,1]),i=Qe(i,[1,-1]),[Vr(s,ql([1,o],s.dtype)),Vr(ql([a,1],i.dtype),i)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ame(r,t){let n=ne(r,"a","minimum"),s=ne(t,"b","minimum");[n,s]=Ln(n,s),n.dtype==="bool"&&(n=Or(n,"int32"),s=Or(s,"int32")),Fr(n.shape,s.shape);const i={a:n,b:s};return Ce.runKernel(BD,i)}const Mb=we({minimum_:Ame});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dme(r,t,n){oe(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=ne(r,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");oe(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const i=n==="reflect"?1:0;for(let u=0;u<s.rank;u++)oe(t[u].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),oe(t[u][0]>=0&&t[u][0]<=s.shape[u]-i&&t[u][1]>=0&&t[u][1]<=s.shape[u]-i,()=>`Padding in dimension ${u} cannot be greater than or equal to ${s.shape[u]-i} or less than 0 for input of shape ${s.shape}`);const a={paddings:t,mode:n},o={x:s};return Ce.runKernel(VD,o,a)}const $$=we({mirrorPad_:Dme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fme(r,t){let n=ne(r,"a","mod"),s=ne(t,"b","mod");[n,s]=Ln(n,s);const i={a:n,b:s};return Ce.runKernel(zD,i)}const HH=we({mod_:Fme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $me(r,t=null,n=!1){r=ne(r,"x","moments");const s=ls(t,r.shape),i=Ob(r,s,n);let a=i.shape;n||(a=_a(i.shape,s));const o=Ka(hr(Or(r,"float32"),Qe(i,a))),u=Ob(o,s,n);return{mean:i,variance:u}}const jH=we({moments_:$me});function Rme(r,t,n,s){const i=ne(t,"data","multiRNNCell"),a=Tb(n,"c","multiRNNCell"),o=Tb(s,"h","multiRNNCell");let u=i;const l=[];for(let d=0;d<r.length;d++){const p=r[d](u,a[d],o[d]);l.push(p[0]),l.push(p[1]),u=p[1]}const c=[],h=[];for(let d=0;d<l.length;d+=2)c.push(l[d]),h.push(l[d+1]);return[c,h]}const qH=we({multiRNNCell_:Rme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ome(r,t,n,s=!1){const i=ne(r,"logits","multinomial"),a=i.size,o=i.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const l={logits:o===1?Qe(i,[1,-1]):i},c={numSamples:t,seed:n,normalized:s},h=Ce.runKernel(UD,l,c);return o===1?Qe(h,[h.size]):h}const KH=we({multinomial_:Ome});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mme(r,t){let n=ne(r,"a","notEqual","string_or_numeric"),s=ne(t,"b","notEqual","string_or_numeric");[n,s]=Ln(n,s),Fr(n.shape,s.shape);const i={a:n,b:s};return Ce.runKernel(HD,i)}const R$=we({notEqual_:Mme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lme(r,t,n=1,s=0,i="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:ne(r,"indices","oneHot","int32")},u={dtype:i,depth:t,onValue:n,offValue:s};return Ce.runKernel(YD,o,u)}const Lb=we({oneHot_:Lme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pme(r){const n={x:ne(r,"x","onesLike")};return Ce.runKernel(XD,n)}const XH=we({onesLike_:Pme});function Bme(r,t){const n=ne(r,"v1","outerProduct"),s=ne(t,"v2","outerProduct");oe(n.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${s.rank}.`);const i=Qe(n,[-1,1]),a=Qe(s,[1,-1]);return Vr(i,a)}const YH=we({outerProduct_:Bme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vme(r,t,n=0){const s=ne(r,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:t,constantValue:n},a={x:s};return Ce.runKernel(JD,a,i)}const Bd=we({pad_:Vme});function zme(r,t,n=0){return oe(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Bd(r,[t],n)}const ZH=we({pad1d_:zme});function Ume(r,t,n=0){return oe(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Bd(r,t,n)}const JH=we({pad2d_:Ume});function Wme(r,t,n=0){return oe(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Bd(r,t,n)}const O$=we({pad3d_:Wme});function Gme(r,t,n=0){return oe(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Bd(r,t,n)}const QH=we({pad4d_:Gme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hme(r,t,n){const s=ne(r,"x","spaceToBatchND");oe(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),oe(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),oe(s.shape.reduce((o,u,l)=>l>0&&l<=t.length?o&&(u+n[l-1][0]+n[l-1][1])%t[l-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const i={x:s},a={blockShape:t,paddings:n};return Ce.runKernel(TF,i,a)}const M$=we({spaceToBatchND_:Hme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jme(r,t,n,s,i,a,o){i==null&&(i=[1,1]),a==null&&(a=1),s===0&&(s="valid");const u=ne(r,"x","maxPool");let l=u,c=!1;u.rank===3&&(c=!0,l=Qe(u,[1,u.shape[0],u.shape[1],u.shape[2]])),oe(oa(a,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${i}'`);const h=Pd(l.shape,t,a,i,s),d=[h.dilationHeight,h.dilationWidth];let p;s==="same"?p=Kme([h.filterHeight,h.filterWidth],d):p=[[0,0],[0,0]];const f=d[0]===1&&d[1]===1,[m,g]=qme([h.inHeight,h.inWidth],d,p),y=f?s:"valid",b=f?l:M$(l,d,m),w=(n==="avg"?()=>f$(b,t,a,y,o):()=>D$(b,t,a,y,o))(),v=f?w:m$(w,d,g);return c?Qe(v,[v.shape[1],v.shape[2],v.shape[3]]):v}function qme(r,t,n){const s=n.map(h=>h[0]),i=n.map(h=>h[1]),a=r.concat(s,i),o=t.map((h,d)=>(h-a[d]%h)%h),u=i.map((h,d)=>h+o[d]),l=t.map((h,d)=>[s[d],u[d]]),c=t.map((h,d)=>[0,o[d]]);return[l,c]}function Kme(r,t){const s=r.map((o,u)=>o+(o-1)*(t[u]-1)).map(o=>o-1),i=s.map(o=>Math.floor(o/2)),a=s.map((o,u)=>o-i[u]);return s.map((o,u)=>[i[u],a[u]])}const ej=we({pool_:jme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xme(r,t){const n=ne(r,"x","prelu"),s=ne(t,"alpha","prelu"),i={x:n,alpha:s};return Ce.runKernel(eF,i)}const L$=we({prelu_:Xme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yme(r,t=null,n=!1){let s=ne(r,"x","prod");s.dtype==="bool"&&(s=Or(s,"int32"));const i={x:s},a={axis:t,keepDims:n};return Ce.runKernel(tF,i,a)}const tj=we({prod_:Yme});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zme(r,t,n,s){const i=r.map((h,d)=>ne(h,`tensors${d}`,"raggedGather","int32")),a=ne(t,"paramsDenseValues","raggedGather"),o=ne(n,"indices","raggedGather","int32"),u={paramsNestedSplits:i,paramsDenseValues:a,indices:o},l={outputRaggedRank:s},c=Ce.runKernel(rF,u,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const rj=we({raggedGather_:Zme});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jme(r,t,n){const s=ne(r,"starts","raggedRange"),i=ne(t,"limits","raggedRange",s.dtype),a=ne(n,"deltas","raggedRange",s.dtype),o={starts:s,limits:i,deltas:a},u=Ce.runKernel(nF,o);return{rtNestedSplits:u[0],rtDenseValues:u[1]}}const nj=we({raggedRange_:Jme});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qme(r,t,n,s,i){const a=ne(r,"shape","raggedTensorToTensor","int32"),o=ne(t,"values","raggedTensorToTensor"),u=ne(n,"defaultValue","raggedTensorToTensor",o.dtype),l=s.map((d,p)=>ne(d,`tensors${p}`,"raggedTensorToTensor","int32")),c={shape:a,values:o,defaultValue:u,rowPartitionTensors:l},h={rowPartitionTypes:i};return Ce.runKernel(sF,c,h)}const sj=we({raggedTensorToTensor_:Qme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ege(r,t,n){aa(r);const s=lt(r);let i=null;if(n==null||n==="float32")i=new Float32Array(s);else if(n==="int32")i=new Int32Array(s);else if(n==="bool")i=new Uint8Array(s);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<s;a++)i[a]=t();return Ce.makeTensor(i,r,n)}const ij=we({rand_:ege});var gw={exports:{}},tge=gw.exports,$4;function rge(){return $4||($4=1,function(r){(function(t,n,s){function i(l){var c=this,h=u();c.next=function(){var d=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=d|0)},c.c=1,c.s0=h(" "),c.s1=h(" "),c.s2=h(" "),c.s0-=h(l),c.s0<0&&(c.s0+=1),c.s1-=h(l),c.s1<0&&(c.s1+=1),c.s2-=h(l),c.s2<0&&(c.s2+=1),h=null}function a(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var h=new i(l),d=c&&c.state,p=h.next;return p.int32=function(){return h.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,d&&(typeof d=="object"&&a(d,h),p.state=function(){return a(h,{})}),p}function u(){var l=4022871197,c=function(h){h=String(h);for(var d=0;d<h.length;d++){l+=h.charCodeAt(d);var p=.02519603282416938*l;l=p>>>0,p-=l,p*=l,l=p>>>0,p-=l,l+=p*4294967296}return(l>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=o:this.alea=o})(tge,r)}(gw)),gw.exports}var yw={exports:{}},nge=yw.exports,R4;function sge(){return R4||(R4=1,function(r){(function(t,n,s){function i(u){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},u===(u|0)?l.x=u:c+=u;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,l.next()}function a(u,l){return l.x=u.x,l.y=u.y,l.z=u.z,l.w=u.w,l}function o(u,l){var c=new i(u),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,h&&(typeof h=="object"&&a(h,c),d.state=function(){return a(c,{})}),d}n&&n.exports?n.exports=o:this.xor128=o})(nge,r)}(yw)),yw.exports}var bw={exports:{}},ige=bw.exports,O4;function age(){return O4||(O4=1,function(r){(function(t,n,s){function i(u){var l=this,c="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,u===(u|0)?l.x=u:c+=u;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,h==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function a(u,l){return l.x=u.x,l.y=u.y,l.z=u.z,l.w=u.w,l.v=u.v,l.d=u.d,l}function o(u,l){var c=new i(u),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,h&&(typeof h=="object"&&a(h,c),d.state=function(){return a(c,{})}),d}n&&n.exports?n.exports=o:this.xorwow=o})(ige,r)}(bw)),bw.exports}var xw={exports:{}},oge=xw.exports,M4;function uge(){return M4||(M4=1,function(r){(function(t,n,s){function i(u){var l=this;l.next=function(){var h=l.x,d=l.i,p,f;return p=h[d],p^=p>>>7,f=p^p<<24,p=h[d+1&7],f^=p^p>>>10,p=h[d+3&7],f^=p^p>>>3,p=h[d+4&7],f^=p^p<<7,p=h[d+7&7],p=p^p<<13,f^=p^p<<9,h[d]=f,l.i=d+1&7,f};function c(h,d){var p,f=[];if(d===(d|0))f[0]=d;else for(d=""+d,p=0;p<d.length;++p)f[p&7]=f[p&7]<<15^d.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?f[7]=-1:f[p],h.x=f,h.i=0,p=256;p>0;--p)h.next()}c(l,u)}function a(u,l){return l.x=u.x.slice(),l.i=u.i,l}function o(u,l){u==null&&(u=+new Date);var c=new i(u),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,h&&(h.x&&a(h,c),d.state=function(){return a(c,{})}),d}n&&n.exports?n.exports=o:this.xorshift7=o})(oge,r)}(xw)),xw.exports}var vw={exports:{}},lge=vw.exports,L4;function cge(){return L4||(L4=1,function(r){(function(t,n,s){function i(u){var l=this;l.next=function(){var h=l.w,d=l.X,p=l.i,f,m;return l.w=h=h+1640531527|0,m=d[p+34&127],f=d[p=p+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=d[p]=m^f,l.i=p,m+(h^h>>>16)|0};function c(h,d){var p,f,m,g,y,b=[],x=128;for(d===(d|0)?(f=d,d=null):(d=d+"\0",f=0,x=Math.max(x,d.length)),m=0,g=-32;g<x;++g)d&&(f^=d.charCodeAt((g+32)%d.length)),g===0&&(y=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,g>=0&&(y=y+1640531527|0,p=b[g&127]^=f+y,m=p==0?m+1:0);for(m>=128&&(b[(d&&d.length||0)&127]=-1),m=127,g=4*128;g>0;--g)f=b[m+34&127],p=b[m=m+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,b[m]=f^p;h.w=y,h.X=b,h.i=m}c(l,u)}function a(u,l){return l.i=u.i,l.w=u.w,l.X=u.X.slice(),l}function o(u,l){u==null&&(u=+new Date);var c=new i(u),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,h&&(h.X&&a(h,c),d.state=function(){return a(c,{})}),d}n&&n.exports?n.exports=o:this.xor4096=o})(lge,r)}(vw)),vw.exports}var ww={exports:{}},hge=ww.exports,P4;function dge(){return P4||(P4=1,function(r){(function(t,n,s){function i(u){var l=this,c="";l.next=function(){var d=l.b,p=l.c,f=l.d,m=l.a;return d=d<<25^d>>>7^p,p=p-f|0,f=f<<24^f>>>8^m,m=m-d|0,l.b=d=d<<20^d>>>12^p,l.c=p=p-f|0,l.d=f<<16^p>>>16^m,l.a=m-d|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,u===Math.floor(u)?(l.a=u/4294967296|0,l.b=u|0):c+=u;for(var h=0;h<c.length+20;h++)l.b^=c.charCodeAt(h)|0,l.next()}function a(u,l){return l.a=u.a,l.b=u.b,l.c=u.c,l.d=u.d,l}function o(u,l){var c=new i(u),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,h&&(typeof h=="object"&&a(h,c),d.state=function(){return a(c,{})}),d}n&&n.exports?n.exports=o:this.tychei=o})(hge,r)}(ww)),ww.exports}var Sw={exports:{}};const pge={},fge=Object.freeze(Object.defineProperty({__proto__:null,default:pge},Symbol.toStringTag,{value:"Module"})),mge=aae(fge);var gge=Sw.exports,B4;function yge(){return B4||(B4=1,function(r){(function(t,n,s){var i=256,a=6,o=52,u="random",l=s.pow(i,a),c=s.pow(2,o),h=c*2,d=i-1,p;function f(v,S,E){var C=[];S=S==!0?{entropy:!0}:S||{};var I=b(y(S.entropy?[v,w(n)]:v??x(),3),C),_=new m(C),A=function(){for(var k=_.g(a),N=l,D=0;k<c;)k=(k+D)*i,N*=i,D=_.g(1);for(;k>=h;)k/=2,N/=2,D>>>=1;return(k+D)/N};return A.int32=function(){return _.g(4)|0},A.quick=function(){return _.g(4)/4294967296},A.double=A,b(w(_.S),n),(S.pass||E||function(k,N,D,F){return F&&(F.S&&g(F,_),k.state=function(){return g(_,{})}),D?(s[u]=k,N):k})(A,I,"global"in S?S.global:this==s,S.state)}function m(v){var S,E=v.length,C=this,I=0,_=C.i=C.j=0,A=C.S=[];for(E||(v=[E++]);I<i;)A[I]=I++;for(I=0;I<i;I++)A[I]=A[_=d&_+v[I%E]+(S=A[I])],A[_]=S;(C.g=function(k){for(var N,D=0,F=C.i,P=C.j,G=C.S;k--;)N=G[F=d&F+1],D=D*i+G[d&(G[F]=G[P=d&P+N])+(G[P]=N)];return C.i=F,C.j=P,D})(i)}function g(v,S){return S.i=v.i,S.j=v.j,S.S=v.S.slice(),S}function y(v,S){var E=[],C=typeof v,I;if(S&&C=="object")for(I in v)try{E.push(y(v[I],S-1))}catch{}return E.length?E:C=="string"?v:v+"\0"}function b(v,S){for(var E=v+"",C,I=0;I<E.length;)S[d&I]=d&(C^=S[d&I]*19)+E.charCodeAt(I++);return w(S)}function x(){try{var v;return p&&(v=p.randomBytes)?v=v(i):(v=new Uint8Array(i),(t.crypto||t.msCrypto).getRandomValues(v)),w(v)}catch{var S=t.navigator,E=S&&S.plugins;return[+new Date,t,E,t.screen,w(n)]}}function w(v){return String.fromCharCode.apply(0,v)}if(b(s.random(),n),r.exports){r.exports=f;try{p=mge}catch{}}else s["seed"+u]=f})(typeof self<"u"?self:gge,[],Math)}(Sw)),Sw.exports}var HE,V4;function bge(){if(V4)return HE;V4=1;var r=rge(),t=sge(),n=age(),s=uge(),i=cge(),a=dge(),o=yge();return o.alea=r,o.xor128=t,o.xorwow=n,o.xorshift7=s,o.xor4096=i,o.tychei=a,HE=o,HE}var P$=bge();/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xge=.001,aj=.1;function vge(r,t,n){return n==null&&(n=B$()),Nk(r,t,(s,i)=>V$(s,i,n))}function B$(){return Ce.backend.floatPrecision()===32?xge:aj}function Nk(r,t,n){let s=!0;if((ms(r)||ms(t))&&(s=!1),ms(r)&&ms(t)&&(s=!0),s){const o=r.constructor.name,u=t.constructor.name;if(o!==u)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${u}`)}if(Array.isArray(r)&&Array.isArray(t)){const o=du(r),u=du(t);if(!En(o,u))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${u}]`)}const i=ms(r)?r:hu(r),a=ms(t)?t:hu(t);if(i.length!==a.length)throw new Error(`Arrays have different lengths actual: ${i.length} vs expected: ${a.length}.
Actual:   ${i}.
Expected: ${a}.`);for(let o=0;o<a.length;++o){const u=i[o],l=a[o];if(!n(u,l))throw new Error(`Arrays differ: actual[${o}] = ${u}, expected[${o}] = ${l}.
Actual:   ${i}.
Expected: ${a}.`)}typeof expect<"u"&&expect().nothing()}function wge(r,t){r().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function Sge(r,t){const n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Xu(r)||Xu(r[0])||Xu(t)||Xu(t[0])?Nk(r,n,(s,i)=>s==i):Nk(r,t,(s,i)=>V$(s,i,0))}function Cge(r,t,n){if(n==null&&(n=B$()),!V$(r,t,n))throw new Error(`Numbers differ: actual === ${r}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function V$(r,t,n){return!isFinite(r)&&!isFinite(t)?!0:!(isNaN(r)||isNaN(t)||Math.abs(r-t)>n)}function _ge(r,t,n){for(let s=0;s<r.length;s++)if(r[s]<t||r[s]>n)throw new Error(`Value out of range:${r[s]} low: ${t}, high: ${n}`)}function Ege(r,t){const n=new Float32Array(r),s=new Float32Array(t);if(n.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${n.length}`);for(let i=0;i<s.length;i++)if(n[i]!==s[i])throw new Error(`Expected ArrayBuffer value at ${i} to be ${s[i]} but got ${n[i]} instead`)}function oj(r){for(let t=0;t<r.length;t++){const n=r[t];Array.isArray(n)?oj(n):r[t]=Zu(n)}return r}function Ige(r){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(r),new Promise(n=>{t.addEventListener("loadeddata",s=>n(t)),t.load()})}async function kge(r){await r.play(),"requestVideoFrameCallback"in r&&await new Promise(t=>{r.requestVideoFrameCallback(t)})}const Nge=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:aj,createVideoElement:Ige,encodeStrings:oj,expectArrayBuffersEqual:Ege,expectArraysClose:vge,expectArraysEqual:Sge,expectNumbersClose:Cge,expectPromiseToFail:wge,expectValuesInRange:_ge,play:kge,testEpsilon:B$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z${constructor(t,n,s,i,a){this.mean=t,this.stdDev=n,this.dtype=s,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=a||Math.random();this.random=P$.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let t,n,s=!1;for(;!s;){let i,a,o;do i=2*this.random()-1,a=2*this.random()-1,o=i*i+a*a;while(o>=1||o===0);const u=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*i*u,n=this.mean+this.stdDev*a*u,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class Tge{constructor(t,n,s,i){this.alpha=t,this.beta=1/n,this.dtype=s;const a=i||Math.random();this.randu=P$.alea(a.toString()),this.randn=new z$(0,1,s,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,n,s,i,a,o;for(;;){do i=this.randn.nextValue(),o=1+this.c*i;while(o<=0);if(o*=o*o,t=i*i,n=1-.331*t*t,s=.5*t+this.d*(1-o+Math.log(o)),a=this.randu(),a<n||Math.log(a)<s)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}}class Age{constructor(t=0,n=1,s,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=n-t,this.dtype=s,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`);this.random=P$.alea(i)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dge(r,t,n=1,s="float32",i){if(aa(r),n==null&&(n=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const a=new Tge(t,n,s,i),o=Tn(r,s);for(let u=0;u<o.values.length;u++)o.values[u]=a.nextValue();return o.toTensor()}const uj=we({randomGamma_:Dge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fge(r,t=0,n=1,s,i){if(aa(r),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const a=new z$(t,n,s,!1,i),o=Tn(r,s);for(let u=0;u<o.values.length;u++)o.values[u]=a.nextValue();return o.toTensor()}const U$=we({randomNormal_:Fge});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ge(r,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return U$(r,0,1,t,n)}const lj=we({randomStandardNormal_:$ge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rge(r,t=0,n=1,s="float32",i){aa(r);const a=Tn(r,s),o=new Age(t,n,null,i);for(let u=0;u<a.values.length;u++)a.values[u]=o.nextValue();return a.toTensor()}const sC=we({randomUniform_:Rge});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oge(r,t,n,s){return sC(r,t,n,"int32",s)}const cj=we({randomUniformInt_:Oge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pc(r,t,n=1,s="float32"){if(n===0)throw new Error("Cannot have a step of zero");const i={start:r,stop:t,step:n,dtype:s};return Ce.runKernel(iF,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mge(r){const n={input:ne(r,"input","real")};return Ce.runKernel(aF,n)}const Mm=we({real_:Mge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lge(r){const n={x:ne(r,"x","reciprocal")};return Ce.runKernel(oF,n)}const hj=we({reciprocal_:Lge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pge(r){const n={x:ne(r,"x","relu")};return Ce.runKernel(uF,n)}const kx=we({relu_:Pge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bge(r){const n={x:ne(r,"x","relu6")};return Ce.runKernel(dF,n)}const W$=we({relu6_:Bge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vge(r,t){const s={x:ne(r,"x","reverse")},i={dims:t};return Ce.runKernel(pF,s,i)}const fc=we({reverse_:Vge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zge(r){const t=ne(r,"x","reverse");return oe(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),fc(t,0)}const dj=we({reverse1d_:zge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uge(r,t){const n=ne(r,"x","reverse");return oe(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),fc(n,t)}const pj=we({reverse2d_:Uge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wge(r,t){const n=ne(r,"x","reverse");return oe(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),fc(n,t)}const fj=we({reverse3d_:Wge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gge(r,t){const n=ne(r,"x","reverse");return oe(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),fc(n,t)}const mj=we({reverse4d_:Gge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hge(r){const n={x:ne(r,"x","round")};return Ce.runKernel(fF,n)}const G$=we({round_:Hge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jge(r){const n={x:ne(r,"x","rsqrt","float32")};return Ce.runKernel(mF,n)}const gj=we({rsqrt_:jge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qge(r){const n={x:ne(r,"x","selu")};return Ce.runKernel(vF,n)}const yj=we({selu_:qge});function Kge(r,t,n,s,i,a=[1,1],o="NHWC"){const u=ne(r,"x","separableConv2d"),l=ne(t,"depthwiseFilter","separableConv2d"),c=ne(n,"pointwiseFilter","separableConv2d");let h=u,d=!1;if(u.rank===3&&(d=!0,h=Qe(u,[1,u.shape[0],u.shape[1],u.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");oe(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),oe(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),oe(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),oe(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),oe(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const p=l.shape[2],f=l.shape[3];oe(c.shape[2]===p*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*f}, but got ${c.shape[2]}.`);const m=eC(h,l,s,i,o,a),y=Cx(m,c,1,"valid",o);return d?Qe(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const bj=we({separableConv2d_:Kge});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Xge(r,t){const n=ne(r,"x","setdiff1d"),s=ne(t,"y","setdiff1d");oe(n.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`),oe(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),oe(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const i=await n.data(),a=await s.data(),o=new Set(a);let u=0;for(let h=0;h<i.length;h++)o.has(i[h])||u++;const l=new td([u],n.dtype),c=new td([u],"int32");for(let h=0,d=0;h<i.length;h++)o.has(i[h])||(l.values[d]=i[h],c.values[d]=h,d++);return[l.toTensor(),c.toTensor()]}const xj=Xge;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yge(r){const n={x:ne(r,"x","sign")};return Ce.runKernel(_F,n)}const vj=we({sign_:Yge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zge(r){const n={x:ne(r,"x","sin","float32")};return Ce.runKernel(SF,n)}const wj=we({sin_:Zge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jge(r){const n={x:ne(r,"x","sinh")};return Ce.runKernel(CF,n)}const Sj=we({sinh_:Jge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qge(r,t,n){const s=ne(r,"x","slice1d");return oe(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),en(s,[t],[n])}const Cj=we({slice1d_:Qge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e0e(r,t,n){const s=ne(r,"x","slice2d");return oe(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),en(s,t,n)}const _j=we({slice2d_:e0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t0e(r,t,n){const s=ne(r,"x","slice3d");return oe(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),en(s,t,n)}const Ej=we({slice3d_:t0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r0e(r,t,n){const s=ne(r,"x","slice4d");return oe(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),en(s,t,n)}const Ij=we({slice4d_:r0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n0e(r,t=-1){const n=ne(r,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const s={logits:n},i={dim:t};return Ce.runKernel(DF,s,i)}const kj=we({softmax_:n0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s0e(r){oe(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);const t={input:r};return Ce.runKernel(oD,t)}const iC=we({fft_:s0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i0e(r){oe(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);const t={input:r};return Ce.runKernel(yD,t)}const Pb=we({ifft_:i0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a0e(r){const t=r.shape[r.shape.length-1],n=r.size/t;let s;if(t<=2){const i=Qe(r,[n,t]);s=Pb(i)}else{const i=[n,2*(t-1)],a=Qe(Mm(r),[n,t]),o=Qe(Ix(r),[n,t]),u=fc(en(a,[0,1],[n,t-2]),1),l=xt(fc(en(o,[0,1],[n,t-2]),1),mr(-1)),c=zs([a,u],1),h=zs([o,l],1),d=Qe(cl(c,h),[i[0],i[1]]);s=Pb(d)}if(s=Mm(s),r.rank===3&&r.shape[0]!==0){const i=s,a=r.shape[0];s=Qe(s,[a,s.shape[0]/a,s.shape[1]]),i.dispose()}return s}const H$=we({irfft_:a0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o0e(r,t,n=0){const i={x:ne(r,"x","split")},a={numOrSizeSplits:t,axis:n};return Ce.runKernel(AF,i,a)}const Lm=we({split_:o0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u0e(r,t){oe(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let n=r.shape[r.shape.length-1];const s=r.size/n;let i;if(t!=null&&t<n){const m=r.shape.map(y=>0),g=r.shape.map(y=>y);g[r.shape.length-1]=t,i=en(r,m,g),n=t}else if(t!=null&&t>n){const m=r.shape.map(g=>g);m[r.shape.length-1]=t-n,i=zs([r,dc(m)],r.shape.length-1),n=t}else i=r;const a=Ji(i),o=Qe(cl(i,a),[s,n]),u=iC(o),l=Math.floor(n/2)+1,c=Mm(u),h=Ix(u),d=Lm(c,[l,n-l],c.shape.length-1),p=Lm(h,[l,n-l],h.shape.length-1),f=i.shape.slice();return f[i.shape.length-1]=l,Qe(cl(d[0],p[0]),f)}const aC=we({rfft_:u0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l0e(r,t){let n=ne(r,"a","squaredDifference"),s=ne(t,"b","squaredDifference");[n,s]=Ln(n,s),Fr(n.shape,s.shape);const i={a:n,b:s},a={};return Ce.runKernel(LF,i,a)}const j$=we({squaredDifference_:l0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c0e(r,t){const n=ne(r,"x","squeeze","string_or_numeric");return Qe(n,ml(n.shape,t).newShape)}const Ga=we({squeeze_:c0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h0e(r,t=0){const n=Tb(r,"tensors","stack","string_or_numeric");oe(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&oe(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const s=n,i={axis:t};return Ce.runKernel(ZD,s,i)}const mu=we({stack_:h0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d0e(r,t=0){const s={x:ne(r,"x","step")},i={alpha:t};return Ce.runKernel(JF,s,i)}const q$=we({step_:d0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0e(r,t,n,s,i=0,a=0,o=0,u=0,l=0){const h={x:ne(r,"x","stridedSlice","string_or_numeric")},d={begin:t,end:n,strides:s,beginMask:i,endMask:a,ellipsisMask:o,newAxisMask:u,shrinkAxisMask:l};return Ce.runKernel(BF,h,d)}const Nj=we({stridedSlice_:p0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f0e(r){const n={x:ne(r,"x","tan","float32")};return Ce.runKernel(GF,n)}const Tj=we({tan_:f0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ha(r,t){Md(r);const n=du(r,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Dc(r,null,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oh(r,t,n){if(Md(r),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=du(r,n);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Dc(r,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K$(r,t,n){if(Md(r),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=du(r,n);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Dc(r,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aj(r,t,n){if(Md(r),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=du(r,n);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Dc(r,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dj(r,t,n){if(Md(r),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=du(r,n);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Dc(r,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fj(r,t,n){if(Md(r),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=du(r,n);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||s,Dc(r,t,s,n)}function X$(r,t,n){const s=t.rank>1?t.shape[t.rank-1]:1,i=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${r}, sliceDim: ${s}, and batchDim: ${i}.`;if(n.rank<i)throw new Error(a+` update.rank < ${i}. `);if(r.length<s+(n.rank-i))throw new Error(a+` Output shape length < ${s+(n.rank-i)}`);if(n.rank!==i+r.length-s)throw new Error(a+` update.rank != ${i+r.length-s}`);for(let o=0;o<i;++o)if(n.shape[o]!==t.shape[o])throw new Error(a+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<n.rank-i;++o)if(n.shape[o+i]!==r[o+s])throw new Error(a+` updates.shape[${o+i}] (${n.shape[o+i]}) != shape[${o+i}] (${r[o+i]})`)}function oC(r,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}X$(n,t,r)}function Nx(r,t,n){const s=t.shape.length,i=s>1?t.shape[s-1]:1,a=n.length;let o=1;for(let d=i;d<a;++d)o*=n[d];const u=i<1?1:i,l=lt(t.shape)/u,c=[...ws(n.slice(0,i)),1],h=lt(n);return{sliceRank:i,numUpdates:l,sliceSize:o,strides:c,outputSize:h}}const m0e=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:Nx,validateInput:oC,validateUpdateShape:X$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g0e(r,t,n){const s=ne(r,"tensor","tensorScatterupdate"),i=ne(t,"indices","tensorScatterupdate","int32"),a=ne(n,"updates","tensorScatterupdate");if(oC(a,i,s.shape),s.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${a.dtype}.`);const o={tensor:s,indices:i,updates:a},u={};return Ce.runKernel(yF,o,u)}const $j=we({tensorScatterUpdate_:g0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y0e(r,t=1,n=!0){const s=ne(r,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${t}`);const a={x:s},o={k:t,sorted:n},[u,l]=Ce.runKernel(jF,a,o);return{values:u,indices:l}}const Rj=we({topk_:y0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b0e(r,t=0,n=1,s,i){if(aa(r),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new z$(t,n,s,!0,i),o=Tn(r,s);for(let u=0;u<o.values.length;u++)o.values[u]=a.nextValue();return o.toTensor()}const Oj=we({truncatedNormal_:b0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0e(r,t=0){const n=ne(r,"x","unique","string_or_numeric");oe(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},i={axis:t},[a,o]=Ce.runKernel(KF,s,i);return{values:a,indices:o}}const Mj=we({unique_:x0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v0e(r,t,n){const s=ne(r,"x","unsortedSegmentSum"),i=ne(t,"segmentIds","unsortedSegmentSum","int32");oe(Qh(n),()=>"numSegments must be of dtype int");const a={x:s,segmentIds:i},o={numSegments:n};return Ce.runKernel(YF,a,o)}const Lj=we({unsortedSegmentSum_:v0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0e(r,t=0){const n=ne(r,"x","unstack","string_or_numeric");oe(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const s={value:n},i={axis:t};return Ce.runKernel(XF,s,i)}const Fc=we({unstack_:w0e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pj(r,t){return nC(r,t,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bj(r,t=!0,n,s){return Ce.makeVariable(r,t,n,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(r,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const s=Tn(r,"int32"),i=Tn([n.length,r.length],"int32");for(let a=0;a<n.length;a++){const o=s.indexToLoc(n[a]),u=a*r.length;i.values.set(o,u)}return i.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function S0e(r){const t=ne(r,"condition","whereAsync","bool"),n=await t.data(),s=Y$(t.shape,n);return r!==t&&t.dispose(),s}const Z$=S0e;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function C0e(r,t,n){const s=ne(r,"tensor","boolMask"),i=ne(t,"mask","boolMask","bool"),a=n??0,o=i.rank,u=s.shape;oe(o>0,()=>"mask cannot be scalar"),Gs(u.slice(a,a+o),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=a;g<a+o;g++)l*=u[g];const c=u.slice(0,a).concat([l],u.slice(a+o)),h=Qe(s,c),d=Qe(i,[-1]),p=await Z$(d),f=Ga(p,[1]),m=C$(h,f,a);return r!==s&&s.dispose(),t!==i&&i.dispose(),f.dispose(),h.dispose(),d.dispose(),p.dispose(),m}const Vj=C0e;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _0e(r,t,n){const s=ne(r,"x","transpose");if(t==null&&(t=s.shape.map((o,u)=>u).reverse()),oe(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{oe(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const i={x:s},a={perm:t};return s.dtype==="complex64"?qt(()=>{let o=Mm(s),u=Ix(s);return o=Ce.runKernel(Xy,{x:o},a),u=Ce.runKernel(Xy,{x:u},a),n&&(u=ko(u)),cl(o,u)}):Ce.runKernel(Xy,i,a)}const Bb=we({transpose_:_0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E0e(r,t,n,s,i=!0){const a=ne(r,"v","movingAverage"),o=ne(t,"x","movingAverage"),u=ne(n,"decay","movingAverage");CG(a,o),oe(En(a.shape,o.shape),()=>"Shape mismatch in v and x");const l=mr(1),c=hr(l,u);let h=xt(hr(o,a),c);if(i){oe(s!=null,()=>"When using zeroDebias: true, step is required.");const d=ne(s,"step","movingAverage");h=hn(h,hr(l,Rm(u,d)))}return jt(a,h)}const zj=we({movingAverage_:E0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I0e(r,t,n){aa(n);const s=ne(r,"indices","scatterND","int32"),i=ne(t,"updates","scatterND");oC(i,s,n);const a={indices:s,updates:i},o={shape:n};return Ce.runKernel(gF,a,o)}const Uj=we({scatterND_:I0e});function k0e(r,t,n,s){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);const i=r.rank>0?r.shape[0]:1,a=r.rank>1?r.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const o=t.size;if(!(t.rank===0||t.rank===1&&o===i))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${i}]`);if(t.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0e(r,t,n,s=0){aa(n);const i=ne(r,"sparseIndices","sparseToDense","int32"),a=ne(t,"sparseValues","sparseToDense","string_or_numeric"),o=ne(s,"defaultValue","sparseToDense",a.dtype);k0e(i,a,n,o);const u={sparseIndices:i,sparseValues:a,defaultValue:o},l={outputShape:n};return Ce.runKernel(MF,u,l)}const Wj=we({sparseToDense_:N0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T0e(r,t){const n=ne(t,"indices","gatherND","int32"),i={params:ne(r,"x","gatherND","string_or_numeric"),indices:n};return Ce.runKernel(fD,i)}const Gj=we({gatherND_:T0e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0e(r,t){if(t==null)return r.shape.slice();if(En(r.shape,t))return t;if(r.shape.length===t.length){const n=[];for(let s=0;s<r.shape.length;s++)t[s]==null&&r.shape[s]!=null?n.push(r.shape[s]):n.push(t[s]);return n}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D0e(r,t,n,s){const i=ne(r,"x","dropout");if(oe(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),oe(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return r instanceof Xr?i.clone():i;const a=A0e(i,n),o=1-t,u=hn(S$(jt(sC(a,0,1,"float32",s),o)),o);return xt(i,u)}const Hj=we({dropout_:D0e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function uC(r,t,n){const s=1-r%2,i=new Float32Array(r);for(let a=0;a<r;++a){const o=2*Math.PI*a/(r+s-1);i[a]=t-n*Math.cos(o)}return ha(i,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function F0e(r,t,n=1){const s=ne(r,"predictions","inTopK"),i=ne(t,"targets","inTopK");oe(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),oe(s.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${i.rank}`),Gs(s.shape.slice(0,s.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=s.shape[s.shape.length-1];oe(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);const o=await s.data(),u=await i.data(),[l,c]=[o.length/a,a],h=ul("bool",l);for(let d=0;d<l;d++){const p=d*c,f=o.subarray(p,p+c),m=[];for(let g=0;g<f.length;g++)m.push({value:f[g],index:g});m.sort((g,y)=>y.value-g.value),h[d]=0;for(let g=0;g<n;g++)if(m[g].index===u[d]){h[d]=1;break}}return r!==s&&s.dispose(),t!==i&&i.dispose(),qa(h,i.shape,"bool")}const jj=F0e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $0e(r,t,n,s,i,a="NHWC",o){let u=r;r.rank===3&&(u=Qe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let l=t;l.rank===3&&(l=Qe(t,[1,t.shape[0],t.shape[1],t.shape[2]])),oe(u.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${u.shape}.`),oe(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),oe(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=a==="NHWC"?u.shape[3]:u.shape[1],h=a==="NHWC"?l.shape[3]:l.shape[1];oe(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),oe(h===n[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${n[3]}).`),to("conv2dDerFilter",i,o);const d={x:u,dy:l},p={strides:s,pad:i,dataFormat:a,dimRoundingMode:o,filterShape:n};return Ce.runKernel(MA,d,p)}const R0e=we({conv2DBackpropFilter_:$0e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lC(r,t,n){if(n==null||n==="linear")return r;if(n==="relu")return xt(r,q$(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function cC(r,t){let n=t;const s=y$(r.shape,t.shape);return s.length>0&&(n=bn(n,s)),Qe(n,r.shape)}function hC(r,t,n,s){if(t==="linear")return r;if(t==="relu")return kx(r);if(t==="elu")return b$(r);if(t==="relu6")return W$(r);if(t==="prelu")return L$(r,n);if(t==="leakyrelu")return E$(r,s);if(t==="sigmoid")return iu(r);throw new Error(`Unknown fused activation ${t}.`)}const dC=(r,t)=>!(r>0)||t==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O0e({x:r,filter:t,strides:n,pad:s,dataFormat:i="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:u,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(l=l||"linear",dC(Ce.state.gradientDepth,l)===!1){oe(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let E=Cx(r,t,n,s,i,a,o);return u!=null&&(E=jt(E,u)),hC(E,l,c,h)}const d=ne(r,"x","conv2d","float32"),p=ne(t,"filter","conv2d","float32");let f=d,m=!1;d.rank===3&&(m=!0,f=Qe(d,[1,d.shape[0],d.shape[1],d.shape[2]])),oe(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),oe(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),to("fused conv2d",s,o);const g=i==="NHWC"?f.shape[3]:f.shape[1];oe(p.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`),oe(oa(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const y=Ca(f.shape,p.shape,n,a,s,o);let b;u!=null&&(b=ne(u,"bias","fused conv2d"),[b]=Ln(b,d),i==="NHWC"?Fr(y.outShape,b.shape):(oe(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),oe(b.shape.length===0||b.shape[0]===y.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let x;if(c!=null){const E=c.shape;if(oe(E.length<=1||E.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${E.length}.`),E.length===1)oe(E[0]===1||E[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the number of output channels (${y.outChannels}).`);else if(E.length===3)try{Fr(E,y.outShape)}catch{const I=`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(I)}x=ne(c,"prelu weights","fused conv2d")}const w=(E,C)=>{oe(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[I,_,A,k]=C,N=lC(E,A,l);oe(Fb(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const D=dH(_.shape,N,I,n,s),F=R0e(_,N,I.shape,n,s),P=[D,F];if(k!=null){const G=cC(k,N);P.push(G)}return P},v={x:f,filter:p,bias:b,preluActivationWeights:x},S={strides:n,pad:s,dataFormat:i,dilations:a,dimRoundingMode:o,activation:l,leakyreluAlpha:h};return u==null?fu((C,I,_)=>{let A=Ce.runKernel(v2,v,S);return _([I,C,A]),m&&(A=Qe(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:w}})(f,p):fu((C,I,_,A)=>{let k=Ce.runKernel(v2,v,S);return A([I,C,k,_]),m&&(k=Qe(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:w}})(f,p,b)}const M0e=we({fusedConv2d_:O0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L0e(r,t,n,s,i,a=[1,1],o){let u=r;r.rank===3&&(u=Qe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let l=t;l.rank===3&&(l=Qe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:u,dy:l},h={strides:s,pad:i,dimRoundingMode:o,dilations:a,filterShape:n};return Ce.runKernel(KA,c,h)}const P0e=we({depthwiseConv2dNativeBackpropFilter_:L0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B0e(r,t,n,s,i,a=[1,1],o){let u=t,l=!1;t.rank===3&&(l=!0,u=Qe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:u,filter:n},h={strides:s,pad:i,dimRoundingMode:o,dilations:a,inputShape:r},d=Ce.runKernel(XA,c,h);return l?Qe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const V0e=we({depthwiseConv2dNativeBackpropInput_:B0e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z0e({x:r,filter:t,strides:n,pad:s,dataFormat:i="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:u,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(dC(Ce.state.gradientDepth,l)===!1){let S=eC(r,t,n,s,i,a,o);return u!=null&&(S=jt(S,u)),hC(S,l,c,h)}const d=ne(r,"x","depthwiseConv2d","float32"),p=ne(t,"filter","depthwiseConv2d","float32");let f=d,m=!1;d.rank===3&&(m=!0,f=Qe(d,[1,d.shape[0],d.shape[1],d.shape[2]])),oe(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),oe(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),oe(f.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),a==null&&(a=[1,1]),oe(oa(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),to("fused depthwiseConv2d",s,o);const g=Ca(f.shape,p.shape,n,a,s,o,!0);let y;u!=null&&(y=ne(u,"bias","fused conv2d"),[y]=Ln(y,d),Fr(g.outShape,y.shape));let b;c!=null&&(b=ne(c,"prelu weights","fused depthwiseConv2d"));const x=(S,E)=>{oe(Fb(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[C,I,_,A]=E,k=lC(S,_,l),N=V0e(I.shape,k,C,n,s,a,o),D=P0e(I,k,C.shape,n,s,a,o);if(A!=null){const F=cC(y,k);return[N,D,F]}return[N,D]},w={x:f,filter:p,bias:y,preluActivationWeights:b},v={strides:n,pad:s,dataFormat:i,dilations:a,dimRoundingMode:o,activation:l,leakyreluAlpha:h};return u==null?fu((E,C,I)=>{let _=Ce.runKernel(w2,w,v);return I([C,E,_]),m&&(_=Qe(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:x}})(f,p):fu((E,C,I,_)=>{let A=Ce.runKernel(w2,w,v);return _([C,E,A,I]),m&&(A=Qe(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:x}})(f,p,y)}const U0e=we({fusedDepthwiseConv2d_:z0e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0e({a:r,b:t,transposeA:n=!1,transposeB:s=!1,bias:i,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:u=.2}){if(dC(Ce.state.gradientDepth,a)===!1){let k=Vr(r,t,n,s);return i!=null&&(k=jt(k,i)),hC(k,a,o,u)}let l=ne(r,"a","fused matMul"),c=ne(t,"b","fused matMul");[l,c]=Ln(l,c);const h=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?c.shape[c.rank-1]:c.shape[c.rank-2],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],f=s?c.shape[c.rank-2]:c.shape[c.rank-1],m=l.shape.slice(0,-2),g=c.shape.slice(0,-2),y=lt(m),b=lt(g);oe(h===d,()=>`Error in fused matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${s} must match.`);const w=Fr(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,f]),v=n?Qe(l,[y,h,p]):Qe(l,[y,p,h]),S=s?Qe(c,[b,f,d]):Qe(c,[b,d,f]);let E;i!=null&&(E=ne(i,"bias","fused matMul"),[E]=Ln(E,l),Fr(w,E.shape));let C;o!=null&&(C=ne(o,"prelu weights","fused matMul"));const I=(k,N)=>{const[D,F,P,G]=N,Y=lC(Qe(k,P.shape),P,a);let Z,ee;if(!n&&!s?(Z=Vr(Y,F,!1,!0),ee=Vr(D,Y,!0,!1)):!n&&s?(Z=Vr(Y,F,!1,!1),ee=Vr(Y,D,!0,!1)):n&&!s?(Z=Vr(F,Y,!1,!0),ee=Vr(D,Y,!1,!1)):(Z=Vr(F,Y,!0,!0),ee=Vr(Y,D,!0,!0)),i!=null){const se=cC(G,Y);return[Z,ee,se]}else return[Z,ee]},_={a:v,b:S,bias:E,preluActivationWeights:C},A={transposeA:n,transposeB:s,activation:a,leakyreluAlpha:u};return i==null?fu((N,D,F)=>{const P=Ce.runKernel(x2,_,A);return F([N,D,P]),{value:Qe(P,w),gradFunc:I}})(v,S):fu((N,D,F,P)=>{const G=Ce.runKernel(x2,_,A);return P([N,D,G,F]),{value:Qe(G,w),gradFunc:I}})(v,S,E)}const G0e=we({fusedMatMul_:W0e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qj=Object.freeze(Object.defineProperty({__proto__:null,conv2d:M0e,depthwiseConv2d:U0e,matMul:G0e},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H0e(r){return uC(r,.54,.46)}const j0e=we({hammingWindow_:H0e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q0e(r){return uC(r,.5,.5)}const Kj=we({hannWindow_:q0e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K0e(r,t,n,s=!1,i=0){let a=0;const o=[];for(;a+t<=r.size;)o.push(en(r,a,t)),a+=n;if(s)for(;a<r.size;){const u=a+t-r.size,l=zs([en(r,a,t-u),pg([u],i)]);o.push(l),a+=n}return o.length===0?Oh([],[0,t]):Qe(zs(o),[o.length,t])}const Xj=we({frame_:K0e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X0e(r,t,n,s,i=Kj){s==null&&(s=J$(t));const a=Xj(r,t,n),o=xt(a,i(t));return aC(o,s)}const Y0e=we({stft_:X0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0e(r,t,n,s,i="bilinear",a=0){const o=ne(r,"image","cropAndResize"),u=ne(t,"boxes","cropAndResize","float32"),l=ne(n,"boxInd","cropAndResize","int32"),c=u.shape[0];oe(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),oe(u.rank===2&&u.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${u.shape}.`),oe(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${u.shape}.`),oe(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),oe(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),oe(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const h={image:o,boxes:u,boxInd:l},d={method:i,extrapolationValue:a,cropSize:s};return Ce.runKernel(GA,h,d)}const J0e=we({cropAndResize_:Z0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q0e(r){const t=ne(r,"image","flipLeftRight","float32");oe(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};return Ce.runKernel(lD,n,{})}const eye=we({flipLeftRight_:Q0e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tye(r){const t=ne(r,"image","grayscaleToRGB"),n=t.rank-1,s=t.shape[n];oe(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),oe(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const i=new Array(t.rank);return i.fill(1,0,n),i[n]=3,pm(t,i)}const rye=we({grayscaleToRGB_:tye});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nye(r){const t=ne(r,"image","RGBToGrayscale"),n=t.rank-1,s=t.shape[n];oe(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),oe(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const i=t.dtype,a=Or(t,"float32"),o=ha([.2989,.587,.114]);let u;switch(t.rank){case 2:u=vh("ij,j->i",a,o);break;case 3:u=vh("ijk,k->ij",a,o);break;case 4:u=vh("ijkl,l->ijk",a,o);break;case 5:u=vh("ijklm,m->ijkl",a,o);break;case 6:u=vh("ijklmn,n->ijklm",a,o);break;default:throw new Error("Not a valid tensor rank.")}return u=vi(u,-1),Or(u,i)}const sye=we({rgbToGrayscale_:nye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iye(r,t,n=0,s=.5){const i=ne(r,"image","rotateWithOffset","float32");oe(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const a={image:i},o={radians:t,fillValue:n,center:s};return Ce.runKernel(QF,a,o)}const aye=we({rotateWithOffset_:iye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mg(r,t,n,s,i,a){s==null&&(s=.5),i==null&&(i=Number.NEGATIVE_INFINITY),a==null&&(a=0);const o=r.shape[0];return n=Math.min(n,o),oe(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),oe(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),oe(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),oe(t.rank===1,()=>"scores must be a 1D tensor"),oe(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),oe(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:i,softNmsSigma:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oye(r,t,n,s=.5,i=Number.NEGATIVE_INFINITY){const a=ne(r,"boxes","nonMaxSuppression","float32"),o=ne(t,"scores","nonMaxSuppression","float32"),u=mg(a,o,n,s,i);n=u.maxOutputSize,s=u.iouThreshold,i=u.scoreThreshold;const l={maxOutputSize:n,iouThreshold:s,scoreThreshold:i};return Ce.runKernel(jD,{boxes:a,scores:o},l)}const uye=we({nonMaxSuppression_:oye});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lye(r,t,n){const s=cye(r,t,n),i=s<0?-(s+1):s;r.splice(i,0,t)}function cye(r,t,n){return dye(r,t,n||hye)}function hye(r,t){return r>t?1:r<t?-1:0}function dye(r,t,n){let s=0,i=r.length,a=0,o=!1;for(;s<i;){a=s+(i-s>>>1);const u=n(t,r[a]);u>0?s=a+1:(i=a,o=!u)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q$(r,t,n,s,i){return rR(r,t,n,s,i,0)}function eR(r,t,n,s,i,a){return rR(r,t,n,s,i,0,!1,a,!0)}function tR(r,t,n,s,i,a){return rR(r,t,n,s,i,a,!0)}function rR(r,t,n,s,i,a,o=!1,u=!1,l=!1){const c=[];for(let y=0;y<t.length;y++)t[y]>i&&c.push({score:t[y],boxIndex:y,suppressBeginIndex:0});c.sort(z4);const h=a>0?-.5/a:0,d=[],p=[];for(;d.length<n&&c.length>0;){const y=c.pop(),{score:b,boxIndex:x,suppressBeginIndex:w}=y;if(b<i)break;let v=!1;for(let S=d.length-1;S>=w;--S){const E=pye(r,x,d[S]);if(E>=s){v=!0;break}if(y.score=y.score*fye(s,h,E),y.score<=i)break}y.suppressBeginIndex=d.length,v||(y.score===b?(d.push(x),p.push(y.score)):y.score>i&&lye(c,y,z4))}const f=d.length,m=n-f;u&&m>0&&(d.push(...new Array(m).fill(0)),p.push(...new Array(m).fill(0)));const g={selectedIndices:d};return o&&(g.selectedScores=p),l&&(g.validOutputs=f),g}function pye(r,t,n){const s=r.subarray(t*4,t*4+4),i=r.subarray(n*4,n*4+4),a=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),u=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(i[0],i[2]),h=Math.min(i[1],i[3]),d=Math.max(i[0],i[2]),p=Math.max(i[1],i[3]),f=(u-a)*(l-o),m=(d-c)*(p-h);if(f<=0||m<=0)return 0;const g=Math.max(a,c),y=Math.max(o,h),b=Math.min(u,d),x=Math.min(l,p),w=Math.max(b-g,0)*Math.max(x-y,0);return w/(f+m-w)}function fye(r,t,n){const s=Math.exp(t*n*n);return n<=r?s:0}function z4(r,t){return r.score-t.score||r.score===t.score&&t.boxIndex-r.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function mye(r,t,n,s=.5,i=Number.NEGATIVE_INFINITY){const a=ne(r,"boxes","nonMaxSuppressionAsync"),o=ne(t,"scores","nonMaxSuppressionAsync"),u=mg(a,o,n,s,i);n=u.maxOutputSize,s=u.iouThreshold,i=u.scoreThreshold;const l=await Promise.all([a.data(),o.data()]),c=l[0],h=l[1],{selectedIndices:d}=Q$(c,h,n,s,i);return a!==r&&a.dispose(),o!==t&&o.dispose(),ha(d,"int32")}const gye=mye;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yye(r,t,n,s=.5,i=Number.NEGATIVE_INFINITY,a=0){const o=ne(r,"boxes","nonMaxSuppression"),u=ne(t,"scores","nonMaxSuppression"),l=mg(o,u,n,s,i,a);n=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,a=l.softNmsSigma;const c={boxes:o,scores:u},h={maxOutputSize:n,iouThreshold:s,scoreThreshold:i,softNmsSigma:a},d=Ce.runKernel(KD,c,h);return{selectedIndices:d[0],selectedScores:d[1]}}const bye=we({nonMaxSuppressionWithScore_:yye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function xye(r,t,n,s=.5,i=Number.NEGATIVE_INFINITY,a=0){const o=ne(r,"boxes","nonMaxSuppressionAsync"),u=ne(t,"scores","nonMaxSuppressionAsync"),l=mg(o,u,n,s,i,a);n=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,a=l.softNmsSigma;const c=await Promise.all([o.data(),u.data()]),h=c[0],d=c[1],{selectedIndices:p,selectedScores:f}=tR(h,d,n,s,i,a);return o!==r&&o.dispose(),u!==t&&u.dispose(),{selectedIndices:ha(p,"int32"),selectedScores:ha(f)}}const vye=xye;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wye(r,t,n,s=.5,i=Number.NEGATIVE_INFINITY,a=!1){const o=ne(r,"boxes","nonMaxSuppression"),u=ne(t,"scores","nonMaxSuppression"),l=mg(o,u,n,s,i,null),c=l.maxOutputSize,h=l.iouThreshold,d=l.scoreThreshold,p={boxes:o,scores:u},f={maxOutputSize:c,iouThreshold:h,scoreThreshold:d,padToMaxOutputSize:a},m=Ce.runKernel(qD,p,f);return{selectedIndices:m[0],validOutputs:m[1]}}const Sye=we({nonMaxSuppressionPadded_:wye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Cye(r,t,n,s=.5,i=Number.NEGATIVE_INFINITY,a=!1){const o=ne(r,"boxes","nonMaxSuppressionAsync"),u=ne(t,"scores","nonMaxSuppressionAsync"),l=mg(o,u,n,s,i,null),c=l.maxOutputSize,h=l.iouThreshold,d=l.scoreThreshold,[p,f]=await Promise.all([o.data(),u.data()]),{selectedIndices:m,validOutputs:g}=eR(p,f,c,h,d,a);return o!==r&&o.dispose(),u!==t&&u.dispose(),{selectedIndices:ha(m,"int32"),validOutputs:mr(g,"int32")}}const _ye=Cye;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eye(r,t,n=!1,s=!1){const i=ne(r,"images","resizeBilinear");oe(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),oe(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),oe(s===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=i,o=!1;i.rank===3&&(o=!0,a=Qe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u={images:a},l={alignCorners:n,halfPixelCenters:s,size:t},c=Ce.runKernel(hF,u,l);return o?Qe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Iye=we({resizeBilinear_:Eye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kye(r,t,n=!1,s=!1){const i=ne(r,"images","resizeNearestNeighbor");oe(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),oe(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),oe(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),oe(s===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=i,o=!1;i.rank===3&&(o=!0,a=Qe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u={images:a},l={alignCorners:n,halfPixelCenters:s,size:t},c=Ce.runKernel(cF,u,l);return o?Qe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Nye=we({resizeNearestNeighbor_:kye});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tye(r,t="binary",n=!1,s=.5){const i=ne(r,"image","threshold"),a=.2989,o=.587,u=.114,l=i.shape[0]*i.shape[1];let c=xt(ha([s]),255),h,d,p,f;if(oe(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),oe(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),oe(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),oe(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),i.shape[2]===3){[h,d,p]=Lm(i,[1,1,1],-1);const y=xt(h,a),b=xt(d,o),x=xt(p,u);f=jt(jt(y,b),x)}else f=r;if(t==="otsu"){const y=g$(Or(G$(f),"int32"),qa([]),256);c=Aye(y,l)}const m=n?tC(f,c):fg(f,c);return Or(xt(m,255),"int32")}function Aye(r,t){let n=ha([-1]),s=ha([0]),i=ha([0]),a,o,u,l,c,h;for(let d=0;d<r.size-1;d++){a=en(r,0,d+1),o=en(r,d+1),c=hn(bn(a),t),h=hn(bn(o),t);const p=bn(xt(a,pc(0,a.size)));u=hn(p,bn(a));const f=pg(o.shape,a.size),m=jt(pc(0,o.size),f),g=xt(o,m);l=hn(bn(g),bn(o));const y=hr(u,l),b=hr(u,l),x=xt(c,h);i=xt(xt(x,y),b);const w=fg(i,s);s=Qu(w,i,s),n=Qu(w,ha([d]),n)}return n}const Dye=we({threshold_:Tye});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fye(r,t,n="nearest",s="constant",i=0,a){const o=ne(r,"image","transform","float32"),u=ne(t,"transforms","transform","float32");oe(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),oe(u.rank===2&&(u.shape[0]===o.shape[0]||u.shape[0]===1)&&u.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),oe(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const l={image:o,transforms:u},c={interpolation:n,fillMode:s,fillValue:i,outputShape:a};return Ce.runKernel(qF,l,c)}const $ye=we({transform_:Fye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rye(r,t,n){const s=ne(r,"a","bandPart");oe(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const i=s.shape,[a,o]=s.shape.slice(-2);let u,l;typeof t=="number"?(oe(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),oe(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),u=ne(t<0?a:t,"numLower","bandPart")):(oe(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),u=Qu(E2(t,0),a,Mb(t,a))),typeof n=="number"?(oe(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),oe(n<=o,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`),l=ne(n<0?o:n,"numUpper","bandPart")):(oe(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Qu(E2(n,0),o,Mb(n,o)));const c=Qe(pc(0,a,1,"int32"),[-1,1]),h=pc(0,o,1,"int32"),d=hr(c,h),p=Rb(tC(d,u),_$(d,ko(l))),f=dc([a,o],s.dtype);return Qe(mu(Fc(Qe(s,[-1,a,o])).map(m=>Qu(p,m,f))),i)}const Oye=we({bandPart_:Rye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mye(r){let t;if(Array.isArray(r)){t=!1,oe(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=r[0].shape[0];for(let a=1;a<r.length;++a)oe(r[a].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[a].shape[0]} vs. ${i})`)}else t=!0,r=Lm(r,r.shape[0],0).map(i=>Ga(i,[0]));oe(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);const n=[],s=r;for(let i=0;i<r.length;++i)n.push(Ce.tidy(()=>{let a=s[i];if(i>0)for(let o=0;o<i;++o){const u=xt(bn(xt(n[o],a)),n[o]);a=hr(a,u)}return hn(a,Ex(a,"euclidean"))}));return t?mu(n,0):n}const Lye=we({gramSchmidt_:Mye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pye(r,t=!1){if(oe(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return U4(r,t);{const n=r.shape.slice(0,r.shape.length-2).reduce((l,c)=>l*c),s=Fc(Qe(r,[n,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),i=[],a=[];s.forEach(l=>{const[c,h]=U4(l,t);i.push(c),a.push(h)});const o=Qe(mu(i,0),r.shape),u=Qe(mu(a,0),r.shape);return[o,u]}}function U4(r,t=!1){return Ce.tidy(()=>{oe(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);const n=r.shape[0],s=r.shape[1];let i=w$(n),a=Ju(r);const o=Oh([[1]],[1,1]);let u=Ju(o);const l=n>=s?s:n;for(let c=0;c<l;++c){const h=a,d=u,p=i;[u,a,i]=Ce.tidy(()=>{const f=en(a,[c,c],[n-c,1]),m=Ex(f),g=en(a,[c,c],[1,1]),y=Qu(fg(g,0),Oh([[-1]]),Oh([[1]])),b=hr(g,xt(y,m)),x=hn(f,b);x.shape[0]===1?u=Ju(o):u=zs([o,en(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);const w=ko(hn(Vr(y,b),m)),v=en(a,[c,0],[n-c,s]),S=xt(w,u),E=Bb(u);if(c===0)a=hr(v,Vr(S,Vr(E,v)));else{const _=hr(v,Vr(S,Vr(E,v)));a=zs([en(a,[0,0],[c,s]),_],0)}const C=Bb(S),I=en(i,[0,c],[n,i.shape[1]-c]);if(c===0)i=hr(I,Vr(Vr(I,u),C));else{const _=hr(I,Vr(Vr(I,u),C));i=zs([en(i,[0,0],[n,c]),_],1)}return[u,a,i]}),ii([h,d,p])}return!t&&n>s&&(i=en(i,[0,0],[n,s]),a=en(a,[0,0],[s,s])),[i,a]})}const Bye=we({qr_:Pye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ti;(function(r){r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ti||(ti={}));function Vye(r,t,n=ti.SUM_BY_NONZERO_WEIGHTS){const s=ne(r,"losses","computeWeightedLoss");let i=null;t!=null&&(i=ne(t,"weights","computeWeightedLoss"));const a=i==null?s:xt(s,i);if(n===ti.NONE)return a;if(n===ti.SUM)return bn(a);if(n===ti.MEAN){if(i==null)return Ob(a);{const o=s.size/i.size,u=hn(bn(a),bn(i));return o>1?hn(u,mr(o)):u}}if(n===ti.SUM_BY_NONZERO_WEIGHTS){if(i==null)return hn(bn(a),mr(s.size));{const o=xt(i,ql(s.shape)),u=Or(bn(R$(o,mr(0))),"float32");return hn(bn(a),u)}}throw Error(`Unknown reduction: ${n}`)}const gl=we({computeWeightedLoss_:Vye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zye(r,t,n,s=ti.SUM_BY_NONZERO_WEIGHTS){const i=ne(r,"labels","absoluteDifference"),a=ne(t,"predictions","absoluteDifference");let o=null;n!=null&&(o=ne(n,"weights","absoluteDifference")),Gs(i.shape,a.shape,"Error in absoluteDifference: ");const u=qi(hr(i,a));return gl(u,o,s)}const Uye=we({absoluteDifference_:zye});function Wye(r,t,n,s,i=ti.SUM_BY_NONZERO_WEIGHTS){const a=ne(r,"labels","cosineDistance"),o=ne(t,"predictions","cosineDistance");let u=null;s!=null&&(u=ne(s,"weights","cosineDistance")),Gs(a.shape,o.shape,"Error in cosineDistance: ");const l=mr(1),c=hr(l,bn(xt(a,o),n,!0));return gl(c,u,i)}const Gye=we({cosineDistance_:Wye});function Hye(r,t,n,s=ti.SUM_BY_NONZERO_WEIGHTS){let i=ne(r,"labels","hingeLoss");const a=ne(t,"predictions","hingeLoss");let o=null;n!=null&&(o=ne(n,"weights","hingeLoss")),Gs(i.shape,a.shape,"Error in hingeLoss: ");const u=mr(1);i=hr(xt(mr(2),i),u);const l=kx(hr(u,xt(i,a)));return gl(l,o,s)}const jye=we({hingeLoss_:Hye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qye(r,t,n,s=1,i=ti.SUM_BY_NONZERO_WEIGHTS){const a=ne(r,"labels","huberLoss"),o=ne(t,"predictions","huberLoss");let u=null;n!=null&&(u=ne(n,"weights","huberLoss")),Gs(a.shape,o.shape,"Error in huberLoss: ");const l=mr(s),c=qi(hr(o,a)),h=Mb(c,l),d=hr(c,h),p=jt(xt(mr(.5),Ka(h)),xt(l,d));return gl(p,u,i)}const Kye=we({huberLoss_:qye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xye(r,t,n,s=1e-7,i=ti.SUM_BY_NONZERO_WEIGHTS){const a=ne(r,"labels","logLoss"),o=ne(t,"predictions","logLoss");let u=null;n!=null&&(u=ne(n,"weights","logLoss")),Gs(a.shape,o.shape,"Error in logLoss: ");const l=mr(1),c=mr(s),h=ko(xt(a,Om(jt(o,c)))),d=xt(hr(l,a),Om(jt(hr(l,o),c))),p=hr(h,d);return gl(p,u,i)}const Yye=we({logLoss_:Xye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zye(r,t,n,s=ti.SUM_BY_NONZERO_WEIGHTS){const i=ne(r,"labels","meanSquaredError"),a=ne(t,"predictions","meanSquaredError");let o=null;n!=null&&(o=ne(n,"weights","meanSquaredError")),Gs(i.shape,a.shape,"Error in meanSquaredError: ");const u=j$(i,a);return gl(u,o,s)}const Jye=we({meanSquaredError_:Zye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qye(r,t){const n=ne(r,"labels","sigmoidCrossEntropyWithLogits"),s=ne(t,"logits","sigmoidCrossEntropyWithLogits");Gs(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=kx(s),a=xt(s,n),o=I$(hc(ko(qi(s))));return jt(hr(i,a),o)}function ebe(r,t,n,s=0,i=ti.SUM_BY_NONZERO_WEIGHTS){let a=ne(r,"multiClassLabels","sigmoidCrossEntropy");const o=ne(t,"logits","sigmoidCrossEntropy");let u=null;if(n!=null&&(u=ne(n,"weights","sigmoidCrossEntropy")),Gs(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=mr(s),h=mr(1),d=mr(.5);a=jt(xt(a,hr(h,c)),xt(d,c))}const l=Qye(a,o);return gl(l,u,i)}const tbe=we({sigmoidCrossEntropy_:ebe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rbe(r,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return fu((i,a,o)=>{const l=N$(a,[n],!0),c=hr(Or(a,"float32"),l);o([i,c]);const h=ko(xt(c,i));return{value:bn(h,[n]),gradFunc:(f,m)=>{const[g,y]=m,b=_a(f.shape,[n]);return[xt(Qe(f,b),hr(Or(g,"float32"),hc(y))),xt(Qe(f,b),hr(hc(y),Or(g,"float32")))]}}})(r,t)}function nbe(r,t,n,s=0,i=ti.SUM_BY_NONZERO_WEIGHTS){let a=ne(r,"onehotLabels","softmaxCrossEntropy");const o=ne(t,"logits","softmaxCrossEntropy");let u=null;if(n!=null&&(u=ne(n,"weights","softmaxCrossEntropy")),Gs(a.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){const c=mr(s),h=mr(1),d=mr(a.shape[1]);a=jt(xt(a,hr(h,c)),hn(c,d))}const l=rbe(a,o);return gl(l,u,i)}const sbe=we({softmaxCrossEntropy_:nbe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ibe(r,t,n,s){const i=ne(r,"indices","sparseFillEmptyRows","int32"),a=ne(t,"values","sparseFillEmptyRows"),o=ne(n,"denseShape","sparseFillEmptyRows","int32"),u=ne(s,"defaultValue","sparseFillEmptyRows",a.dtype);if(i.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(u.rank!==0)throw new Error(`Default value should be a scalar but received shape ${u.shape}`);const l={indices:i,values:a,denseShape:o,defaultValue:u},c=Ce.runKernel(FF,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const abe=we({sparseFillEmptyRows_:ibe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function obe(r,t,n){const s=ne(r,"inputIndices","sparseReshape","int32"),i=ne(t,"inputShape","sparseReshape","int32"),a=ne(n,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(i.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const o={inputIndices:s,inputShape:i,newShape:a},u=Ce.runKernel($F,o);return{outputIndices:u[0],outputShape:u[1]}}const ube=we({sparseReshape_:obe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lbe(r,t,n){const s=ne(r,"data","sparseSegmentMean"),i=ne(t,"indices","sparseSegmentMean","int32"),a=ne(n,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const o={data:s,indices:i,segmentIds:a};return Ce.runKernel(RF,o)}const cbe=we({sparseSegmentMean_:lbe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hbe(r,t,n){const s=ne(r,"data","sparseSegmentSum"),i=ne(t,"indices","sparseSegmentSum","int32"),a=ne(n,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const o={data:s,indices:i,segmentIds:a};return Ce.runKernel(OF,o)}const dbe=we({sparseSegmentSum_:hbe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pbe(r,t,n,s,i,a,o,u){const l=ne(r,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=ne(t,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const h={separator:n,nGramWidths:s,leftPad:i,rightPad:a,padWidth:o,preserveShortSequences:u},d={data:l,dataSplits:c},p=Ce.runKernel(VF,d,h);return{nGrams:p[0],nGramsSplits:p[1]}}const fbe=we({stringNGrams_:pbe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mbe(r,t,n=!0){const s=ne(r,"input","stringSplit","string"),i=ne(t,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(i.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const a={skipEmpty:n},o={input:s,delimiter:i},u=Ce.runKernel(zF,o,a);return{indices:u[0],values:u[1],shape:u[2]}}const gbe=we({stringSplit_:mbe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ybe(r,t){const n=ne(r,"input","stringToHashBucketFast","string"),s={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const i={input:n};return Ce.runKernel(UF,i,s)}const bbe=we({stringToHashBucketFast_:ybe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xbe(r,t,n,s=!0){const i=ne(r,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:s};return Ce.runKernel(PF,{x:i},a)}const vbe=we({staticRegexReplace_:xbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yj={fft:iC,ifft:Pb,rfft:aC,irfft:H$},Zj={hammingWindow:j0e,hannWindow:Kj,frame:Xj,stft:Y0e},ad={flipLeftRight:eye,grayscaleToRGB:rye,resizeNearestNeighbor:Nye,resizeBilinear:Iye,rgbToGrayscale:sye,rotateWithOffset:aye,cropAndResize:J0e,nonMaxSuppression:uye,nonMaxSuppressionAsync:gye,nonMaxSuppressionWithScore:bye,nonMaxSuppressionWithScoreAsync:vye,nonMaxSuppressionPadded:Sye,nonMaxSuppressionPaddedAsync:_ye,threshold:Dye,transform:$ye},Jj={bandPart:Oye,gramSchmidt:Lye,qr:Bye},Qj={absoluteDifference:Uye,computeWeightedLoss:gl,cosineDistance:Gye,hingeLoss:jye,huberLoss:Kye,logLoss:Yye,meanSquaredError:Jye,sigmoidCrossEntropy:tbe,softmaxCrossEntropy:sbe},e9={sparseFillEmptyRows:abe,sparseReshape:ube,sparseSegmentMean:cbe,sparseSegmentSum:dbe},t9={stringNGrams:fbe,stringSplit:gbe,stringToHashBucketFast:bbe,staticRegexReplace:vbe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wbe=new Map,Tk=new Map;class r9{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class Vl{constructor(){this.classNameMap={}}static getMap(){return Vl.instance==null&&(Vl.instance=new Vl),Vl.instance}static register(t){Vl.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function n9(r,t,n){oe(r.className!=null,()=>"Class being registered does not have the static className property defined."),oe(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),oe(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=r.className);const s=n,i=t+">"+s;return Vl.register(r),wbe.set(i,r),Tk.set(r,i),r}function Sbe(r){return Tk.has(r)?Tk.get(r):r.className}const Cbe=Object.freeze(Object.defineProperty({__proto__:null,Serializable:r9,SerializationMap:Vl,getRegisteredName:Sbe,registerClass:n9},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $c extends r9{minimize(t,n=!1,s){const{value:i,grads:a}=this.computeGradients(t,s);if(s!=null){const o=s.map(u=>({name:u.name,tensor:a[u.name]}));this.applyGradients(o)}else this.applyGradients(a);return ii(a),n?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return LH(t,n)}dispose(){this.iterations_!=null&&ii(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:mr(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty($c,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nR extends $c{static get className(){return"Adadelta"}constructor(t,n,s=null){super(),this.learningRate=t,this.rho=n,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=Ce.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const a=Ce.registeredVariables[s],o=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accum_grad`,variable:qt(()=>Ji(a).variable(o))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${s}/accum_var`,variable:qt(()=>Ji(a).variable(o))});const u=Array.isArray(t)?t[i].tensor:t[s];if(u==null)return;const l=this.accumulatedGrads[i].variable,c=this.accumulatedUpdates[i].variable;qt(()=>{const h=jt(xt(l,this.rho),xt(Ka(u),1-this.rho)),d=xt(hn(pu(jt(c,this.epsilon)),pu(jt(l,this.epsilon))),u),p=jt(xt(c,this.rho),xt(Ka(d),1-this.rho));l.assign(h),c.assign(p);const f=jt(xt(d,-this.learningRate),a);a.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(ii(this.accumulatedGrads.map(t=>t.variable)),ii(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,n).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedUpdates=t.slice(n,n*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sR extends $c{static get className(){return"Adagrad"}constructor(t,n=.1){super(),this.learningRate=t,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const a=Ce.registeredVariables[s];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accumulator`,variable:qt(()=>pg(a.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[i].tensor:t[s];if(o==null)return;const u=this.accumulatedGrads[i].variable;qt(()=>{const l=jt(u,Ka(o));u.assign(l);const c=jt(xt(hn(o,pu(jt(l,Ce.backend.epsilon()))),-this.learningRate),a);a.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&ii(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iR extends $c{static get className(){return"Adam"}constructor(t,n,s,i=null){super(),this.learningRate=t,this.beta1=n,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],qt(()=>{this.accBeta1=mr(n).variable(),this.accBeta2=mr(s).variable()}),i==null&&(this.epsilon=Ce.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);qt(()=>{const s=hr(1,this.accBeta1),i=hr(1,this.accBeta2);n.forEach((a,o)=>{const u=Ce.registeredVariables[a],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:qt(()=>Ji(u).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${a}/v`,variable:qt(()=>Ji(u).variable(l))});const c=Array.isArray(t)?t[o].tensor:t[a];if(c==null)return;const h=this.accumulatedFirstMoment[o].variable,d=this.accumulatedSecondMoment[o].variable,p=jt(xt(h,this.beta1),xt(c,1-this.beta1)),f=jt(xt(d,this.beta2),xt(Ka(c),1-this.beta2)),m=hn(p,s),g=hn(f,i);h.assign(p),d.assign(f);const y=jt(xt(hn(m,jt(pu(g),this.epsilon)),-this.learningRate),u);u.assign(y)}),this.accBeta1.assign(xt(this.accBeta1,this.beta1)),this.accBeta2.assign(xt(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&ii(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&ii(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),qt(()=>{this.accBeta1.assign(Rm(this.beta1,this.iterations_+1)),this.accBeta2.assign(Rm(this.beta2,this.iterations_+1))});const n=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,n).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aR extends $c{static get className(){return"Adamax"}constructor(t,n,s,i=null,a=0){super(),this.learningRate=t,this.beta1=n,this.beta2=s,this.epsilon=i,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],qt(()=>{this.iteration=mr(0).variable(),this.accBeta1=mr(n).variable()}),i==null&&(this.epsilon=Ce.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);qt(()=>{const s=hr(1,this.accBeta1),i=hn(-this.learningRate,jt(xt(this.iteration,this.decay),1));n.forEach((a,o)=>{const u=Ce.registeredVariables[a],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:Ji(u).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${a}/v`,variable:Ji(u).variable(l)});const c=Array.isArray(t)?t[o].tensor:t[a];if(c==null)return;const h=this.accumulatedFirstMoment[o].variable,d=this.accumulatedWeightedInfNorm[o].variable,p=jt(xt(h,this.beta1),xt(c,1-this.beta1)),f=xt(d,this.beta2),m=qi(c),g=F$(f,m);h.assign(p),d.assign(g);const y=jt(xt(hn(i,s),hn(p,jt(g,this.epsilon))),u);u.assign(y)}),this.iteration.assign(jt(this.iteration,1)),this.accBeta1.assign(xt(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&ii(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&ii(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pC extends $c{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const a=Array.isArray(t)?t[i].tensor:t[s];if(a==null)return;const o=Ce.registeredVariables[s];qt(()=>{const u=jt(xt(this.c,a),o);o.assign(u)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Co(mr(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oR extends pC{static get className(){return"Momentum"}constructor(t,n,s=!1){super(t),this.learningRate=t,this.momentum=n,this.useNesterov=s,this.accumulations=[],this.m=mr(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const a=Ce.registeredVariables[s];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${s}/momentum`,variable:qt(()=>Ji(a).variable(!1))});const o=this.accumulations[i].variable,u=Array.isArray(t)?t[i].tensor:t[s];u!=null&&qt(()=>{let l;const c=jt(xt(this.m,o),u);this.useNesterov?l=jt(xt(this.c,jt(u,xt(c,this.m))),a):l=jt(xt(this.c,c),a),o.assign(c),a.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&ii(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uR extends $c{static get className(){return"RMSProp"}constructor(t,n=.9,s=0,i=null,a=!1){if(super(),this.learningRate=t,this.decay=n,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,i==null&&(this.epsilon=Ce.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const a=Ce.registeredVariables[s],o=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${s}/rms`,variable:qt(()=>Ji(a).variable(o))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${s}/momentum`,variable:qt(()=>Ji(a).variable(o))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${s}/mg`,variable:qt(()=>Ji(a).variable(o))});const u=Array.isArray(t)?t[i].tensor:t[s];if(u==null)return;const l=this.accumulatedMeanSquares[i].variable,c=this.accumulatedMoments[i].variable;qt(()=>{const h=jt(xt(l,this.decay),xt(Ka(u),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[i].variable,p=jt(xt(d,this.decay),xt(u,1-this.decay)),f=hn(xt(u,this.learningRate),pu(hr(h,jt(Ka(p),this.epsilon)))),m=jt(xt(c,this.momentum),f);l.assign(h),d.assign(p),c.assign(m);const g=hr(a,m);a.assign(g)}else{const d=jt(xt(l,this.decay),xt(Ka(u),1-this.decay)),p=jt(xt(c,this.momentum),hn(xt(u,this.learningRate),pu(jt(d,this.epsilon))));l.assign(d),c.assign(p);const f=hr(a,p);a.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&ii(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&ii(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&ii(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,n).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedMoments=t.slice(n,n*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _be=[nR,sR,iR,aR,oR,uR,pC];function Ebe(){for(const r of _be)n9(r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ibe="model",kbe=".json",Nbe=".weights.bin";function W4(r){return new Promise(t=>setTimeout(t)).then(r)}class od{constructor(t){if(!Be().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(od.URL_SCHEME)&&(t=t.slice(od.URL_SCHEME.length)),(t==null||t.length===0)&&(t=Ibe),this.modelJsonFileName=t+kbe,this.weightDataFileName=t+Nbe}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=Bo.join(t.weightData),s=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],a=DG(t,i),o=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),u=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(u.download=this.modelJsonFileName,u.href=o,await W4(()=>u.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await W4(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:xx(t)}}}}od.URL_SCHEME="downloads://";class Tbe{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,n)=>{const s=new FileReader;s.onload=i=>{const a=JSON.parse(i.target.result),o=a.modelTopology;if(o==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:o});return}const l=l$(a,c=>this.loadWeights(c));t(l)},s.onerror=i=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(t){const n=[],s=[];for(const o of t)n.push(...o.weights),s.push(...o.paths);const i=this.checkManifestAndWeightFiles(t),a=s.map(o=>this.loadWeightsFile(o,i[o]));return Promise.all(a).then(o=>[n,o])}loadWeightsFile(t,n){return new Promise((s,i)=>{const a=new FileReader;a.onload=o=>{const u=o.target.result;s(u)},a.onerror=o=>i(`Failed to weights data from file of path '${t}'.`),a.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(t){const n=[],s=this.weightsFiles.map(a=>F4(a.name)),i={};for(const a of t)a.paths.forEach(o=>{const u=F4(o);if(n.indexOf(u)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${u}'`);if(n.push(u),s.indexOf(u)===-1)throw new Error(`Weight file with basename '${u}' is not provided.`);i[o]=this.weightsFiles[s.indexOf(u)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}const Abe=r=>Be().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(od.URL_SCHEME)?Dbe(r.slice(od.URL_SCHEME.length)):null;Fn.registerSaveRouter(Abe);function Dbe(r="model"){return new od(r)}function Fbe(r){return new Tbe(r)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G4(r,t,n,s){o(r),n=n??0,s=s??1,u(n,s);let i=0;const a=l=>(l.then(c=>{const h=n+ ++i/r.length*(s-n);return t(h),c}),l);function o(l){oe(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function u(l,c){oe(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),oe(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),oe(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(r.map(a))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function s9(r,t){t==null&&(t={});const n=t.fetchFunc==null?Be().platform.fetch:t.fetchFunc,s=r.map(d=>n(d,t.requestInit,{isBinary:!0})),u=(t.onProgress==null?await Promise.all(s):await G4(s,t.onProgress,0,.5)).map(d=>d.arrayBuffer());return t.onProgress==null?await Promise.all(u):await G4(u,t.onProgress,.5,1)}function $be(r,t){var n;const s=t.fetchFunc==null?Be().platform.fetch:t.fetchFunc;let i=0,a;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async o=>{for(var u;i<r.length;){a||(a=(await s(r[i],t.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:c}=await a.read();if(l){i++,a=void 0,(u=t.onProgress)===null||u===void 0||u.call(t,i/r.length);continue}o.enqueue(c);return}o.close()}})}async function Rbe(r,t="",n,s){return i9(o=>s9(o,{requestInit:s}))(r,t,n)}function i9(r){return async(t,n="",s)=>{const i=t.map(()=>!1),a={},o=s!=null?s.map(()=>!1):[],u=[];if(t.forEach((f,m)=>{let g=0;f.weights.forEach(y=>{const b="quantization"in y?y.quantization.dtype:y.dtype,x=rd[b]*lt(y.shape),w=()=>{i[m]=!0,a[m]==null&&(a[m]=[]),a[m].push({manifestEntry:y,groupOffset:g,sizeBytes:x})};s!=null?s.forEach((v,S)=>{v===y.name&&(w(),o[S]=!0)}):w(),u.push(y.name),g+=x})}),!o.every(f=>f)){const f=s.filter((m,g)=>!o[g]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${u.join(", ")}.`)}const l=i.reduce((f,m,g)=>(m&&f.push(g),f),[]),c=[];l.forEach(f=>{t[f].paths.forEach(m=>{const g=n+(n.endsWith("/")?"":"/")+m;c.push(g)})});const h=await r(c),d={};let p=0;return l.forEach(f=>{const m=t[f].paths.length,g=new Bo(h.slice(p,p+m));a[f].forEach(b=>{const x=g.slice(b.groupOffset,b.groupOffset+b.sizeBytes),w=NG(x,[b.manifestEntry]);for(const v in w)d[v]=w[v]}),p+=m}),d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Obe="application/octet-stream",Mbe="application/json";class lR{constructor(t,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(oe(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=Be().platform.fetch,oe(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&oe(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],i=DG(t,s);if(n.body.append("model.json",new Blob([JSON.stringify(i)],{type:Mbe}),"model.json"),t.weightData!=null){const o=Bo.join(t.weightData);n.body.append("model.weights.bin",new Blob([o],{type:Obe}),"model.weights.bin")}const a=await this.fetch(this.path,n);if(a.ok)return{modelArtifactsInfo:xx(t),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await t.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=n.modelTopology,i=n.weightsManifest;if(s==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return l$(t,n=>this.loadWeights(n))}async loadStream(){const t=await this.loadModelJSON(),n=await this.getWeightUrls(t.weightsManifest),s=Ck(t.weightsManifest),i=()=>$be(n,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:s,getWeightStream:i})}async getWeightUrls(t){const n=Array.isArray(this.path)?this.path[1]:this.path,[s,i]=Lbe(n),a=this.weightPathPrefix||s,o=[],u=[];for(const l of t)for(const c of l.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(c)):o.push(a+c+i);return this.weightUrlConverter&&o.push(...await Promise.all(u)),o}async loadWeights(t){const n=await this.getWeightUrls(t),s=Ck(t),i=await s9(n,this.loadOptions);return[s,i]}}lR.URL_SCHEME_REGEX=/^https?:\/\//;function Lbe(r){const t=r.lastIndexOf("/"),n=r.lastIndexOf("?"),s=r.substring(0,t),i=n>t?r.substring(n):"";return[s+"/",i]}function Ak(r){return r.match(lR.URL_SCHEME_REGEX)!=null}const a9=(r,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(r)?n=r.every(s=>Ak(s)):n=Ak(r),n)return cR(r,t)}return null};Fn.registerSaveRouter(a9);Fn.registerLoadRouter(a9);function cR(r,t){return new lR(r,t)}function Pbe(r,t){return cR(r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jE{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class o9{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class Bbe{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=n=>Promise.resolve(t.save(n)))}}function Vbe(r,t,n,s){const i=arguments;return new Bbe(u9(...i))}function u9(r,t,n,s){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new jE(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new jE({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new jE({modelTopology:r,weightSpecs:t,weightData:n,trainingConfig:s}))}function zbe(r){return new o9(r)}function Ube(r){return new o9(r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hR=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Bo,browserFiles:Fbe,browserHTTPRequest:Pbe,concatenateArrayBuffers:Ude,copyModel:cpe,decodeWeights:NG,decodeWeightsStream:AG,encodeWeights:Mde,fromMemory:Vbe,fromMemorySync:u9,getLoadHandlers:Yde,getModelArtifactsForJSON:l$,getModelArtifactsForJSONSync:FG,getModelArtifactsInfoForJSON:xx,getSaveHandlers:Xde,getWeightSpecs:Ck,http:cR,isHTTPScheme:Ak,listModels:upe,loadWeights:Rbe,moveModel:hpe,registerLoadRouter:Kde,registerSaveRouter:qde,removeModel:lpe,weightsLoaderFactory:i9,withSaveHandler:zbe,withSaveHandlerSync:Ube},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wbe(r,t,n){const s=ne(r,"labels","confusionMatrix"),i=ne(t,"predictions","confusionMatrix");oe(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),oe(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),oe(i.rank===1,()=>`Expected the rank of predictions to be 1, but got ${i.rank}`),oe(s.shape[0]===i.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`),oe(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const a=Lb(Or(s,"int32"),n),o=Lb(Or(i,"int32"),n),u=Bb(a),l=Vr(u,o);return Or(l,"int32")}const Gbe=we({confusionMatrix_:Wbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hbe=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:Gbe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sh,H4=!1;function l9(r,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,s=!1,i=!1,a=!1,o=!1,u=!1;if(r.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&r instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement)a=!0;else if(r.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&r instanceof ImageBitmap)u=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(kb(b2,Ce.backendName)!=null){const m={pixels:r},g={numChannels:t};return Ce.runKernel(b2,m,g)}const[c,h]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height];let d;if(o)d=r.getContext("2d").getImageData(0,0,c,h).data;else if(s||n)d=r.data;else if(a||i||u){if(sh==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")sh=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else sh=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});sh.canvas.width=c,sh.canvas.height=h,sh.drawImage(r,0,0,c,h),d=sh.getImageData(0,0,c,h).data}let p;if(t===4)p=new Int32Array(d);else{const m=c*h;p=new Int32Array(m*t);for(let g=0;g<m;g++)for(let y=0;y<t;++y)p[g*t+y]=d[g*4+y]}return K$(p,[h,c,t],"int32")}function jbe(r){return r!=null&&r.data instanceof Uint8Array}function qbe(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function Kbe(r){return r!=null&&r.width!==0&&r.height!==0}function Xbe(r){return qbe()&&!(r instanceof ImageBitmap)&&Kbe(r)&&!jbe(r)}async function Ybe(r,t=3){let n=null;if(Be().getBool("WRAP_TO_IMAGEBITMAP")&&Xbe(r)){let s;try{s=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===r.width&&s.height===r.height?n=s:n=r}else n=r;return l9(n,t)}function c9(r){if(r.rank!==2&&r.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${r.rank}.`);const t=r.rank===2?1:r.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(r.dtype!=="float32"&&r.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${r.dtype}. Please use float32 or int32 tensors.`)}function Zbe(r){const t=(r==null?void 0:r.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function fC(r,t){let n=ne(r,"img","toPixels");if(!(r instanceof Xr)){const c=n;n=Or(c,"int32"),c.dispose()}c9(n);const[s,i]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2],o=await n.data(),u=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(i*s*4);for(let c=0;c<s*i;++c){const h=[0,0,0,255];for(let p=0;p<a;p++){const f=o[c*a+p];if(n.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(n.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);a===1?(h[0]=f*u,h[1]=f*u,h[2]=f*u):h[p]=f*u}const d=c*4;l[d+0]=Math.round(h[0]),l[d+1]=Math.round(h[1]),l[d+2]=Math.round(h[2]),l[d+3]=Math.round(h[3])}if(t!=null){H4||kb(JA,Ce.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),H4=!0),t.width=i,t.height=s;const c=t.getContext("2d"),h=new ImageData(l,i,s);c.putImageData(h,0,0)}return n!==r&&n.dispose(),l}function Jbe(r,t,n){let s=ne(r,"img","draw");if(!(r instanceof Xr)){const o=s;s=Or(o,"int32"),o.dispose()}c9(s),Zbe(n==null?void 0:n.imageOptions);const i={image:s},a={canvas:t,options:n};Ce.runKernel(JA,i,a)}const mC=we({fromPixels_:l9}),Qbe=Object.freeze(Object.defineProperty({__proto__:null,draw:Jbe,fromPixels:mC,fromPixelsAsync:Ybe,toPixels:fC},Symbol.toStringTag,{value:"Module"}));function dR(r,t){const n=r.shape.length,s=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${n}`);if(lt(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);const i=t.shape,a=i[i.length-1];let o=1;for(let d=0;d<i.length-1;++d)o*=i[d];const u=r.shape,l=i.slice();l.pop();let c=1;for(let d=a;d<n;++d)c*=u[d],l.push(u[d]);const h=[...ws(r.shape).map(d=>d/c),1].slice(0,a);return[l,o,c,h]}const exe=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:dR},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dk=-2,txe=-1;function h9(r,t,n){const s=r.shape.length;oe(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),oe(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let i=0;i<s;++i)oe(t[i]+n[i]<=r.shape[i],()=>`Error in slice${s}D: begin[${i}] + size[${i}] (${t[i]+n[i]}) would overflow input.shape[${i}] (${r.shape[i]})`)}function rxe(r){const t=[];let n=0;for(;r>0;)r&1&&t.push(n),r/=2,n++;return t}function d9(r,t,n){const s=[];for(let i=0;i<r.length;i++)s[i]=Math.ceil((t[i]-r[i])/n[i]);return s}function p9(r,t,n,s){const i=[...r];for(let a=i.length;a<s.length;a++)i.push(1);for(let a=0;a<n;a++)a===0?i[t]=1:(i.splice(t,0,1),i.pop());return i}function f9(r,t,n){return n<=r?n:n-(t-1)}function m9(r,t){const n=[];for(let s=0;s<r;s++)n.push(t+s);return n}function nxe(r,t,n,s,i,a,o,u,l){const c=r.length;let h=new Array(c),d=new Array(c),p=new Array(c);if(t.length&&n>0){const f=t[0],m=n+1;h=g9(o,f,m,s,r),d=y9(u,f,m,i,r),p=p9(a,f,m,r)}else for(let f=0;f<c;f++)h[f]=x9(o,s,a,r,f,l),d[f]=v9(u,i,a,r,f,l),p[f]=b9(a,f,l);return{begin:h,end:d,strides:p}}function g9(r,t,n,s,i){const a=[...i],o=m9(n,t);for(let u=0;u<a.length;u++)if(o.indexOf(u)>-1)a[u]=0;else{const l=f9(t,n,u);let c=s[l];r&1<<l&&(c=0),a[u]=c}return a}function y9(r,t,n,s,i){const a=[...i],o=m9(n,t);for(let u=0;u<a.length;u++)if(o.indexOf(u)>-1)a[u]=Number.MAX_SAFE_INTEGER;else{const l=f9(t,n,u);let c=s[l];r&1<<l&&(c=Number.MAX_SAFE_INTEGER),a[u]=c}for(let u=0;u<a.length;u++){const l=i[u];a[u]<0&&(a[u]+=l),a[u]=_b(0,a[u],i[u])}return a}function b9(r,t,n){let s=r[t];return(n&1<<t||s==null)&&(s=1),s}function x9(r,t,n,s,i,a){let o=t[i];const u=n[i]||1;(r&1<<i||a&1<<i||o==null)&&(u>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=s[i];return o<0&&(o+=l),o=_b(0,o,l-1),o}function v9(r,t,n,s,i,a){let o=t[i];const u=n[i]||1;(r&1<<i||a&1<<i||o==null)&&(u>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=s[i];return o<0&&(o+=l),u>0?o=_b(0,o,l):o=_b(-1,o,l-1),o}function pR(r,t,n){let s=n.length;for(let i=0;i<n.length;i++)if(n[i]>1){s=i;break}for(let i=s+1;i<n.length;i++)if(t[i]>0||n[i]!==r[i])return!1;return!0}function fR(r,t){let n=r.length>0?r[r.length-1]:1;for(let s=0;s<r.length-1;s++)n+=r[s]*t[s];return n}function w9(r,t,n){let s;const i=r.shape.length;typeof t=="number"?s=[t,...new Array(i-1).fill(0)]:t.length<i?s=t.concat(new Array(i-t.length).fill(0)):s=t.slice(),s.forEach(o=>{oe(o!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(i).fill(-1):typeof n=="number"?a=[n,...new Array(i-1).fill(-1)]:n.length<i?a=n.concat(new Array(i-n.length).fill(-1)):a=n,a=a.map((o,u)=>o>=0?o:(oe(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${u}.`),r.shape[u]-s[u])),[s,a]}function S9(r,t,n,s,i,a,o,u,l){let c;if(s==null?(c=new Array(t.length),c.fill(1)):c=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:i,endMask:a,ellipsisMask:o,newAxisMask:u,shrinkAxisMask:l};for(let w=0;w<d.dims;w++)h&&(1<<w&u)!==0&&d.numAddAxisAfterEllipsis++,1<<w&o&&(h=!0);h||(d.ellipsisMask|=1<<d.dims,d.dims++);const p={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};sxe(d,p);let f=!0,m=!0,g=!0;const y=[],b=[];for(let w=0;w<r.length;++w){if(p.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);const v=!!(p.shrinkAxisMask&1<<w),S=r[w];if(S===-1){y.push(v?1:-1);continue}const E=[p.beginMask&1<<w,p.endMask&1<<w],C=[p.strides[w]>0?0:-1,p.strides[w]>0?S:S-1];if(v&&p.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&p.strides[w]===1;const I=!!(p.beginMask&1<<w&&p.endMask&1<<w);if(p.beginValid&&p.endValid){if(v){const N=p.begin[w]<0?S+p.begin[w]:p.begin[w];if(p.begin[w]=N,p.end[w]=p.begin[w]+1,N<0||N>=S)throw Error(`slice index ${p.begin[w]} of dimension ${w} out of bounds.`)}else p.begin[w]=j4(p.begin[w],0,p.strides[w],S,E,C),p.end[w]=j4(p.end[w],1,p.strides[w],S,E,C);const k=p.strides[w]===1&&p.begin[w]===0&&p.end[w]===S;f=f&&k,m=m&&(w===0&&p.strides[w]===1||k)}else f=f&&p.strides[w]===1&&I,m=m&&(w===0&&p.strides[w]===1||I);let _,A=!1;if(p.beginValid&&p.endValid?(_=p.end[w]-p.begin[w],A=!0):v?(_=1,A=!0):I&&S>=0&&(p.strides[w]<0?_=-S:_=S,A=!0),A){let k;_===0||_<0!=p.strides[w]<0?k=0:k=Math.trunc(_/p.strides[w])+(_%p.strides[w]!==0?1:0),y.push(k)}else y.push(-1)}for(let w=0;w<p.finalShapeGatherIndices.length;++w){const v=p.finalShapeGatherIndices[w];v>=0?b.push(y[v]):v===Dk&&b.push(1)}return{finalShapeSparse:b.filter((w,v)=>p.finalShapeGatherIndices[v]!==Dk),finalShape:b,isIdentity:f,sliceDim0:m,isSimpleSlice:g,begin:p.begin,end:p.end,strides:p.strides}}function sxe(r,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=r.begin!=null,t.endValid=r.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<r.dims;s++)if(1<<s&r.ellipsisMask){const i=Math.min(t.dims-(r.dims-s)+1+r.numAddAxisAfterEllipsis,t.dims);for(;n<i;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=s}else if(1<<s&r.newAxisMask)t.finalShapeGatherIndices.push(Dk),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);r.begin!=null&&(t.begin[n]=r.begin[s]),r.end!=null&&(t.end[n]=r.end[s]),t.strides[n]=r.strides[s],r.beginMask&1<<s&&(t.beginMask|=1<<n),r.endMask&1<<s&&(t.endMask|=1<<n),r.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(txe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[n]=s,n++}}function j4(r,t,n,s,i,a){if(i[t])return n>0?a[t]:a[t+1&1];{const o=r<0?s+r:r;return o<a[0]?a[0]:o>a[1]?a[1]:o}}const C9=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:h9,computeFlatOffset:fR,computeOutShape:d9,getNormalizedAxes:nxe,isSliceContinous:pR,maskToAxes:rxe,parseSliceParams:w9,sliceInfo:S9,startForAxis:x9,startIndicesWithElidedDims:g9,stopForAxis:v9,stopIndicesWithElidedDims:y9,stridesForAxis:b9,stridesWithElidedDims:p9},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const ixe="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _9{static sgd(t){return new pC(t)}static momentum(t,n,s=!1){return new oR(t,n,s)}static rmsprop(t,n=.9,s=0,i=null,a=!1){return new uR(t,n,s,i,a)}static adam(t=.001,n=.9,s=.999,i=null){return new iR(t,n,s,i)}static adadelta(t=.001,n=.95,s=null){return new nR(t,n,s)}static adamax(t=.002,n=.9,s=.999,i=null,a=0){return new aR(t,n,s,i,a)}static adagrad(t,n=.1){return new sR(t,n)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const axe=_9;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oxe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:r=>r();function E9(){return new Promise(r=>oxe(()=>r()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I9(r,t){const n=r[0].length;r.forEach((i,a)=>{oe(i.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),oe(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=r[0];r.forEach((i,a)=>{for(let o=0;o<n;o++)oe(o===t||i[o]===s[o],()=>`Error in concat${n}D: Shape of tensors[${a}] (${i}) does not match the shape of the rest (${s}) along the non-concatenated axis ${a}.`)})}function ud(r,t){const n=r[0].slice();for(let s=1;s<r.length;s++)n[t]+=r[s][t];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var xo;(function(r){r[r.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",r[r.VALUE_ROWIDS=1]="VALUE_ROWIDS",r[r.ROW_LENGTHS=2]="ROW_LENGTHS",r[r.ROW_SPLITS=3]="ROW_SPLITS",r[r.ROW_LIMITS=4]="ROW_LIMITS",r[r.ROW_STARTS=5]="ROW_STARTS"})(xo||(xo={}));function k9(r,t,n){let s=new Array;if(n==null&&t==null)return s;if(t==null)for(;s.length<r+n.length;)s.push(-1);else s=t.slice();if(n==null)return s;if(r+n.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${r+n.length}, but shape.rank = ${s.length}`);for(let i=1;i<n.length;++i){const a=n[i],o=s[s.length-n.length+i],u=s[o];if(a>=0)if(u>=0){if(u!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${i+r}] = ${a} but shape[${i+r}] = ${u}`)}else s[o]=a}return s}function N9(r){const t={FIRST_DIM_SIZE:xo.FIRST_DIM_SIZE,VALUE_ROWIDS:xo.VALUE_ROWIDS,ROW_LENGTHS:xo.ROW_LENGTHS,ROW_SPLITS:xo.ROW_SPLITS,ROW_LIMITS:xo.ROW_LIMITS,ROW_STARTS:xo.ROW_STARTS},n=[];for(const s of r)if(s in t)n.push(t[s]);else break;return n}function T9(r){return r.length===0?0:r[0]===xo.FIRST_DIM_SIZE?r.length-1:r.length}function A9(r,t){if(r==null||t==null)return;const n=r.length,s=t.length;if(n>=s)throw new Error(`defaultValue.shape=${r} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);for(let i=0;i<Math.min(n,s-1);++i){const a=r[i],o=t[i+1];if(a>=0&&o>=0&&a!==1&&a!==o)throw new Error(`defaultValue.shape=${r}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${i-r.length}] = ${a} but ragged tensor input.flatValues.shape[${i-r.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mR=30;function gC(r){return r<=mR?r:g2(r,Math.floor(Math.sqrt(r)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D9(r,t,n){const s=n*(typeof r=="number"?r:r[0]),i=t*(typeof r=="number"?r:r[1]);return[s,i]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gR(r,t,n,s=!0){let i=[];if(s)i=i.concat(t.slice(0)),i.push(r[0]/n),i=i.concat(r.slice(1));else{i=i.concat(r[0]);const a=t.length;for(let o=0;o<a;++o)i=i.concat([r[o+1]/t[o],t[o]]);i=i.concat(r.slice(a+1))}return i}function yR(r,t,n=!0){const s=[];if(n){s.push(t);for(let i=t+1;i<r;++i)i<=2*t?(s.push(i),s.push(i-(t+1))):s.push(i)}else{const i=[],a=[];for(let o=1;o<r;++o)o>=t*2+1||o%2===1?a.push(o):i.push(o);s.push(...i),s.push(0),s.push(...a)}return s}function bR(r,t,n,s=!0){const i=[];s?i.push(r[0]/n):i.push(r[0]*n);for(let a=1;a<r.length;++a)a<=t.length?s?i.push(t[a-1]*r[a]):i.push(r[a]/t[a-1]):i.push(r[a]);return i}function F9(r,t){const n=[0];for(let s=0;s<t;++s)n.push(r[s][0]);return n}function $9(r,t,n){const s=r.slice(0,1);for(let i=0;i<n;++i)s.push(r[i+1]-t[i][0]-t[i][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R9=1.7580993408473768,O9=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M9=.3275911,L9=.254829592,P9=-.284496736,B9=1.421413741,V9=-1.453152027,z9=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fk(r,t){if(r.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${t.length}.`);const n=new Float32Array(r.length*2);for(let s=0;s<n.length;s+=2)n[s]=r[s/2],n[s+1]=t[s/2];return n}function uxe(r){const t=new Float32Array(r.length/2),n=new Float32Array(r.length/2);for(let s=0;s<r.length;s+=2)t[s/2]=r[s],n[s/2]=r[s+1];return{real:t,imag:n}}function lxe(r){const t=Math.ceil(r.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let i=0;i<r.length;i+=4)n[Math.floor(i/4)]=r[i],s[Math.floor(i/4)]=r[i+1];return{real:n,imag:s}}function cxe(r){const t=Math.floor(r.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let i=2;i<r.length;i+=4)n[Math.floor(i/4)]=r[i],s[Math.floor(i/4)]=r[i+1];return{real:n,imag:s}}function hxe(r,t){const n=r[t*2],s=r[t*2+1];return{real:n,imag:s}}function dxe(r,t,n,s){r[s*2]=t,r[s*2+1]=n}function pxe(r,t){const n=new Float32Array(r/2),s=new Float32Array(r/2);for(let i=0;i<Math.ceil(r/2);i++){const a=(t?2:-2)*Math.PI*(i/r);n[i]=Math.cos(a),s[i]=Math.sin(a)}return{real:n,imag:s}}function fxe(r,t,n){const s=(n?2:-2)*Math.PI*(r/t),i=Math.cos(s),a=Math.sin(s);return{real:i,imag:a}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qE="->",mxe=/->/g,q4=",",K4="...";function U9(r,t){r=r.replace(/\s/g,"");const n=(r.length-r.replace(mxe,"").length)/qE.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${qE}").`);const[s,i]=r.split(qE);oe(s.indexOf(K4)===-1,()=>`The ellipsis notation ("${K4}") is not supported yet.`);const a=s.split(q4),o=a.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const u=[];for(let p=0;p<i.length;++p){const f=i[p];if(!a.some(m=>m.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);u.indexOf(f)===-1&&u.push(f)}for(let p=0;p<s.length;++p){const f=s[p];u.indexOf(f)===-1&&f!==q4&&u.push(f)}const l=new Array(a.length);for(let p=0;p<o;++p){if(new Set(a[p].split("")).size!==a[p].length)throw new Error(`Found duplicate axes in input component ${a[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let f=0;f<a[p].length;++f)l[p].push(u.indexOf(a[p][f]))}const c=u.length,h=i.length,d=[];for(let p=h;p<c;++p)d.push(p);return{allDims:u,summedDims:d,idDims:l}}function W9(r,t){let n=new Array(r);n.fill(-1);for(let i=0;i<t.length;++i)n[t[i]]=i;const s=[];for(let i=0;i<r;++i)n[i]===-1&&s.push(i);return n=n.filter(i=>i!==-1),{permutationIndices:n,expandDims:s}}function G9(r,t,n){const s=new Array(r);for(let i=0;i<n.length;++i){const a=n[i].shape;for(let o=0;o<t[i].length;++o)s[t[i][o]]===void 0?s[t[i][o]]=a[o]:oe(s[t[i][o]]===a[o],()=>`Expected dimension ${s[t[i][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function H9(r,t){const n=r,s=[];let i=0;r.length===0&&n.push(-1),i=r.length+1;for(let o=0;o<i;++o)s.push([]);const a=[];for(let o=0;o<n.length;++o){const u=n[o],l=gxe(t,u);for(const c of l)a.indexOf(c)===-1&&(s[o].push(c),a.push(c))}return{path:n,steps:s}}function j9(r){return r.every((t,n)=>t===n)}function gxe(r,t){const n=[];for(let s=0;s<r.length;++s)(r[s].length===0||r[s].indexOf(t)!==-1||t===-1)&&n.push(s);return n}function q9(r,t,n=0){let s=[];if(typeof t=="number")oe(r.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(r.shape[n]/t);else{const i=t.reduce((o,u)=>(u===-1&&(o+=1),o),0);oe(i<=1,()=>"There should be only one negative value in split array.");const a=t.indexOf(-1);if(a!==-1){const o=t.reduce((u,l)=>l>0?u+l:u);t[a]=r.shape[n]-o}oe(r.shape[n]===t.reduce((o,u)=>o+u),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K9(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function X9(r,t){return`indices(${r}, 0) is invalid: ${t} < 0`}function Y9(r,t,n){return`indices(${r}, 0) is invalid: ${t} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z9(r,t){return`only one output dimension may be -1, not both ${r} and ${t}`}function J9(r,t){return`size ${r} must be non-negative, not ${t}`}function Q9(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function e7(r,t){const n=lt(r),s=lt(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${r} outputShape= ${t}`}function t7(r,t){const n=lt(r),s=lt(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${r} outputShape=${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $k(){return"segment ids must be >= 0"}function r7(){return"segment ids are not increasing"}function n7(r,t){return`Segment id ${r} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function s7(r,t,n){return`Bad: indices[${r}] == ${t} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i7(r,t){let n=!1,s;for(r<=mR?(s=r,n=!0):s=g2(r,Math.floor(Math.sqrt(r)));!n;)s>t||s===r?n=!0:s=g2(r,s+1);return s}function a7(r,t,n){const s=[],i=r.length;for(let a=0;a<i;a++)a!==t?s.push(r[a]):s.push(n);return s}function o7(r,t,n,s){const i=t.shape.length,a=r.shape.length;if(s!==0&&(s<-i||s>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${s}`);if(s<0&&(s+=i),s>a)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${a}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let d=0;d<s;++d)if(r.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${r.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const o=r.shape[n],u=[];let l=1,c=1,h=1;for(let d=0;d<s;++d)u.push(r.shape[d]),l*=r.shape[d];for(let d=s;d<n;d++)u.push(r.shape[d]),c*=r.shape[d];for(let d=s;d<i;d++)u.push(t.shape[d]);for(let d=n+1;d<a;d++)u.push(r.shape[d]),h*=r.shape[d];return{batchSize:l,sliceSize:h,outerSize:c,dimSize:o,outputShape:u}}const yxe=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:o7,computeOutShape:a7,segOpComputeOptimalWindowSize:i7},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pm(r){try{return r.map(t=>ed(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function u7(r){return r.map(t=>Zu(t))}const l7=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:L9,ERF_A2:P9,ERF_A3:B9,ERF_A4:V9,ERF_A5:z9,ERF_P:M9,PARALLELIZE_THRESHOLD:mR,get RowPartitionType(){return xo},SELU_SCALE:O9,SELU_SCALEALPHA:R9,applyActivation:hC,assertAndGetBroadcastShape:Fr,assertAxesAreInnerMostDims:Vo,assertParamsConsistent:I9,assignToTypedArray:dxe,axesAreInnerMostDims:x$,calculateShapes:Nx,checkEinsumDimSizes:G9,checkPadOnDimRoundingMode:to,combineLocations:NH,combineRaggedTensorToTensorShapes:k9,complexWithEvenIndex:lxe,complexWithOddIndex:cxe,computeConv2DInfo:Ca,computeConv3DInfo:wx,computeDefaultPad:p$,computeDilation2DInfo:ZG,computeOptimalWindowSize:gC,computeOutAndReduceShapes:_u,computeOutShape:ud,computePool2DInfo:Pd,computePool3DInfo:vx,convertConv2DDataFormat:dg,decodeEinsumEquation:U9,eitherStridesOrDilationsAreOne:oa,expandShapeToKeepDim:_a,exponent:fxe,exponents:pxe,fromStringArrayToUint8:u7,fromUint8ToStringArray:Pm,getAxesPermutation:ro,getBroadcastDims:$b,getComplexWithIndex:hxe,getEinsumComputePath:H9,getEinsumPermutation:W9,getFusedBiasGradient:cC,getFusedDyActivation:lC,getImageCenter:D9,getInnerMostAxes:no,getPermuted:yR,getRaggedRank:T9,getReductionAxes:y$,getReshaped:gR,getReshapedPermuted:bR,getRowPartitionTypesHelper:N9,getSliceBeginCoords:F9,getSliceSize:$9,getSparseFillEmptyRowsIndicesDenseShapeMismatch:K9,getSparseFillEmptyRowsNegativeIndexErrorMessage:X9,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Y9,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Q9,getSparseReshapeInputOutputMismatchErrorMessage:t7,getSparseReshapeInputOutputMultipleErrorMessage:e7,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Z9,getSparseReshapeNegativeOutputDimErrorMessage:J9,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:s7,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:$k,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:r7,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:n7,getUndoAxesPermutation:v$,isIdentityPermutation:j9,log:Uhe,mergeRealAndImagArrays:Fk,prepareAndValidate:dR,prepareSplitSize:q9,segment_util:yxe,shouldFuse:dC,slice_util:C9,splitRealAndImagArrays:uxe,stridesOrDilationsArePositive:id,tupleValuesAreOne:Fb,upcastType:Fo,validateDefaultValueShape:A9,validateInput:oC,validateUpdateShape:X$,warn:Wa},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bxe=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:Q$,nonMaxSuppressionV4Impl:eR,nonMaxSuppressionV5Impl:tR,whereImpl:Y$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ebe();const c7=Object.freeze(Object.defineProperty({__proto__:null,Abs:cA,Acos:hA,Acosh:dA,AdadeltaOptimizer:nR,AdagradOptimizer:sR,AdamOptimizer:iR,AdamaxOptimizer:aR,Add:XS,AddN:pA,All:fA,Any:mA,ArgMax:gA,ArgMin:yA,Asin:bA,Asinh:xA,Atan:vA,Atan2:SA,Atanh:wA,AvgPool:CA,AvgPool3D:_A,AvgPool3DGrad:sG,AvgPoolGrad:nG,BatchMatMul:EA,BatchToSpaceND:IA,Bincount:kA,BitwiseAnd:NA,BroadcastArgs:TA,BroadcastTo:$he,Cast:YS,Ceil:AA,ClipByValue:DA,Complex:FA,ComplexAbs:$A,Concat:RA,Conv2D:OA,Conv2DBackpropFilter:MA,Conv2DBackpropInput:LA,Conv3D:PA,Conv3DBackpropFilterV2:iG,Conv3DBackpropInputV2:BA,Cos:VA,Cosh:zA,CropAndResize:GA,Cumprod:UA,Cumsum:WA,DataStorage:W8,DenseBincount:HA,DepthToSpace:jA,DepthwiseConv2dNative:qA,DepthwiseConv2dNativeBackpropFilter:KA,DepthwiseConv2dNativeBackpropInput:XA,Diag:YA,Dilation2D:ZA,Dilation2DBackpropFilter:Ohe,Dilation2DBackpropInput:Rhe,Draw:JA,get ENV(){return uA},Einsum:eD,Elu:tD,EluGrad:aG,Environment:tG,Equal:nD,Erf:rD,Exp:sD,ExpandDims:iD,Expm1:aD,FFT:oD,Fill:uD,FlipLeftRight:lD,Floor:cD,FloorDiv:hD,FromPixels:b2,FusedBatchNorm:dD,FusedConv2D:v2,FusedDepthwiseConv2D:w2,GatherNd:fD,GatherV2:pD,Greater:mD,GreaterEqual:gD,IFFT:yD,Identity:ZS,Imag:bD,IsFinite:xD,IsInf:vD,IsNan:wD,KernelBackend:aA,LRN:DD,LRNGrad:oG,LeakyRelu:SD,Less:CD,LessEqual:_D,LinSpace:ED,Log:ID,Log1p:kD,LogSoftmax:Lhe,LogicalAnd:ND,LogicalNot:TD,LogicalOr:AD,LogicalXor:Mhe,LowerBound:Phe,MatrixBandPart:Bhe,Max:FD,MaxPool:RD,MaxPool3D:OD,MaxPool3DGrad:lG,MaxPoolGrad:uG,MaxPoolWithArgmax:MD,Maximum:$D,Mean:LD,Min:PD,Minimum:BD,MirrorPad:VD,Mod:zD,MomentumOptimizer:oR,Multinomial:UD,Multiply:WD,Neg:GD,NonMaxSuppressionV3:jD,NonMaxSuppressionV4:qD,NonMaxSuppressionV5:KD,NotEqual:HD,OP_SCOPE_SUFFIX:i$,OneHot:YD,OnesLike:XD,Optimizer:$c,OptimizerConstructors:_9,Pack:ZD,PadV2:JD,Pool:Vhe,Pow:QD,Prelu:eF,Prod:tF,RMSPropOptimizer:uR,RaggedGather:rF,RaggedRange:nF,RaggedTensorToTensor:sF,Range:iF,get Rank(){return yk},Real:aF,RealDiv:QA,Reciprocal:oF,get Reduction(){return ti},Relu:uF,Relu6:dF,Reshape:lF,ResizeBilinear:hF,ResizeBilinearGrad:hG,ResizeNearestNeighbor:cF,ResizeNearestNeighborGrad:cG,Reverse:pF,RotateWithOffset:QF,Round:fF,Rsqrt:mF,SGDOptimizer:pC,ScatterNd:gF,SearchSorted:bF,Select:xF,Selu:vF,Sigmoid:EF,Sign:_F,Sin:SF,Sinh:CF,Slice:wF,Softmax:DF,Softplus:IF,SpaceToBatchND:TF,SparseFillEmptyRows:FF,SparseReshape:$F,SparseSegmentMean:RF,SparseSegmentSum:OF,SparseToDense:MF,SplitV:AF,Sqrt:kF,Square:dG,SquaredDifference:LF,StaticRegexReplace:PF,Step:JF,StridedSlice:BF,StringNGrams:VF,StringSplit:zF,StringToHashBucketFast:UF,Sub:WF,Sum:NF,Tan:GF,Tanh:HF,Tensor:Xr,TensorBuffer:td,TensorScatterUpdate:yF,Tile:JS,TopK:jF,Transform:qF,Transpose:Xy,Unique:KF,Unpack:XF,UnsortedSegmentSum:YF,UpperBound:zhe,Variable:Nb,ZerosLike:ZF,_FusedMatMul:x2,abs:qi,acos:VG,acosh:zG,add:jt,addN:UG,all:WG,any:GG,argMax:d$,argMin:HG,asin:jG,asinh:qG,atan:KG,atan2:XG,atanh:YG,avgPool:f$,avgPool3d:JG,backend:o$,backend_util:l7,basicLSTMCell:QG,batchNorm:Sx,batchNorm2d:eH,batchNorm3d:tH,batchNorm4d:rH,batchToSpaceND:m$,bincount:g$,bitwiseAnd:nH,booleanMaskAsync:Vj,broadcastArgs:sH,broadcastTo:dm,broadcast_util:kfe,browser:Qbe,buffer:Tn,cast:Or,ceil:iH,clipByValue:aH,clone:Ju,complex:cl,concat:zs,concat1d:oH,concat2d:uH,concat3d:lH,concat4d:cH,conv1d:hH,conv2d:Cx,conv2dTranspose:pH,conv3d:fH,conv3dTranspose:mH,copyRegisteredKernels:jhe,cos:gH,cosh:yH,cosineWindow:uC,cumprod:bH,cumsum:xH,customGrad:fu,denseBincount:vH,deprecationWarn:Ede,depthToSpace:wH,depthwiseConv2d:eC,device_util:xde,diag:SH,dilation2d:CH,disableDeprecationWarnings:_de,dispose:ii,disposeVariables:Ide,div:hn,divNoNan:_H,dot:EH,dropout:Hj,einsum:vh,elu:b$,enableDebugMode:Cde,enableProdMode:Sde,enclosingPowerOfTwo:J$,engine:mo,ensureShape:IH,env:Be,equal:_x,erf:kH,euclideanNorm:AH,exp:hc,expandDims:vi,expm1:DH,eye:w$,fft:iC,fill:pg,findBackend:$de,findBackendFactory:Rde,floor:S$,floorDiv:h$,fused:qj,gather:C$,gatherND:Gj,gather_util:exe,getBackend:a$,getGradient:mk,getKernel:kb,getKernelsForBackend:S2,grad:cme,grads:hme,greater:fg,greaterEqual:_$,ifft:Pb,imag:Ix,image:ad,inTopKAsync:jj,io:hR,irfft:H$,isFinite:FH,isInf:$H,isNaN:RH,keep:Co,kernel_impls:bxe,leakyRelu:E$,less:E2,lessEqual:tC,linalg:Jj,linspace:OH,localResponseNormalization:MH,log:Om,log1p:I$,logSigmoid:PH,logSoftmax:BH,logSumExp:N$,logicalAnd:Rb,logicalNot:T$,logicalOr:A$,logicalXor:VH,losses:Qj,lowerBound:zH,matMul:Vr,math:Hbe,max:Rh,maxPool:D$,maxPool3d:UH,maxPoolWithArgmax:WH,maximum:F$,mean:Ob,memory:kde,meshgrid:GH,min:_2,minimum:Mb,mirrorPad:$$,mod:HH,moments:jH,movingAverage:zj,mul:xt,multiRNNCell:qH,multinomial:KH,neg:ko,nextFrame:E9,norm:Ex,notEqual:R$,oneHot:Lb,ones:ql,onesLike:XH,op:we,outerProduct:YH,pad:Bd,pad1d:ZH,pad2d:JH,pad3d:O$,pad4d:QH,pool:ej,pow:Rm,prelu:L$,print:c$,prod:tj,profile:Nde,raggedGather:rj,raggedRange:nj,raggedTensorToTensor:sj,rand:ij,randomGamma:uj,randomNormal:U$,randomStandardNormal:lj,randomUniform:sC,randomUniformInt:cj,range:pc,ready:Dde,real:Mm,reciprocal:hj,registerBackend:kG,registerGradient:Whe,registerKernel:e$,relu:kx,relu6:W$,removeBackend:Fde,reshape:Qe,reverse:fc,reverse1d:dj,reverse2d:pj,reverse3d:fj,reverse4d:mj,rfft:aC,round:G$,rsqrt:gj,scalar:mr,scatterND:Uj,scatter_util:m0e,searchSorted:nC,selu:yj,separableConv2d:bj,serialization:Cbe,setBackend:Ade,setPlatform:Ode,setdiff1dAsync:xj,sigmoid:iu,sign:vj,signal:Zj,sin:wj,sinh:Sj,slice:en,slice1d:Cj,slice2d:_j,slice3d:Ej,slice4d:Ij,slice_util:C9,softmax:kj,softplus:k$,spaceToBatchND:M$,sparse:e9,sparseToDense:Wj,spectral:Yj,split:Lm,sqrt:pu,square:Ka,squaredDifference:j$,squeeze:Ga,stack:mu,step:q$,stridedSlice:Nj,string:t9,sub:hr,sum:bn,sumOutType:QS,tan:Tj,tanh:C2,tensor:qa,tensor1d:ha,tensor2d:Oh,tensor3d:K$,tensor4d:Aj,tensor5d:Dj,tensor6d:Fj,tensorScatterUpdate:$j,tensor_util:fde,test_util:Nge,tidy:qt,tile:pm,time:Tde,topk:Rj,train:axe,transpose:Bb,truncatedNormal:Oj,unique:Mj,unregisterGradient:Hhe,unregisterKernel:Ghe,unsortedSegmentSum:Lj,unstack:Fc,upcastType:Fo,upperBound:Pj,util:tde,valueAndGrad:dme,valueAndGrads:pme,variable:Bj,variableGrads:LH,version_core:ixe,where:Qu,whereAsync:Z$,zeros:dc,zerosLike:Ji},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wh={},w1={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function xxe(r,t){wh[r]=t}function $o(r,t){if(!(r in wh)||t!=null){const s=wxe(r,t);if(s!==null)wh[r]=s;else return console.log("Could not get context for WebGL version",r),null}const n=wh[r];return n==null||n.isContextLost()?(delete wh[r],$o(r)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),wh[r])}function vxe(r){if(!Be().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&r===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function wxe(r,t){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=t??vxe(r);return n.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete wh[r]},!1),Be().getBool("SOFTWARE_WEBGL_ENABLED")&&(w1.failIfMajorPerformanceCaveat=!1),r===1?n.getContext("webgl",w1)||n.getContext("experimental-webgl",w1):n.getContext("webgl2",w1)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Vb;(function(r){r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH"})(Vb||(Vb={}));var da;(function(r){r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD"})(da||(da={}));var Ts;(function(r){r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Ts||(Ts={}));function Tx(r,t){return[t,r]}function Sxe(r,t){return r*t}function S1(r){const t=lt(r),n=Math.ceil(t/4);return m2(n)}function gg(r,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(r/2))]}function Cxe(r,t){const[n,s]=gg(r,t);return n*s*4}function xR(r,t){const n=r;let s,i,a,o,u,l,c,h,d,p;return Be().getNumber("WEBGL_VERSION")===2?(s=n.R32F,i=n.R16F,a=n.RGBA16F,o=n.RGBA32F,u=n.RED,c=4,h=1,d=n.HALF_FLOAT,p=n.FLOAT,l=n.RGBA8):(s=r.RGBA,i=r.RGBA,a=r.RGBA,o=n.RGBA,u=r.RGBA,c=4,h=4,d=t!=null?t.HALF_FLOAT_OES:null,p=r.FLOAT,l=r.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:o,textureFormatFloat:u,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:h,textureTypeHalfFloat:d,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ct(r,t){const n=t();return Be().getBool("DEBUG")&&_xe(r),n}function _xe(r){const t=r.getError();if(t!==r.NO_ERROR)throw new Error("WebGL Error: "+Nxe(r,t))}const Exe=596e-10,Ixe=65504;function kxe(r){return!!(Be().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||Exe<Math.abs(r)&&Math.abs(r)<Ixe)}function Nxe(r,t){switch(t){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function C1(r,t){return yl(r,()=>r.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function Txe(r,t){const n=yl(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ct(r,()=>r.shaderSource(n,t)),Ct(r,()=>r.compileShader(n)),r.getShaderParameter(n,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function Axe(r,t){const n=yl(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ct(r,()=>r.shaderSource(n,t)),Ct(r,()=>r.compileShader(n)),Be().get("ENGINE_COMPILE_ONLY"))return n;if(r.getShaderParameter(n,r.COMPILE_STATUS)===!1)throw h7(t,r.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const Dxe=/ERROR: [0-9]+:([0-9]+):/g;function h7(r,t){const n=Dxe.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(r);return}const s=+n[1],i=r.split(`
`),a=i.length.toString().length+2,o=i.map((d,p)=>Fh((p+1).toString(),a)+d);let u=0;for(let d=0;d<o.length;d++)u=Math.max(o[d].length,u);const l=o.slice(0,s-1),c=o.slice(s-1,s),h=o.slice(s);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${Fh(c[0],u)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function Fxe(r){return yl(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function $xe(r,t){if(Ct(r,()=>r.linkProgram(t)),!Be().get("ENGINE_COMPILE_ONLY")&&r.getProgramParameter(t,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function KE(r,t){if(Ct(r,()=>r.validateProgram(t)),r.getProgramParameter(t,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function Rxe(r,t){const n=yl(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Ct(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),Ct(r,()=>r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW)),n}function Oxe(r,t){const n=yl(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Ct(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,n)),Ct(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW)),n}function Mxe(r){return yl(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function Lxe(r,t){const n=Be().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||t<=0){const s=`[${r}x${t}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(r>n||t>n){const s=`[${r}x${t}]`,i=`[${n}x${n}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+i+".")}}function Pxe(r){return yl(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function X4(r,t,n,s,i,a,o){const u=r.getAttribLocation(t,n);return u===-1?!1:(Ct(r,()=>r.bindBuffer(r.ARRAY_BUFFER,s)),Ct(r,()=>r.vertexAttribPointer(u,i,r.FLOAT,!1,a,o)),Ct(r,()=>r.enableVertexAttribArray(u)),!0)}function Bxe(r,t,n){Gxe(r,n),Ct(r,()=>r.activeTexture(r.TEXTURE0+n)),Ct(r,()=>r.bindTexture(r.TEXTURE_2D,t))}function Vxe(r,t,n){return yl(r,()=>r.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function zxe(r,t,n){return r.getUniformLocation(t,n)}function Uxe(r,t,n,s){Ct(r,()=>Bxe(r,t,s)),Ct(r,()=>r.uniform1i(n,s))}function XE(r,t,n){Ct(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,n)),Ct(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0))}function Y4(r,t){Ct(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),Ct(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function _1(r){const t=r.checkFramebufferStatus(r.FRAMEBUFFER);if(t!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Wxe(r,t))}function Wxe(r,t){switch(t){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function yl(r,t,n){const s=Ct(r,()=>t());if(s==null)throw new Error(n);return s}function Gxe(r,t){const n=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+r.TEXTURE0;if(s<r.TEXTURE0||s>n){const i=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${i}.`)}}function Bm(r,t=2){return lt(r.slice(0,r.length-t))}function Vm(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function E1(r){let t=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(t=[Bm(r),...Vm(r)]),t}function Hxe(r,t=!1){let n=Be().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=Be().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&Be().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=n/2),t&&(n=n*2,s=s*2,r=r.map((u,l)=>l>=r.length-2?qS(r[l]):r[l]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=ml(r).newShape);let i=lt(r),a=null;r.length<=1&&i<=n?a=[1,i]:r.length===2&&r[0]<=n&&r[1]<=n?a=r:r.length===3&&r[0]*r[1]<=n&&r[2]<=n?a=[r[0]*r[1],r[2]]:r.length===3&&r[0]<=n&&r[1]*r[2]<=n?a=[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=n&&r[3]<=n?a=[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=n&&r[1]*r[2]*r[3]<=n&&(a=[r[0],r[1]*r[2]*r[3]]);const o=a!=null&&Math.max(...a)>s&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(a==null||o)if(t){const u=Bm(r);let l=2,c=2;r.length&&([l,c]=Vm(r)),i=u*(l/2)*(c/2),a=m2(i).map(h=>h*2)}else a=m2(i);return a}function I1(r){return r%2===0}function I2(r,t){if(r=r.slice(-2),t=t.slice(-2),En(r,t)||!r.length||!t.length||r[0]===0||r[1]===0||t[0]===0||t[1]===0)return!0;if(r.length!==t.length){const n=r[r.length-1],s=t[t.length-1];if(n===s||I1(n)&&I1(s)&&(r[0]===1||t[0]===1))return!0}return r[1]===t[1]&&I1(r[0])&&I1(t[0])}let YE,ZE;function jxe(r){if(YE==null){const t=$o(r);YE=t.getParameter(t.MAX_TEXTURE_SIZE)}return YE}function qxe(r){if(ZE==null){const t=$o(r);ZE=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,ZE)}function Kxe(r){if(r===0)return 0;let t;const n=$o(r);return Ha(n,"EXT_disjoint_timer_query_webgl2")&&r===2?t=2:Ha(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function Ha(r,t){return r.getExtension(t)!=null}function Z4(r){try{if($o(r)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Xxe(r){if(r===0)return!1;const t=$o(r);if(r===1){if(!Ha(t,"OES_texture_float"))return!1}else if(!Ha(t,"EXT_color_buffer_float"))return!1;return Rk(t)}function Yxe(r){if(r===0)return!1;const t=$o(r);if(r===1){if(!Ha(t,"OES_texture_float")||!Ha(t,"WEBGL_color_buffer_float"))return!1}else{if(Ha(t,"EXT_color_buffer_float"))return Rk(t);const s="EXT_color_buffer_half_float";if(Ha(t,s)){const i=t.getExtension(s);return Zxe(t,i)}return!1}return Rk(t)}function Rk(r){const t=xR(r),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n),r.texImage2D(r.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,a),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);const o=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(a),o}function Zxe(r,t){const n=xR(r,t),s=r.createTexture();r.bindTexture(r.TEXTURE_2D,s),r.texImage2D(r.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,o),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,s,0);const u=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(s),r.deleteFramebuffer(o),u}function Jxe(r){return r!==2?!1:$o(r).fenceSync!=null}function Ax(r,t){Array.isArray(r)||(r=[r]),r.forEach(n=>{n!=null&&oe(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $t=Be();$t.registerFlag("HAS_WEBGL",()=>$t.getNumber("WEBGL_VERSION")>0);$t.registerFlag("WEBGL_VERSION",()=>Z4(2)?2:Z4(1)?1:0);$t.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);$t.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>$t.get("WEBGL_VERSION")===2);$t.registerFlag("WEBGL_CPU_FORWARD",()=>!0);$t.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);$t.registerFlag("WEBGL_PACK",()=>$t.getBool("HAS_WEBGL"));$t.registerFlag("WEBGL_PACK_NORMALIZATION",()=>$t.getBool("WEBGL_PACK"));$t.registerFlag("WEBGL_PACK_CLIP",()=>$t.getBool("WEBGL_PACK"));$t.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>$t.getBool("WEBGL_PACK"));$t.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>$t.getBool("WEBGL_PACK"));$t.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>$t.getBool("WEBGL_PACK"));$t.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>$t.getBool("WEBGL_PACK"));$t.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>$t.getBool("WEBGL_PACK"));$t.registerFlag("WEBGL_PACK_REDUCE",()=>$t.getBool("WEBGL_PACK"));$t.registerFlag("WEBGL_LAZILY_UNPACK",()=>$t.getBool("WEBGL_PACK"));$t.registerFlag("WEBGL_CONV_IM2COL",()=>$t.getBool("WEBGL_PACK"));$t.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>$t.getBool("WEBGL_PACK"));$t.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>jxe($t.getNumber("WEBGL_VERSION")));$t.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>qxe($t.getNumber("WEBGL_VERSION")));$t.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const r=$t.getNumber("WEBGL_VERSION");return r===0?0:Kxe(r)});$t.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>$t.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!n$());$t.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Xxe($t.getNumber("WEBGL_VERSION")));$t.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>$t.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:$t.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));$t.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Yxe($t.getNumber("WEBGL_VERSION")));$t.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Jxe($t.getNumber("WEBGL_VERSION")));$t.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>$t.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);$t.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(typeof r!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${r}.`);if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});$t.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>n$()?1:-1,r=>{if(typeof r!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${r}.`);if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});$t.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);$t.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);$t.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);$t.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);$t.registerFlag("WEBGL_EXP_CONV",()=>!1);$t.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>$t.getBool("IS_TEST"));$t.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);$t.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);$t.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);$t.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hi(){let r,t,n,s,i,a,o,u,l,c;return Be().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",t="in",n="out",s="in",i="texture",a="outputColor",o="out vec4 outputColor;",u=Be().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",t="attribute",n="varying",s="varying",i="texture2D",a="gl_FragColor",o="",u=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:t,varyingVs:n,varyingFs:s,texture2D:i,output:a,defineOutput:o,defineSpecialNaN:u,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vd(r,t,n="index"){const s=ws(t);return s.map((i,a)=>{const o=`int ${r[a]} = ${n} / ${i}`,u=a===s.length-1?`int ${r[a+1]} = ${n} - ${r[a]} * ${i}`:`index -= ${r[a]} * ${i}`;return`${o}; ${u};`}).join("")}function yC(r,t,n="index"){const s=ws(t);return s.map((i,a)=>{const o=`int ${r[a]} = ${n} / outShapeStrides[${a}]`,u=a===s.length-1?`int ${r[a+1]} = ${n} - ${r[a]} * outShapeStrides[${a}]`:`index -= ${r[a]} * outShapeStrides[${a}]`;return`${o}; ${u};`}).join("")}function Qxe(r,t){const n=r.length,s=r.map(a=>`${t}[${a}]`),i=new Array(n-1);i[n-2]=s[n-1];for(let a=n-3;a>=0;--a)i[a]=`(${i[a+1]} * ${s[a+1]})`;return i}function eve(r,t,n="index"){const s=r.map((a,o)=>o),i=Qxe(s,t);return i.map((a,o)=>{const u=`int ${r[o]} = ${n} / ${i[o]}`,l=o===i.length-1?`int ${r[o+1]} = ${n} - ${r[o]} * ${i[o]}`:`index -= ${r[o]} * ${i[o]}`;return`${u}; ${l};`}).join("")}function vR(r){const t=ws(r).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function wR(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const d7=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:p7}=l7;function tve(r,t,n){const s=[];if(r.forEach(f=>{const m=lt(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?s.push(`uniform float ${f.name}${m>1?`[${m}]`:""};`):(s.push(`uniform sampler2D ${f.name};`),s.push(`uniform int offset${f.name};`)),n.enableShapeUniforms){const{uniformShape:g}=SR(n.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(g.length){case 1:s.push(`uniform int ${f.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${f.name}Shape;`);break}s.push(`uniform ivec2 ${f.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(f=>{s.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const i=s.join(`
`),a=r.map(f=>rve(f,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),o=t.texShape,u=hi(),l=ive(u);let c,h,d=uve(u);return t.isPacked?(c=nve(t.logicalShape,o,n.enableShapeUniforms),h=ove(u)):(c=sve(t.logicalShape,o,n.enableShapeUniforms),h=ave(u)),n.packedInputs&&(d+=dve),[d,l,h,i,c,a,n.userCode].join(`
`)}function yg(r,t=!1){const n=r.shapeInfo.logicalShape;switch(n.length){case 0:return _ve(r,t);case 1:return Ive(r,t);case 2:return Nve(r,t);case 3:return Ave(r,t);case 4:return Fve(r,t);case 5:return $ve(r);case 6:return Rve(r);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function f7(r,t){switch(r.shapeInfo.logicalShape.length){case 0:return Cve(r);case 1:return Eve(r,t);case 2:return kve(r,t);case 3:return Tve(r,t);default:return Dve(r,t)}}function rve(r,t,n=!1,s){let i="";n?i+=f7(r,s):i+=yg(r,s);const a=r.shapeInfo.logicalShape,o=t.logicalShape;return a.length<=o.length&&(n?i+=Ove(r,t):i+=Mve(r,t)),i}function nve(r,t,n){switch(r.length){case 0:return m7();case 1:return pve(r,t,n);case 2:return wve(r,t,n);case 3:return mve(r,t,n);default:return yve(r,t,n)}}function sve(r,t,n){switch(r.length){case 0:return m7();case 1:return fve(r,t,n);case 2:return Sve(r,t,n);case 3:return gve(r,t,n);case 4:return bve(r,t,n);case 5:return xve(r,t);case 6:return vve(r,t);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function ive(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function ave(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function ove(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function uve(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${lve}
    ${cve}
    ${hve}
  `}const lve=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,cve=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,hve=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,dve=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function m7(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function pve(r,t,n){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return s[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function fve(r,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function mve(r,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(r[2]/2),a=i*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function gve(r,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${yC(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;const s=Vd(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function yve(r,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(r[r.length-1]/2),a=i*Math.ceil(r[r.length-2]/2);let o=a,u="",l="b, r, c";for(let c=2;c<r.length-1;c++)o*=r[r.length-c-1],u=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+u,l=`b${c}, `+l;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${u}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${r.length}(${l});
    }
  `}function bve(r,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${yC(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Vd(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function xve(r,t){const n=Vd(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function vve(r,t){const n=Vd(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function wve(r,t,n){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(En(r,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const i=Math.ceil(r[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function Sve(r,t,n){return En(r,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:r[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function zd(r){return`offset${r}`}function Cve(r){const t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),s=hi();return`
    vec4 ${n}() {
      return ${s.texture2D}(${t}, halfCR);
    }
  `}function _ve(r,t){const n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(r.shapeInfo.isUniform)return`float ${s}() {return ${n};}`;const[i,a]=r.shapeInfo.texShape;if(i===1&&a===1)return`
      float ${s}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=zd(n);if(t)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});
      return sampleTexture(${n}, uv);
    }
  `;const[u,l]=r.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${u}, ${l}, ${o});
      return sampleTexture(${n}, uv);
    }
  `}function Eve(r,t){const n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),i=r.shapeInfo.texShape,a=hi();if(t)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;const o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function Ive(r,t){const n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(r.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${bg(r)}
      }
    `;const i=r.shapeInfo.texShape,a=i[0],o=i[1];if(o===1&&a===1)return`
      float ${s}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const u=zd(n);return o===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${u}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${u}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${u}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${u}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${u});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${a}, ${o}, index + ${u});
      return sampleTexture(${n}, uv);
    }
  `}function kve(r,t){const n=r.shapeInfo.logicalShape,s=r.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=r.shapeInfo.texShape,o=a[0],u=a[1],l=hi();if(a!=null&&En(n,a))return t?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${u}.0, ${o}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(t)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],h=Math.ceil(n[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function Nve(r,t){const n=r.shapeInfo.logicalShape,s=r.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=r.shapeInfo.texShape;if(a!=null&&En(n,a)){if(t)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const p=a[0],f=a[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:u}=ml(n),l=o;if(l.length<n.length){const p=xg(r,l),f=["row","col"];return`
      ${yg(p,t)}
      float ${i}(int row, int col) {
        return ${i}(${vg(f,u)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${bg(r)}
      }
    `;const c=a[0],h=a[1],d=zd(s);return h===1?t?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?t?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:t?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${c}, ${h}, index);
    return sampleTexture(${s}, uv);
  }
`}function Tve(r,t){const n=r.shapeInfo.logicalShape,s=r.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=r.shapeInfo.texShape,o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){const p=n.slice(1),f=[1,2],m=xg(r,p),g=["b","row","col"];return`
        ${f7(m,t)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${vg(g,f)});
        }
      `}const u=hi();if(t)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;const l=o[0],c=o[1],h=Math.ceil(n[2]/2),d=h*Math.ceil(n[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${d}, ${h}, b, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function Ave(r,t){const n=r.shapeInfo.logicalShape,s=r.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n[1]*n[2],o=n[2],{newShape:u,keptDims:l}=ml(n),c=u;if(c.length<n.length){const g=xg(r,c),y=["row","col","depth"];return`
        ${yg(g,t)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${vg(y,l)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${o}, 1)));
        ${bg(r)}
      }
    `;const h=r.shapeInfo.texShape,d=h[0],p=h[1],f=r.shapeInfo.flatOffset;if(p===a&&f==null)return t?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${d}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(p===o&&f==null)return t?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;const m=zd(s);return t?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${o} + depth + ${m};
        vec2 uv = uvFromFlat(${d}, ${p}, index);
        return sampleTexture(${s}, uv);
      }
  `}function Dve(r,t){const n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),i=hi();if(t)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${n}, uv);
    }
  `;const a=r.shapeInfo.logicalShape,o=a.length,u=r.shapeInfo.texShape,l=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],c=l[0],h=l[1],d=Math.ceil(a[o-1]/2);let p=d*Math.ceil(a[o-2]/2),f="int b, int row, int col",m=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<o-1;g++)f=`int b${g}, `+f,p*=a[o-g-1],m=`b${g} * ${p} + `+m;return`
    vec4 ${s}(${f}) {
      int index = ${m};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${c});
      return ${i.texture2D}(${n}, uv);
    }
  `}function Fve(r,t){const n=r.shapeInfo.logicalShape,s=r.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n[3],o=n[2]*a,u=n[1]*o,{newShape:l,keptDims:c}=ml(n);if(l.length<n.length){const x=xg(r,l),w=["row","col","depth","depth2"];return`
      ${yg(x,t)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${vg(w,c)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${u}, ${o}, ${a}, 1)));
        ${bg(r)}
      }
    `;const h=r.shapeInfo.flatOffset,d=r.shapeInfo.texShape,p=d[0],f=d[1],m=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,y=`int stride0 = ${s}Shape[1] * stride1;`;if(f===u&&h==null)return t?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${m}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(f===a&&h==null)return t?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;const b=zd(s);return t?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${o} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${p}, ${f}, index + ${b});
      return sampleTexture(${s}, uv);
    }
  `}function $ve(r){const t=r.shapeInfo.logicalShape,n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t[4],a=t[3]*i,o=t[2]*a,u=t[1]*o,{newShape:l,keptDims:c}=ml(t);if(l.length<t.length){const g=xg(r,l),y=["row","col","depth","depth2","depth3"];return`
      ${yg(g)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${vg(y,c)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${o}, ${a}, ${i})) +
          depth3;
        ${bg(r)}
      }
    `;const h=r.shapeInfo.flatOffset,d=r.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const m=zd(n);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${o} + depth * ${a} +
          depth2 * ${i} + depth3 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Rve(r){const t=r.shapeInfo.logicalShape,n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:i,keptDims:a}=ml(t);if(i.length<t.length){const y=xg(r,i),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${yg(y)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${vg(b,a)});
      }
    `}const o=t[5],u=t[4]*o,l=t[3]*u,c=t[2]*l,h=t[1]*c;if(r.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${c}, ${l}, ${u})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${bg(r)}
      }
    `;const d=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,f=p[0],m=p[1];if(m===h&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${u}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===o&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;const g=zd(n);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${c} + depth * ${l} +
          depth2 * ${u} + depth3 * ${o} + depth4 + ${g};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `}function bg(r){const t=r.name,n=lt(r.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Ove(r,t){const n=r.name,s=n.charAt(0).toUpperCase()+n.slice(1),i="get"+s+"AtOutCoords",a=r.shapeInfo.logicalShape.length,o=t.logicalShape.length,u=p7(r.shapeInfo.logicalShape,t.logicalShape),l=on(o),c=o-a;let h;const d=["x","y","z","w","u","v"];a===0?h="":o<2&&u.length>=1?h="coords = 0;":h=u.map(x=>`coords.${d[x+c]} = 0;`).join(`
`);let p="";o<2&&a>0?p="coords":p=r.shapeInfo.logicalShape.map((x,w)=>`coords.${d[w+c]}`).join(", ");let f="return outputValue;";const g=lt(r.shapeInfo.logicalShape)===1,b=lt(t.logicalShape)===1;if(a===1&&!g&&!b)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!b)o===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(u.length){const x=a-2,w=a-1;u.indexOf(x)>-1&&u.indexOf(w)>-1?f="return vec4(outputValue.x);":u.indexOf(x)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(w)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${h}
      vec4 outputValue = get${s}(${p});
      ${f}
    }
  `}function Mve(r,t){const n=r.name,s=n.charAt(0).toUpperCase()+n.slice(1),i="get"+s+"AtOutCoords",a=t.texShape,o=r.shapeInfo.texShape,u=r.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!r.shapeInfo.isUniform&&u===l&&r.shapeInfo.flatOffset==null&&En(o,a))return`
      float ${i}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const c=on(l),h=p7(r.shapeInfo.logicalShape,t.logicalShape),d=l-u;let p;const f=["x","y","z","w","u","v"];u===0?p="":l<2&&h.length>=1?p="coords = 0;":p=h.map(g=>`coords.${f[g+d]} = 0;`).join(`
`);let m="";return l<2&&u>0?m="coords":m=r.shapeInfo.logicalShape.map((g,y)=>`coords.${f[y+d]}`).join(", "),`
    float ${i}() {
      ${c} coords = getOutputCoords();
      ${p}
      return get${s}(${m});
    }
  `}function on(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function SR(r,t,n){const{newShape:s,keptDims:i}=ml(t),a=t.length,o=r&&a===3&&t[0]===1,u=o?t.slice(1):s,l=!r&&a>1&&!En(t,n)&&s.length<a||o;return{useSqueezeShape:l,uniformShape:l?u:t,keptDims:i}}function xg(r,t){const n=JSON.parse(JSON.stringify(r));return n.shapeInfo.logicalShape=t,n}function vg(r,t){return t.map(n=>r[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lve(r,t,n,s){const i=n.map((h,d)=>{const p={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:h.isUniform?!1:h.texData.isPacked,flatOffset:null};return h.texData!=null&&h.texData.slice!=null&&h.texData.slice.flatOffset>0&&(p.flatOffset=h.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:p}}),a=i.map(h=>h.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},u=tve(i,o,t),l=Axe(r.gl,u),c=r.createProgram(l);return Be().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:u,webGLProgram:c,inShapeInfos:a,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(r.buildVao(c),Object.assign({program:t,fragmentShader:l,source:u,webGLProgram:c,inShapeInfos:a,outShapeInfo:o},g7(r,t,c)))}function g7(r,t,n){const s=[],i=[];let a,o,u,l=null,c=null;c=r.getUniformLocation(n,"NAN",!1),Be().getNumber("WEBGL_VERSION")===1&&(l=r.getUniformLocation(n,"INFINITY",!1));const h=!1;for(const d of t.variableNames){const p={name:d,uniform:r.getUniformLocation(n,d,h),offset:r.getUniformLocation(n,`offset${d}`,h)};t.enableShapeUniforms&&(p.shape=r.getUniformLocation(n,`${d}Shape`,h),p.texShape=r.getUniformLocation(n,`${d}TexShape`,h)),s.push(p)}if(t.enableShapeUniforms&&(a=r.getUniformLocation(n,"outShape",h),u=r.getUniformLocation(n,"outShapeStrides",h),o=r.getUniformLocation(n,"outTexShape",h)),t.customUniforms)for(const d of t.customUniforms)i.push(r.getUniformLocation(n,d.name,h));return{variablesLocations:s,customUniformLocations:i,infLoc:l,nanLoc:c,outShapeLocation:a,outShapeStridesLocation:u,outTexShapeLocation:o}}function J4(r,t){if(r.length!==t.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${t.length} inputs`);r.forEach((n,s)=>{const i=n.logicalShape,a=t[s],o=a.shape;if(!En(i,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${o} must match`);if(n.isUniform&&a.isUniform)return;const u=n.texShape,l=a.isUniform?null:a.texData.texShape;if(!En(u,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${u} and ${l} must match`)})}function Pve(r,t,n,s,i){t.program.enableShapeUniforms||(J4(t.inShapeInfos,n),J4([t.outShapeInfo],[s]));const a=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?r.setOutputPackedMatrixTexture(a.texture,o[0],o[1]):r.setOutputMatrixTexture(a.texture,o[0],o[1]),r.setProgram(t.webGLProgram),r.bindVertexArray(t.webGLProgram.vao),Be().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&r.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&r.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const c=n[l],{uniform:h,offset:d,shape:p,texShape:f}=t.variablesLocations[l];if(p){const{uniformShape:m}=SR(t.program.packedInputs,c.shape,c.texData.texShape);switch(m.length){case 1:r.gl.uniform1iv(p,new Int32Array(m));break;case 2:r.gl.uniform2iv(p,new Int32Array(m));break;case 3:r.gl.uniform3iv(p,new Int32Array(m));break;case 4:r.gl.uniform4iv(p,new Int32Array(m));break}}if(f&&r.gl.uniform2i(f,c.texData.texShape[0],c.texData.texShape[1]),h!=null){if(c.isUniform){if(lt(c.shape)<2)r.gl.uniform1f(h,c.uniformValues[0]);else{let m=c.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),r.gl.uniform1fv(h,m)}continue}c.texData.slice!=null&&d!=null&&r.gl.uniform1i(d,c.texData.slice.flatOffset),r.setInputMatrixTexture(c.texData.texture.texture,h,l)}}const u=t.outShapeLocation;if(u)switch(s.shape.length){case 1:r.gl.uniform1iv(u,new Int32Array(s.shape));break;case 2:r.gl.uniform2iv(u,new Int32Array(s.shape));break;case 3:r.gl.uniform3iv(u,new Int32Array(s.shape));break;case 4:r.gl.uniform4iv(u,new Int32Array(s.shape));break}if(t.outShapeStridesLocation){const l=ws(s.shape);switch(s.shape.length){case 2:r.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:r.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:r.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&r.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&i)for(let l=0;l<t.program.customUniforms.length;++l){const c=t.program.customUniforms[l],h=t.customUniformLocations[l],d=i[l];if(c.type==="float")r.gl.uniform1fv(h,d);else if(c.type==="vec2")r.gl.uniform2fv(h,d);else if(c.type==="vec3")r.gl.uniform3fv(h,d);else if(c.type==="vec4")r.gl.uniform4fv(h,d);else if(c.type==="int")r.gl.uniform1iv(h,d);else if(c.type==="ivec2")r.gl.uniform2iv(h,d);else if(c.type==="ivec3")r.gl.uniform3iv(h,d);else if(c.type==="ivec4")r.gl.uniform4iv(h,d);else throw Error(`uniform type ${c.type} is not supported yet.`)}r.executeProgram()}function Bve(r,t,n){let s="";t.concat(n).forEach(o=>{const u=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:h,keptDims:d}=SR(r.packedInputs,o.shape,l);let p="",f="",m="";if(h.length===1&&r.packedInputs){const S=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${S[0]>1}_${S[1]>1}`}else if(h.length===2&&!r.packedInputs)f=`${h[0]>1}_${h[1]>1}`;else if(h.length>2&&!r.packedInputs){const S=ws(h);m=`${S[0]===l[1]}_${S[S.length-1]===l[1]}`}const g=o.shape.length,y=h.length===2&&En(o.shape,l),b=lt(o.shape)===1,x=$b(o.shape,n.shape),w=!r.packedInputs&&g===n.shape.length&&En(l,n.texData.texShape),v=r.packedInputs||h.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${g}_${w}_${c?d:""}_${h.length}_${b}_${x}_${y}_${p}_${f}_${m}_${v}_${u}`}else{const l=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${l}_${u}`}});const i=r.userCode;let a=r.constructor.name;return a+="_"+s+"_"+i+`${Be().getNumber("WEBGL_VERSION")}`,a}function Hs(r){return Be().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vve{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Vb.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=hi();this.outputShape=t,this.enableShapeUniforms=Hs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?yC(["r","c","d"],t):Vd(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zve{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Vb.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=hi();this.outputShape=t,this.enableShapeUniforms=Hs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?yC(["r","c","d"],t):Vd(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uve{constructor(t){this.variableNames=["A"],this.outTexUsage=da.DOWNLOAD;const n=hi();this.outputShape=t,this.userCode=`
      ${d7}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wve{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=da.DOWNLOAD;const n=hi();this.outputShape=t,this.userCode=`
      ${d7}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gve={R:0,G:1,B:2,A:3};class Q4{constructor(t,n=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=hi();this.outputShape=t,this.enableShapeUniforms=Hs(this.outputShape.length);let a="result";n&&(a="floor(result * 255. + 0.5)");let o="";for(let u=0;u<s.length;u++){const l=s[u];o+=`
          if(offset == ${u}) {
            result = values[${Gve[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?wR():vR(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${o}
        }
        ${i.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hve{constructor(t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=hi();this.outputShape=t,this.enableShapeUniforms=Hs(this.outputShape.length);let i="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let u=0;u<=1;u++){const l=o*2+u;i+=`
          localCoords = coords;
          if(localCoords[2] + ${u} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${u};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?wR():vR(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${s.output} = ${a};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jve(r){const t=hi(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Txe(r,n)}function qve(r){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Rxe(r,t)}function Kve(r){const t=new Uint16Array([0,1,2,2,1,3]);return Oxe(r,t)}function Dx(r,t,n,s,i,a){Lxe(t,n);const o=Mxe(r),u=r.TEXTURE_2D;return Ct(r,()=>r.bindTexture(u,o)),Ct(r,()=>r.texParameteri(u,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),Ct(r,()=>r.texParameteri(u,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),Ct(r,()=>r.texParameteri(u,r.TEXTURE_MIN_FILTER,r.NEAREST)),Ct(r,()=>r.texParameteri(u,r.TEXTURE_MAG_FILTER,r.NEAREST)),Be().getNumber("WEBGL_VERSION")===1?Ct(r,()=>r.texImage2D(u,0,s,t,n,0,i,a,null)):Ct(r,()=>r.texStorage2D(u,1,s,t,n)),Ct(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:o,texShape:[n,t]}}function y7(r){return r.internalFormatFloat}function Xve(r,t,n,s){const[i,a]=Tx(t,n);return Dx(r,i,a,y7(s),s.textureFormatFloat,r.FLOAT)}function b7(r){return r.internalFormatHalfFloat}function Yve(r,t,n,s){const[i,a]=Tx(t,n);return Dx(r,i,a,b7(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function x7(r){return r.downloadTextureFormat}function Zve(r,t,n,s){const[i,a]=Tx(t,n);return Dx(r,i,a,x7(s),r.RGBA,r.UNSIGNED_BYTE)}function v7(r){return r.internalFormatPackedFloat}function Jve(r,t,n,s){const[i,a]=gg(t,n);return Dx(r,i,a,v7(s),r.RGBA,r.FLOAT)}function w7(r){return r.internalFormatPackedHalfFloat}function Qve(r,t,n,s){const[i,a]=gg(t,n);return Dx(r,i,a,w7(s),r.RGBA,s.textureTypeHalfFloat)}function e1e(r,t,n){return Ct(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),X4(r,t,"clipSpacePos",n,3,20,0)&&X4(r,t,"uv",n,2,20,12)}function t1e(r,t,n,s,i,a){Ct(r,()=>r.bindTexture(r.TEXTURE_2D,t));let o,u,l;i instanceof Uint8Array?(o=new Uint8Array(n*s*4),u=r.UNSIGNED_BYTE,l=r.RGBA):(o=new Float32Array(n*s*4),u=r.FLOAT,l=a.internalFormatPackedFloat),o.set(i),Be().getNumber("WEBGL_VERSION")===2?Ct(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,n,s,r.RGBA,u,o)):Ct(r,()=>r.texImage2D(r.TEXTURE_2D,0,l,n,s,0,r.RGBA,u,o)),Ct(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function r1e(r,t,n){Ct(r,()=>r.bindTexture(r.TEXTURE_2D,t)),n.data instanceof Uint8Array?Be().getNumber("WEBGL_VERSION")===2?Ct(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,n.width,n.height,r.RGBA,r.UNSIGNED_BYTE,n.data)):Ct(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,n.width,n.height,0,r.RGBA,r.UNSIGNED_BYTE,n.data)):Be().getNumber("WEBGL_VERSION")===2?Ct(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,n)):Ct(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,n)),Ct(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function n1e(r,t,n,s){const i=r.createBuffer();Ct(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,i));const u=4*4*t*n;return Ct(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,u,r.STREAM_READ)),Ct(r,()=>r.readPixels(0,0,n,t,r.RGBA,r.FLOAT,0)),Ct(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),i}function s1e(r,t,n){const s=r,i=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,i),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),i}function i1e(r,t,n,s){const[i,a]=Tx(t,n),o=4,u=new Uint8Array(Sxe(t*n,o));return Ct(r,()=>r.readPixels(0,0,i,a,s.downloadTextureFormat,r.UNSIGNED_BYTE,u)),new Float32Array(u.buffer)}function a1e(r,t,n,s,i,a,o,u){const l=r,c=new Float32Array(Cxe(a,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function o1e(r,t,n){const s=new Float32Array(t*n*4);return Ct(r,()=>r.readPixels(0,0,n,t,r.RGBA,r.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JE{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=Be().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,xxe(n,t)):this.gl=$o(n),t=this.gl,Be().getNumber("WEBGL_VERSION")===2){const a=t;this.createVertexArray=()=>Ct(a,()=>a.createVertexArray()),this.bindVertexArray=o=>Ct(a,()=>a.bindVertexArray(o)),this.deleteVertexArray=o=>Ct(a,()=>a.deleteVertexArray(o)),this.getVertexArray=()=>Ct(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(t!=null){const a=t.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ct(t,()=>a.createVertexArrayOES()),this.bindVertexArray=o=>Ct(t,()=>a.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Ct(t,()=>a.deleteVertexArrayOES(o)),this.getVertexArray=()=>Ct(t,()=>t.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Be().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=C1(this.gl,a),Ha(this.gl,o))this.textureHalfFloatExtension=C1(this.gl,o);else if(Be().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),Ha(this.gl,i))this.colorBufferHalfFloatExtension=C1(this.gl,i);else if(Be().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",Ha(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(Ha(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=qve(this.gl),this.indexBuffer=Kve(this.gl),this.framebuffer=Pxe(this.gl),this.textureConfig=xR(this.gl,this.textureHalfFloatExtension)}get debug(){return Be().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;Ct(t,()=>t.finish()),Ct(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Ct(t,()=>t.deleteFramebuffer(this.framebuffer)),Ct(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Ct(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Ct(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,n){return this.throwIfDisposed(),Xve(this.gl,t,n,this.textureConfig)}createFloat16MatrixTexture(t,n){return this.throwIfDisposed(),Yve(this.gl,t,n,this.textureConfig)}createUnsignedBytesMatrixTexture(t,n){return this.throwIfDisposed(),Zve(this.gl,t,n,this.textureConfig)}uploadPixelDataToTexture(t,n){this.throwIfDisposed(),r1e(this.gl,t,n)}uploadDenseMatrixToTexture(t,n,s,i){this.throwIfDisposed(),t1e(this.gl,t,n,s,i,this.textureConfig)}createFloat16PackedMatrixTexture(t,n){return this.throwIfDisposed(),Qve(this.gl,t,n,this.textureConfig)}createPackedMatrixTexture(t,n){return this.throwIfDisposed(),Jve(this.gl,t,n,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(Y4(this.gl,this.framebuffer),this.outputTexture=null),Ct(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,n,s){return this.downloadMatrixDriver(t,()=>i1e(this.gl,n,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,n,s,i,a,o){return a1e(this.gl,t,n,s,i,a,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,n){return s1e(this.gl,t,n)}createBufferFromTexture(t,n,s){this.bindTextureToFrameBuffer(t);const i=n1e(this.gl,n,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let n,s;if(Be().getBool("WEBGL_FENCE_API_ENABLED")){const i=t,a=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{const o=i.clientWaitSync(a,0,0);return o===i.ALREADY_SIGNALED||o===i.CONDITION_SATISFIED},n=a}else Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(n,Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:n,isFencePassed:s}}downloadMatrixFromPackedTexture(t,n,s){return this.downloadMatrixDriver(t,()=>o1e(this.gl,n,s))}createProgram(t){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=jve(n));const s=Fxe(n);Ct(n,()=>n.attachShader(s,this.vertexShader)),Ct(n,()=>n.attachShader(s,t)),$xe(n,s);const i=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&KE(n,i),i}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const n=this.gl;Ct(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),e1e(n,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(Ct(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&KE(this.gl,this.program),Ct(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,n,s=!0){return this.throwIfDisposed(),s?Vxe(this.gl,t,n):zxe(this.gl,t,n)}getAttributeLocation(t,n){return this.throwIfDisposed(),Ct(this.gl,()=>this.gl.getAttribLocation(t,n))}getUniformLocationNoThrow(t,n){return this.throwIfDisposed(),this.gl.getUniformLocation(t,n)}setInputMatrixTexture(t,n,s){this.throwIfDisposed(),this.throwIfNoProgram(),Uxe(this.gl,t,n,s)}setOutputMatrixTexture(t,n,s){this.setOutputMatrixTextureDriver(t,s,n)}setOutputPackedMatrixTexture(t,n,s){this.throwIfDisposed();const[i,a]=gg(n,s);this.setOutputMatrixTextureDriver(t,i,a)}setOutputMatrixWriteRegion(t,n,s,i){this.setOutputMatrixWriteRegionDriver(s,t,i,n)}setOutputPackedMatrixWriteRegion(t,n,s,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&KE(this.gl,this.program),_1(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ct(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ct(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=C1(this.gl,Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),a=s.createQuery();return s.beginQuery(i.TIME_ELAPSED_EXT,a),a}const t=this.getQueryTimerExtensionWebGL1(),n=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,n),n}endQuery(){if(Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,s=this.getQueryTimerExtensionWebGL2();n.endQuery(s.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await fk(()=>this.disposed||this.isQueryAvailable(t,Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,n){if(n===0)return null;if(n===2){const s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,n){if(n===0)return!0;if(n===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),a=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),i=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(t){return new Promise(n=>{this.addItemToPoll(()=>t.isFencePassed(),()=>n())})}pollItems(){const t=u1e(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=t;++n){const{resolveFn:s}=this.itemsToPoll[n];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,n){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:n}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in Be().platform&&(s=Be().platform.setTimeoutCustom.bind(Be().platform)),fk(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),XE(this.gl,t,this.framebuffer),this.debug&&_1(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(XE(this.gl,this.outputTexture,this.framebuffer),this.debug&&_1(this.gl)):Y4(this.gl,this.framebuffer)}downloadMatrixDriver(t,n){this.bindTextureToFrameBuffer(t);const s=n();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,n,s){this.throwIfDisposed();const i=this.gl;XE(i,t,this.framebuffer),this.debug&&_1(i),this.outputTexture=t,Ct(i,()=>i.viewport(0,0,n,s)),Ct(i,()=>i.scissor(0,0,n,s))}setOutputMatrixWriteRegionDriver(t,n,s,i){this.throwIfDisposed(),Ct(this.gl,()=>this.gl.scissor(t,n,s,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function u1e(r){let t=0;for(;t<r.length&&r[t]();++t);return t-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l1e(r){const t=new Float32Array(r.length);for(let n=0;n<r.length;++n)t[n]=Math.abs(r[n]);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $i(r){return(t,n,s,i,a)=>{const o=Fr(t,n),u=o.length,l=ws(o),c=lt(o),h=ul(a,c),d=t.length,p=n.length,f=ws(t),m=ws(n),g=$b(t,o),y=$b(n,o);if(g.length+y.length===0)for(let b=0;b<h.length;++b)h[b]=r(s[b%s.length],i[b%i.length]);else for(let b=0;b<h.length;++b){const x=KS(b,u,l),w=x.slice(-d);g.forEach(C=>w[C]=0);const v=y2(w,d,f),S=x.slice(-p);y.forEach(C=>S[C]=0);const E=y2(S,p,m);h[b]=r(s[v],i[E])}return[h,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c1e(r,t,n,s){if(s==="int32"){const i=Int32Array.from(r);return[t,"int32",i]}if(s==="bool"){const i=bx([0],n),[a,o]=$i((u,l)=>u!==l?1:0)(t,[],r,i,"bool");return[o,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h1e=$i((r,t)=>r+t);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d1e(r,t,n,s,i){const a=lt(s),o=ll(i,n);for(let u=0;u<r.length;u++){const l=r[u];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(a>0?o[l]+=t[u]:o[l]+=1)}return o}function p1e(r,t,n,s=!1){const i=r.shape[0],a=r.shape[1],o=Tn([i,n],t.dtype);for(let u=0;u<i;u++)for(let l=0;l<a;l++){const c=r.get(u,l);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(s?o.set(1,u,c):t.size>0?o.set(o.get(u,c)+t.get(u,l),u,c):o.set(o.get(u,c)+1,u,c))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f1e=$i((r,t)=>r&t);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bl(r){return(t,n,s)=>{const i=rs(n,t.length);for(let a=0;a<t.length;++a)i[a]=r(t[a],s);return i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m1e=bl(r=>Math.ceil(r));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g1e(r,t,n,s){const i=rs(n,lt(t));if(s&&n!=="string"){let a=0;r.forEach(o=>{const u=lt(o.shape);i.set(o.vals,a),a+=u})}else{let a=0;r.forEach(o=>{const u=n==="string"?Pm(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const h=c*t[1]+a;for(let d=0;d<o.shape[1];++d)i[h+d]=u[l++]}a+=o.shape[1]})}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y1e=$i((r,t)=>r===t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b1e=bl(r=>Math.exp(r));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x1e=bl(r=>Math.expm1(r));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v1e=bl(r=>Math.floor(r));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w1e=$i((r,t)=>Math.floor(r/t));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S1e(r,t,n,s,i,a,o,u,l){const c=Tn([s,a],n);for(let h=0;h<s;h++){const d=[];let p=0;for(let f=0;f<i;f++){const m=r[h*i+f];p+=m*o[f],d.push(m)}if(p<0||p>=l/a)throw new Error(`Invalid indices: ${d} does not index into ${u}`);for(let f=0;f<a;f++)c.values[h*a+f]=t.get(...t.indexToLoc(p*a+f))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C1e(r,t,n){const s=Tn(n,r.dtype);for(let i=0;i<s.size;++i){const o=s.indexToLoc(i).slice(),u=o[0],l=o[2],c=t.locToIndex([u,l]);o[2]=t.values[c];const h=r.locToIndex(o);0<=h&&h<r.values.length&&(s.values[i]=r.values[h])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _1e=$i((r,t)=>r>t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E1e=$i((r,t)=>r>=t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I1e=$i((r,t)=>r<t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k1e=$i((r,t)=>r<=t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N1e(r,t,n){const s=(t-r)/(n-1),i=ll(n,"float32");i[0]=r;for(let a=1;a<i.length;a++)i[a]=i[a-1]+s;return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T1e=bl(r=>Math.log(r));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1e(r,t,n,s){const i=ul(s,lt(n));for(let a=0;a<i.length;++a){const o=a*t;let u=r[o];for(let l=0;l<t;++l){const c=r[o+l];(Number.isNaN(c)||c>u)&&(u=c)}i[a]=u}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D1e=$i((r,t)=>Math.max(r,t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F1e=$i((r,t)=>Math.min(r,t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S7=$i((r,t)=>r*t);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $1e(r,t,n){const s=Ld(-1,n);return S7([],t,s,r,n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R1e=$i((r,t)=>r!==t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O1e(r,t,n,s,i){const a=t.length,o=lt(t),u=ws(t),l=ws(i),c=ul(n,lt(i));for(let h=0;h<o;++h){const d=KS(h,a,u),p=new Array(d.length);for(let m=0;m<p.length;m++)p[m]=d[s[m]];const f=y2(p,a,l);c[f]=r[h]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M1e(r,t,n,s){const[i,a]=_u(r,s),o=Fo(t,"int32"),u=ll(lt(i),o),l=lt(a);for(let c=0;c<u.length;++c){const h=c*l;let d=1;for(let p=0;p<l;++p)d*=n[h+p];u[c]=d}return{outVals:u,outShape:i,outDtype:o}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L1e(r,t,n){r.forEach((s,i)=>{if(s<0||s>=n){const a=KS(i,t.length,ws(t)).join(",");throw new Error(`indices[${a}] = ${s} is not in [0, ${n})`)}})}function P1e(r,t){for(let n=0;n<r.length;++n){const s=r[n],i=n===r.length-1?t:r[n+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>i)throw new Error("Ragged splits must not point past values");for(let a=1;a<s.length;++a)if(s[a-1]>s[a])throw new Error("Ragged splits must be sorted in ascending order")}}function B1e(r,t,n,s){const i=[];let a=0;const o=t.length-1+n.length,u=new Array(o).fill(null).map(()=>[0]);P1e(n,s);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];const h=t[c+1];for(let d=1;d<l+1;++d)u[c].push(d*h)}for(let c=0;c<r.length;++c){let h=r[c],d=r[c]+1;for(let p=0;p<n.length;++p){const f=n[p],m=p+t.length-1;if(m>=0){const g=u[m],y=g[g.length-1]-f[h];for(let b=h;b<d;++b)u[m].push(f[b+1]+y)}h=f[h],d=f[d]}d!==h&&(i.push([h,d]),a+=d-h)}return{outSplits:u,valueSlices:i,numValues:a}}function V1e(r){const t=[];for(let n=0;n<r.length;++n){const s=r[n].length,i=rs("int32",s);t.push(i),r[n].forEach((a,o)=>i[o]=a)}return t}function e5(r,t){const n=r.slice(0,t);for(;n.length<t;)n.push(1);for(let s=t;s<r.length;s++)n[t-1]*=r[s];return n}function z1e(r,t,n,s,i,a){const o=e5(t,2)[1],u=e5(a,2)[1];let l=0;for(const c of n)for(let h=c[0];h<c[1];++h){for(let d=0;d<s;++d)i[l*u+d]=r[h*o+d];++l}}function U1e(r,t,n,s,i){const a=t.slice();a[0]=i;const o=rs(n,lt(a)),u=r.length,l=u===0?0:u/t[0];return z1e(r,t,s,l,o,a),[o,a]}function W1e(r,t,n,s,i,a,o,u){if(r.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const l=t[0][0]-1;if(L1e(a,o,l),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:h,valueSlices:d,numValues:p}=B1e(a,o,r,c),f=V1e(h),m=U1e(n,s,i,d,p);return[f,m[0],m[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t5=2147483647;function G1e(r,t,n,s,i,a,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const u=t.length===0,l=i.length===0,c=o.length===0,h=[];u||h.push(t[0]),l||h.push(i[0]),c||h.push(o[0]);for(let y=1;y<h.length;++y)if(h[y]!==h[y-1])throw new Error("starts, limits, and deltas must have the same shape");const d=h.length===0?1:h[0],p=rs("int32",d+1);p[0]=0;for(let y=0;y<d;++y){const b=u?r[0]:r[y],x=l?s[0]:s[y],w=c?a[0]:a[y];if(w===0)throw new Error("Requires delta != 0");let v;if(w>0&&x<b||w<0&&x>b)v=0;else if(v=Math.ceil(Math.abs((x-b)/w)),v>t5)throw new Error(`Requires ((limit - start) / delta) <= ${t5}`);p[y+1]=p[y]+v}const f=p[d],m=rs(n,f);let g=0;for(let y=0;y<d;++y){const b=p[y+1]-p[y];let x=u?r[0]:r[y];const w=c?a[0]:a[y];for(let v=0;v<b;++v)m[g++]=x,x+=w}return[p,m]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var $a=xo;class k2{constructor(t,n,s,i,a,o,u,l,c,h){this.shape=t,this.shapeShape=n,this.values=s,this.valuesShape=i,this.valuesDType=a,this.defaultValue=o,this.defaultValueShape=u,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=N9(h),this.raggedRank=T9(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===$a.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===$a.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case $a.VALUE_ROWIDS:return k2.getMaxWidthValueRowID(n);case $a.ROW_SPLITS:return k2.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${$a[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const n=t.length;if(n===0||n===1)return 0;let s=0;for(let i=0;i<n-1;++i){const a=t[i+1]-t[i];a>s&&(s=a)}return s}static getMaxWidthValueRowID(t){const n=t.length;if(n===0)return 0;let s=0,i=t[0],a=0;for(let o=1;o<n;++o){const u=t[o];u!==i&&(i=u,a=Math.max(o-s,a),s=o)}return Math.max(n-s,a)}tensorShapeFromTensor(t,n,s=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return n5(t,s)}calculateOutputSize(t){const n=this.valuesShape,s=this.defaultValueShape;A9(s,n);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=k9(this.raggedRank,i,n);o[0]<0&&(o[0]=t);for(let u=1;u<=this.raggedRank;++u)o[u]<0&&(o[u]=this.getMaxWidth(u));return o}calculateFirstParentOutputIndex(t,n,s){const i=Math.min(t,s),a=[];let o=0;for(let u=0;u<i;++u,o+=n)a.push(o);for(let u=i;u<t;++u)a.push(-1);return oe(a.length===t,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(t,n,s,i){const a=t.length,o=[];for(let u=0;u<a-1;++u){const l=t[u+1]-t[u];let c=Math.min(i,l),h=n[u];h===-1&&(c=0);for(let d=0;d<c;++d)o.push(h),h+=s;for(let d=0;d<l-c;++d)o.push(-1)}if(a>0&&o.length!==t[a-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,n,s,i){const a=t.length,o=[];if(a===0)return[];let u=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let c=n[l];o.push(c);for(let h=1;h<a;++h){const d=t[h];if(d===l)c>=0&&(++u,u<i?c+=s:c=-1);else{if(u=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);c=n[d]}o.push(c)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,n,s,i){const a=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case $a.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,s,i);case $a.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,s,i);default:throw new Error(`Unsupported partition type: ${$a[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case $a.FIRST_DIM_SIZE:return t[0];case $a.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case $a.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${$a[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),s=this.calculateOutputSize(n),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let l=i.length-2;l>=0;--l)i[l]=i[l+1]*s[l+1];const a=n5(s,!1),o=rs(this.valuesDType,lt(a));if(i[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(n,i[0],s[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,i[c],s[c]);this.setOutput(this.raggedRank,l,o,a)}return[a,o]}setOutput(t,n,s,i){if(s.length===0)return;const a=this.values,o=s;let u=i.slice();u=u.slice(t+1);const l=lt(u),c=n.length;let h=this.defaultValue;if(h.length!==l&&h.length!==1){const m=this.defaultValueShape;qt(()=>{const g=Qe(h,m);h=dm(g,u).dataSync()})}let d=0,p=0,f=0;for(let m=0;m<=c;++m){let g=m<c?n[m]:-1;if(g===f){++f;continue}if(p<f){const y=a.subarray(d*l),b=o.subarray(p*l),x=(f-p)*l;r5(b,y,x)}if(m>=c){const y=s.length;g=Math.floor(y/l)}if(g>f)if(this.defaultValue.length===1)o.subarray(f*l,g*l).fill(this.defaultValue[0]),f=g;else for(;g>f;){const y=o.slice(f*l);r5(y,h,l),++f}g<0?(d=m+1,p=f):(d=m,p=f,f=p+1)}}}function r5(r,t,n){for(let s=0;s<n;s++)r[s]=t[s]}function n5(r,t){const n=[];for(let s of r){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}n.push(s)}return n}function H1e(r,t,n,s,i,a,o,u,l,c){return new k2(r,t,n,s,i,a,o,u,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j1e(r,t,n,s){const i=r===t,a=r<t&&n<0,o=t<r&&n>1;if(i||a||o)return ll(0,s);const u=Math.abs(Math.ceil((t-r)/n)),l=ll(u,s);t<r&&n===1&&(n=-1),l[0]=r;for(let c=1;c<l.length;c++)l[c]=l[c-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q1e=bl(r=>1/Math.sqrt(r));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K1e(r,t,n,s,i,a,o,u,l,c){const h=[s/i,i],d=r.values,p=t.values;if(s===0)return Tn(n,t.dtype);const f=l instanceof td?l:Tn(h,t.dtype);typeof l=="string"||typeof l=="number"?f.values.fill(l):typeof l=="boolean"&&f.values.fill(+l);for(let m=0;m<a;m++){const g=[];let y=0;for(let b=0;b<o;b++){const x=d[m*o+b];g.push(x),y+=x*u[b]}if(y<0||y>=s/i)throw new Error(`Invalid indices: ${g} does not index into ${n}`);for(let b=0;b<i;b++)c?f.values[y*i+b]+=p[m*i+b]:f.values[y*i+b]=t.rank===0?p[0]:p[m*i+b]}return f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X1e=bl(r=>1/(1+Math.exp(-r)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y1e(r,t,n,s,i){const a=pR(s,t,n),o=lt(n),u=ws(s);if(a){const d=fR(t,u);return i==="string"?r.slice(d,d+o):r.subarray(d,d+o)}const l=i==="string"?Pm(r):r,c=Tn(s,i,l),h=Tn(n,i);for(let d=0;d<h.size;++d){const p=h.indexToLoc(d),f=p.map((m,g)=>m+t[g]);h.set(c.get(...f),...p)}return i==="string"?u7(h.values):h.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z1e(r,t,n,s,i,a,o){const u=t[0],l=a[0],c=new Array(l),h=new Array(u),d=t[1];if(l===0){if(u!==0)throw new Error(K9(u));const y=rs(n,0),b=rs(i,0);return[y,[0,d],b,c,h]}let p=!0,f=0;const m=new Array(l).fill(0);for(let y=0;y<u;++y){const b=r[y*d];if(b<0)throw new Error(X9(y,b));if(b>=l)throw new Error(Y9(y,b,l));++m[b],p=p&&b>=f,f=b}let g=!0;for(let y=0;y<l;++y){const b=m[y]===0;c[y]=b,g=g&&!b,m[y]=Math.max(m[y],1),y>0&&(m[y]+=m[y-1])}if(g&&p){const y=r,b=s;for(let x=0;x<u;++x)h[x]=x;return[y,[u,d],b,c,h]}else{const y=m[l-1],b=rs(n,y*d),x=rs(i,y),w=new Array(l).fill(0);for(let v=0;v<u;++v){const S=r[v*d],E=w[S],C=(S===0?0:m[S-1])+E;w[S]++;for(let I=0;I<d;++I)b[C*d+I]=r[v*d+I];x[C]=s[v],h[v]=C}for(let v=0;v<l;++v)if(w[v]===0){const E=v===0?0:m[v-1];b[E*d+0]=v;for(let C=1;C<d;++C)b[E*d+C]=0;x[E]=o}return[b,[y,d],x,c,h]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J1e(r,t,n,s,i){const a=lt(s),o=t[0],u=i.length,l=[];let c=1,h=-1;for(let y=0;y<u;++y){const b=i[y];if(b===-1){if(h!==-1)throw new Error(Z9(h,y));h=y,l.push(1)}else{if(b<0)throw new Error(J9(y,b));c*=b,l.push(b)}}if(h!==-1){if(c<=0)throw new Error(Q9());const y=Math.trunc(a/c);if(c*y!==a)throw new Error(e7(s,l));l[h]=y}if(lt(l)!==a)throw new Error(t7(s,l));const p=s.length,f=[];if(p>0){f[p-1]=1;for(let y=p-2;y>=0;--y)f[y]=f[y+1]*s[y+1]}const m=[];if(u>0){m[u-1]=1;for(let y=u-2;y>=0;--y)m[y]=m[y+1]*l[y+1]}const g=rs(n,o*u);for(let y=0;y<o;++y){let b=0;for(let x=0;x<p;++x)b+=r[y*p+x]*f[x];for(let x=0;x<u;++x)g[y*u+x]=Math.trunc(b/m[x]),b%=m[x]}return[g,[o,u],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q1e(r,t,n,s,i,a=!1,o=0){const u=s.length,l=[t[0],r.length/t[0]],c=l[1],d=u>0?i[u-1]+1:0;if(d<0)throw new Error($k());const p=t.slice();p[0]=d;const f=p.reduce((w,v)=>w*v,1),m=rs(n,f);if(u===0)return d>0&&m.fill(o),[m,p];if(d<=0)throw new Error($k());let g=0,y=1,b=0,x=i[g];for(;;){let w=0;if(y<u){if(w=i[y],x===w){++y;continue}if(x>=w)throw new Error(r7())}if(x<0||x>=d)throw new Error(n7(x,d));x>b&&m.fill(o,b*c,x*c);for(let v=g;v<y;++v){const S=s[v];if(S<0||S>=l[0])throw new Error(s7(v,s[v],l[0]));for(let E=0;E<c;E++)m[x*c+E]+=r[S*c+E]}if(a)for(let v=0;v<c;v++)m[x*c+v]/=y-g;if(g=y,++y,b=x+1,x=w,y>u)break}return b<d&&m.fill(o,b*c,d*c),[m,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ewe=bl(r=>Math.sqrt(r));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const twe=$i((r,t)=>{const n=r-t;return n*n});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rwe=bl((r,t)=>{const{pattern:n,replaceGlobal:s,rewrite:i}=t;return r.replace(new RegExp(n,s?"g":""),i)});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nwe(r,t,n,s){const i=Tn(r,t.dtype);for(let a=0;a<i.size;a++){const o=i.indexToLoc(a),u=new Array(o.length);for(let l=0;l<u.length;l++)u[l]=o[l]*n[l]+s[l];i.set(t.get(...u),...o)}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class swe{constructor(t,n,s,i,a,o){this.separator=Zu(t),this.nGramWidths=n,this.leftPad=Zu(s),this.rightPad=Zu(i),this.padWidth=a,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){const s=this.getPadWidth(n);return Math.max(0,t+2*s-n+1)}createNGrams(t,n,s,i,a,o){for(let u=0;u<a;++u){const l=this.getPadWidth(o),c=Math.max(0,l-u),h=Math.max(0,l-(a-(u+1))),d=o-(c+h),p=n+(c>0?0:u-l);let f=0;f+=c*this.leftPad.length;for(let x=0;x<d;++x)f+=t[p+x].length;f+=h*this.rightPad.length;const m=c+h+d-1;f+=m*this.separator.length,s[i+u]=new Uint8Array(f);const g=s[i+u];let y=0;const b=x=>x.forEach(w=>g[y++]=w);for(let x=0;x<c;++x)b(this.leftPad),b(this.separator);for(let x=0;x<d-1;++x)b(t[p+x]),b(this.separator);if(d>0){b(t[p+d-1]);for(let x=0;x<h;++x)b(this.separator),b(this.rightPad)}else{for(let x=0;x<h-1;++x)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(t,n){const s=t.length,i=n.length;if(i>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<i;++c){let h=n[c]>=l;if(h=h&&n[c]<=s,!h)throw new Error(`Invalid split value ${n[c]}, must be in [${l}, ${s}]`);l=n[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const a=i-1,o=rs("int32",i);if(s===0||i===0){const l=new Array(s);for(let c=0;c<=a;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=a;++l){const c=n[l]-n[l-1];let h=0;this.nGramWidths.forEach(d=>{h+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&h===0&&(h=1),o[l]=o[l-1]+h}const u=new Array(o[a]);for(let l=0;l<a;++l){const c=n[l];let h=o[l];if(this.nGramWidths.forEach(d=>{const p=n[l+1]-n[l],f=this.getNumNGrams(p,d);this.createNGrams(t,c,u,h,f,d),h+=f}),this.preserveShort&&h===o[l]){const d=n[l+1]-n[l];if(d===0)continue;const p=d+2*this.padWidth;this.createNGrams(t,c,u,h,1,p)}}return[u,o]}}function iwe(r,t,n,s,i,a,o,u){return new swe(n,s,i,a,o,u).compute(r,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function awe(r,t,n,s){if(!r.length)return;if(t.length===0){for(let a=0;a<r.length;++a)s.push(r.subarray(a,a+1));return}if(t.length===1){const a=t[0];let o=r.indexOf(a);for(;o!==-1;){const u=r.subarray(0,o);(!n||u.length!==0)&&s.push(u),r=r.subarray(o+1),o=r.indexOf(a)}(!n||r.length!==0)&&s.push(r);return}let i=0;for(let a=0;a<r.length+1;a++)if(a===r.length||t.indexOf(r[a])!==-1){const o=r.subarray(i,a);(!n||o.length!==0)&&s.push(o),i=a+1}}function owe(r,t,n){const s=r.length,i=[];let a=0,o=0;const u=new Array(s);for(let p=0;p<s;++p){const f=i.length;awe(r[p],t,n,i);const m=i.length-f;u[p]=m,a+=m,o=Math.max(o,m)}const l=rs("int32",a*2),c=new Array(a),h=[s,o];let d=0;for(let p=0;p<s;++p)for(let f=0;f<u[p];++f)l[d*2]=p,l[d*2+1]=f,c[d]=i[d],++d;return[l,c,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uwe(r,t){const n=rs("int32",r.length);for(let s=0;s<r.length;++s)n[s]=bG(r[s]).modulo(t).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lwe=$i((r,t)=>r-t);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cwe(r,t){const n=new Array(r.rank);for(let i=0;i<n.length;i++)n[i]=r.shape[i]*t[i];const s=Tn(n,r.dtype);for(let i=0;i<s.values.length;++i){const a=s.indexToLoc(i),o=new Array(r.rank);for(let l=0;l<o.length;l++)o[l]=a[l]%r.shape[l];const u=r.locToIndex(o);s.values[i]=r.values[u]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ny=(r,t)=>{const n=t.value-r.value;return n===0?r.index-t.index:n};function C7(r,t,n=0,s=r.length-1){for(;s>n;){if(s-n>600){const u=s-n+1,l=t-n+1,c=Math.log(u),h=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*h*(u-h)/u)*Math.sign(l-u/2),p=Math.max(n,Math.floor(t-l*h/u+d)),f=Math.min(s,Math.floor(t+(u-l)*h/u+d));C7(r,t,p,f)}const i=r[t];let a=n,o=s;for(Uu(r,n,t),Ny(r[s],i)>0&&Uu(r,n,s);a<o;){for(Uu(r,a,o),a++,o--;Ny(r[a],i)<0;)a=a+1;for(;Ny(r[o],i)>0;)o=o-1}Ny(r[n],i)===0?Uu(r,n,o):(o=o+1,Uu(r,o,s)),o<=t&&(n=o+1),t<=o&&(s=o-1)}}function hwe(r,t,n,s,i){const a=t[t.length-1],[o,u]=[r.length/a,a],l=ul(n,o*s),c=ul("int32",o*s);for(let d=0;d<o;d++){const p=d*u,f=r.subarray(p,p+u);let m=new Array(f.length);f.forEach((x,w)=>m[w]={value:x,index:w}),s<m.length&&(C7(m,s),m=m.slice(0,s)),i&&m.sort(Ny);const g=d*s,y=l.subarray(g,g+s),b=c.subarray(g,g+s);for(let x=0;x<s;x++)y[x]=m[x].value,b[x]=m[x].index}const h=t.slice();return h[h.length-1]=s,[Tn(h,n,l),Tn(h,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dwe(r,t,n,s){const i=ls(t,n)[0],a=[1,n[0],1];for(let m=0;m<i;m++)a[0]*=n[m];a[1]=n[i];for(let m=i+1;m<n.length;m++)a[2]*=n[m];const o=new Map,u=new Int32Array(n[i]),l=new td(a,s,r),c=[],h=a[0]===1&&a[2]===1;for(let m=0;m<n[i];m++){let g;if(h)g=r[m].toString();else{const b=[];for(let x=0;x<a[0];x++)for(let w=0;w<a[2];w++)b.push(l.get(x,m,w));g=b.join(",")}const y=o.get(g);if(y!=null)u[m]=y;else{const b=o.size;o.set(g,b),u[m]=b,c.push(m)}}const d=a.slice();d[1]=o.size;const p=new td(d,s);c.forEach((m,g)=>{for(let y=0;y<a[0];y++)for(let b=0;b<a[2];b++)p.set(l.get(y,m,b),y,g,b)});const f=n.slice();return f[i]=d[1],{outputValues:p.values,outputShape:f,indices:u}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pwe=Object.freeze(Object.defineProperty({__proto__:null,addImpl:h1e,bincountImpl:d1e,bincountReduceImpl:p1e,bitwiseAndImpl:f1e,castImpl:c1e,ceilImpl:m1e,concatImpl:g1e,equalImpl:y1e,expImpl:b1e,expm1Impl:x1e,floorDivImpl:w1e,floorImpl:v1e,gatherNdImpl:S1e,gatherV2Impl:C1e,greaterEqualImpl:E1e,greaterImpl:_1e,lessEqualImpl:k1e,lessImpl:I1e,linSpaceImpl:N1e,logImpl:T1e,maxImpl:A1e,maximumImpl:D1e,minimumImpl:F1e,multiplyImpl:S7,negImpl:$1e,notEqualImpl:R1e,prodImpl:M1e,raggedGatherImpl:W1e,raggedRangeImpl:G1e,raggedTensorToTensorImpl:H1e,rangeImpl:j1e,rsqrtImpl:q1e,scatterImpl:K1e,sigmoidImpl:X1e,simpleAbsImpl:l1e,sliceImpl:Y1e,sparseFillEmptyRowsImpl:Z1e,sparseReshapeImpl:J1e,sparseSegmentReductionImpl:Q1e,sqrtImpl:ewe,squaredDifferenceImpl:twe,staticRegexReplaceImpl:rwe,stridedSliceImpl:nwe,stringNGramsImpl:iwe,stringSplitImpl:owe,stringToHashBucketFastImpl:uwe,subImpl:lwe,tileImpl:cwe,topKImpl:hwe,transposeImpl:O1e,uniqueImpl:dwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:fwe,bincountImpl:_7,bincountReduceImpl:mwe,bitwiseAndImpl:gwe,castImpl:ywe,ceilImpl:bwe,concatImpl:xwe,equalImpl:vwe,expImpl:wwe,expm1Impl:Swe,floorImpl:Cwe,gatherNdImpl:_we,gatherV2Impl:Ewe,greaterImpl:Iwe,greaterEqualImpl:kwe,lessImpl:Nwe,lessEqualImpl:Twe,linSpaceImpl:Awe,logImpl:Dwe,maxImpl:Fwe,maximumImpl:$we,minimumImpl:Rwe,multiplyImpl:Owe,negImpl:Mwe,notEqualImpl:Lwe,prodImpl:Pwe,raggedGatherImpl:Bwe,raggedRangeImpl:Vwe,raggedTensorToTensorImpl:zwe,rangeImpl:Uwe,rsqrtImpl:Wwe,scatterImpl:Gwe,sigmoidImpl:Hwe,simpleAbsImpl:E7,sliceImpl:jwe,sparseFillEmptyRowsImpl:qwe,sparseReshapeImpl:Kwe,sparseSegmentReductionImpl:I7,sqrtImpl:Xwe,staticRegexReplaceImpl:Ywe,stridedSliceImpl:Zwe,stringNGramsImpl:Jwe,stringSplitImpl:Qwe,stringToHashBucketFastImpl:e2e,subImpl:t2e,tileImpl:r2e,topKImpl:n2e,transposeImpl:CR,uniqueImpl:s2e}=pwe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k7(r,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${r}.${n}`)}function ri(r,t){return t===1?[r]:k7(r,t)}function i2e(r,t){if(r===1)return"rc";let n="";for(let s=0;s<r;s++)n+=t[s],s<r-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a2e{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Hs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=ri("rc",this.rank),s=on(this.rank),i=this.getOutOfBoundsCondition(n),a=this.getSetup(n),o=this.getOutput(n);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(t){const n=[];for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let a=`${s===0?"r":"rp1"}, ${i===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)a=`${t[t.length-1-o]},`+a;n.push(a)}return n}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let s=this.rank-2;s<this.rank;s++)n+=`${t[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(n+="||");return n}getSetup(t){if(this.rank===1)return"";const n=t.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${i};
    `}getOutput(t){const n=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N7{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Hs(this.outputShape.length);let s="";for(let i=0;i<4;i++){let a="thisRC = rc;";i%2===1&&(a+="thisRC.z += 1;"),i>1&&(a+="thisRC.y += 1;"),s+=`
        ${a}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${o2e(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?wR():vR(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${s}

        setOutput(result);
      }
    `}}function o2e(r,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?eve(["r","c","d"],"inputShape"):Vd(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u2e{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,n,s){const i=i5(n,s),a=a5(t,i,s);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const o=s5(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[a].pop();return this.usedTextures[a].push(l),l}let u;return i===Ts.PACKED_2X2_FLOAT32?u=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):i===Ts.PACKED_2X2_FLOAT16?u=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):i===Ts.UNPACKED_FLOAT32?u=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):i===Ts.UNPACKED_FLOAT16?u=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):i===Ts.PACKED_4X1_UNSIGNED_BYTE&&(u=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(u),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),u}releaseTexture(t,n,s,i){if(this.freeTextures==null)return;const a=i5(s,i),o=a5(n,a,i);o in this.freeTextures||(this.freeTextures[o]=[]);const u=s5(n,a,this.gpgpu.gl,this.gpgpu.textureConfig,i),l=Be().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=u):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=u),this.numUsedTextures--;const c=this.usedTextures[o],h=c&&c.indexOf(t);if(h==null||h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[h]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function l2e(r,t){const n=r;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===r.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function s5(r,t,n,s,i){const a=c2e(t,s);let o;if(i){const[l,c]=gg(r[0],r[1]);o=l*c}else{const[l,c]=Tx(r[0],r[1]);o=l*c}const u=l2e(n,a);return o*u}function c2e(r,t){switch(r){case Ts.PACKED_2X2_FLOAT32:return v7(t);case Ts.PACKED_2X2_FLOAT16:return w7(t);case Ts.UNPACKED_FLOAT32:return y7(t);case Ts.UNPACKED_FLOAT16:return b7(t);case Ts.PACKED_4X1_UNSIGNED_BYTE:return x7(t);default:throw new Error(`Unknown physical texture type ${r}`)}}function h2e(r){return Be().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?Ts.PACKED_2X2_FLOAT32:Ts.UNPACKED_FLOAT32:r?Ts.PACKED_2X2_FLOAT16:Ts.UNPACKED_FLOAT16}function i5(r,t){if(r===da.UPLOAD)return Ts.PACKED_2X2_FLOAT32;if(r===da.RENDER||r==null)return h2e(t);if(r===da.DOWNLOAD||r===da.PIXELS)return Ts.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function a5(r,t,n){return`${r[0]}_${r[1]}_${t}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tu{constructor(t,n){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Hs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const so="if (isnan(x)) return x;",d2e="return x;",o5="return abs(x);",p2e="return (x >= 0.0) ? x : (exp(x) - 1.0);",f2e=so+`
  return (x < 0.0) ? 0.0 : x;
`,m2e=so+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ml="return x;",g2e="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y2e="return x;",b2e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,x2e=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,v2e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,w2e="return 1.0 / (1.0 + exp(-1.0 * x));";class Kl{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Hs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S2e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Hs(this.outputShape.length);const n=t.length,s=ri("rc",n),i=on(n),a=i2e(n,s),o=s.slice(-2),u=n<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${u}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C2e=Y$,_2e=1e-7,E2e=1e-4,k1={};function I2e(r){return r in k1||(k1[r]={}),k1[r]}const k2e=Be().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),N2e=600;function T2e(){return Be().global.screen==null?1024:Be().global.screen.height*Be().global.screen.width*window.devicePixelRatio*N2e/1024/1024}class bC extends aA{nextDataId(){return bC.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Be().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof JE)n=t;else{const s=$o(Be().getNumber("WEBGL_VERSION"),t);n=new JE(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=$o(Be().getNumber("WEBGL_VERSION"));n=new JE(s),this.binaryCache=I2e(Be().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new u2e(this.gpgpu),this.numMBBeforeWarning=T2e(),this.texData=new W8(this,mo())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,s,i,a,o){const u=this.makeTensorInfo(n,s),l=this.texData.get(u.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[i,a]},l.texShape=[i,a];const c=E1(n),h=new Q4(c,!1,o),d=this.runWebGLProgram(h,[u],s,[[i,a]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(u),d.dataId}write(t,n,s){if((Be().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Be().getBool("DEBUG"))&&this.checkNumericalProblems(t),s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:n,dtype:s,values:t,usage:da.UPLOAD,refCount:1}),i}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){const n=this.texData.get(t);n.refCount--}}move(t,n,s,i,a){if(Be().getBool("DEBUG")&&this.checkNumericalProblems(n),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:s,dtype:i,values:n,usage:da.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const n=this.texData.get(t),{values:s,dtype:i,complexTensorInfos:a,slice:o,shape:u,isPacked:l}=n;if(o!=null){let p;l?p=new Kl(u,Ml):p=new tu(u,Ml);const f=this.runWebGLProgram(p,[{dataId:t,shape:u,dtype:i}],i),m=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),m}if(s!=null)return this.convertAndCacheOnCPU(t);if(i==="string")return s;const c=this.activeTimers!=null;let h;c&&(h=Ba());let d;if(i==="complex64"){const p=this.readSync(a.real.dataId),f=this.readSync(a.imag.dataId);d=Fk(p,f)}else d=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=Ba()-h),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){const m=this.pendingRead.get(t);return new Promise(g=>m.push(g))}const n=this.texData.get(t),{values:s,shape:i,slice:a,dtype:o,complexTensorInfos:u,isPacked:l}=n;if(a!=null){let m;l?m=new Kl(i,Ml):m=new tu(i,Ml);const g=this.runWebGLProgram(m,[{dataId:t,shape:i,dtype:o}],o),y=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(s!=null)return this.convertAndCacheOnCPU(t);if(Be().getBool("DEBUG")&&!Be().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Be().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,h;if(o!=="complex64"&&Be().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(t);const m=this.texData.get(h.dataId);c=this.gpgpu.createBufferFromTexture(m.texture.texture,...S1(i))}this.pendingRead.set(t,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(o==="complex64"){const m=await Promise.all([this.read(u.real.dataId),this.read(u.imag.dataId)]),g=m[0],y=m[1];d=Fk(g,y)}else if(c==null)d=this.getValuesFromTexture(t);else{const m=lt(i);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,m)}if(h!=null&&this.disposeIntermediateTensorInfo(h),c!=null){const m=this.gpgpu.gl;Ct(m,()=>m.deleteBuffer(c))}const p=this.convertAndCacheOnCPU(t,d),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(m=>m(p)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&mo().removeDataId(t,this),this.pendingDeletes--),p}readToGPU(t,n={}){const s=this.texData.get(t),{values:i,shape:a,slice:o,dtype:u,isPacked:l,texture:c}=s;if(u==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let f;l?f=new Kl(a,Ml):f=new tu(a,Ml);const m=this.runWebGLProgram(f,[{dataId:t,shape:a,dtype:u}],u),g=this.readToGPU(m,n);return this.disposeIntermediateTensorInfo(m),g}if(c==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(t,n.customTexShape),d=mo().makeTensorFromTensorInfo(h),p=this.texData.get(h.dataId);return Object.assign({tensorRef:d},p.texture)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const s=n.map(i=>ed(i));return Tn(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Tn(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){const s=t[n];if(!kxe(s))throw Be().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:n,dtype:s,isPacked:i}=this.texData.get(t),a=lt(n);if(Be().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(t),f=this.texData.get(p.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...S1(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(p),m}const o=Be().getBool("WEBGL_PACK")&&i===!0,u=o?E1(n):n,l=o?new Wve(u):new Uve(u),c=this.runWebGLProgram(l,[{shape:u,dtype:s,dataId:t}],"float32"),h=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const n=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,t();const a=hu(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=hu(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,i&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(a);u.kernelMs=H8(l),u.getExtraProfileInfo=()=>l.map((c,h)=>({name:o[h],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ba(),endMs:null}}endTimer(t){return Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=Ba(),t)}async getQueryTime(t){if(Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:s}=this.texData.get(t);return s!=null&&(this.disposeData(s.real.dataId,n),this.disposeData(s.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:n,dtype:s,texShape:i,usage:a,isPacked:o,slice:u}=this.texData.get(t),l=u&&u.origDataId||t,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(n,i,a,o)));const h=this.texData.get(t);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=k2e){return Be().getBool("WEBGL_CPU_FORWARD")&&t.every(s=>this.texData.get(s.dataId).texture==null&&lt(s.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){Wa("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=t.dataSync();return C2e(t.shape,n)}packedUnaryOp(t,n,s){const i=new Kl(t.shape,n),a=this.compileAndRun(i,[t],s);return mo().makeTensorFromTensorInfo(a)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const i=E7(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,i)}if(Be().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,o5,t.dtype);const n=new tu(t.shape,o5),s=this.compileAndRun(n,[t]);return mo().makeTensorFromTensorInfo(s)}makeTensorInfo(t,n,s){let i;if(n==="string"&&s!=null&&s.length>0&&Xu(s[0])){const a=s.map(o=>Zu(o));i=this.write(a,t,n)}else i=this.write(s,t,n);return this.texData.get(i).usage=null,{dataId:i,shape:t,dtype:n}}makeOutput(t,n,s){return mo().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,s),this)}unpackTensor(t){const n=new S2e(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){const n=new a2e(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){const s=[Bm(t.shape),...Vm(t.shape)],i={dtype:t.dtype,shape:s,dataId:t.dataId},a=[Bm(n),...Vm(n)],o=new N7(a,s),u=!0,l=[s],c=this.runWebGLProgram(o,[i],t.dtype,l,u);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(t,n){const s=this.texData.get(t),{isPacked:i,shape:a,dtype:o}=s;if(n!=null){const p=lt(a),f=n[0]*n[1]*4;oe(p<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const u=E1(a);let l;i?l=new zve(u):l=new Vve(u);const c=!0,h=[n??S1(u)],d=this.runWebGLProgram(l,[{shape:u,dtype:o,dataId:t}],o,h,c,n);return{dtype:o,shape:a,dataId:d.dataId}}runWebGLProgram(t,n,s,i,a=!1,o){const u=this.makeTensorInfo(t.outputShape,s),l=this.texData.get(u.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===Vb.DENSE){const b=o??S1(t.outputShape);l.texShape=b.map(x=>x*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),lt(u.shape)===0)return l.values=ul(u.dtype,0),u;const c=[],h=n.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(b.dataId);if(x.texture==null){if(!t.packedInputs&&lt(b.shape)<=Be().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:x.values};t.packedInputs&&(x.isPacked=!0,x.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!x.isPacked!=!!t.packedInputs)b=x.isPacked?this.unpackTensor(b):this.packTensor(b),c.push(b),x=this.texData.get(b.dataId);else if(x.isPacked&&!I2(x.shape,b.shape)){const w=b,v=b.shape;b.shape=x.shape,b=this.packedReshape(b,v),c.push(b),x=this.texData.get(b.dataId),w.shape=v}return{shape:b.shape,texData:x,isUniform:!1}});this.uploadToGPU(u.dataId);const d={shape:u.shape,texData:l,isUniform:!1},p=Bve(t,h,d),f=this.getAndSaveBinary(p,()=>Lve(this.gpgpu,t,h,d)),m=this.activeTimers!=null;let g;m&&(g=this.startTimer()),Be().get("ENGINE_COMPILE_ONLY")||Pve(this.gpgpu,f,h,d,i),c.forEach(b=>this.disposeIntermediateTensorInfo(b)),m&&(g=this.endTimer(g),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(g)}));const y=Be().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const b=Ba();b-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!Be().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&a===!1){const b=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),b}return u}compileAndRun(t,n,s,i,a=!1){return s=s||n[0].dtype,this.runWebGLProgram(t,n,s,i,a)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Be().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=qt(()=>{if(!Be().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Be().getBool("DEBUG");Be().set("DEBUG",!1);const n=this.abs(mr(1e-8)).dataSync()[0];if(Be().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?_2e:E2e}uploadToGPU(t){const n=this.texData.get(t),{shape:s,dtype:i,values:a,texture:o,usage:u,isPacked:l}=n;if(o!=null)return;const c=this.activeTimers!=null;let h;c&&(h=Ba());let d=n.texShape;if(d==null&&(d=Hxe(s,l),n.texShape=d),a!=null){const p=E1(s);let f,m=d[1],g=d[0];const y=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(l||!y)&&([m,g]=gg(d[0],d[1])),l?f=new Hve(p,y):f=new Q4(p,y);const b=y?[g,m]:d,x=this.makeTensorInfo(b,i),w=this.texData.get(x.dataId);y?w.usage=da.PIXELS:w.usage=da.UPLOAD,w.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),m,g,a);const v=[[g,m]],E=this.runWebGLProgram(f,[x],i,v,!0),C=this.texData.get(E.dataId);n.texShape=C.texShape,n.isPacked=C.isPacked,n.usage=C.usage,Be().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(n.texture=C.texture,n.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(x),c&&(this.uploadWaitMs+=Ba()-h)}else{const p=this.acquireTexture(d,u,i,l);n.texture=p}}convertAndCacheOnCPU(t,n){const s=this.texData.get(t),{dtype:i}=s;return n!=null&&(s.values=A2e(n,i)),s.values}acquireTexture(t,n,s,i){if(this.numBytesInGPU+=this.computeBytes(t,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,i)}computeBytes(t,n){return t[0]*t[1]*Eb(n)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(const[,n]of Object.entries(this.binaryCache)){const s=new Promise(i=>{try{this.checkCompletion_(n),i(!0)}catch(a){throw a}});t.push(s)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await E9(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(h7(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:n,customUniformLocations:s,infLoc:i,nanLoc:a,outShapeLocation:o,outShapeStridesLocation:u,outTexShapeLocation:l}=g7(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=s,t.infLoc=i,t.nanLoc=a,t.outShapeLocation=o,t.outShapeStridesLocation=u,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,s){t.channels=t.channels||"RGBA";const{texture:i,height:a,width:o,channels:u}=t,l=mo().backend;if(!l.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(i,n,s,a,o,u);return mo().makeTensorFromDataId(c,n,s,l)}}bC.nextDataId=0;function A2e(r,t){if(t==="float32"||t==="complex64")return r;if(t==="int32"||t==="bool"){const n=t==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let s=0;s<n.length;++s)n[s]=Math.round(r[s]);return n}else throw new Error(`Unknown dtype ${t}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */s$()&&kG("webgl",()=>new bC,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _R=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class ld{constructor(t,n,s){this.variableNames=["A","B"],this.outputShape=Fr(n,s),this.enableShapeUniforms=Hs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ud=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class wg{constructor(t,n,s,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Fr(n,s);const a=this.outputShape.length;this.enableShapeUniforms=Hs(a);let o="";if(i)if(a===0||lt(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${on(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=ri("coords",a);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ta(r){const{inputs:t,backend:n}=r,{x:s}=t;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const D2e={kernelName:ZS,backendName:"webgl",kernelFunc:ta};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rc(r){const{inputs:t,backend:n}=r,{real:s,imag:i}=t,a=n.makeTensorInfo(s.shape,"complex64"),o=n.texData.get(a.dataId),u=ta({inputs:{x:s},backend:n}),l=ta({inputs:{x:i},backend:n});return o.complexTensorInfos={real:u,imag:l},a}const F2e={kernelName:FA,backendName:"webgl",kernelFunc:Rc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T7="return (a < 0.) ? b * a : a;",A7=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function $2e(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{alpha:a}=s,o=n.makeTensorInfo([],"float32",Ld(a,"float32")),u=Be().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wg(A7,i.shape,o.shape):new ld(T7,i.shape,o.shape),l=n.runWebGLProgram(u,[i,o],"float32");return n.disposeIntermediateTensorInfo(o),l}const R2e={kernelName:SD,backendName:"webgl",kernelFunc:$2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D7="return (a < 0.) ? b * a : a;",F7=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function O2e(r){const{inputs:t,backend:n}=r,{x:s,alpha:i}=t,a=Be().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wg(F7,s.shape,i.shape):new ld(D7,s.shape,i.shape);return n.runWebGLProgram(a,[s,i],"float32")}const M2e={kernelName:eF,backendName:"webgl",kernelFunc:O2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sg="if (isnan(x)) return x;";function $r({opSnippet:r,packedOpSnippet:t,cpuKernelImpl:n,dtype:s}){return({inputs:i,backend:a})=>{const{x:o}=i,u=a,l=s||o.dtype;if(u.shouldExecuteOnCPU([o])&&n!=null){const d=u.texData.get(o.dataId),p=n(d.values,l);return u.makeTensorInfo(o.shape,l,p)}const c=Be().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let h;return c?h=new Kl(o.shape,t):h=new tu(o.shape,r),u.runWebGLProgram(h,[o],l)}}function Rs({opSnippet:r,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:i,dtype:a}){return({inputs:o,backend:u})=>{const{a:l,b:c}=o,h=u;if(s&&l.dtype==="complex64"){const m=h.texData.get(l.dataId),g=h.texData.get(c.dataId),[y,b]=[[m.complexTensorInfos.real,g.complexTensorInfos.real],[m.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(w=>{const[v,S]=w,E={dataId:v.dataId,dtype:v.dtype,shape:l.shape},C={dataId:S.dataId,dtype:S.dtype,shape:c.shape},I=new ld(r,l.shape,c.shape);return h.runWebGLProgram(I,[E,C],Fo(v.dtype,S.dtype))}),x=Rc({inputs:{real:y,imag:b},backend:h});return h.disposeIntermediateTensorInfo(y),h.disposeIntermediateTensorInfo(b),x}const d=a||Fo(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||h.shouldExecuteOnCPU([l,c]))&&i!=null){const m=h.texData.get(l.dataId).values,g=h.texData.get(c.dataId).values,y=l.dtype==="string"?Pm(m):m,b=l.dtype==="string"?Pm(g):g,[x,w]=i(l.shape,c.shape,y,b,d),v=h.makeTensorInfo(w,d),S=h.texData.get(v.dataId);return S.values=x,v}const p=Be().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let f;return p?f=new wg(t,l.shape,c.shape,n):f=new ld(r,l.shape,c.shape),h.runWebGLProgram(f,[l,c],d)}}function zb(r,t=!1){if(r==="linear")return t?y2e:d2e;if(r==="relu")return t?x2e:f2e;if(r==="elu")return t?b2e:p2e;if(r==="relu6")return t?v2e:m2e;if(r==="prelu")return t?F7:D7;if(r==="leakyrelu")return t?A7:T7;if(r==="sigmoid")return t?w2e:g2e;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $7{constructor(t,n,s,i=!1,a=!1,o=!1,u=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Hs(this.outputShape.length);const h=i?t[1]:t[2],d=Math.ceil(h/2),p=i?"i * 2, rc.y":"rc.y, i * 2",f=a?"rc.z, i * 2":"i * 2, rc.z",m=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",b="";u&&(l?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${u}
        }`:c?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${u}
        }`:y=`vec4 activation(vec4 x) {
          ${u}
        }`,b="result = activation(result);");const x=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let w="rc.x",v="rc.x";t[0]<n[0]?w=`imod(rc.x, ${t[0]})`:n[0]<t[0]&&(v=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${w};
        int batchB = ${v};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${m[0]} * ${g[0]});
          result += (${m[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${b}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u5={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class l5{constructor(t,n,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Fr(n,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c5="return a * b;";function ER(r){const{inputs:t,backend:n}=r,{a:s,b:i}=t,a=Fo(s.dtype,i.dtype);if(s.dtype==="complex64"){const u=n.texData.get(s.dataId),l=n.texData.get(i.dataId),c=new l5(u5.REAL,s.shape,i.shape),h=new l5(u5.IMAG,s.shape,i.shape),d=[{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],p=n.runWebGLProgram(c,d,"float32"),f=n.runWebGLProgram(h,d,"float32"),m=Rc({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}if(n.shouldExecuteOnCPU([s,i])){const u=n.texData.get(s.dataId),l=n.texData.get(i.dataId),[c,h]=Owe(s.shape,i.shape,u.values,l.values,a),d=n.makeTensorInfo(h,a),p=n.texData.get(d.dataId);return p.values=c,d}let o;return Be().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new wg(c5,s.shape,i.shape):o=new ld(c5,s.shape,i.shape),n.runWebGLProgram(o,[s,i],a)}const L2e={kernelName:WD,backendName:"webgl",kernelFunc:ER};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P2e(r,t,n){const s=[Bm(r.shape),...Vm(r.shape)],i={dtype:r.dtype,shape:s,dataId:r.dataId},a=[Bm(t),...Vm(t)],o=new N7(a,s),u=!0,l=[s],c=n.runWebGLProgram(o,[i],r.dtype,l,u);return{dataId:c.dataId,shape:t,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mt(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{shape:a}=s,o=n,u=lt(i.shape),l=q8(a,u),c=lt(l);oe(u===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${i.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`);const h=o.texData.get(i.dataId);return h.isPacked&&!I2(i.shape,l)&&!(h.texture!==null&&I2(h.shape,l))?P2e(i,l,o):(o.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}const B2e={kernelName:lF,backendName:"webgl",kernelFunc:mt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h5{constructor(t,n){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:a,outSize:o}=t;this.outputShape=[i,o];const u=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(n!=null){const d=1/n;c=`sumValue += dot(values * ${Qh(d)?d.toPrecision(2):d}, ones);`}let h="";a%s>0&&(h=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${u};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V2e{constructor(t,n){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:a,outSize:o}=t;this.outputShape=[i,o];let u="0.0",l="";n==="prod"?u="1.0":n==="min"?(u="1.0 / 1e-20",l="min"):n==="max"&&(u="-1.0 / 1e-20",l="max");let c=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?c="sumValue":n==="prod"?c="prodValue":n==="all"?c="allValue":n==="any"&&(c="anyValue");const h=Math.floor(s/4)*4,d=s%4;let p=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";n==="all"?(u="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):n==="any"&&(u="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let m="";a%s>0&&(m=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${u};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${u});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${h};
        if (${d===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2e(r){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const n=t.length?t[t.length-1].outSize:r[1],s=gC(n);t.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return t}function Wd(r,t,n,s){const i=z2e(r.shape);let a=r;for(let o=0;o<i.length;o++){const{inSize:u,windowSize:l,outSize:c}=i[o];let h,d;n==="mean"?h=o===0?new h5({windowSize:l,inSize:u,batchSize:r.shape[0],outSize:c},u):new h5({windowSize:l,inSize:u,batchSize:r.shape[0],outSize:c}):h=new V2e({windowSize:l,inSize:u,batchSize:r.shape[0],outSize:c},n),d=a,a=s.runWebGLProgram(h,[a],t),d.dataId!==r.dataId&&s.disposeIntermediateTensorInfo(d)}return a}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U2e{constructor(t,n){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[n[o]];this.outputShape=s,this.rank=s.length;const i=on(this.rank),a=W2e(n);this.userCode=`
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}function W2e(r){const t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let i=0;i<r.length;i++)s[r[i]]=n[i];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G2e{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(t.length);for(let h=0;h<s.length;h++)s[h]=t[n[h]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=on(this.rank),a=k7("rc",this.rank),o=new Array(this.rank);for(let h=0;h<n.length;h++)o[n[h]]=a[h];const u=`vec2(${o.slice(-2).join()})`,l=`++${a[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${u})`;this.userCode=`
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xC(r,t,n){const s=Be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new G2e(r.shape,t):new U2e(r.shape,t);return n.runWebGLProgram(s,[r],r.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H2e(r,t,n,s){const i=t,a=r.shape.length,o=ls(i,r.shape);let u=o;const l=ro(u,a),c=l!=null;let h=r;c&&(h=xC(r,l,s),u=no(u.length,a)),Vo("sum",u,a);const[d,p]=_u(h.shape,u);let f=d;n&&(f=_a(d,o));const m=lt(p),y=lt(r.shape)/m,b=mt({inputs:{x:h},attrs:{shape:[y,m]},backend:s}),x=QS(r.dtype),w=Wd(b,x,"sum",s),v=mt({inputs:{x:w},attrs:{shape:f},backend:s});return s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(w),c&&s.disposeIntermediateTensorInfo(h),v}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vC(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s;return H2e(i,a,o,n)}const j2e={kernelName:NF,backendName:"webgl",kernelFunc:vC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oi(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{perm:a}=s,o=n,u=i.shape.length,l=new Array(u);for(let h=0;h<l.length;h++)l[h]=i.shape[a[h]];let c;if(o.shouldExecuteOnCPU([i])){const d=o.texData.get(i.dataId).values,p=CR(d,i.shape,i.dtype,a,l);c=o.makeTensorInfo(l,i.dtype);const f=o.texData.get(c.dataId);f.values=p}else c=xC(i,a,o);return c}const q2e={kernelName:Xy,backendName:"webgl",kernelFunc:oi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R7=1e3;function N2({a:r,b:t,transposeA:n,transposeB:s,backend:i,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:l=null}){const c=r.shape.length,h=t.shape.length,d=n?r.shape[c-2]:r.shape[c-1],p=s?t.shape[h-1]:t.shape[h-2],f=n?r.shape[c-1]:r.shape[c-2],m=s?t.shape[h-2]:t.shape[h-1],g=r.shape.slice(0,-2),y=t.shape.slice(0,-2),b=lt(g),x=lt(y),v=Fr(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);oe(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${n} and transposeB=${s} must match.`);const S=n?[b,d,f]:[b,f,d],E=s?[x,m,p]:[x,p,m],C=mt({inputs:{x:r},backend:i,attrs:{shape:S}}),I=mt({inputs:{x:t},backend:i,attrs:{shape:E}}),_=[C,I],A=Math.max(b,x),k=n?C.shape[1]:C.shape[2],N=a!=null,D=o!=null,F=l==="leakyrelu",P=l!=null?zb(l,!0):null,G=N||D||F||P!=null;let Y;if((f===1||m===1)&&k>R7&&G===!1){let ee=C,se=I;n&&(ee=oi({inputs:{x:C},backend:i,attrs:{perm:[0,2,1]}}),_.push(ee)),s&&(se=oi({inputs:{x:I},backend:i,attrs:{perm:[0,2,1]}}),_.push(se));const re=m!==1,J=m===1;let le=ee;re&&(le=mt({inputs:{x:ee},backend:i,attrs:{shape:[A,k,1]}}),_.push(le));const he=m===1?2:1;let xe=se;J&&(xe=mt({inputs:{x:se},backend:i,attrs:{shape:[A,1,k]}}),_.push(xe));const Fe=ER({inputs:{a:le,b:xe},backend:i});Y=vC({inputs:{x:Fe},backend:i,attrs:{axis:he,keepDims:!0}}),_.push(Fe)}else{const ee=Fo(r.dtype,t.dtype),se=new $7(S,E,[A,f,m],n,s,N,P,D,F),re=[C,I];if(a!=null&&re.push(a),D&&re.push(o),F){const J=i.makeTensorInfo([],"float32",Ld(u,"float32"));re.push(J),_.push(J)}Y=i.runWebGLProgram(se,re,ee)}const Z=mt({inputs:{x:Y},backend:i,attrs:{shape:v}});_.push(Y);for(const ee of _)i.disposeIntermediateTensorInfo(ee);return Z}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K2e(r){const{inputs:t,backend:n,attrs:s}=r,{a:i,b:a,bias:o,preluActivationWeights:u}=t,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:d}=s;return N2({a:i,b:a,transposeA:l,transposeB:c,backend:n,bias:o,preluActivationWeights:u,leakyreluAlpha:d,activation:h})}const X2e={kernelName:x2,backendName:"webgl",kernelFunc:K2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d5="return abs(x);";function Y2e(r){const{inputs:t,backend:n}=r,{x:s}=t;if(n.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const a=n.texData.get(s.dataId),o=E7(a.values);return n.makeTensorInfo(s.shape,s.dtype,o)}let i;return Be().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Kl(s.shape,d5):i=new tu(s.shape,d5),n.runWebGLProgram(i,[s],s.dtype)}const Z2e={kernelName:cA,backendName:"webgl",kernelFunc:Y2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J2e=so+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Q2e=$r({opSnippet:J2e}),eSe={kernelName:hA,backendName:"webgl",kernelFunc:Q2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tSe=so+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,rSe=$r({opSnippet:tSe}),nSe={kernelName:dA,backendName:"webgl",kernelFunc:rSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f5="return a + b;",sSe=Rs({opSnippet:f5,packedOpSnippet:f5,supportsComplex:!0,cpuKernelImpl:fwe}),iSe={kernelName:XS,backendName:"webgl",kernelFunc:sSe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aSe{constructor(t,n){this.outputShape=[],this.outputShape=t,this.variableNames=n.map((a,o)=>`T${o}`);const s=[];this.variableNames.forEach(a=>{s.push(`float v${a} = get${a}AtOutCoords();`)});const i=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oSe{constructor(t,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=n.map((a,o)=>`T${o}`);const s=[];this.variableNames.forEach(a=>{s.push(`vec4 v${a} = get${a}AtOutCoords();`)});const i=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cw(r){const{inputs:t,backend:n}=r,s=t;if(s.length===1)return ta({inputs:{x:s[0]},backend:n});if(s.length>Be().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),c=Cw({inputs:s.slice(0,l),backend:n}),h=Cw({inputs:s.slice(l),backend:n});return Cw({inputs:[c,h],backend:n})}const i=s.map(l=>l.dtype).reduce((l,c)=>Fo(l,c)),a=s.map(l=>l.shape),u=Be().getBool("WEBGL_PACK")?new oSe(s[0].shape,a):new aSe(s[0].shape,a);return n.runWebGLProgram(u,s,i)}const uSe={kernelName:pA,backendName:"webgl",kernelFunc:Cw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lSe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s,u=i.shape.length,l=ls(a,i.shape);let c=l;const h=ro(c,u);let d=i;h!=null&&(d=oi({inputs:{x:i},backend:n,attrs:{perm:h}}),c=no(c.length,u)),Vo("all",c,u);const[p,f]=_u(d.shape,c),m=lt(f),g=mt({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=Wd(g,g.dtype,"all",n);let b;if(o){const x=_a(p,l);b=mt({inputs:{x:y},backend:n,attrs:{shape:x}})}else b=mt({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),h!=null&&n.disposeIntermediateTensorInfo(d),b}const cSe={kernelName:fA,backendName:"webgl",kernelFunc:lSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hSe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s,u=i.shape.length,l=ls(a,i.shape);let c=l;const h=ro(c,u);let d=i;h!=null&&(d=oi({inputs:{x:i},backend:n,attrs:{perm:h}}),c=no(c.length,u)),Vo("any",c,u);const[p,f]=_u(d.shape,c),m=lt(f),g=mt({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=Wd(g,g.dtype,"any",n);let b;if(o){const x=_a(p,l);b=mt({inputs:{x:y},backend:n,attrs:{shape:x}})}else b=mt({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),h!=null&&n.disposeIntermediateTensorInfo(d),b}const dSe={kernelName:mA,backendName:"webgl",kernelFunc:hSe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pSe{constructor(t,n,s){this.variableNames=["A"];const{windowSize:i,batchSize:a,outSize:o}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[a,o];const u=n==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${u} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fSe{constructor(t,n,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,oe(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const a=t[t.length-1],o=Math.ceil(a/n);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),i||this.variableNames.push("bestIndicesA");const u=this.outputShape,l=u.length,c=on(l),h=ri("coords",l);let d,p;if(o===1){p=l+1;const I=on(p);d=`
        ${I} sourceLocR = ${I}(${h.join()}, 0);
        ++${h[l-1]};
        ${I} sourceLocG = ${I}(${h.join()}, 0);
        ++${h[l-2]};
        ${I} sourceLocA = ${I}(${h.join()}, 0);
        --${h[l-1]};
        ${I} sourceLocB = ${I}(${h.join()}, 0);
        --${h[l-2]};`}else p=l,d=`
        ${c} sourceLocR = coords;
        ++${h[l-1]};
        ${c} sourceLocG = coords;
        ++${h[l-2]};
        ${c} sourceLocA = coords;
        --${h[l-1]};
        ${c} sourceLocB = coords;
        --${h[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,p),m="."+f[p-1],g=f.map(I=>"int "+I),y=ri("sourceLocR",p-1).concat("inIdx.r"),b=ri("sourceLocG",p-1).concat("inIdx.g"),x=ri("sourceLocB",p-1).concat("inIdx.b"),w=ri("sourceLocA",p-1).concat("inIdx.a"),v=s==="max"?"greaterThan":"lessThan",S=i?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${w.join()})));`,E=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,C=i?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${C}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${h[l-1]} < ${u[l-1]-1};
        bool hasNextRow = ${h[l-2]} < ${u[l-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${E};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${S}
          vec4 candidate = ${E};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O7(r,t,n,s=null){let i=t.shape[0],a=t.shape[1];s!=null&&(i=s.shape[0],a=s.shape[1]);const o=gC(a),u={windowSize:o,inSize:a,batchSize:i,outSize:Math.ceil(a/o)},l=new pSe(u,n,s==null),c=[t];s!=null&&c.push(s);const h=r.runWebGLProgram(l,c,"int32");if(h.shape[1]===1)return h;const d=O7(r,t,n,h);return r.disposeIntermediateTensorInfo(h),d}function M7(r,t,n,s=null){const i=s!=null?s.shape:t.shape,a=i[i.length-1],o=gC(a),u=new fSe(i,o,n,s==null),l=s==null?[t]:[t,s],c=r.runWebGLProgram(u,l,"int32");if(c.shape.length===t.shape.length){const h=M7(r,t,n,c);return r.disposeIntermediateTensorInfo(c),h}return c}function L7(r,t,n,s){const i=[n];if(Vo("arg"+s.charAt(0).toUpperCase()+s.slice(1),i,t.shape.length),!Be().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const a=[],o=r.texData.get(t.dataId),u=o!==null&&o.isPacked;let l=t;u&&(l=r.unpackTensor(t),a.push(l));const[c,h]=_u(l.shape,i),d=lt(h),p=mt({inputs:{x:l},backend:r,attrs:{shape:[-1,d]}});a.push(p);const f=O7(r,p,s);a.push(f);const m=mt({inputs:{x:f},backend:r,attrs:{shape:c}});return a.forEach(g=>r.disposeIntermediateTensorInfo(g)),m}return M7(r,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mSe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a}=s;let o=ls(a,i.shape);const u=ro(o,i.shape.length);let l=i;const c=[];u!=null&&(l=oi({inputs:{x:i},backend:n,attrs:{perm:u}}),c.push(l),o=no(o.length,l.shape.length)),Vo("argMax",[o[0]],l.shape.length);const h=L7(n,l,o[0],"max");return c.forEach(d=>n.disposeIntermediateTensorInfo(d)),h}const gSe={kernelName:gA,backendName:"webgl",kernelFunc:mSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ySe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a}=s;let o=ls(a,i.shape);const u=ro(o,i.shape.length);let l=i;const c=[];u!=null&&(l=oi({inputs:{x:i},backend:n,attrs:{perm:u}}),c.push(l),o=no(o.length,l.shape.length)),Vo("argMin",[o[0]],l.shape.length);const h=L7(n,l,o[0],"min");return c.forEach(d=>n.disposeIntermediateTensorInfo(d)),h}const bSe={kernelName:yA,backendName:"webgl",kernelFunc:ySe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xSe=so+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,vSe=$r({opSnippet:xSe}),wSe={kernelName:bA,backendName:"webgl",kernelFunc:vSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SSe=so+"return log(x + sqrt(x * x + 1.0));",CSe=$r({opSnippet:SSe}),_Se={kernelName:xA,backendName:"webgl",kernelFunc:CSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ESe=so+`
  return atan(x);
`,ISe=$r({opSnippet:ESe}),kSe={kernelName:vA,backendName:"webgl",kernelFunc:ISe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NSe=_R+`
  return atan(a, b);
`,TSe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ud+`
  return result;
`,ASe=Rs({opSnippet:NSe,packedOpSnippet:TSe}),DSe={kernelName:SA,backendName:"webgl",kernelFunc:ASe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FSe=so+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,$Se=$r({opSnippet:FSe}),RSe={kernelName:wA,backendName:"webgl",kernelFunc:$Se};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ub{constructor(t,n,s,i=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,u=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterHeight,p=t.effectiveFilterWidth,f=t.padInfo.top,m=t.padInfo.left;this.outputShape=t.outShape;const g=n==="avg",y=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,b=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let x="0.0";if(g||(x="-1.0 / 1e-20"),s){const I=">=";this.userCode=`
        const ivec2 strides = ivec2(${u}, ${l});
        const ivec2 pads = ivec2(${f}, ${m});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${h}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i?a?y:b:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let v=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(v="avgValue / max(count, 1.0)");const S=Math.floor(o/4)*4,E=o%4,C=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${f}, ${m});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${S}; wC += 4) {
            int xC = xCCorner + wC * ${h};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              getValue(batch, xR, xC + 3 * ${h}, d)
            );

            ${C}
          }

          int xC = xCCorner + ${S};
          if (${E===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${C}
          } else if (${E===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              initializationValue,
              initializationValue
            );

            ${C}
          } else if (${E===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              initializationValue
            );

            ${C}
          }
        }
        setOutput(${v});
      }
    `}}class IR{constructor(t,n,s,i=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,u=t.strideDepth,l=t.strideHeight,c=t.strideWidth,h=t.dilationDepth,d=t.dilationHeight,p=t.dilationWidth,f=t.effectiveFilterDepth,m=t.effectiveFilterHeight,g=t.effectiveFilterWidth,y=t.padInfo.front,b=t.padInfo.top,x=t.padInfo.left;this.outputShape=t.outShape;const w=n==="avg";let v="0.0";if(w||(v="-1.0 / 1e-20"),s){const A=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${u}, ${l}, ${c});
        const ivec3 pads = ivec3(${y}, ${b}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${h}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${m};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${A} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i?a?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${m} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let E=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(E="avgValue / max(count, 1.0)");const C=Math.floor(o/4)*4,I=o%4,_=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${u}, ${l}, ${c});
      const ivec3 pads = ivec3(${y}, ${b}, ${x});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${h}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${C}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${_}
            }

            int xC = xCCorner + ${C};
            if (${I===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${_}
            } else if (${I===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${_}
            } else if (${I===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${_}
            }
          }
        }
        setOutput(${E});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OSe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t;Ax(i,"avgPool");const{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=s,c=1;oe(oa(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=Pd(i.shape,a,o,c,u,l);if(h.filterWidth===1&&h.filterHeight===1&&En(h.inShape,h.outShape))return ta({inputs:{x:i},backend:n});const d=new Ub(h,"avg",!1);return n.runWebGLProgram(d,[i],"float32")}const MSe={kernelName:CA,backendName:"webgl",kernelFunc:OSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LSe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l,dataFormat:c}=s,h=[1,1,1],d=vx(i.shape,a,o,h,u,l,c),p=new IR(d,"avg",!1);return n.runWebGLProgram(p,[i],"float32")}const PSe={kernelName:_A,backendName:"webgl",kernelFunc:LSe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BSe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterHeight,s=t.filterWidth,i=t.strideHeight,a=t.strideWidth,o=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,h=l-1-t.padInfo.top,d=c-1-t.padInfo.left,p=1/(n*s);this.userCode=`
      const ivec2 pads = ivec2(${h}, ${d});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${u}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class VSe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterDepth,s=t.filterHeight,i=t.filterWidth,a=t.strideDepth,o=t.strideHeight,u=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=d-1-t.padInfo.front,g=p-1-t.padInfo.top,y=f-1-t.padInfo.left,b=1/(n*s*i);this.userCode=`
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${u}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zSe(r){const{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,o=a,{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=s,d=[1,1,1],p=vx(o.shape,u,l,d,c,h),f=new VSe(p);return n.runWebGLProgram(f,[i],o.dtype)}const USe={kernelName:sG,backendName:"webgl",kernelFunc:zSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WSe(r){const{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,o=a;Ax([i,a],"avgPoolGrad");const{filterSize:u,strides:l,pad:c}=s,h=Pd(o.shape,u,l,1,c),d=new BSe(h);return n.runWebGLProgram(d,[i],o.dtype)}const GSe={kernelName:nG,backendName:"webgl",kernelFunc:WSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HSe(r){const{inputs:t,backend:n,attrs:s}=r,{a:i,b:a}=t,{transposeA:o,transposeB:u}=s;return N2({a:i,b:a,transposeA:o,transposeB:u,backend:n})}const jSe={kernelName:EA,backendName:"webgl",kernelFunc:HSe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qSe{constructor(t,n,s,i,a,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Fr(t,n),Fr(t,s);let u="0.0";i!=null&&(Fr(t,i),this.variableNames.push("offset"),u="getOffsetAtOutCoords()");let l="1.0";a!=null&&(Fr(t,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${u};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KSe{constructor(t,n,s,i,a,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Fr(t,n),Fr(t,s);let u="vec4(0.0)";i!=null&&(Fr(t,i),this.variableNames.push("offset"),u="getOffsetAtOutCoords()");let l="vec4(1.0)";a!=null&&(Fr(t,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${u};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XSe=({inputs:r,backend:t,attrs:n})=>{const{x:s,mean:i,variance:a,offset:o,scale:u}=r;oe(i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),oe(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),oe(u==null||i.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const c=[s,i,a];let h=null;o!=null&&(h=o.shape,c.push(o));let d=null;u!=null&&(d=u.shape,c.push(u));const p=Be().getBool("WEBGL_PACK_NORMALIZATION")?new KSe(s.shape,i.shape,a.shape,h,d,l):new qSe(s.shape,i.shape,a.shape,h,d,l);return t.runWebGLProgram(p,c,c[0].dtype)},YSe={kernelName:dD,backendName:"webgl",kernelFunc:XSe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZSe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const n=on(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=JSe(this.rank);let i;const a=t.map((o,u)=>`sourceLoc.${Ok[u]} = start[${u}] + coords.${Ok[u]};`);i=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${i}
        setOutput(getSource(${s}));
      }
    `}}const Ok=["x","y","z","w","u","v"];function JSe(r){if(r===1)return"sourceLoc";if(r<=6)return Ok.slice(0,r).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QSe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=on(this.rank),s=ri("coords",this.rank),i=ri("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${i.slice(-2).join()})`,o=`getChannel(getSource(${i.join()}), ${a})`,u=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
        ++${i[this.rank-1]};
        result.y = ${o};
        --${i[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {
        ++${i[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
          ++${i[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${n}(${t.map((h,d)=>`start[${d}]`).join()});`:t.map((h,d)=>`${i[d]} = ${s[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${u}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eCe(r,t,n,s){const i=s.texData.get(r.dataId),a=s.makeTensorInfo(n,r.dtype),o=s.texData.get(a.dataId);Object.assign(o,i),o.refCount=1,o.shape=n,o.dtype=r.dtype;let u=fR(t,ws(r.shape));i.slice&&(u+=i.slice.flatOffset),o.slice={flatOffset:u,origDataId:i.slice&&i.slice.origDataId||r.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),a}function Cg(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{begin:a,size:o}=s,[u,l]=w9(i,a,o);if(h9(i,u,l),lt(l)===0)return n.makeTensorInfo(l,i.dtype,[]);if(n.shouldExecuteOnCPU([i])||i.dtype==="string"){const d=n.texData.get(i.dataId),p=jwe(d.values,u,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,p)}const{isPacked:c}=n.texData.get(i.dataId),h=pR(i.shape,u,l);if(c||!h){const d=Be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new QSe(l):new ZSe(l),p=[u];return n.runWebGLProgram(d,[i],i.dtype,p)}return n.uploadToGPU(i.dataId),eCe(i,u,l,n)}const tCe={kernelName:wF,backendName:"webgl",kernelFunc:Cg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rCe=r=>{const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{blockShape:a,crops:o}=s;oe(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const u=a.reduce((x,w)=>x*w),l=gR(i.shape,a,u),c=yR(l.length,a.length),h=bR(i.shape,a,u),d=F9(o,a.length),p=$9(h,o,a.length),f=[],m=mt({inputs:{x:i},backend:n,attrs:{shape:l}}),g=oi({inputs:{x:m},backend:n,attrs:{perm:c}}),y=mt({inputs:{x:g},backend:n,attrs:{shape:h}}),b=Cg({inputs:{x:y},backend:n,attrs:{begin:d,size:p}});return f.push(m),f.push(g),f.push(y),f.forEach(x=>n.disposeIntermediateTensorInfo(x)),b},nCe={kernelName:IA,backendName:"webgl",kernelFunc:rCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sCe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,weights:a}=t,{size:o}=s,u=n.readSync(i.dataId),l=n.readSync(a.dataId),c=_7(u,l,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,c)}const iCe={kernelName:kA,backendName:"webgl",kernelFunc:sCe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aCe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,oCe=`
  return float(int(a.r) & int(b.r));
`;function uCe(r){const{inputs:t,backend:n}=r,{a:s,b:i}=t,a=Be().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Be().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([s,i])||o===1){const l=n.texData.get(s.dataId).values,c=n.texData.get(i.dataId).values,[h,d]=gwe(s.shape,i.shape,l,c,s.dtype),p=n.makeTensorInfo(d,s.dtype),f=n.texData.get(p.dataId);return f.values=h,p}let u;return a?u=new wg(aCe,s.shape,i.shape,!1):u=new ld(oCe,s.shape,i.shape),n.runWebGLProgram(u,[s,i],s.dtype)}const lCe={kernelName:NA,backendName:"webgl",kernelFunc:uCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cCe(r){const{inputs:t,backend:n}=r,{s0:s,s1:i}=t,a=n.readSync(s.dataId),o=n.readSync(i.dataId),u=Fr(Array.from(a),Array.from(o));return n.makeTensorInfo([u.length],"int32",Int32Array.from(u))}const hCe={kernelName:TA,backendName:"webgl",kernelFunc:cCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dCe="return float(a != b);",P7=Rs({opSnippet:dCe,cpuKernelImpl:Lwe,dtype:"bool"}),pCe={kernelName:HD,backendName:"webgl",kernelFunc:P7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fx(r){const{inputs:t,backend:n}=r,{input:s}=t,i=n.texData.get(s.dataId);return ta({inputs:{x:i.complexTensorInfos.real},backend:n})}const fCe={kernelName:aF,backendName:"webgl",kernelFunc:Fx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mCe="return float(int(x));";function gCe(r,t){const n=new tu(r.shape,mCe),s=t.runWebGLProgram(n,[r],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mk(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{dtype:a}=s;if(a==="complex64"){if(i.dtype==="complex64")return ta({inputs:{x:i},backend:n});const o=dc(i.shape),u=Mk({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),l=Rc({inputs:{real:u,imag:o},backend:n});return o.dispose(),n.disposeIntermediateTensorInfo(u),l}if(i.dtype==="complex64"){const o=Fx({inputs:{input:i},backend:n}),u=Mk({inputs:{x:o},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(o),u}if(!Y8(i.dtype,a)){const o=ta({inputs:{x:i},backend:n});return{dataId:o.dataId,shape:o.shape,dtype:a}}if(n.shouldExecuteOnCPU([i])){const o=n.texData.get(i.dataId).values,[u,l,c]=ywe(o,i.shape,i.dtype,a);return n.makeTensorInfo(u,l,c)}if(a==="int32")return gCe(i,n);if(a==="bool"){const o=n.makeTensorInfo([],"bool",ul("bool",1)),l=P7({inputs:{a:i,b:o},backend:n});return n.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`)}const yCe={kernelName:YS,backendName:"webgl",kernelFunc:Mk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m5="return ceil(x);",bCe=$r({opSnippet:m5,packedOpSnippet:m5,cpuKernelImpl:bwe}),xCe={kernelName:AA,backendName:"webgl",kernelFunc:bCe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vCe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wCe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SCe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{clipValueMin:a,clipValueMax:o}=s;let u;Be().getBool("WEBGL_PACK_CLIP")?u=new wCe(i.shape):u=new vCe(i.shape);const l=[[a],[o]];return n.runWebGLProgram(u,[i],i.dtype,l)}const CCe={kernelName:DA,backendName:"webgl",kernelFunc:SCe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Ce{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g5(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}function ECe(r){const{inputs:t,backend:n}=r,{x:s}=t,i=n.texData.get(s.dataId),a=new _Ce(s.shape),o=[g5(s,i.complexTensorInfos.real),g5(s,i.complexTensorInfos.imag)];return n.runWebGLProgram(a,o,o[0].dtype)}const ICe={kernelName:$A,backendName:"webgl",kernelFunc:ECe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kCe{constructor(t){this.outputShape=[],this.outputShape=ud(t,1),this.variableNames=t.map((o,u)=>`T${u}`);const n=new Array(t.length-1);n[0]=t[0][1];for(let o=1;o<n.length;o++)n[o]=n[o-1]+t[o][1];const s=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<n.length;o++){const u=n[o-1];s.push(`else if (yC < ${n[o]}) setOutput(getT${o}(yR, yC-${u}));`)}const i=n.length,a=n[n.length-1];s.push(`else setOutput(getT${i}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NCe{constructor(t,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ud(t,n);const s=this.outputShape,i=s.length,a=on(i),o=ri("coords",i),u=["x","y","z","w","u","v"].slice(0,i);this.variableNames=t.map((g,y)=>`T${y}`);const l=new Array(t.length-1);l[0]=t[0][n];for(let g=1;g<l.length;g++)l[g]=l[g-1]+t[g][n];const c=u[n],h=u.slice(-2),d=u.join();let p=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${h.join()}));
        }`;for(let g=1;g<l.length;g++){const y=l[g-1];p+=`
        if (${c} < ${l[g]}  && ${c} >= ${l[g-1]}) {
          return getChannel(
            getT${g}(${N1(u,c,y)}),
            vec2(${N1(h,c,y)}));
        }`}const f=l.length,m=l[l.length-1];p+=`
        return getChannel(
          getT${f}(${N1(u,c,m)}),
          vec2(${N1(h,c,m)}));`,this.userCode=`
      float getValue(${u.map(g=>"int "+g)}) {
        ${p}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[i-1]} = ${o[i-1]} + 1;
        if (${o[i-1]} < ${s[i-1]}) {
          result.g = getValue(${o});
        }

        ${o[i-2]} = ${o[i-2]} + 1;
        if (${o[i-2]} < ${s[i-2]}) {
          result.a = getValue(${o});
        }

        ${o[i-1]} = ${o[i-1]} - 1;
        if (${o[i-2]} < ${s[i-2]} &&
            ${o[i-1]} < ${s[i-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function N1(r,t,n){const s=r.indexOf(t);return r.map((a,o)=>o===s?`${a} - ${n}`:a).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wC(r){const{inputs:t,backend:n}=r,{input:s}=t,i=n.texData.get(s.dataId);return ta({inputs:{x:i.complexTensorInfos.imag},backend:n})}const TCe={kernelName:bD,backendName:"webgl",kernelFunc:wC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ty(r,t,n){const s=r[0].dtype;if(s==="complex64"){const f=r.map(x=>Fx({inputs:{input:x},backend:n})),m=r.map(x=>wC({inputs:{input:x},backend:n})),g=Ty(f,t,n),y=Ty(m,t,n),b=Rc({inputs:{real:g,imag:y},backend:n});return f.forEach(x=>n.disposeIntermediateTensorInfo(x)),m.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),b}let i=n.shouldExecuteOnCPU(r);if(s==="string"&&(i=!0),i){const f=r.map(v=>{const E=[-1,lt(v.shape.slice(t))];return mt({inputs:{x:v},backend:n,attrs:{shape:E}})}),m=f.map(v=>({vals:n.readSync(v.dataId),shape:v.shape})),g=ud(f.map(v=>v.shape),1),y=f[0].shape[0]===1,b=xwe(m,g,s,y),x=ud(r.map(v=>v.shape),t),w=n.makeTensorInfo(x,s,b);return f.forEach(v=>n.disposeIntermediateTensorInfo(v)),w}const a=r.filter(f=>lt(f.shape)>0),o=Be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){const f=o?new tu(r[0].shape,Ml):new Kl(r[0].shape,Ml);return n.runWebGLProgram(f,r,s)}const u=Be().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>u){const f=[];for(let g=0;g<a.length;g+=u){const y=a.slice(g,g+u);f.push(Ty(y,t,n))}const m=Ty(f,t,n);for(const g of f)n.disposeIntermediateTensorInfo(g);return m}if(o){const f=new NCe(a.map(m=>m.shape),t);return n.runWebGLProgram(f,a,s)}const{tensors2D:l,outShape:c}=ACe(a,t,n),h=new kCe(l.map(f=>f.shape)),d=n.runWebGLProgram(h,l,s);l.forEach(f=>n.disposeIntermediateTensorInfo(f));const p=mt({inputs:{x:d},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(d),p}function ACe(r,t,n){const s=ud(r.map(a=>a.shape),t);return{tensors2D:r.map(a=>mt({inputs:{x:a},attrs:{shape:[-1,lt(a.shape.slice(t))]},backend:n})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B7(r){const{inputs:t,backend:n,attrs:s}=r,{axis:i}=s,a=ls(i,t[0].shape)[0],o=t.map(c=>c.shape);I9(o,a);const u=ud(t.map(c=>c.shape),a);if(lt(u)===0)return n.makeTensorInfo(u,t[0].dtype,[]);const l=t.filter(c=>lt(c.shape)>0);return l.length===1?ta({inputs:{x:l[0]},backend:n}):Ty(l,a,n)}const DCe={kernelName:RA,backendName:"webgl",kernelFunc:B7};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V7{constructor(t,n=!1,s=null,i=!1,a=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,u=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,p=t.filterHeight,f=t.filterWidth,m=Math.floor(t.inChannels/4)*4,g=t.inChannels%4,y=t.dataFormat==="channelsLast",b=y?1:2,x=y?2:3,w=y?3:1;let v="",S="";s&&(i?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:v=`
          float activation(float x) {
            ${s}
          }
        `,S="result = activation(result);");const E=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${h};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${m}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${m}) *
                    getW(wR, wC, ${m}, d2);
              } else {
                dotProd +=
                    getX(batch, ${m}, xR, xC) *
                    getW(wR, wC, ${m}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2),
                getW(wR, wC, ${m} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1),
                  getX(batch, xR, xC, ${m} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC),
                  getX(batch, ${m} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${E}
        ${S}
        setOutput(result);
      }
    `}}class FCe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const n=t.padInfo.front,s=t.padInfo.top,i=t.padInfo.left,a=t.strideDepth,o=t.strideHeight,u=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,d=t.filterDepth,p=t.filterHeight,f=t.filterWidth,m=Math.floor(t.inChannels/4)*4,g=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${o}, ${u});
      const ivec3 pads = ivec3(${n}, ${s}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${h};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${m}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${m}) *
                  getW(wF, wR, wC, ${m}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1),
                  getX(batch, xF, xR, xC, ${m} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2),
                  getW(wF, wR, wC, ${m} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z7{constructor(t,n=!1,s=null,i=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Hs(this.outputShape.length);const o=t.padInfo.left,u=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,h=t.filterWidth,d=h;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<h;y++)p+=`
           vec4 xTexelC${y*2};
           int xTexelC${y*2}Ready;
           vec4 xTexelC${y*2+1};
           int xTexelC${y*2+1}Ready;
           vec4 xC${y};`;p+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let y=0;y<h;y++)p+=`
           xTexelC${y*2} = vec4(0.0);
           xTexelC${y*2}Ready = 0;
           xTexelC${y*2+1} = vec4(0.0);
           xTexelC${y*2+1}Ready = 0;
           xC${y} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let y=0;y<(d+1)/2;y++){const b=y*2;if(p+=`
           xC = xCCorner + ${b*l};
           `,u===1){if(b<h&&(o%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,l===1&&b>0?p+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<h)){const x=o%2===0?qS(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${x};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,l>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:p+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):x===1?p+=`
                     xC${b+1} = xTexelC${b};
                     `:p+=`
                     xCOffset = xC + ${x};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<h&&(o%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<h&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<h&&(p+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<h&&(p+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<h&&(p+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let f="",m="";s&&(i?f=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:a?f=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:f=`vec4 activation(vec4 x) {
           ${s}
         }`,m="result = activation(result);");const g=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${m}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Ce{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Hs(this.outputShape.length);const{dataFormat:s}=n,i=hi(),a=s==="channelsLast",o=a?1:2,u=a?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let h=0;h<=1;h++)for(let d=0;d<=1;d++)c+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${h};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${u}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${h*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${h*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${i.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T2(r,t){const n=r.length;return n>=3?t?[...r.slice(0,-3),r[n-3]*r[n-2],r[n-1]]:[...r.slice(0,-3),r[n-3],r[n-2]*r[n-1]]:!t&&n===1&&r[0]>1?[r[0],1]:null}function U7({x:r,filter:t,convInfo:n,backend:s,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const l=r.shape,c=s.texData.get(r.dataId),h=n.inChannels,d=l[0]*l[1]*l[2],p=n.outChannels,f=n.dataFormat==="channelsLast",m=!1,g=!1;let y;const b=[];if(a!=null){const v=T2(a.shape,f);v!=null&&(a=mt({inputs:{x:a},backend:s,attrs:{shape:v}}),b.push(a))}if(i!=null){const v=T2(i.shape,f);v!=null&&(i=mt({inputs:{x:i},backend:s,attrs:{shape:v}}),b.push(i))}if(!((d===1||p===1)&&h>R7)&&c.isPacked&&f&&c.texture!=null&&l[2]%2!==0&&En(c.shape.slice(-3),l.slice(-3))){const v=l[0]*l[1]*(l[2]+1),S={dataId:r.dataId,shape:[1,v,n.inChannels],dtype:r.dtype},E=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,oe(I2(c.shape,S.shape),()=>`packed reshape ${c.shape} to ${S.shape} isn't free`);const C=mt({inputs:{x:t},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});b.push(C);const I=N2({a:S,b:C,backend:s,transposeA:m,transposeB:g,bias:i,activation:u,preluActivationWeights:a,leakyreluAlpha:o}),_=s.texData.get(I.dataId);oe(_.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=E,_.shape=n.outShape,y=ta({inputs:{x:I},backend:s}),y.shape=n.outShape,b.push(I)}else{const v=n.outHeight*n.outWidth,S=mt({inputs:{x:r},backend:s,attrs:{shape:f?[n.batchSize,v,n.inChannels]:[n.batchSize,n.inChannels,v]}}),E=mt({inputs:{x:t},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}}),C=N2({a:f?S:E,b:f?E:S,transposeA:!f,transposeB:g,backend:s,bias:i,activation:u,preluActivationWeights:a,leakyreluAlpha:o});y=mt({inputs:{x:C},backend:s,attrs:{shape:n.outShape}}),b.push(S),b.push(E),b.push(C)}for(const v of b)s.disposeIntermediateTensorInfo(v);return y}function W7({x:r,filter:t,convInfo:n,backend:s,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const{filterWidth:l,filterHeight:c,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=n,m=f==="channelsLast",g=l*c*h,y=p*d,b=[n.batchSize,g,y],x=!0,w=!1,v=[];if(a!=null){const Z=T2(a.shape,m);Z!=null&&(a=mt({inputs:{x:a},backend:s,attrs:{shape:Z}}),v.push(a))}if(i!=null){const Z=T2(i.shape,m);Z!=null&&(i=mt({inputs:{x:i},backend:s,attrs:{shape:Z}}),v.push(i))}const S=mt({inputs:{x:t},backend:s,attrs:{shape:[1,g,lt(t.shape)/g]}});v.push(S);const E=new $Ce(b,n),C=[r.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],I=s.runWebGLProgram(E,[r],"float32",C),_=mt({inputs:{x:I},backend:s,attrs:{shape:b}});v.push(I),v.push(_);const A=i!=null,k=a!=null,N=u==="leakyrelu",D=u?zb(u,!0):null,F=new $7(m?_.shape:S.shape,m?S.shape:_.shape,m?[n.batchSize,y,n.outChannels]:[n.batchSize,n.outChannels,y],x,w,A,D,k,N),P=m?[_,S]:[S,_];if(i&&P.push(i),k&&P.push(a),N){const Z=s.makeTensorInfo([],"float32",Ld(o,"float32"));P.push(Z),v.push(Z)}const G=s.runWebGLProgram(F,P,"float32"),Y=mt({inputs:{x:G},backend:s,attrs:{shape:n.outShape}});v.push(G);for(const Z of v)s.disposeIntermediateTensorInfo(Z);return Y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RCe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dataFormat:l,dilations:c,dimRoundingMode:h}=s,d=dg(l),p=Ca(i.shape,a.shape,o,c,u,h,!1,d);let f;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))f=U7({x:i,filter:a,convInfo:p,backend:n});else if(p.strideWidth<=2&&d==="channelsLast"&&Be().getBool("WEBGL_EXP_CONV")){const g=new z7(p),y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];f=n.runWebGLProgram(g,[i,a],"float32",y)}else if(Be().getBool("WEBGL_CONV_IM2COL"))f=W7({x:i,filter:a,convInfo:p,backend:n});else{const g=new V7(p);f=n.runWebGLProgram(g,[i,a],"float32")}const m=mt({inputs:{x:f},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(f),m}const OCe={kernelName:OA,backendName:"webgl",kernelFunc:RCe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MCe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,s=t.strideWidth,i=t.padInfo.top,a=t.padInfo.left,o=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${i};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${a};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class LCe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,s=t.filterWidth,i=t.strideHeight,a=t.strideWidth,o=t.dataFormat==="channelsLast",u=n-1-t.padInfo.top,l=s-1-t.padInfo.left,c=o?1:2,h=o?2:3,d=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${u}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${h}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class PCe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideDepth,s=t.strideHeight,i=t.strideWidth,a=t.padInfo.front,o=t.padInfo.top,u=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${a};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${u};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class BCe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterDepth,s=t.filterHeight,i=t.filterWidth,a=t.strideDepth,o=t.strideHeight,u=t.strideWidth,l=n-1-t.padInfo.front,c=s-1-t.padInfo.top,h=i-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${u}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VCe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,dy:a}=t,{strides:o,pad:u,dataFormat:l,dimRoundingMode:c,filterShape:h}=s,d=dg(l),p=Ca(i.shape,h,o,1,u,c,!1,d),f=new MCe(p);return n.runWebGLProgram(f,[i,a],"float32")}const zCe={kernelName:MA,backendName:"webgl",kernelFunc:VCe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UCe{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=Hs(this.outputShape.length);const n=t.filterHeight,s=t.filterWidth,i=n-1-t.padInfo.top,a=s-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WCe(r){const{inputs:t,backend:n,attrs:s}=r,{dy:i,filter:a}=t,{inputShape:o,strides:u,pad:l,dataFormat:c,dimRoundingMode:h}=s,d=dg(c),p=Ca(o,a.shape,u,1,l,h,!1,d);if(Be().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const f=[[p.strideHeight,p.strideWidth]],m=new UCe(p);return n.runWebGLProgram(m,[i,a],"float32",f)}else{const f=new LCe(p);return n.runWebGLProgram(f,[i,a],"float32")}}const GCe={kernelName:LA,backendName:"webgl",kernelFunc:WCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HCe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dilations:l}=s,c=wx(i.shape,a.shape,o,l,u),h=new FCe(c);return n.runWebGLProgram(h,[i,a],"float32")}const jCe={kernelName:PA,backendName:"webgl",kernelFunc:HCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qCe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,dy:a}=t,{strides:o,pad:u,filterShape:l}=s,c=wx(i.shape,l,o,1,u),h=new PCe(c);return n.runWebGLProgram(h,[i,a],"float32")}const KCe={kernelName:iG,backendName:"webgl",kernelFunc:qCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XCe(r){const{inputs:t,backend:n,attrs:s}=r,{dy:i,filter:a}=t,{pad:o,strides:u,inputShape:l}=s,c=wx(l,a.shape,u,1,o),h=new BCe(c);return n.runWebGLProgram(h,[i,a],"float32")}const YCe={kernelName:BA,backendName:"webgl",kernelFunc:XCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZCe=Sg+`
  return cos(x);
`,JCe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Ud}
  return result;
`,QCe=$r({opSnippet:ZCe,packedOpSnippet:JCe}),e_e={kernelName:VA,backendName:"webgl",kernelFunc:QCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t_e=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,r_e=$r({opSnippet:t_e}),n_e={kernelName:zA,backendName:"webgl",kernelFunc:r_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s_e{constructor(t,n,s,i,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,u,l,c]=t,[h]=n,[d,p]=s;this.outputShape=[h,d,p,c];const f=i==="bilinear"?1:0,[m,g]=[`${u-1}.0`,`${l-1}.0`],[y,b,x]=d>1?[`${(u-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[w,v,S]=p>1?[`${(l-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${v};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${m} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${S};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i_e=r=>{const{inputs:t,backend:n,attrs:s}=r,{image:i,boxes:a,boxInd:o}=t,{cropSize:u,method:l,extrapolationValue:c}=s,h=new s_e(i.shape,a.shape,u,l,c);return n.runWebGLProgram(h,[i,a,o],"float32")},a_e={kernelName:GA,backendName:"webgl",kernelFunc:i_e};var Wb;(function(r){r.Prod="*",r.Sum="+"})(Wb||(Wb={}));class y5{constructor(t,n,s,i){this.op=t,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,o=this.op===Wb.Prod?"1.0":"0.0",u=s?o:`getX(${b5(a,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",h="";s?(c=i?`end != ${l-1}`:"end != 0",h=i?"end + 1":"end - 1"):(c=i?`end + pow2 < ${l}`:"end >= pow2",h=i?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${on(a)} coords = getOutputCoords();
        int end = ${x5(a,"coords",this.op)};
        float val = ${u};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${h};
          ${x5(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${b5(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function b5(r,t,n){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${r} is not yet supported`)}function x5(r,t,n){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${r} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G7(r,t,n,s,i,a){const o=t.shape.length,u=ro([s],o);let l=t;u!=null&&(l=oi({inputs:{x:t},backend:n,attrs:{perm:u}}));const c=no(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const h=l.shape[c];let d=ta({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(h))-1;p++){const f=new y5(r,l.shape,!1,a),m=[[p]],g=d;d=n.runWebGLProgram(f,[d],d.dtype,m),n.disposeIntermediateTensorInfo(g)}if(i){const p=new y5(r,l.shape,i,a),f=d;d=n.runWebGLProgram(p,[d],d.dtype),n.disposeIntermediateTensorInfo(f)}if(u!=null){const p=v$(u),f=oi({inputs:{x:d},backend:n,attrs:{perm:p}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),f}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o_e(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,exclusive:o,reverse:u}=s;return G7(Wb.Prod,i,n,a,o,u)}const u_e={kernelName:UA,backendName:"webgl",kernelFunc:o_e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l_e(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,exclusive:o,reverse:u}=s;return G7(Wb.Sum,i,n,a,o,u)}const c_e={kernelName:WA,backendName:"webgl",kernelFunc:l_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h_e(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,weights:a}=t,{size:o,binaryOutput:u}=s;if(i.shape.length===1){const l=n.readSync(i.dataId),c=n.readSync(a.dataId),h=_7(l,c,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,h)}else if(i.shape.length===2){const l=n.bufferSync(i),c=n.bufferSync(a),h=mwe(l,c,o,u);return n.makeTensorInfo(h.shape,a.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const d_e={kernelName:HA,backendName:"webgl",kernelFunc:h_e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p_e{constructor(t,n,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=n,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f_e(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{blockSize:a,dataFormat:o}=s,u=i.shape[0],l=o==="NHWC"?i.shape[1]:i.shape[2],c=o==="NHWC"?i.shape[2]:i.shape[3],h=o==="NHWC"?i.shape[3]:i.shape[1],d=l*a,p=c*a,f=h/(a*a),m=o==="NHWC"?[u,d,p,f]:[u,f,d,p],g=new p_e(m,a,o);return n.runWebGLProgram(g,[i],i.dtype)}const m_e={kernelName:jA,backendName:"webgl",kernelFunc:f_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H7{constructor(t,n=!1,s=null,i=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Hs(this.outputShape.length);const o=t.filterHeight,u=t.filterWidth,l=t.outChannels/t.inChannels;let c="",h="";s&&(i?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,h="result = activation(result);");const d=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${u}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j7{constructor(t,n=!1,s=null,i=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Hs(this.outputShape.length);const o=t.outChannels/t.inChannels,u=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=d;let f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<d;b++)f+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;f+=`
    for (int r = 0; r < ${h}; r++) {
      `;for(let b=0;b<d;b++)f+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(p+1)/2;b++){const x=b*2;if(f+=`
          xC = xCCorner + ${x*c};
          `,l===1){if(x<d&&(u%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,c===1&&x>0?f+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<d)){const w=u%2===0?qS(c):c;c%2===0&&u%2===1||c%2!==0&&u%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,c>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                    } else {
                     xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                    }
                    `:f+=`
                    xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                    `):w===1?f+=`
                    xC${x+1} = xTexelC${x};
                    `:f+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<d&&(u%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<d&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<d&&(f+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<d&&(f+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<d&&(f+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let m="",g="";s&&(i?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:m=`vec4 activation(vec4 x) {
          ${s}
        }`,g="result = activation(result);");const y=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${m}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g_e(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dilations:l,dimRoundingMode:c}=s;let h=l;h==null&&(h=[1,1]),oe(oa(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=Ca(i.shape,a.shape,o,h,u,c,!0);let p;Be().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?p=new j7(d):p=new H7(d);const f=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(p,[i,a],"float32",f)}const y_e={kernelName:qA,backendName:"webgl",kernelFunc:g_e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b_e{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,s=t.strideWidth,i=t.padInfo.top,a=t.padInfo.left,o=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${i};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${a};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class x_e{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,s=t.filterWidth,i=t.strideHeight,a=t.strideWidth,o=n-1-t.padInfo.top,u=s-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v_e(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,dy:a}=t,{strides:o,dilations:u,pad:l,dimRoundingMode:c,filterShape:h}=s,d=Ca(i.shape,h,o,u,l,c,!0),p=new b_e(d);return n.runWebGLProgram(p,[i,a],"float32")}const w_e={kernelName:KA,backendName:"webgl",kernelFunc:v_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S_e(r){const{inputs:t,backend:n,attrs:s}=r,{dy:i,filter:a}=t,{strides:o,dilations:u,pad:l,dimRoundingMode:c,inputShape:h}=s,d=Ca(h,a.shape,o,u,l,c,!0),p=new x_e(d);return n.runWebGLProgram(p,[i,a],"float32")}const C_e={kernelName:XA,backendName:"webgl",kernelFunc:S_e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class __e{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E_e(r){const{inputs:t,backend:n}=r,{x:s}=t,i=[...s.shape,...s.shape],a=lt(s.shape),o=mt({inputs:{x:s},backend:n,attrs:{shape:[a]}}),u=new __e(a),l=n.runWebGLProgram(u,[o],o.dtype),c=mt({inputs:{x:l},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}const I_e={kernelName:YA,backendName:"webgl",kernelFunc:E_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k_e{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:n,inWidth:s,padInfo:i,strideHeight:a,strideWidth:o,filterHeight:u,filterWidth:l,dilationHeight:c,dilationWidth:h}=t,{top:d,left:p}=i;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${o});
      const ivec2 pads = ivec2(${d}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${u}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${h};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N_e(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dilations:l}=s,c=ZG(i.shape,a.shape,o,u,"NHWC",l);let h;const d=new k_e(c);h=n.runWebGLProgram(d,[i,a],"float32");const p=mt({inputs:{x:h},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(h),p}const T_e={kernelName:ZA,backendName:"webgl",kernelFunc:N_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A_e(r){const{inputs:t,backend:n,attrs:s}=r,{equation:i}=s,a=t,{allDims:o,summedDims:u,idDims:l}=U9(i,a.length);G9(o.length,l,a);const{path:c,steps:h}=H9(u,l),d=h.length;let p=null,f=o.length;const m=[];for(let g=0;g<d;++g){for(const y of h[g]){const{permutationIndices:b,expandDims:x}=W9(f,l[y]);let w;j9(b)?w=a[y]:(w=oi({inputs:{x:a[y]},backend:n,attrs:{perm:b}}),m.push(w));const v=w.shape.slice();for(let S=0;S<x.length;++S)v.splice(x[S],0,1);En(w.shape,v)||(w=mt({inputs:{x:w},backend:n,attrs:{shape:v}}),m.push(w)),p===null?p=w:(p=ER({inputs:{a:w,b:p},backend:n}),m.push(p))}g<d-1&&(c[g]>=0&&(p=vC({inputs:{x:p},backend:n,attrs:{axis:c[g]-(o.length-f),keepDims:!1}}),m.push(p)),f--)}for(const g of m)g!==p&&n.disposeIntermediateTensorInfo(g);return p}const D_e={kernelName:eD,backendName:"webgl",kernelFunc:A_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F_e="return (x >= 0.0) ? x : (exp(x) - 1.0);",$_e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,R_e=$r({opSnippet:F_e,packedOpSnippet:$_e}),O_e={kernelName:tD,backendName:"webgl",kernelFunc:R_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M_e="return (b >= 0.0) ? a : a * (b + 1.0);",L_e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,P_e=r=>{const{inputs:t,backend:n}=r,{dy:s,y:i}=t,a=Be().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wg(L_e,s.shape,i.shape):new ld(M_e,s.shape,i.shape);return n.runWebGLProgram(a,[s,i],s.dtype)},B_e={kernelName:aG,backendName:"webgl",kernelFunc:P_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V_e=`
  return vec4(equal(a, b));
`,z_e="return float(a == b);",U_e=Rs({opSnippet:z_e,packedOpSnippet:V_e,dtype:"bool",cpuKernelImpl:vwe}),W_e={kernelName:nD,backendName:"webgl",kernelFunc:U_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G_e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${M9};
  float a1 = ${L9};
  float a2 = ${P9};
  float a3 = ${B9};
  float a4 = ${V9};
  float a5 = ${z9};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,H_e=$r({opSnippet:G_e}),j_e={kernelName:rD,backendName:"webgl",kernelFunc:H_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q_e=Sg+`
  return exp(x);
`,K_e=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,q7=$r({opSnippet:q_e,packedOpSnippet:K_e,cpuKernelImpl:wwe,dtype:"float32"}),X_e={kernelName:sD,backendName:"webgl",kernelFunc:q7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lk(r){const{inputs:t,attrs:n,backend:s}=r,{dim:i}=n,{input:a}=t,o=a.shape.length,u=a.shape.slice();let l=i;return i<0&&(oe(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),u.splice(l,0,1),mt({inputs:{x:a},backend:s,attrs:{shape:u}})}const Y_e={kernelName:iD,backendName:"webgl",kernelFunc:Lk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v5="return exp(x) - 1.0;",Z_e=$r({opSnippet:v5,packedOpSnippet:v5,cpuKernelImpl:Swe}),J_e={kernelName:aD,backendName:"webgl",kernelFunc:Z_e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w5{constructor(t,n,s){this.variableNames=["real","imag"];const i=n[1];this.outputShape=n;const a=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${i}.0`:"1.0";let u;if(t==="real")u="return real * expR - imag * expI;";else if(t==="imag")u="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${u}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K7(r,t,n){const s=n.texData.get(r.dataId),i=lt(r.shape),a=r.shape[r.shape.length-1],o=i/a,u=mt({inputs:{x:r},backend:n,attrs:{shape:[o,a]}}),l=u.shape,c=new w5("real",l,t),h=new w5("imag",l,t),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],p=n.runWebGLProgram(c,d,"float32"),f=n.runWebGLProgram(h,d,"float32"),m=Rc({inputs:{real:p,imag:f},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f);const g=mt({inputs:{x:m},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(m),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q_e(r){const{inputs:t,backend:n}=r,{input:s}=t;return K7(s,!1,n)}const eEe={kernelName:oD,backendName:"webgl",kernelFunc:Q_e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tEe{constructor(t,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $x(r){const{backend:t,attrs:n}=r,{shape:s,value:i}=n;let{dtype:a}=n;if(a=a||hg(i),a==="string"){const o=rs(a,lt(s));return o.fill(i),t.makeTensorInfo(s,a,o)}else{const o=new tEe(s,i),u=[[i]];return t.runWebGLProgram(o,[],a,u)}}const rEe={kernelName:uD,backendName:"webgl",kernelFunc:$x};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nEe{constructor(t){this.variableNames=["Image"],this.outputShape=[];const n=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sEe={kernelName:lD,backendName:"webgl",kernelFunc:({inputs:r,backend:t})=>{const{image:n}=r,s=t,i=new nEe(n.shape);return s.runWebGLProgram(i,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S5="return floor(x);",iEe=$r({opSnippet:S5,packedOpSnippet:S5,cpuKernelImpl:Cwe}),aEe={kernelName:cD,backendName:"webgl",kernelFunc:iEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oEe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,uEe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,lEe=Rs({opSnippet:oEe,packedOpSnippet:uEe,dtype:"int32"}),cEe={kernelName:hD,backendName:"webgl",kernelFunc:lEe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hEe{constructor(t){this.variableNames=["A"];const n=hi(),[s,i]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${s}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dEe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=hi(),[s,i]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${s}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pEe={kernelName:b2,backendName:"webgl",kernelFunc:fEe};let Lf,QE=Be().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function fEe(r){const{inputs:t,backend:n,attrs:s}=r;let{pixels:i}=t;const{numChannels:a}=s,o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,u=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,c]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],h=[c,l],d=[c,l,a];if(u||o){const g=Be().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Lf==null||g!==QE)&&(QE=g,Lf=document.createElement("canvas").getContext("2d",{willReadFrequently:QE})),Lf.canvas.width=l,Lf.canvas.height=c,Lf.drawImage(i,0,0,l,c),i=Lf.canvas}const p=n.makeTensorInfo(h,"int32");n.texData.get(p.dataId).usage=da.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),i);const f=Be().getBool("WEBGL_PACK")?new dEe(d):new hEe(d),m=n.runWebGLProgram(f,[p],"int32");return n.disposeData(p.dataId),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mEe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s,g=dg(h),y=Ca(i.shape,a.shape,l,d,c,p,!1,g);let b;const x=[],w=o!=null,v=u!=null,S=f==="leakyrelu",E=()=>{const I=[i,a],_=(A,k)=>{if(k==="NCHW"&&A.shape.length===1&&A.shape[0]!==1){const N=mt({inputs:{x:A},backend:n,attrs:{shape:[A.shape[0],1,1]}});return x.push(N),N}return A};if(w&&I.push(_(o,h)),v&&I.push(_(u,h)),S){const A=n.makeTensorInfo([],"float32",Ld(m,"float32"));I.push(A),x.push(A)}return I};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))b=U7({x:i,filter:a,convInfo:y,backend:n,bias:o,activation:f,preluActivationWeights:u,leakyreluAlpha:m});else if(y.strideWidth<=2&&g==="channelsLast"&&Be().getBool("WEBGL_EXP_CONV")){const I=f?zb(f,!0):null,_=new z7(y,w,I,v,S),A=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],k=E();b=n.runWebGLProgram(_,k,"float32",A)}else if(Be().getBool("WEBGL_CONV_IM2COL"))b=W7({x:i,filter:a,convInfo:y,backend:n,bias:o,activation:f,preluActivationWeights:u,leakyreluAlpha:m});else{const I=f?zb(f,!1):null,_=new V7(y,w,I,v,S),A=E();b=n.runWebGLProgram(_,A,"float32")}const C=mt({inputs:{x:b},backend:n,attrs:{shape:y.outShape}});return x.push(b),x.forEach(I=>n.disposeIntermediateTensorInfo(I)),C}const gEe={kernelName:v2,backendName:"webgl",kernelFunc:mEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yEe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,m=[];let g=h;g==null&&(g=[1,1]),oe(oa(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const y=Ca(i.shape,a.shape,l,g,c,d,!0),b=Be().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,x=p?zb(p,b):null,w=[i,a],v=o!=null,S=u!=null,E=p==="leakyrelu";if(v&&w.push(o),S&&w.push(u),E){const A=n.makeTensorInfo([],"float32",Ld(f,"float32"));w.push(A),m.push(A)}let C;b?C=new j7(y,v,x,S,E):C=new H7(y,v,x,S,E);const I=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],_=n.runWebGLProgram(C,w,"float32",I);return m.forEach(A=>n.disposeIntermediateTensorInfo(A)),_}const bEe={kernelName:w2,backendName:"webgl",kernelFunc:yEe};class xEe{constructor(t,n,s,i){this.sliceDim=t,this.strides=n,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=s;const a=on(s.length);let o=`
    int index;`;for(let u=0;u<this.sliceDim;u++)o+=`
          index = round(getIndices(coords[0], ${u}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[u]};
          flattenIndex += index * ${this.strides[u]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vEe(r){const{inputs:t,backend:n}=r,{params:s,indices:i}=t,a=i.shape,o=a[a.length-1],u=lt(s.shape),[l,c,h,d]=dR(s,i),p=mt({inputs:{x:i},backend:n,attrs:{shape:[c,o]}}),f=mt({inputs:{x:s},backend:n,attrs:{shape:[lt(s.shape)/h,h]}});if(n.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const b=n.readSync(i.dataId),x=n.bufferSync(s),w=_we(b,x,s.dtype,c,o,h,d,s.shape,u);return n.makeTensorInfo(l,s.dtype,w.values)}const m=new xEe(o,d,[c,h],s.shape),g=n.runWebGLProgram(m,[f,p],f.dtype),y=mt({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),y}const wEe={kernelName:fD,backendName:"webgl",kernelFunc:vEe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SEe{constructor(t,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const s=on(this.rank),i=CEe(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `}}function CEe(r,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<r.length;i++)i===2?s.push("index"):s.push(`${n[i]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X7(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,indices:a}=t,{axis:o,batchDims:u}=s,l=ls(o,i.shape)[0];if(Be().get("DEBUG")){const x=n.readSync(a.dataId),w=i.shape[l];for(let v=0;v<x.length;++v){const S=x[v];oe(S<=w-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${w-1}]`)}}const c=o7(i,a,l,u),h=lt(a.shape),d=[],p=mt({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=mt({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,h/c.batchSize]}});d.push(p),d.push(f);const m=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([i,a])||i.dtype==="string"){const x=n.bufferSync(f),w=n.bufferSync(p),v=Ewe(w,x,m);return d.forEach(S=>n.disposeIntermediateTensorInfo(S)),n.makeTensorInfo(c.outputShape,v.dtype,v.values)}const g=new SEe(p.shape,m),y=n.runWebGLProgram(g,[p,f],p.dtype);d.push(y);const b=mt({inputs:{x:y},backend:n,attrs:{shape:c.outputShape}});return d.forEach(x=>n.disposeIntermediateTensorInfo(x)),b}const _Ee={kernelName:pD,backendName:"webgl",kernelFunc:X7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EEe="return float(a > b);",IEe=`
  return vec4(greaterThan(a, b));
`,kEe=Rs({opSnippet:EEe,packedOpSnippet:IEe,cpuKernelImpl:Iwe,dtype:"bool"}),NEe={kernelName:mD,backendName:"webgl",kernelFunc:kEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TEe="return float(a >= b);",AEe=`
  return vec4(greaterThanEqual(a, b));
`,DEe=Rs({opSnippet:TEe,packedOpSnippet:AEe,dtype:"bool",cpuKernelImpl:kwe}),FEe={kernelName:gD,backendName:"webgl",kernelFunc:DEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ee(r){const{inputs:t,backend:n}=r,{input:s}=t;return K7(s,!0,n)}const REe={kernelName:yD,backendName:"webgl",kernelFunc:$Ee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OEe="return float(!isnan(x) && !isinf(x));",MEe=$r({opSnippet:OEe,dtype:"bool"}),LEe={kernelName:xD,backendName:"webgl",kernelFunc:MEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PEe="return float(isinf(x));",BEe=$r({opSnippet:PEe,dtype:"bool"}),VEe={kernelName:vD,backendName:"webgl",kernelFunc:BEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zEe="return float(isnan(x));",UEe=$r({opSnippet:zEe,dtype:"bool"}),WEe={kernelName:wD,backendName:"webgl",kernelFunc:UEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GEe="return float(a < b);",HEe=`
  return vec4(lessThan(a, b));
`,jEe=Rs({opSnippet:GEe,packedOpSnippet:HEe,cpuKernelImpl:Nwe,dtype:"bool"}),qEe={kernelName:CD,backendName:"webgl",kernelFunc:jEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KEe="return float(a <= b);",XEe=`
  return vec4(lessThanEqual(a, b));
`,YEe=Rs({opSnippet:KEe,packedOpSnippet:XEe,cpuKernelImpl:Twe,dtype:"bool"}),ZEe={kernelName:_D,backendName:"webgl",kernelFunc:YEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JEe(r){const{backend:t,attrs:n}=r,{start:s,stop:i,num:a}=n,o=Awe(s,i,a);return t.makeTensorInfo([o.length],"float32",o)}const QEe={kernelName:ED,backendName:"webgl",kernelFunc:JEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eIe=Sg+`
  return x < 0.0 ? 0./0. : log(x);
`,tIe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,rIe=$r({opSnippet:eIe,packedOpSnippet:tIe,cpuKernelImpl:Dwe}),nIe={kernelName:ID,backendName:"webgl",kernelFunc:rIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sIe=Sg+`
  return log(1.0 + x);
`,iIe=$r({opSnippet:sIe}),aIe={kernelName:kD,backendName:"webgl",kernelFunc:iIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oIe="return float(a >= 1.0 && b >= 1.0);",uIe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,lIe=Rs({opSnippet:oIe,packedOpSnippet:uIe,dtype:"bool"}),cIe={kernelName:ND,backendName:"webgl",kernelFunc:lIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hIe="return float(!(x >= 1.0));",dIe=$r({opSnippet:hIe}),pIe={kernelName:TD,backendName:"webgl",kernelFunc:dIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fIe="return float(a >= 1.0 || b >= 1.0);",mIe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,gIe=Rs({opSnippet:fIe,packedOpSnippet:mIe,dtype:"bool"}),yIe={kernelName:AD,backendName:"webgl",kernelFunc:gIe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bIe{constructor(t,n,s,i,a){this.variableNames=["x"],this.outputShape=[];const o=n,u=t[3]-1;this.outputShape=t;let l;const c=`float(${s}) + float(${i}) * sum`;a===.5?l=`inversesqrt(${c})`:a===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${u}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xIe{constructor(t,n,s,i,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=n,u=t[3]-1;this.outputShape=t;let l;const c=`float(${s}) + float(${i}) * sum`;a===.5?l=`inversesqrt(${c})`:a===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${u}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vIe=r=>{const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{depthRadius:a,bias:o,alpha:u,beta:l}=s,c=Be().getBool("WEBGL_PACK_NORMALIZATION")?new xIe(i.shape,a,o,u,l):new bIe(i.shape,a,o,u,l);return n.runWebGLProgram(c,[i],i.dtype)},wIe={kernelName:DD,backendName:"webgl",kernelFunc:vIe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SIe{constructor(t,n,s,i,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=n,this.bias=s,this.alpha=i,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CIe=r=>{const{inputs:t,backend:n,attrs:s}=r,{x:i,y:a,dy:o}=t,{depthRadius:u,bias:l,alpha:c,beta:h}=s,d=new SIe(i.shape,u,l,c,h);return n.runWebGLProgram(d,[i,a,o],i.dtype)},_Ie={kernelName:oG,backendName:"webgl",kernelFunc:CIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EIe(r,t,n,s){const i=lt(t),o=lt(r.shape)/i,u=mt({inputs:{x:r},attrs:{shape:[o,i]},backend:s}),l=Wd(u,r.dtype,"max",s),c=mt({inputs:{x:l},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(u),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y7(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{reductionIndices:a,keepDims:o}=s,u=i.shape.length,l=ls(a,i.shape);let c=l;const h=ro(c,u),d=h!=null,p=n.shouldExecuteOnCPU([i]);let f=i;if(d){if(p){const w=n.texData.get(f.dataId).values,v=new Array(u);for(let C=0;C<v.length;C++)v[C]=i.shape[h[C]];const S=CR(w,i.shape,i.dtype,h,v);f=n.makeTensorInfo(v,i.dtype);const E=n.texData.get(f.dataId);E.values=S}else f=xC(i,h,n);c=no(c.length,u)}Vo("max",c,u);const[m,g]=_u(f.shape,c);let y=m;o&&(y=_a(m,l));let b;if(p){const w=n.texData.get(f.dataId).values,v=Fwe(w,lt(g),y,i.dtype);b=n.makeTensorInfo(y,i.dtype);const S=n.texData.get(b.dataId);S.values=v}else b=EIe(f,g,y,n);return d&&n.disposeIntermediateTensorInfo(f),b}const IIe={kernelName:FD,backendName:"webgl",kernelFunc:Y7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kIe=_R+`
  return max(a, b);
`,NIe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ud+`
  return result;
`,TIe=Rs({opSnippet:kIe,packedOpSnippet:NIe,cpuKernelImpl:$we}),AIe={kernelName:$D,backendName:"webgl",kernelFunc:TIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DIe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t;Ax(i,"maxPool");const{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=s,c=1;oe(oa(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=Pd(i.shape,a,o,c,u,l);if(h.filterWidth===1&&h.filterHeight===1&&En(h.inShape,h.outShape))return ta({inputs:{x:i},backend:n});const d=new Ub(h,"max",!1);return n.runWebGLProgram(d,[i],i.dtype)}const FIe={kernelName:RD,backendName:"webgl",kernelFunc:DIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ie(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{filterSize:a,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=s,h=[1,1,1],d=vx(i.shape,a,o,h,u,c,l),p=new IR(d,"max",!1);return n.runWebGLProgram(p,[i],i.dtype)}const RIe={kernelName:OD,backendName:"webgl",kernelFunc:$Ie};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OIe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,a=t.effectiveFilterHeight,o=t.effectiveFilterWidth,u=a-1-t.padInfo.top,l=o-1-t.padInfo.left,c=a*o-1;this.userCode=`
      const ivec2 pads = ivec2(${u}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class MIe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideDepth,s=t.strideHeight,i=t.strideWidth,a=t.dilationDepth,o=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=l-1-t.padInfo.front,p=c-1-t.padInfo.top,f=h-1-t.padInfo.left,m=l*c*h-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${p}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${m} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${h} +
                  wR * ${h} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LIe(r){const{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,o=a,{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=s,d=[1,1,1],p=vx(o.shape,u,l,d,c,h),f=new IR(p,"max",!0),m=n.runWebGLProgram(f,[o],o.dtype),g=new MIe(p),y=n.runWebGLProgram(g,[i,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}const PIe={kernelName:lG,backendName:"webgl",kernelFunc:LIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BIe(r){const{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a,output:o}=t,u=a;Ax([a,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=Pd(u.shape,l,c,1,h,d),f=!0,m=new Ub(p,"max",f),g=n.runWebGLProgram(m,[u],u.dtype),y=new OIe(p),b=n.runWebGLProgram(y,[i,g],u.dtype);return n.disposeIntermediateTensorInfo(g),b}const VIe={kernelName:uG,backendName:"webgl",kernelFunc:BIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zIe(r,t,n,s){let i=new Ub(n,"max",!1);const a=s.runWebGLProgram(i,[r],"float32");i=new Ub(n,"max",!0,!0,t);const o=s.runWebGLProgram(i,[r],"float32");return[a,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UIe={kernelName:MD,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:n})=>{const{x:s}=r,{filterSize:i,strides:a,pad:o,includeBatchInIndex:u}=t,l=n;oe(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];oe(oa(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=Pd(s.shape,i,a,c,o),[d,p]=zIe(s,u,h,l);return[d,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WIe(r,t,n,s){const i=lt(t),o=lt(r.shape)/i,u=mt({inputs:{x:r},attrs:{shape:[o,i]},backend:s}),l=Wd(u,"float32","mean",s),c=mt({inputs:{x:l},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(u),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GIe={kernelName:LD,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:n})=>{const{x:s}=r,{keepDims:i,axis:a}=t,o=n,u=s.shape.length,l=ls(a,s.shape);let c=l;const h=ro(c,u),d=h!=null,p=o.shouldExecuteOnCPU([s]),f=[];let m=s;if(d){if(p){const v=o.texData.get(m.dataId).values,S=new Array(u);for(let I=0;I<S.length;I++)S[I]=s.shape[h[I]];const E=CR(v,s.shape,s.dtype,h,S);m=o.makeTensorInfo(S,s.dtype);const C=o.texData.get(m.dataId);C.values=E}else m=xC(s,h,o);f.push(m),c=no(c.length,u)}Vo("sum",c,u);const[g,y]=_u(m.shape,c);let b=g;i&&(b=_a(g,l));const x=WIe(m,y,b,o);for(const w of f)o.disposeIntermediateTensorInfo(w);return x}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HIe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s,u=i.shape.length,l=ls(a,i.shape);let c=l;const h=ro(c,u);let d=i;h!=null&&(d=oi({inputs:{x:i},backend:n,attrs:{perm:h}}),c=no(c.length,i.shape.length)),Vo("min",c,u);const[p,f]=_u(d.shape,c),m=lt(f),g=mt({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=Wd(g,g.dtype,"min",n);let b;if(o){const x=_a(p,l);b=mt({inputs:{x:y},backend:n,attrs:{shape:x}})}else b=mt({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),h!=null&&n.disposeIntermediateTensorInfo(d),b}const jIe={kernelName:PD,backendName:"webgl",kernelFunc:HIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qIe=_R+`
  return min(a, b);
`,KIe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ud+`
  return result;
`,XIe=Rs({opSnippet:qIe,packedOpSnippet:KIe,cpuKernelImpl:Rwe}),YIe={kernelName:BD,backendName:"webgl",kernelFunc:XIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZIe{constructor(t,n,s){this.variableNames=["x"],this.outputShape=n.map((h,d)=>h[0]+t[d]+h[1]);const i=t.length,a=on(i),o=n.map(h=>h[0]).join(","),u=n.map((h,d)=>h[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),c=s==="reflect"?0:1;if(i===1){this.userCode=`
        int start = ${o};
        int end = ${u};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${o});
      ${a} end = ${a}(${u});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JIe{constructor(t,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((m,g)=>m[0]+t[g]+m[1]);const i=t.length,a=on(i),o=n.map(m=>m[0]).join(","),u=n.map((m,g)=>m[0]+t[g]).join(","),l=ri("rc",i),c=ri("source",i),h=`${l[i-1]} < ${this.outputShape[i-1]}`,d=i===1?"source":`vec2(${c.slice(-2).join()})`,p=s==="reflect"?0:1;let f="";if(i===1){const m=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;f=`
        ${a} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[i-1]} += 1;
        if(${h}) {
          ${m}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
      `}else{const m=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;f=`
        ${a} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[i-1]} += 1;
        if(${h}) {
          ${m}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
        rc = outputLoc;
        ${l[i-2]} += 1;
        if(${l[i-2]} < ${this.outputShape[i-2]}) {
          ${m}
          result[2] = getChannel(getX(${c.join()}), ${d});
          ${l[i-1]} += 1;
          if(${h}) {
            ${m}
            result[3] = getChannel(getX(${c.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${o});
      const ${a} end = ${a}(${u});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QIe=({inputs:r,backend:t,attrs:n})=>{const{x:s}=r,{paddings:i,mode:a}=n,o=Be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new JIe(s.shape,i,a):new ZIe(s.shape,i,a);return t.runWebGLProgram(o,[s],s.dtype)},eke={kernelName:VD,backendName:"webgl",kernelFunc:QIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tke=`if (b == 0.0) return NAN;
  return mod(a, b);`,rke=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Ud+`
  return result;
`,nke=Rs({opSnippet:tke,packedOpSnippet:rke}),ske={kernelName:zD,backendName:"webgl",kernelFunc:nke};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ike{constructor(t,n,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ake=`
if (a == b) {
  return 1.0;
};
return a / b;`,oke=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Z7=Rs({opSnippet:ake,packedOpSnippet:oke,checkOutOfBounds:!0}),uke={kernelName:QA,backendName:"webgl",kernelFunc:Z7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C5="return a - b;",J7=Rs({opSnippet:C5,packedOpSnippet:C5,supportsComplex:!0,cpuKernelImpl:t2e}),lke={kernelName:WF,backendName:"webgl",kernelFunc:J7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q7(r){const{inputs:t,backend:n,attrs:s}=r,{logits:i}=t,{dim:a}=s,o=ls([a],i.shape),u=Y7({inputs:{x:i},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=_a(u.shape,o),c=mt({inputs:{x:u},backend:n,attrs:{shape:l}}),h=J7({inputs:{a:i,b:c},backend:n}),d=q7({inputs:{x:h},backend:n}),p=vC({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),f=mt({inputs:{x:p},backend:n,attrs:{shape:l}}),m=Z7({inputs:{a:d,b:f},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}const cke={kernelName:DF,backendName:"webgl",kernelFunc:Q7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hke(r){const{inputs:t,backend:n,attrs:s}=r,{logits:i}=t,{numSamples:a,seed:o,normalized:u}=s,l=u?i:Q7({inputs:{logits:i},backend:n,attrs:{dim:i.shape.length-1}}),c=l.shape[0],h=l.shape[1],d=new ike(c,h,a),p=[[o]],f=n.runWebGLProgram(d,[l],"int32",p);return u||n.disposeIntermediateTensorInfo(l),f}const dke={kernelName:UD,backendName:"webgl",kernelFunc:hke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pke=so+`
  return -x;
`,fke=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function mke(r){const{inputs:t,backend:n}=r,{x:s}=t;if(n.shouldExecuteOnCPU([s])){const a=n.texData.get(s.dataId),[o,u]=Mwe(a.values,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,o)}let i;return Be().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Kl(s.shape,fke):i=new tu(s.shape,pke),n.runWebGLProgram(i,[s],s.dtype)}const gke={kernelName:GD,backendName:"webgl",kernelFunc:mke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yke=Q$;function bke(r){Wa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=r,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l}=s,c=n.readSync(i.dataId),h=n.readSync(a.dataId),{selectedIndices:d}=yke(c,h,o,u,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const xke={kernelName:jD,backendName:"webgl",kernelFunc:bke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vke=eR;function wke(r){Wa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=r,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l,padToMaxOutputSize:c}=s,h=n.readSync(i.dataId),d=n.readSync(a.dataId),{selectedIndices:p,validOutputs:f}=vke(h,d,o,u,l,c);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}const Ske={kernelName:qD,backendName:"webgl",kernelFunc:wke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cke=tR;function _ke(r){Wa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=r,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=s,h=n.readSync(i.dataId),d=n.readSync(a.dataId),p=o,f=u,m=l,g=c,{selectedIndices:y,selectedScores:b}=Cke(h,d,p,f,m,g);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const Eke={kernelName:KD,backendName:"webgl",kernelFunc:_ke};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ike{constructor(t,n,s,i){this.variableNames=["indices"],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kke=r=>{const{inputs:t,backend:n,attrs:s}=r,{indices:i}=t,{dtype:a,depth:o,onValue:u,offValue:l}=s,c=lt(i.shape),h=new Ike(c,o,u,l),d=mt({inputs:{x:i},backend:n,attrs:{shape:[c]}}),p=n.runWebGLProgram(h,[d],a);n.disposeIntermediateTensorInfo(d);const f=[...i.shape,o],m=mt({inputs:{x:p},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(p),m},Nke={kernelName:YD,backendName:"webgl",kernelFunc:kke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A2(r){const{inputs:t,backend:n}=r,{x:s}=t;if(s.dtype==="complex64"){const i=Fx({inputs:{input:s},backend:n}),a=A2({inputs:{x:i},backend:n}),o=wC({inputs:{input:s},backend:n}),u=A2({inputs:{x:o},backend:n}),l=Rc({inputs:{real:a,imag:u},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}else return $x({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:n})}const Tke={kernelName:ZF,backendName:"webgl",kernelFunc:A2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eq(r){const{inputs:t,backend:n}=r,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=Fx({inputs:{input:s},backend:n}),a=eq({inputs:{x:i},backend:n}),o=wC({inputs:{input:s},backend:n}),u=A2({inputs:{x:o},backend:n}),l=Rc({inputs:{real:a,imag:u},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}else return $x({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:n})}const Ake={kernelName:XD,backendName:"webgl",kernelFunc:eq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dke(r){const{inputs:t,backend:n,attrs:s}=r,{axis:i}=s;if(t.length===1)return Lk({inputs:{input:t[0]},backend:n,attrs:{dim:i}});const a=t[0].shape,o=t[0].dtype;t.forEach(h=>{Gs(a,h.shape,"All tensors passed to stack must have matching shapes"),oe(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],l=t.map(h=>{const d=Lk({inputs:{input:h},backend:n,attrs:{dim:i}});return u.push(d),d}),c=B7({inputs:l,backend:n,attrs:{axis:i}});return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const Fke={kernelName:ZD,backendName:"webgl",kernelFunc:Dke};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $ke{constructor(t,n,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((c,h)=>c[0]+t[h]+c[1]);const i=t.length,a=on(i),o=n.map(c=>c[0]).join(","),u=n.map((c,h)=>c[0]+t[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = ${o};
        int end = ${u};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${o});
      ${a} end = ${a}(${u});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rke{constructor(t,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((g,y)=>g[0]+t[y]+g[1]);const i=t.length,a=on(i),o=n.map(g=>g[0]).join(","),u=n.map((g,y)=>g[0]+t[y]).join(","),l=ri("rc",i),c=ri("source",i),h=`${l[i-1]} < ${this.outputShape[i-1]}`,d=i===1?"source":`vec2(${c.slice(-2).join()})`,p=[`${a} rc = outputLoc;`,`${l[i-1]} += 1;
       if(${h}) {
      `,i===1?"":`}
       rc = outputLoc;
       ${l[i-2]} += 1;
       if(${l[i-2]} < ${this.outputShape[i-2]}) {`,i===1?"":`  ${l[i-1]} += 1;
         if(${h}) {`],f=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let m="";for(let g=0,y=i===1?2:4;g<y;g++)m+=`
        ${p[g]}
        if (${f}) {
          result[${g}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${g}] = getChannel(getX(${c.join()}), ${d});
        }
      `;m+=i===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${o});
      const ${a} end = ${a}(${u});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tq=r=>{const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{paddings:a,constantValue:o}=s;if(lt(i.shape)===0){const c=a.map((h,d)=>h[0]+i.shape[d]+h[1]);return $x({backend:n,attrs:{shape:c,value:o,dtype:i.dtype}})}const u=Be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rke(i.shape,a,o):new $ke(i.shape,a,o),l=[[o]];return n.runWebGLProgram(u,[i],i.dtype,l)},Oke={kernelName:JD,backendName:"webgl",kernelFunc:tq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mke=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Lke=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Ud+`
  return result;
`,Pke=Rs({opSnippet:Mke,packedOpSnippet:Lke}),Bke={kernelName:QD,backendName:"webgl",kernelFunc:Pke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vke(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s,u=i.shape.length,l=[],c=ls(a,i.shape);let h=c;const d=ro(h,u);let p=i;d!=null&&(p=oi({inputs:{x:i},backend:n,attrs:{perm:d}}),h=no(h.length,u),l.push(p)),Vo("prod",h,u);let f;if(n.shouldExecuteOnCPU([p])){const m=n.texData.get(p.dataId).values,{outVals:g,outShape:y,outDtype:b}=Pwe(p.shape,p.dtype,m,h);f=n.makeTensorInfo(y,b,g)}else{const[m,g]=_u(p.shape,h),y=lt(g),b=mt({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),x=QS(i.dtype),w=Wd(b,x,"prod",n);f=mt({inputs:{x:w},backend:n,attrs:{shape:m}}),l.push(b),l.push(w)}if(o){l.push(f);const m=_a(f.shape,c);f=mt({inputs:{x:f},backend:n,attrs:{shape:m}})}return l.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const zke={kernelName:tF,backendName:"webgl",kernelFunc:Vke};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uke(r){const{inputs:t,backend:n,attrs:s}=r,{paramsNestedSplits:i,paramsDenseValues:a,indices:o}=t,{outputRaggedRank:u}=s,l=i.map(b=>n.readSync(b.dataId)),c=i.map(b=>b.shape),h=n.readSync(a.dataId),d=n.readSync(o.dataId),[p,f,m]=Bwe(l,c,h,a.shape,a.dtype,d,o.shape,u),g=p.map(b=>n.makeTensorInfo([b.length],"int32",b)),y=n.makeTensorInfo(m,a.dtype,f);return g.concat([y])}const Wke={kernelName:rF,backendName:"webgl",kernelFunc:Uke};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gke(r){const{inputs:t,backend:n}=r,{starts:s,limits:i,deltas:a}=t,o=n.readSync(s.dataId),u=n.readSync(i.dataId),l=n.readSync(a.dataId),[c,h]=Vwe(o,s.shape,s.dtype,u,i.shape,l,a.shape),d=n.makeTensorInfo([c.length],"int32",c),p=n.makeTensorInfo([h.length],s.dtype,h);return[d,p]}const Hke={kernelName:nF,backendName:"webgl",kernelFunc:Gke};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jke(r){const{inputs:t,backend:n,attrs:s}=r,{shape:i,values:a,defaultValue:o,rowPartitionTensors:u}=t,{rowPartitionTypes:l}=s,c=n.readSync(i.dataId),h=n.readSync(a.dataId),d=n.readSync(o.dataId),p=u.map(y=>n.readSync(y.dataId)),f=u.map(y=>y.shape),[m,g]=zwe(c,i.shape,h,a.shape,a.dtype,d,o.shape,p,f,l);return n.makeTensorInfo(m,a.dtype,g)}const qke={kernelName:sF,backendName:"webgl",kernelFunc:jke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rq=r=>{const{backend:t,attrs:n}=r,{start:s,stop:i,step:a,dtype:o}=n,u=Uwe(s,i,a,o);return t.makeTensorInfo([u.length],o,u)},Kke={kernelName:iF,backendName:"webgl",kernelFunc:rq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xke="return 1.0 / x;",Yke=$r({opSnippet:Xke}),Zke={kernelName:oF,backendName:"webgl",kernelFunc:Yke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jke=so+`
  return (x < 0.0) ? 0.0 : x;
`,Qke=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,eNe=$r({opSnippet:Jke,packedOpSnippet:Qke}),tNe={kernelName:uF,backendName:"webgl",kernelFunc:eNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rNe=so+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,nNe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,sNe=$r({opSnippet:rNe,packedOpSnippet:nNe}),iNe={kernelName:dF,backendName:"webgl",kernelFunc:sNe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aNe{constructor(t,n,s,i,a){this.variableNames=["A"],this.outputShape=[];const[o,u,l,c]=t;this.outputShape=[o,n,s,c];const h=[i&&n>1?u-1:u,i&&s>1?l-1:l],d=[i&&n>1?n-1:n,i&&s>1?s-1:s];let p;a?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/d[0]},
          ${h[1]/d[1]});
      const vec2 inputShapeRC = vec2(${u}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oNe{constructor(t,n,s,i,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,u,l,c]=t;this.outputShape=[o,n,s,c];const h=[i&&n>1?u-1:u,i&&s>1?l-1:l],d=[i&&n>1?n-1:n,i&&s>1?s-1:s];let p;a?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/d[0]},
          ${h[1]/d[1]},
          ${h[1]/d[1]});
      const vec3 inputShapeRC = vec3(${u}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uNe(r){const{inputs:t,backend:n,attrs:s}=r,{images:i}=t,{alignCorners:a,halfPixelCenters:o,size:u}=s,[l,c]=u,h=Be().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new oNe(i.shape,l,c,a,o):new aNe(i.shape,l,c,a,o);return n.runWebGLProgram(h,[i],"float32")}const lNe={kernelName:hF,backendName:"webgl",kernelFunc:uNe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cNe{constructor(t,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,i,a]=n,[,o,u]=t,l=[s&&o>1?i-1:i,s&&u>1?a-1:a],c=[s&&o>1?o-1:o,s&&u>1?u-1:u],h=l[0]/c[0],d=l[1]/c[1],p=1/h,f=1/d,m=Math.ceil(p)*2+2,g=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${u}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hNe(r){const{inputs:t,backend:n,attrs:s}=r,{images:i,dy:a}=t,{alignCorners:o}=s,u=new cNe(a.shape,i.shape,o);return n.runWebGLProgram(u,[a],a.dtype)}const dNe={kernelName:hG,backendName:"webgl",kernelFunc:hNe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pNe{constructor(t,n,s,i,a){this.variableNames=["A"],this.outputShape=[];const[o,u,l,c]=t;this.outputShape=[o,n,s,c];const h=[i&&n>1?u-1:u,i&&s>1?l-1:l],d=[i&&n>1?n-1:n,i&&s>1?s-1:s],p=i?"0.5":"0.0";let f;a?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/d[0]},
          ${h[1]/d[1]});
      const vec2 inputShapeRC = vec2(${u}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fNe{constructor(t,n,s,i,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,u,l,c]=t;this.outputShape=[o,n,s,c];const h=[i&&n>1?u-1:u,i&&s>1?l-1:l],d=[i&&n>1?n-1:n,i&&s>1?s-1:s],p=i?"0.5":"0.0";let f;a?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/d[0]},
          ${h[1]/d[1]},
          ${h[1]/d[1]});
      const vec3 inputShapeRC = vec3(${u}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mNe(r){const{inputs:t,backend:n,attrs:s}=r,{images:i}=t,{alignCorners:a,halfPixelCenters:o,size:u}=s,[l,c]=u,h=Be().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new fNe(i.shape,l,c,a,o):new pNe(i.shape,l,c,a,o);return n.runWebGLProgram(h,[i],i.dtype)}const gNe={kernelName:cF,backendName:"webgl",kernelFunc:mNe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yNe{constructor(t,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,i,a]=n,[,o,u]=t,l=[s&&o>1?i-1:i,s&&u>1?a-1:a],c=[s&&o>1?o-1:o,s&&u>1?u-1:u],h=l[0]/c[0],d=l[1]/c[1],p=1/h,f=1/d,m=Math.ceil(p)*2+2,g=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${u}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bNe(r){const{inputs:t,backend:n,attrs:s}=r,{images:i,dy:a}=t,{alignCorners:o}=s,u=new yNe(a.shape,i.shape,o);return n.runWebGLProgram(u,[a],a.dtype)}const xNe={kernelName:cG,backendName:"webgl",kernelFunc:bNe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vNe{constructor(t,n){this.variableNames=["x"];const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const i=u=>n.indexOf(u)!==-1&&t[u]!==1?`${t[u]} - coords[${u}] - 1`:`coords[${u}]`,a=t.map((u,l)=>i(l)).join(","),o=on(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wNe{constructor(t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;const i=ri("rc",s),a=`${i[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${i[s-2]} + 1 < ${this.outputShape[s-2]}`,u=on(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${u} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(i.slice())};
          if(${a}){
            result.g = ${c(i.slice())};
          }
          if(${o}) {
            result.b = ${h(i.slice())};
            if(${a}) {
              result.a = ${d(i.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(m){return p(m)}function c(m){return m[s-1]="("+m[s-1]+" + 1)",p(m)}function h(m){return m[s-2]="("+m[s-2]+" + 1)",p(m)}function d(m){return m[s-1]="("+m[s-1]+" + 1)",m[s-2]="("+m[s-2]+" + 1)",p(m)}function p(m){const g=t.map((x,w)=>f(w,m)),y=g.join(","),b=g.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${b}))`}function f(m,g){return n.indexOf(m)!==-1&&t[m]!==1?`${t[m]} - ${g[m]} - 1`:`${g[m]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SNe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{dims:a}=s,o=i.shape.length,u=ls(a,i.shape);if(o===0)return ta({inputs:{x:i},backend:n});const l=Be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wNe(i.shape,u):new vNe(i.shape,u);return n.runWebGLProgram(l,[i],i.dtype)}const CNe={kernelName:pF,backendName:"webgl",kernelFunc:SNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Ne{constructor(t,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=t[1],i=t[2];this.outputShape=t;let a="";typeof n=="number"?a=`float outputValue = ${n.toFixed(2)};`:a=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ENe={kernelName:QF,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:n})=>{const{image:s}=r,{radians:i,fillValue:a,center:o}=t,u=n,l=new _Ne(s.shape,a),[c,h]=D9(o,s.shape[1],s.shape[2]),d=[[c,h,Math.sin(i),Math.cos(i)]];return u.runWebGLProgram(l,[s],s.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const INe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,kNe=$r({opSnippet:INe}),NNe={kernelName:fF,backendName:"webgl",kernelFunc:kNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TNe="return inversesqrt(x);",ANe=$r({opSnippet:TNe,cpuKernelImpl:Wwe}),DNe={kernelName:mF,backendName:"webgl",kernelFunc:ANe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kR{constructor(t,n,s,i,a,o,u=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=on(a.length),h=on(o.length);let d="";s===1?d="i":s===2&&(d="i, j");const p=`getIndices(${d})`;let f="";i===1?f="i":i===2&&(f="i, coords[1]");const m=`getUpdates(${f})`;let g="";l&&(g="coords[0], coords[1]");const y=`getDefaultValue(${g})`,b=n>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${a});

        void main() {
          ${h} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${b};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${m};
              found = true;
            }
          }
          setOutput(mix(${y}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FNe{constructor(t,n,s,i,a,o,u=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=on(a.length),h=on(o.length);let d="";s===1?d="i":s===2&&(d="i, j");const p=`getIndices(${d})`;let f="";i===1?f="i":i===2&&(f="i, coords[1]");const m=`getUpdates(${f})`;let g="";l&&(g="coords[0], coords[1]");const y=`getDefaultValue(${g})`,b=n>1?"strides[j]":"strides",x=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${a});

        void main() {
          ${h} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${b};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${x};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${m};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${y}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ne(r){const{inputs:t,backend:n,attrs:s}=r,{indices:i,updates:a}=t,{shape:o}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=Nx(a,i,o),p=[d/c,c];if(d===0)return n.makeTensorInfo(o,i.dtype);const f=mt({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=mt({inputs:{x:a},backend:n,attrs:{shape:[l,c]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let y;Be().getBool("WEBGL_PACK")?y=new FNe(l,u,f.shape.length,m.shape.length,h,p):y=new kR(l,u,f.shape.length,m.shape.length,h,p);const b=n.runWebGLProgram(y,[m,f,g],m.dtype),x=mt({inputs:{x:b},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),x}const RNe={kernelName:gF,backendName:"webgl",kernelFunc:$Ne};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ONe{constructor(t,n,s,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,s];const a="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,u=Be().getNumber("WEBGL_VERSION")===2?a:o,l=i==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${u}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MNe(r){const{inputs:t,backend:n,attrs:s}=r,{sortedSequence:i,values:a}=t,{side:o}=s,u=new ONe(i.shape[0],i.shape[1],a.shape[1],o),l=[[i.shape[1]]];return n.runWebGLProgram(u,[i,a],"int32",l)}const LNe={kernelName:bF,backendName:"webgl",kernelFunc:MNe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PNe{constructor(t,n,s){this.variableNames=["c","a","b"],this.outputShape=n;let i,a;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)a="resRC",i="resRC";else{const u=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let h=0;h<n.length;h++)c.push(`${u[h]}`),h<t&&l.push(`${u[h]}`);i=l.join(),a=c.join()}const o=on(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BNe(r){const{inputs:t,backend:n}=r,{condition:s,t:i,e:a}=t,o=new PNe(s.shape.length,i.shape,i.shape.length);return n.runWebGLProgram(o,[s,i,a],Fo(i.dtype,a.dtype))}const VNe={kernelName:xF,backendName:"webgl",kernelFunc:BNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zNe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${R9};
  float scale = ${O9};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,UNe=$r({opSnippet:zNe}),WNe={kernelName:vF,backendName:"webgl",kernelFunc:UNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GNe=Sg+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,HNe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,jNe=$r({opSnippet:GNe,packedOpSnippet:HNe,cpuKernelImpl:Hwe}),qNe={kernelName:EF,backendName:"webgl",kernelFunc:jNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KNe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,XNe=$r({opSnippet:KNe}),YNe={kernelName:_F,backendName:"webgl",kernelFunc:XNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZNe=Sg+`
  return sin(x);
`,JNe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Ud}
  return result;
`,QNe=$r({opSnippet:ZNe,packedOpSnippet:JNe}),eTe={kernelName:SF,backendName:"webgl",kernelFunc:QNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tTe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,rTe=$r({opSnippet:tTe}),nTe={kernelName:CF,backendName:"webgl",kernelFunc:rTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sTe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,iTe=$r({opSnippet:sTe}),aTe={kernelName:IF,backendName:"webgl",kernelFunc:iTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oTe=r=>{const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{blockShape:a,paddings:o}=s;oe(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const u=a.reduce((b,x)=>b*x),l=[[0,0]];l.push(...o);for(let b=1+a.length;b<i.shape.length;++b)l.push([0,0]);const c=[],h=tq({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),d=gR(h.shape,a,u,!1),p=yR(d.length,a.length,!1),f=bR(h.shape,a,u,!1),m=mt({inputs:{x:h},backend:n,attrs:{shape:d}}),g=oi({inputs:{x:m},backend:n,attrs:{perm:p}}),y=mt({inputs:{x:g},backend:n,attrs:{shape:f}});return c.push(h),c.push(m),c.push(g),c.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},uTe={kernelName:TF,backendName:"webgl",kernelFunc:oTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lTe(r){const{inputs:t,backend:n}=r,{indices:s,values:i,denseShape:a,defaultValue:o}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const u=n.readSync(s.dataId),l=n.readSync(i.dataId),c=n.readSync(a.dataId),h=n.readSync(o.dataId)[0],[d,p,f,m,g]=qwe(u,s.shape,s.dtype,l,i.dtype,c,h);return[n.makeTensorInfo(p,s.dtype,d),n.makeTensorInfo([p[0]],i.dtype,f),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(y=>Number(y)))),n.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const cTe={kernelName:FF,backendName:"webgl",kernelFunc:lTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hTe(r){const{inputs:t,backend:n}=r,{inputIndices:s,inputShape:i,newShape:a}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const o=Array.from(n.readSync(i.dataId)),u=n.readSync(s.dataId),l=Array.from(n.readSync(a.dataId)),[c,h,d]=Kwe(u,s.shape,s.dtype,o,l);return[n.makeTensorInfo(h,s.dtype,c),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const dTe={kernelName:$F,backendName:"webgl",kernelFunc:hTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pTe(r){const{inputs:t,backend:n}=r,{data:s,indices:i,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const o=n.readSync(s.dataId),u=n.readSync(i.dataId),l=n.readSync(a.dataId),[c,h]=I7(o,s.shape,s.dtype,u,l,!0);return n.makeTensorInfo(h,s.dtype,c)}const fTe={kernelName:RF,backendName:"webgl",kernelFunc:pTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mTe(r){const{inputs:t,backend:n}=r,{data:s,indices:i,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const o=n.readSync(s.dataId),u=n.readSync(i.dataId),l=n.readSync(a.dataId),[c,h]=I7(o,s.shape,s.dtype,u,l);return n.makeTensorInfo(h,s.dtype,c)}const gTe={kernelName:OF,backendName:"webgl",kernelFunc:mTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yTe(r){const{inputs:t,backend:n,attrs:s}=r,{sparseIndices:i,sparseValues:a,defaultValue:o}=t,{outputShape:u}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=Nx(a,i,u),f=!1;if(a.dtype==="string"){const b=n.bufferSync(i),x=n.bufferSync(a),w=ed(n.readSync(o.dataId)[0]),v=Gwe(b,x,u,p,h,c,l,d,w,f);return n.makeTensorInfo(u,v.dtype,v.values)}const m=new kR(c,l,i.shape.length,a.shape.length,d,[p,1],f),g=n.runWebGLProgram(m,[a,i,o],a.dtype),y=mt({inputs:{x:g},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(g),y}const bTe={kernelName:MF,backendName:"webgl",kernelFunc:yTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xTe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{numOrSizeSplits:a,axis:o}=s,u=ls(o,i.shape)[0],l=q9(i,a,u),c=i.shape.length,h=new Array(c).fill(0),d=i.shape.slice();return l.map(p=>{const f=[...d];f[u]=p;const m=Cg({inputs:{x:i},backend:n,attrs:{begin:h,size:f}});return h[u]+=p,m})}const vTe={kernelName:AF,backendName:"webgl",kernelFunc:xTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _5="return sqrt(x);",wTe=$r({opSnippet:_5,packedOpSnippet:_5,cpuKernelImpl:Xwe}),STe={kernelName:kF,backendName:"webgl",kernelFunc:wTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CTe="return x * x;",_Te=$r({opSnippet:CTe}),ETe={kernelName:dG,backendName:"webgl",kernelFunc:_Te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E5="return (a - b) * (a - b);",ITe=Rs({opSnippet:E5,packedOpSnippet:E5}),kTe={kernelName:LF,backendName:"webgl",kernelFunc:ITe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NTe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");const a=n.readSync(i.dataId),o=Pm(a),u=Ywe(o,"string",s);return n.makeTensorInfo(i.shape,"string",u)}const TTe={kernelName:PF,backendName:"webgl",kernelFunc:NTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ATe({inputs:r,attrs:t,backend:n}){const{x:s}=r,i=so+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new tu(s.shape,i);return n.runWebGLProgram(a,[s],s.dtype)}const DTe={kernelName:JF,backendName:"webgl",kernelFunc:ATe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FTe{constructor(t,n,s){this.variableNames=["x"],this.outputShape=s;const i=s.length,a=on(s.length),o=on(s.length);let u="";if(i===1)u="coords * strides + begin";else{let l=0;u=s.map((c,h)=>(l++,s.length===1?`coords * strides[${h}] + begin[${h}]`:`coords[${l-1}] * strides[${h}] + begin[${h}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${t});
      ${a} strides = ${a}(${n});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Te(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{begin:a,end:o,strides:u,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=s,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:x,end:w,strides:v}=S9(i.shape,a,o,u,l,c,h,d,p);let S;if(g)S=mt({inputs:{x:i},backend:n,attrs:{shape:m}});else if(y||b){oe(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const C=d9(x,w,v),I=Cg({inputs:{x:i},backend:n,attrs:{begin:x,size:C}});S=mt({inputs:{x:I},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(I)}else if(n.shouldExecuteOnCPU([i])){const I=n.readSync(i.dataId),_=Tn(i.shape,i.dtype,I),A=Zwe(f,_,v,x);S=n.makeTensorInfo(m,i.dtype,A.values)}else{const I=new FTe(x,v,f);S=n.runWebGLProgram(I,[i],i.dtype)}const E=mt({inputs:{x:S},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(S),E}const RTe={kernelName:BF,backendName:"webgl",kernelFunc:$Te};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OTe(r){const{inputs:t,backend:n,attrs:s}=r,{separator:i,nGramWidths:a,leftPad:o,rightPad:u,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:d}=t,p=n.readSync(h.dataId),f=n.readSync(d.dataId),[m,g]=Jwe(p,f,i,a,o,u,l,c);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(d.shape,"int32",g)]}const MTe={kernelName:VF,backendName:"webgl",kernelFunc:OTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LTe(r){const{inputs:t,backend:n,attrs:s}=r,{skipEmpty:i}=s,{input:a,delimiter:o}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const u=n.readSync(a.dataId),l=n.readSync(o.dataId)[0],[c,h,d]=Qwe(u,l,i),p=h.length;return[n.makeTensorInfo([p,2],"int32",c),n.makeTensorInfo([p],"string",h),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const PTe={kernelName:zF,backendName:"webgl",kernelFunc:LTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BTe(r){const{inputs:t,backend:n,attrs:s}=r,{numBuckets:i}=s,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(a.dataId),u=e2e(o,i);return n.makeTensorInfo(a.shape,"int32",u)}const VTe={kernelName:UF,backendName:"webgl",kernelFunc:BTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zTe="return tan(x);",UTe=$r({opSnippet:zTe}),WTe={kernelName:GF,backendName:"webgl",kernelFunc:UTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GTe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,HTe=$r({opSnippet:GTe}),jTe={kernelName:HF,backendName:"webgl",kernelFunc:HTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qTe(r){const{inputs:t,backend:n,attrs:s}=r,{tensor:i,indices:a,updates:o}=t,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=Nx(o,a,i.shape),p=[d/c,c];if(d===0)return n.makeTensorInfo(i.shape,a.dtype);const f=mt({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=mt({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),g=mt({inputs:{x:i},backend:n,attrs:{shape:p}}),y=new kR(l,u,f.shape.length,m.shape.length,h,p,!1,!0),b=n.runWebGLProgram(y,[m,f,g],g.dtype),x=mt({inputs:{x:b},backend:n,attrs:{shape:i.shape}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),x}const KTe={kernelName:yF,backendName:"webgl",kernelFunc:qTe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XTe{constructor(t,n){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[o]*n[o];this.outputShape=s,this.rank=s.length;const i=on(this.rank),a=YTe(t);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function YTe(r){const t=r.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${r[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let i=0;i<r.length;i++)s.push(`imod(${n[i]}, ${r[i]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nq(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{reps:a}=s;if(i.dtype==="string"||i.shape.length>5){const l=n.readSync(i.dataId),c=i.dtype==="string"?l.map(p=>ed(p)):l,h=Tn(i.shape,i.dtype,c),d=r2e(h,a);return n.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new XTe(i.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}const ZTe={kernelName:JS,backendName:"webgl",kernelFunc:nq};class JTe{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class QTe{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ih(r,t){t!==null&&r.disposeIntermediateTensorInfo(t)}function I5(r){let t=1;for(;t<r;)t*=2;return t}function eAe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{k:a,sorted:o}=s,u=Be().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Be().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,h=c[c.length-1];if(n.shouldExecuteOnCPU([i])||h<u||a>l){const A=n.readSync(i.dataId),[k,N]=n2e(A,c,i.dtype,a,o);return[n.makeTensorInfo(k.shape,k.dtype,k.values),n.makeTensorInfo(N.shape,N.dtype,N.values)]}if(a===0)return c[c.length-1]=0,[n.makeTensorInfo(c,i.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(h===1)return[i,$x({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const d=n.texData.get(i.dataId),p=d!==null&&d.isPacked,f=p?n.unpackTensor(i):i,g=lt(c)/h,y=mt({inputs:{x:f},attrs:{shape:[g,h]},backend:n});p&&ih(n,f);const b=I5(a),x=I5(h);let w=null;const v=()=>w===null?[y,y]:[y,w],S=(A,k,N)=>{const D=v(),F=new JTe(N),G=[[h],[w===null?1:0],[Number.NEGATIVE_INFINITY],[A],[k]],Y=w;w=n.runWebGLProgram(F,D,"int32",G),ih(n,Y)};for(let A=1;A<b;A*=2){const k=A*2;for(let N=A;N>=1;N/=2)S(k,N,[g,x])}for(let A=x;A>b;A/=2){const k=v(),N=new QTe([g,A/2]),F=[[h],[w===null?1:0],[b]],P=w;w=n.runWebGLProgram(N,k,"int32",F),ih(n,P);const G=b/2,Y=G*2;for(let Z=G;Z>=1;Z/=2)S(Y,Z,w.shape)}let E=w;w=Cg({inputs:{x:w},backend:n,attrs:{begin:0,size:[g,a]}}),ih(n,E);let C=X7({inputs:{x:y,indices:w},backend:n,attrs:{axis:1,batchDims:1}});ih(n,y);const I=c.slice(0,-1);I.push(a),E=w,w=mt({inputs:{x:w},attrs:{shape:I},backend:n}),ih(n,E);const _=C;return C=mt({inputs:{x:C},attrs:{shape:I},backend:n}),ih(n,_),[C,w]}const tAe={kernelName:jF,backendName:"webgl",kernelFunc:eAe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rAe{constructor(t,n,s,i,a,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const u=s==="nearest"?1:2;let l;switch(i){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${t}));

                if (${u} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nAe(r){const{inputs:t,backend:n,attrs:s}=r,{image:i,transforms:a}=t,{interpolation:o,fillMode:u,fillValue:l,outputShape:c}=s,[h,d,p,f]=i.shape,[m,g]=c??[d,p],y=[h,m,g,f],b=new rAe(d,p,o,u,l,y);return n.runWebGLProgram(b,[i,a],"float32")}const sAe={kernelName:qF,backendName:"webgl",kernelFunc:nAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iAe(r){const{inputs:t,attrs:n,backend:s}=r,{axis:i}=n,{x:a}=t;Ax(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(a.dataId),{outputValues:u,outputShape:l,indices:c}=s2e(o,i,a.shape,a.dtype);return[s.makeTensorInfo(l,a.dtype,u),s.makeTensorInfo([c.length],"int32",c)]}const aAe={kernelName:KF,backendName:"webgl",kernelFunc:iAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oAe(r){const{inputs:t,backend:n,attrs:s}=r,{value:i}=t;let{axis:a}=s;a<0&&(a+=i.shape.length);const o=i,u=o.shape.length,l=i.shape[a],c=new Array(u-1);let h=0;for(let g=0;g<u;g++)g!==a&&(c[h++]=o.shape[g]);const d=[],p=new Array(u).fill(0),f=o.shape.slice();f[a]=1;const m=new Array(l);for(let g=0;g<m.length;g++){p[a]=g;const y=Cg({inputs:{x:o},backend:n,attrs:{begin:p,size:f}}),b=mt({inputs:{x:y},backend:n,attrs:{shape:c}});m[g]=b,d.push(y)}return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const uAe={kernelName:XF,backendName:"webgl",kernelFunc:oAe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lAe{constructor(t,n){this.variableNames=["x","segmentIds"];const s=t.windowSize,i=t.batchSize,a=t.inSize,o=t.numSegments,u=o*Math.ceil(a/s);this.outputShape=[i,u];const l="0.0",c="sumValue",h=Math.floor(s/4)*4,d=s%4,p=`
        sumValue += dot(values, segFilter);
    `;let f="";a%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let m="";a%s>0&&(m=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${m}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${h};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cAe(r){const{inputs:t,backend:n,attrs:s}=r,{x:i,segmentIds:a}=t,{numSegments:o}=s,u=i.shape.length,l=[];let c=0;const h=ro([c],u);let d=i;h!=null&&(d=oi({inputs:{x:i},backend:n,attrs:{perm:h}}),l.push(d),c=no(1,u)[0]);const p=a7(d.shape,c,o),f=lt([d.shape[c]]),m=mt({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}});l.push(m);const g=QS(i.dtype),y=(v,S,E,C,I)=>{const _=v.shape[0],A=v.shape[1],k=i7(A,I),N={windowSize:k,inSize:A,batchSize:_,numSegments:I},D=new lAe(N,S),F=n.compileAndRun(D,[v,E],C);if(l.push(F),F.shape[1]===I)return F;const P=rq({backend:n,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),G=nq({inputs:{x:P},backend:n,attrs:{reps:[A/k]}});return l.push(P),l.push(G),y(F,S,G,C,I)},b=y(m,"unsortedSegmentSum",a,g,o),x=mt({inputs:{x:b},backend:n,attrs:{shape:p}});let w=x;if(h!=null){l.push(x);const v=v$(h);w=oi({inputs:{x:w},backend:n,attrs:{perm:v}})}return l.forEach(v=>n.disposeIntermediateTensorInfo(v)),w}const hAe={kernelName:YF,backendName:"webgl",kernelFunc:cAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dAe=[X2e,Z2e,eSe,nSe,iSe,uSe,cSe,dSe,gSe,bSe,wSe,_Se,kSe,DSe,RSe,MSe,PSe,USe,GSe,jSe,YSe,nCe,iCe,lCe,hCe,yCe,xCe,CCe,F2e,ICe,DCe,OCe,zCe,GCe,jCe,KCe,YCe,e_e,n_e,a_e,u_e,c_e,d_e,m_e,y_e,w_e,C_e,I_e,T_e,D_e,O_e,B_e,W_e,j_e,X_e,Y_e,J_e,eEe,rEe,sEe,aEe,cEe,pEe,gEe,bEe,wEe,_Ee,NEe,FEe,D2e,REe,TCe,LEe,VEe,WEe,R2e,qEe,ZEe,QEe,nIe,aIe,cIe,pIe,yIe,wIe,_Ie,IIe,AIe,FIe,RIe,PIe,VIe,UIe,GIe,jIe,YIe,eke,ske,dke,L2e,gke,xke,Ske,Eke,pCe,Nke,Ake,Fke,Oke,Bke,M2e,zke,Wke,Hke,qke,Kke,fCe,uke,Zke,tNe,iNe,B2e,lNe,dNe,gNe,xNe,CNe,ENe,NNe,DNe,RNe,LNe,VNe,WNe,qNe,YNe,eTe,nTe,tCe,cke,aTe,uTe,cTe,dTe,fTe,gTe,bTe,vTe,STe,ETe,kTe,TTe,DTe,RTe,MTe,PTe,VTe,lke,j2e,WTe,jTe,KTe,ZTe,tAe,sAe,q2e,aAe,uAe,hAe,Tke];for(const r of dAe)e$(r);var pAe=Object.defineProperty,fAe=(r=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(r,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):r)(function(r){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+r+'" is not supported')}),NR=(r,t)=>{for(var n in t)pAe(r,n,{get:t[n],enumerable:!0})},mAe={};NR(mAe,{Abs:()=>Eg,Acos:()=>Hd,Acosh:()=>jd,AdadeltaOptimizer:()=>K3,AdagradOptimizer:()=>X3,AdamOptimizer:()=>Y3,AdamaxOptimizer:()=>Z3,Add:()=>Mc,AddN:()=>qd,All:()=>Ig,Any:()=>kg,ArgMax:()=>Ng,ArgMin:()=>Tg,Asin:()=>Kd,Asinh:()=>Xd,Atan:()=>Yd,Atan2:()=>Jd,Atanh:()=>Zd,AvgPool:()=>Qd,AvgPool3D:()=>Ag,AvgPool3DGrad:()=>Lx,AvgPoolGrad:()=>Mx,BackendWasm:()=>dre,BatchMatMul:()=>ep,BatchToSpaceND:()=>Dg,Bincount:()=>Fg,BitwiseAnd:()=>$g,BroadcastArgs:()=>Px,BroadcastTo:()=>bq,Callback:()=>hZ,CallbackList:()=>sY,Cast:()=>tp,Ceil:()=>rp,ClipByValue:()=>Lc,Complex:()=>IC,ComplexAbs:()=>Bx,Concat:()=>Rg,Conv2D:()=>np,Conv2DBackpropFilter:()=>kC,Conv2DBackpropInput:()=>sp,Conv3D:()=>ip,Conv3DBackpropFilterV2:()=>Og,Conv3DBackpropInputV2:()=>Mg,Cos:()=>ap,Cosh:()=>op,CropAndResize:()=>Pg,Cumprod:()=>Lg,Cumsum:()=>up,CustomCallback:()=>aY,DataStorage:()=>CC,DenseBincount:()=>Vx,DepthToSpace:()=>Bg,DepthwiseConv2dNative:()=>lp,DepthwiseConv2dNativeBackpropFilter:()=>NC,DepthwiseConv2dNativeBackpropInput:()=>TC,Diag:()=>zx,Dilation2D:()=>cp,Dilation2DBackpropFilter:()=>Wm,Dilation2DBackpropInput:()=>Um,Draw:()=>AC,ENV:()=>$R,EarlyStopping:()=>dZ,Einsum:()=>DC,Elu:()=>dp,EluGrad:()=>Vg,Environment:()=>gq,Equal:()=>zg,Erf:()=>pp,Exp:()=>fp,ExpandDims:()=>Ug,Expm1:()=>mp,FFT:()=>FC,Fill:()=>Ux,FlipLeftRight:()=>Wg,Floor:()=>gp,FloorDiv:()=>yp,FromPixels:()=>R2,FusedBatchNorm:()=>bp,FusedConv2D:()=>hd,FusedDepthwiseConv2D:()=>dd,GPGPUContext:()=>Dw,GatherNd:()=>Hg,GatherV2:()=>Gg,GraphModel:()=>LM,Greater:()=>jg,GreaterEqual:()=>xp,History:()=>iY,IFFT:()=>$C,Identity:()=>vp,Imag:()=>RC,InputSpec:()=>Kn,IsFinite:()=>wp,IsInf:()=>Sp,IsNan:()=>Cp,KernelBackend:()=>Rx,LRN:()=>kp,LRNGrad:()=>Qg,LayerVariable:()=>YX,LayersModel:()=>tl,LeakyRelu:()=>_p,Less:()=>qg,LessEqual:()=>Kg,LinSpace:()=>Xg,Log:()=>Ep,Log1p:()=>Ip,LogSoftmax:()=>vq,LogicalAnd:()=>Yg,LogicalNot:()=>Zg,LogicalOr:()=>Jg,LogicalXor:()=>xq,LowerBound:()=>aDe,MathBackendCPU:()=>VM,MathBackendWebGL:()=>fL,MatrixBandPart:()=>oDe,Max:()=>Np,MaxPool:()=>Ap,MaxPool3D:()=>e0,MaxPool3DGrad:()=>Gx,MaxPoolGrad:()=>Wx,MaxPoolWithArgmax:()=>Hx,Maximum:()=>Tp,Mean:()=>Dp,Min:()=>Fp,Minimum:()=>$p,MirrorPad:()=>Rp,Mod:()=>Op,MomentumOptimizer:()=>J3,Multinomial:()=>t0,Multiply:()=>Mp,Neg:()=>r0,NonMaxSuppressionV3:()=>s0,NonMaxSuppressionV4:()=>i0,NonMaxSuppressionV5:()=>a0,NotEqual:()=>n0,OP_SCOPE_SUFFIX:()=>PR,OneHot:()=>Lp,OnesLike:()=>o0,Optimizer:()=>_l,OptimizerConstructors:()=>TX,Pack:()=>u0,PadV2:()=>Pp,Pool:()=>uDe,Pow:()=>Bp,Prelu:()=>Vp,Prod:()=>zp,RMSPropOptimizer:()=>Q3,RNN:()=>El,RaggedGather:()=>OC,RaggedRange:()=>MC,RaggedTensorToTensor:()=>LC,Range:()=>jx,Rank:()=>Vk,Real:()=>PC,RealDiv:()=>hp,Reciprocal:()=>Up,Reduction:()=>ni,Relu:()=>Wp,Relu6:()=>jp,Reshape:()=>l0,ResizeBilinear:()=>Hp,ResizeBilinearGrad:()=>h0,ResizeNearestNeighbor:()=>Gp,ResizeNearestNeighborGrad:()=>c0,Reverse:()=>qp,RotateWithOffset:()=>I0,Round:()=>Kp,Rsqrt:()=>Xp,SGDOptimizer:()=>v_,ScatterNd:()=>d0,SearchSorted:()=>f0,Select:()=>m0,Selu:()=>Yp,Sequential:()=>$_,Sigmoid:()=>ef,Sign:()=>Qp,Sin:()=>Zp,Sinh:()=>Jp,Slice:()=>g0,Softmax:()=>sf,Softplus:()=>tf,SpaceToBatchND:()=>y0,SparseFillEmptyRows:()=>qx,SparseReshape:()=>x0,SparseSegmentMean:()=>Kx,SparseSegmentSum:()=>Xx,SparseToDense:()=>v0,SplitV:()=>b0,Sqrt:()=>rf,Square:()=>Yx,SquaredDifference:()=>af,StaticRegexReplace:()=>Zx,Step:()=>Bc,StridedSlice:()=>w0,StringNGrams:()=>Jx,StringSplit:()=>Qx,StringToHashBucketFast:()=>ev,Sub:()=>of,Sum:()=>nf,SymbolicTensor:()=>Mo,Tan:()=>uf,Tanh:()=>lf,Tensor:()=>ur,TensorBuffer:()=>Xn,TensorScatterUpdate:()=>p0,Tile:()=>Pc,TopK:()=>S0,Transform:()=>C0,Transpose:()=>el,Unique:()=>tv,Unpack:()=>_0,UnsortedSegmentSum:()=>rv,UpperBound:()=>lDe,Variable:()=>pd,ZerosLike:()=>E0,_FusedMatMul:()=>cd,abs:()=>jn,acos:()=>WR,acosh:()=>GR,add:()=>Ke,addN:()=>Kq,all:()=>WC,any:()=>Xb,argMax:()=>yd,argMin:()=>HR,asin:()=>jR,asinh:()=>qR,atan:()=>KR,atan2:()=>XR,atanh:()=>YR,avgPool:()=>wl,avgPool3d:()=>JR,backend:()=>BR,backend_util:()=>q,basicLSTMCell:()=>Jq,batchNorm:()=>cf,batchNorm2d:()=>QR,batchNorm3d:()=>e3,batchNorm4d:()=>t3,batchToSpaceND:()=>lv,bincount:()=>r3,bitwiseAnd:()=>Qq,booleanMaskAsync:()=>UK,broadcastArgs:()=>eK,broadcastTo:()=>Mh,broadcast_util:()=>k0,browser:()=>Sv,buffer:()=>pr,callbacks:()=>s6e,cast:()=>at,ceil:()=>n3,clipByValue:()=>Us,clone:()=>au,complex:()=>hl,concat:()=>an,concat1d:()=>s3,concat2d:()=>i3,concat3d:()=>a3,concat4d:()=>o3,constraints:()=>eY,conv1d:()=>GC,conv2d:()=>ui,conv2dTranspose:()=>HC,conv3d:()=>l3,conv3dTranspose:()=>c3,copyRegisteredKernels:()=>pDe,cos:()=>cv,cosh:()=>jC,cosineWindow:()=>m_,cumprod:()=>Jb,cumsum:()=>qC,customGrad:()=>bu,data:()=>MZ,denseBincount:()=>L2,deprecationWarn:()=>Rq,depthToSpace:()=>h3,depthwiseConv2d:()=>hf,deregisterOp:()=>o6e,device_util:()=>av,diag:()=>rK,dilation2d:()=>d3,disableDeprecationWarnings:()=>WDe,dispose:()=>nr,disposeVariables:()=>GDe,div:()=>_t,divNoNan:()=>p3,dot:()=>f3,dropout:()=>W3,einsum:()=>Ch,elu:()=>N0,enableDebugMode:()=>UDe,enableProdMode:()=>zDe,enclosingPowerOfTwo:()=>G3,engine:()=>Ma,ensureShape:()=>sK,env:()=>Re,equal:()=>ra,erf:()=>KC,euclideanNorm:()=>y3,exp:()=>Ws,expandDims:()=>bs,expm1:()=>b3,eye:()=>XC,fft:()=>vv,fill:()=>Qi,findBackend:()=>YDe,findBackendFactory:()=>ZDe,floor:()=>A0,floorDiv:()=>UC,forceHalfFloat:()=>aee,fused:()=>Zm,gather:()=>D0,gatherND:()=>jK,gather_util:()=>rO,getBackend:()=>Oq,getGradient:()=>Pk,getKernel:()=>jb,getKernelsForBackend:()=>O2,getThreadsCount:()=>pht,gpgpu_util:()=>LQ,grad:()=>TRe,grads:()=>ARe,greater:()=>fi,greaterEqual:()=>Sl,ifft:()=>Ym,imag:()=>hv,image:()=>pa,inTopKAsync:()=>qK,initializers:()=>tY,input:()=>vY,io:()=>$s,irfft:()=>u_,isFinite:()=>x3,isInf:()=>v3,isNaN:()=>w3,keep:()=>ns,kernel_impls:()=>ku,layers:()=>rY,leakyRelu:()=>dv,less:()=>jm,lessEqual:()=>zc,linalg:()=>q3,linspace:()=>lK,loadGraphModel:()=>pWe,loadGraphModelSync:()=>fWe,loadLayersModel:()=>QVe,localResponseNormalization:()=>S3,log:()=>na,log1p:()=>pv,logSigmoid:()=>C3,logSoftmax:()=>ZC,logSumExp:()=>fv,logicalAnd:()=>Za,logicalNot:()=>mv,logicalOr:()=>JC,logicalXor:()=>_3,losses:()=>iX,lowerBound:()=>hK,matMul:()=>cr,math:()=>gX,max:()=>ya,maxPool:()=>ps,maxPool3d:()=>E3,maxPoolWithArgmax:()=>dK,maximum:()=>Iu,mean:()=>Rn,memory:()=>qk,meshgrid:()=>pK,metrics:()=>uZ,min:()=>Hm,minimum:()=>wc,mirrorPad:()=>I3,mod:()=>k3,model:()=>rze,models:()=>lZ,moments:()=>gv,movingAverage:()=>WK,mul:()=>Se,multiRNNCell:()=>fK,multinomial:()=>mK,neg:()=>xn,nextFrame:()=>nO,norm:()=>T0,notEqual:()=>vd,oneHot:()=>qm,ones:()=>Ci,onesLike:()=>sa,op:()=>be,outerProduct:()=>gK,pad:()=>zo,pad1d:()=>yK,pad2d:()=>bK,pad3d:()=>xK,pad4d:()=>vK,pool:()=>N3,pow:()=>yu,prelu:()=>bv,print:()=>UR,prod:()=>T3,profile:()=>HDe,raggedGather:()=>wK,raggedRange:()=>SK,raggedTensorToTensor:()=>CK,rand:()=>_K,randomGamma:()=>NK,randomNormal:()=>e_,randomStandardNormal:()=>TK,randomUniform:()=>Uc,randomUniformInt:()=>AK,range:()=>wd,ready:()=>KDe,real:()=>Km,reciprocal:()=>R3,registerBackend:()=>zC,registerCallbackConstructor:()=>sze,registerGradient:()=>wq,registerKernel:()=>nv,registerOp:()=>a6e,regularizers:()=>cZ,relu:()=>Yr,relu6:()=>t_,removeBackend:()=>XDe,reshape:()=>Ee,reverse:()=>Sa,reverse1d:()=>DK,reverse2d:()=>FK,reverse3d:()=>$K,reverse4d:()=>RK,rfft:()=>wv,round:()=>r_,rsqrt:()=>n_,scalar:()=>Pt,scatterND:()=>GK,scatter_util:()=>h_,searchSorted:()=>QC,selu:()=>s_,separableConv2d:()=>F0,sequential:()=>nze,serialization:()=>et,setBackend:()=>qDe,setPlatform:()=>JDe,setThreadsCount:()=>dht,setWasmPath:()=>cht,setWasmPaths:()=>hht,setWebGLContext:()=>oQ,setdiff1dAsync:()=>OK,shared:()=>zM,sigmoid:()=>Xa,sign:()=>O3,signal:()=>sX,sin:()=>i_,sinh:()=>a_,slice:()=>vr,slice1d:()=>xv,slice2d:()=>o_,slice3d:()=>$0,slice4d:()=>Xm,slice_util:()=>is,softmax:()=>Wc,softplus:()=>df,spaceToBatchND:()=>yv,sparse:()=>aX,sparseToDense:()=>HK,spectral:()=>nX,split:()=>_i,sqrt:()=>_s,square:()=>rn,squaredDifference:()=>l_,squeeze:()=>Gc,stack:()=>Yn,step:()=>pf,stridedSlice:()=>M3,string:()=>oX,sub:()=>vt,sum:()=>Tt,sumOutType:()=>VC,tan:()=>L3,tanh:()=>vc,tensor:()=>ai,tensor1d:()=>qr,tensor2d:()=>ou,tensor3d:()=>c_,tensor4d:()=>Sc,tensor5d:()=>MK,tensor6d:()=>LK,tensorScatterUpdate:()=>BK,tensor_util:()=>No,test_util:()=>EK,tidy:()=>Ie,tile:()=>Zi,time:()=>jDe,topk:()=>B3,train:()=>fh,transpose:()=>dr,truncatedNormal:()=>p_,unique:()=>V3,unregisterGradient:()=>dDe,unregisterKernel:()=>hDe,unsortedSegmentSum:()=>f_,unstack:()=>Bn,upcastType:()=>va,upperBound:()=>VK,util:()=>O,valueAndGrad:()=>DRe,valueAndGrads:()=>FRe,variable:()=>z3,variableGrads:()=>cK,version:()=>vht,version_converter:()=>gWe,version_core:()=>rPe,version_cpu:()=>yGe,version_layers:()=>IO,version_wasm:()=>fht,version_webgl:()=>aYe,webgl:()=>oYe,webgl_util:()=>aQ,where:()=>Ss,whereAsync:()=>U3,zeros:()=>On,zerosLike:()=>Cr});var gAe=Object.create,TR=Object.defineProperty,yAe=Object.getOwnPropertyDescriptor,bAe=Object.getOwnPropertyNames,xAe=Object.getPrototypeOf,vAe=Object.prototype.hasOwnProperty,Jn=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),ir=(r,t)=>{for(var n in t)TR(r,n,{get:t[n],enumerable:!0})},wAe=(r,t,n,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of bAe(t))!vAe.call(r,i)&&i!==n&&TR(r,i,{get:()=>t[i],enumerable:!(s=yAe(t,i))||s.enumerable});return r},Oc=(r,t,n)=>(n=r!=null?gAe(xAe(r)):{},wAe(!r||!r.__esModule?TR(n,"default",{value:r,enumerable:!0}):n,r)),SAe=Jn((r,t)=>{t.exports=s;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function s(N,D,F){this.low=N|0,this.high=D|0,this.unsigned=!!F}s.prototype.__isLong__,Object.defineProperty(s.prototype,"__isLong__",{value:!0});function i(N){return(N&&N.__isLong__)===!0}s.isLong=i;var a={},o={};function u(N,D){var F,P,G;return D?(N>>>=0,(G=0<=N&&N<256)&&(P=o[N],P)?P:(F=c(N,(N|0)<0?-1:0,!0),G&&(o[N]=F),F)):(N|=0,(G=-128<=N&&N<128)&&(P=a[N],P)?P:(F=c(N,N<0?-1:0,!1),G&&(a[N]=F),F))}s.fromInt=u;function l(N,D){if(isNaN(N))return D?v:w;if(D){if(N<0)return v;if(N>=y)return _}else{if(N<=-9223372036854776e3)return A;if(N+1>=b)return I}return N<0?l(-N,D).neg():c(N%g|0,N/g|0,D)}s.fromNumber=l;function c(N,D,F){return new s(N,D,F)}s.fromBits=c;var h=Math.pow;function d(N,D,F){if(N.length===0)throw Error("empty string");if(N==="NaN"||N==="Infinity"||N==="+Infinity"||N==="-Infinity")return w;if(typeof D=="number"?(F=D,D=!1):D=!!D,F=F||10,F<2||36<F)throw RangeError("radix");var P;if((P=N.indexOf("-"))>0)throw Error("interior hyphen");if(P===0)return d(N.substring(1),D,F).neg();for(var G=l(h(F,8)),Y=w,Z=0;Z<N.length;Z+=8){var ee=Math.min(8,N.length-Z),se=parseInt(N.substring(Z,Z+ee),F);if(ee<8){var re=l(h(F,ee));Y=Y.mul(re).add(l(se))}else Y=Y.mul(G),Y=Y.add(l(se))}return Y.unsigned=D,Y}s.fromString=d;function p(N,D){return typeof N=="number"?l(N,D):typeof N=="string"?d(N,D):c(N.low,N.high,typeof D=="boolean"?D:N.unsigned)}s.fromValue=p;var f=65536,m=1<<24,g=f*f,y=g*g,b=y/2,x=u(m),w=u(0);s.ZERO=w;var v=u(0,!0);s.UZERO=v;var S=u(1);s.ONE=S;var E=u(1,!0);s.UONE=E;var C=u(-1);s.NEG_ONE=C;var I=c(-1,2147483647,!1);s.MAX_VALUE=I;var _=c(-1,-1,!0);s.MAX_UNSIGNED_VALUE=_;var A=c(0,-2147483648,!1);s.MIN_VALUE=A;var k=s.prototype;k.toInt=function(){return this.unsigned?this.low>>>0:this.low},k.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},k.toString=function(N){if(N=N||10,N<2||36<N)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(A)){var D=l(N),F=this.div(D),P=F.mul(D).sub(this);return F.toString(N)+P.toInt().toString(N)}else return"-"+this.neg().toString(N);for(var G=l(h(N,6),this.unsigned),Y=this,Z="";;){var ee=Y.div(G),se=Y.sub(ee.mul(G)).toInt()>>>0,re=se.toString(N);if(Y=ee,Y.isZero())return re+Z;for(;re.length<6;)re="0"+re;Z=""+re+Z}},k.getHighBits=function(){return this.high},k.getHighBitsUnsigned=function(){return this.high>>>0},k.getLowBits=function(){return this.low},k.getLowBitsUnsigned=function(){return this.low>>>0},k.getNumBitsAbs=function(){if(this.isNegative())return this.eq(A)?64:this.neg().getNumBitsAbs();for(var N=this.high!=0?this.high:this.low,D=31;D>0&&!(N&1<<D);D--);return this.high!=0?D+33:D+1},k.isZero=function(){return this.high===0&&this.low===0},k.eqz=k.isZero,k.isNegative=function(){return!this.unsigned&&this.high<0},k.isPositive=function(){return this.unsigned||this.high>=0},k.isOdd=function(){return(this.low&1)===1},k.isEven=function(){return(this.low&1)===0},k.equals=function(N){return i(N)||(N=p(N)),this.unsigned!==N.unsigned&&this.high>>>31===1&&N.high>>>31===1?!1:this.high===N.high&&this.low===N.low},k.eq=k.equals,k.notEquals=function(N){return!this.eq(N)},k.neq=k.notEquals,k.ne=k.notEquals,k.lessThan=function(N){return this.comp(N)<0},k.lt=k.lessThan,k.lessThanOrEqual=function(N){return this.comp(N)<=0},k.lte=k.lessThanOrEqual,k.le=k.lessThanOrEqual,k.greaterThan=function(N){return this.comp(N)>0},k.gt=k.greaterThan,k.greaterThanOrEqual=function(N){return this.comp(N)>=0},k.gte=k.greaterThanOrEqual,k.ge=k.greaterThanOrEqual,k.compare=function(N){if(i(N)||(N=p(N)),this.eq(N))return 0;var D=this.isNegative(),F=N.isNegative();return D&&!F?-1:!D&&F?1:this.unsigned?N.high>>>0>this.high>>>0||N.high===this.high&&N.low>>>0>this.low>>>0?-1:1:this.sub(N).isNegative()?-1:1},k.comp=k.compare,k.negate=function(){return!this.unsigned&&this.eq(A)?A:this.not().add(S)},k.neg=k.negate,k.add=function(N){i(N)||(N=p(N));var D=this.high>>>16,F=this.high&65535,P=this.low>>>16,G=this.low&65535,Y=N.high>>>16,Z=N.high&65535,ee=N.low>>>16,se=N.low&65535,re=0,J=0,le=0,he=0;return he+=G+se,le+=he>>>16,he&=65535,le+=P+ee,J+=le>>>16,le&=65535,J+=F+Z,re+=J>>>16,J&=65535,re+=D+Y,re&=65535,c(le<<16|he,re<<16|J,this.unsigned)},k.subtract=function(N){return i(N)||(N=p(N)),this.add(N.neg())},k.sub=k.subtract,k.multiply=function(N){if(this.isZero())return w;if(i(N)||(N=p(N)),n){var D=n.mul(this.low,this.high,N.low,N.high);return c(D,n.get_high(),this.unsigned)}if(N.isZero())return w;if(this.eq(A))return N.isOdd()?A:w;if(N.eq(A))return this.isOdd()?A:w;if(this.isNegative())return N.isNegative()?this.neg().mul(N.neg()):this.neg().mul(N).neg();if(N.isNegative())return this.mul(N.neg()).neg();if(this.lt(x)&&N.lt(x))return l(this.toNumber()*N.toNumber(),this.unsigned);var F=this.high>>>16,P=this.high&65535,G=this.low>>>16,Y=this.low&65535,Z=N.high>>>16,ee=N.high&65535,se=N.low>>>16,re=N.low&65535,J=0,le=0,he=0,xe=0;return xe+=Y*re,he+=xe>>>16,xe&=65535,he+=G*re,le+=he>>>16,he&=65535,he+=Y*se,le+=he>>>16,he&=65535,le+=P*re,J+=le>>>16,le&=65535,le+=G*se,J+=le>>>16,le&=65535,le+=Y*ee,J+=le>>>16,le&=65535,J+=F*re+P*se+G*ee+Y*Z,J&=65535,c(he<<16|xe,J<<16|le,this.unsigned)},k.mul=k.multiply,k.divide=function(N){if(i(N)||(N=p(N)),N.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&N.low===-1&&N.high===-1)return this;var D=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,N.low,N.high);return c(D,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?v:w;var F,P,G;if(this.unsigned){if(N.unsigned||(N=N.toUnsigned()),N.gt(this))return v;if(N.gt(this.shru(1)))return E;G=v}else{if(this.eq(A)){if(N.eq(S)||N.eq(C))return A;if(N.eq(A))return S;var Y=this.shr(1);return F=Y.div(N).shl(1),F.eq(w)?N.isNegative()?S:C:(P=this.sub(N.mul(F)),G=F.add(P.div(N)),G)}else if(N.eq(A))return this.unsigned?v:w;if(this.isNegative())return N.isNegative()?this.neg().div(N.neg()):this.neg().div(N).neg();if(N.isNegative())return this.div(N.neg()).neg();G=w}for(P=this;P.gte(N);){F=Math.max(1,Math.floor(P.toNumber()/N.toNumber()));for(var Z=Math.ceil(Math.log(F)/Math.LN2),ee=Z<=48?1:h(2,Z-48),se=l(F),re=se.mul(N);re.isNegative()||re.gt(P);)F-=ee,se=l(F,this.unsigned),re=se.mul(N);se.isZero()&&(se=S),G=G.add(se),P=P.sub(re)}return G},k.div=k.divide,k.modulo=function(N){if(i(N)||(N=p(N)),n){var D=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,N.low,N.high);return c(D,n.get_high(),this.unsigned)}return this.sub(this.div(N).mul(N))},k.mod=k.modulo,k.rem=k.modulo,k.not=function(){return c(~this.low,~this.high,this.unsigned)},k.and=function(N){return i(N)||(N=p(N)),c(this.low&N.low,this.high&N.high,this.unsigned)},k.or=function(N){return i(N)||(N=p(N)),c(this.low|N.low,this.high|N.high,this.unsigned)},k.xor=function(N){return i(N)||(N=p(N)),c(this.low^N.low,this.high^N.high,this.unsigned)},k.shiftLeft=function(N){return i(N)&&(N=N.toInt()),(N&=63)===0?this:N<32?c(this.low<<N,this.high<<N|this.low>>>32-N,this.unsigned):c(0,this.low<<N-32,this.unsigned)},k.shl=k.shiftLeft,k.shiftRight=function(N){return i(N)&&(N=N.toInt()),(N&=63)===0?this:N<32?c(this.low>>>N|this.high<<32-N,this.high>>N,this.unsigned):c(this.high>>N-32,this.high>=0?0:-1,this.unsigned)},k.shr=k.shiftRight,k.shiftRightUnsigned=function(N){if(i(N)&&(N=N.toInt()),N&=63,N===0)return this;var D=this.high;if(N<32){var F=this.low;return c(F>>>N|D<<32-N,D>>>N,this.unsigned)}else return N===32?c(D,0,this.unsigned):c(D>>>N-32,0,this.unsigned)},k.shru=k.shiftRightUnsigned,k.shr_u=k.shiftRightUnsigned,k.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},k.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},k.toBytes=function(N){return N?this.toBytesLE():this.toBytesBE()},k.toBytesLE=function(){var N=this.high,D=this.low;return[D&255,D>>>8&255,D>>>16&255,D>>>24,N&255,N>>>8&255,N>>>16&255,N>>>24]},k.toBytesBE=function(){var N=this.high,D=this.low;return[N>>>24,N>>>16&255,N>>>8&255,N&255,D>>>24,D>>>16&255,D>>>8&255,D&255]},s.fromBytes=function(N,D,F){return F?s.fromBytesLE(N,D):s.fromBytesBE(N,D)},s.fromBytesLE=function(N,D){return new s(N[0]|N[1]<<8|N[2]<<16|N[3]<<24,N[4]|N[5]<<8|N[6]<<16|N[7]<<24,D)},s.fromBytesBE=function(N,D){return new s(N[4]<<24|N[5]<<16|N[6]<<8|N[7],N[0]<<24|N[1]<<16|N[2]<<8|N[3],D)}}),CAe=Jn(()=>{}),_Ae=Jn(()=>{}),EAe=Jn((r,t)=>{(function(n,s,i){function a(c){var h=this,d=l();h.next=function(){var p=2091639*h.s0+h.c*23283064365386963e-26;return h.s0=h.s1,h.s1=h.s2,h.s2=p-(h.c=p|0)},h.c=1,h.s0=d(" "),h.s1=d(" "),h.s2=d(" "),h.s0-=d(c),h.s0<0&&(h.s0+=1),h.s1-=d(c),h.s1<0&&(h.s1+=1),h.s2-=d(c),h.s2<0&&(h.s2+=1),d=null}function o(c,h){return h.c=c.c,h.s0=c.s0,h.s1=c.s1,h.s2=c.s2,h}function u(c,h){var d=new a(c),p=h&&h.state,f=d.next;return f.int32=function(){return d.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,p&&(typeof p=="object"&&o(p,d),f.state=function(){return o(d,{})}),f}function l(){var c=4022871197,h=function(d){d=String(d);for(var p=0;p<d.length;p++){c+=d.charCodeAt(p);var f=.02519603282416938*c;c=f>>>0,f-=c,f*=c,c=f>>>0,f-=c,c+=f*4294967296}return(c>>>0)*23283064365386963e-26};return h}s&&s.exports?s.exports=u:i&&i.amd?i(function(){return u}):this.alea=u})(r,typeof t=="object"&&t,typeof define=="function"&&define)}),IAe=Jn((r,t)=>{(function(n,s,i){function a(l){var c=this,h="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var p=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^p^p>>>8},l===(l|0)?c.x=l:h+=l;for(var d=0;d<h.length+64;d++)c.x^=h.charCodeAt(d)|0,c.next()}function o(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c}function u(l,c){var h=new a(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var f=h.next()>>>11,m=(h.next()>>>0)/4294967296,g=(f+m)/(1<<21);while(g===0);return g},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&o(d,h),p.state=function(){return o(h,{})}),p}s&&s.exports?s.exports=u:i&&i.amd?i(function(){return u}):this.xor128=u})(r,typeof t=="object"&&t,typeof define=="function"&&define)}),kAe=Jn((r,t)=>{(function(n,s,i){function a(l){var c=this,h="";c.next=function(){var p=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(p^p<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,l===(l|0)?c.x=l:h+=l;for(var d=0;d<h.length+64;d++)c.x^=h.charCodeAt(d)|0,d==h.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function o(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c.v=l.v,c.d=l.d,c}function u(l,c){var h=new a(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var f=h.next()>>>11,m=(h.next()>>>0)/4294967296,g=(f+m)/(1<<21);while(g===0);return g},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&o(d,h),p.state=function(){return o(h,{})}),p}s&&s.exports?s.exports=u:i&&i.amd?i(function(){return u}):this.xorwow=u})(r,typeof t=="object"&&t,typeof define=="function"&&define)}),NAe=Jn((r,t)=>{(function(n,s,i){function a(l){var c=this;c.next=function(){var d=c.x,p=c.i,f,m;return f=d[p],f^=f>>>7,m=f^f<<24,f=d[p+1&7],m^=f^f>>>10,f=d[p+3&7],m^=f^f>>>3,f=d[p+4&7],m^=f^f<<7,f=d[p+7&7],f=f^f<<13,m^=f^f<<9,d[p]=m,c.i=p+1&7,m};function h(d,p){var f,m=[];if(p===(p|0))m[0]=p;else for(p=""+p,f=0;f<p.length;++f)m[f&7]=m[f&7]<<15^p.charCodeAt(f)+m[f+1&7]<<13;for(;m.length<8;)m.push(0);for(f=0;f<8&&m[f]===0;++f);for(f==8?m[7]=-1:m[f],d.x=m,d.i=0,f=256;f>0;--f)d.next()}h(c,l)}function o(l,c){return c.x=l.x.slice(),c.i=l.i,c}function u(l,c){l==null&&(l=+new Date);var h=new a(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var f=h.next()>>>11,m=(h.next()>>>0)/4294967296,g=(f+m)/(1<<21);while(g===0);return g},p.int32=h.next,p.quick=p,d&&(d.x&&o(d,h),p.state=function(){return o(h,{})}),p}s&&s.exports?s.exports=u:i&&i.amd?i(function(){return u}):this.xorshift7=u})(r,typeof t=="object"&&t,typeof define=="function"&&define)}),TAe=Jn((r,t)=>{(function(n,s,i){function a(l){var c=this;c.next=function(){var d=c.w,p=c.X,f=c.i,m,g;return c.w=d=d+1640531527|0,g=p[f+34&127],m=p[f=f+1&127],g^=g<<13,m^=m<<17,g^=g>>>15,m^=m>>>12,g=p[f]=g^m,c.i=f,g+(d^d>>>16)|0};function h(d,p){var f,m,g,y,b,x=[],w=128;for(p===(p|0)?(m=p,p=null):(p=p+"\0",m=0,w=Math.max(w,p.length)),g=0,y=-32;y<w;++y)p&&(m^=p.charCodeAt((y+32)%p.length)),y===0&&(b=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,y>=0&&(b=b+1640531527|0,f=x[y&127]^=m+b,g=f==0?g+1:0);for(g>=128&&(x[(p&&p.length||0)&127]=-1),g=127,y=4*128;y>0;--y)m=x[g+34&127],f=x[g=g+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,x[g]=m^f;d.w=b,d.X=x,d.i=g}h(c,l)}function o(l,c){return c.i=l.i,c.w=l.w,c.X=l.X.slice(),c}function u(l,c){l==null&&(l=+new Date);var h=new a(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var f=h.next()>>>11,m=(h.next()>>>0)/4294967296,g=(f+m)/(1<<21);while(g===0);return g},p.int32=h.next,p.quick=p,d&&(d.X&&o(d,h),p.state=function(){return o(h,{})}),p}s&&s.exports?s.exports=u:i&&i.amd?i(function(){return u}):this.xor4096=u})(r,typeof t=="object"&&t,typeof define=="function"&&define)}),AAe=Jn((r,t)=>{(function(n,s,i){function a(l){var c=this,h="";c.next=function(){var p=c.b,f=c.c,m=c.d,g=c.a;return p=p<<25^p>>>7^f,f=f-m|0,m=m<<24^m>>>8^g,g=g-p|0,c.b=p=p<<20^p>>>12^f,c.c=f=f-m|0,c.d=m<<16^f>>>16^g,c.a=g-p|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,l===Math.floor(l)?(c.a=l/4294967296|0,c.b=l|0):h+=l;for(var d=0;d<h.length+20;d++)c.b^=h.charCodeAt(d)|0,c.next()}function o(l,c){return c.a=l.a,c.b=l.b,c.c=l.c,c.d=l.d,c}function u(l,c){var h=new a(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var f=h.next()>>>11,m=(h.next()>>>0)/4294967296,g=(f+m)/(1<<21);while(g===0);return g},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&o(d,h),p.state=function(){return o(h,{})}),p}s&&s.exports?s.exports=u:i&&i.amd?i(function(){return u}):this.tychei=u})(r,typeof t=="object"&&t,typeof define=="function"&&define)}),DAe=Jn(()=>{}),FAe=Jn((r,t)=>{(function(n,s,i){var a=256,o=6,u=52,l="random",c=i.pow(a,o),h=i.pow(2,u),d=h*2,p=a-1,f;function m(S,E,C){var I=[];E=E==!0?{entropy:!0}:E||{};var _=x(b(E.entropy?[S,v(s)]:S??w(),3),I),A=new g(I),k=function(){for(var N=A.g(o),D=c,F=0;N<h;)N=(N+F)*a,D*=a,F=A.g(1);for(;N>=d;)N/=2,D/=2,F>>>=1;return(N+F)/D};return k.int32=function(){return A.g(4)|0},k.quick=function(){return A.g(4)/4294967296},k.double=k,x(v(A.S),s),(E.pass||C||function(N,D,F,P){return P&&(P.S&&y(P,A),N.state=function(){return y(A,{})}),F?(i[l]=N,D):N})(k,_,"global"in E?E.global:this==i,E.state)}function g(S){var E,C=S.length,I=this,_=0,A=I.i=I.j=0,k=I.S=[];for(C||(S=[C++]);_<a;)k[_]=_++;for(_=0;_<a;_++)k[_]=k[A=p&A+S[_%C]+(E=k[_])],k[A]=E;(I.g=function(N){for(var D,F=0,P=I.i,G=I.j,Y=I.S;N--;)D=Y[P=p&P+1],F=F*a+Y[p&(Y[P]=Y[G=p&G+D])+(Y[G]=D)];return I.i=P,I.j=G,F})(a)}function y(S,E){return E.i=S.i,E.j=S.j,E.S=S.S.slice(),E}function b(S,E){var C=[],I=typeof S,_;if(E&&I=="object")for(_ in S)try{C.push(b(S[_],E-1))}catch{}return C.length?C:I=="string"?S:S+"\0"}function x(S,E){for(var C=S+"",I,_=0;_<C.length;)E[p&_]=p&(I^=E[p&_]*19)+C.charCodeAt(_++);return v(E)}function w(){try{var S;return f&&(S=f.randomBytes)?S=S(a):(S=new Uint8Array(a),(n.crypto||n.msCrypto).getRandomValues(S)),v(S)}catch{var E=n.navigator,C=E&&E.plugins;return[+new Date,n,C,n.screen,v(s)]}}function v(S){return String.fromCharCode.apply(0,S)}if(x(i.random(),s),typeof t=="object"&&t.exports){t.exports=m;try{f=DAe()}catch{}}else typeof define=="function"&&define.amd?define(function(){return m}):i["seed"+l]=m})(typeof self<"u"?self:r,[],Math)}),SC=Jn((r,t)=>{var n=EAe(),s=IAe(),i=kAe(),a=NAe(),o=TAe(),u=AAe(),l=FAe();l.alea=n,l.xor128=s,l.xorwow=i,l.xorshift7=a,l.xor4096=o,l.tychei=u,t.exports=l}),sq=Jn(()=>{}),AR=Jn(()=>{}),iq=Jn(()=>{}),$Ae=Jn(()=>{}),RAe=Jn(()=>{}),OAe=Jn(()=>{}),MAe=Jn((r,t)=>{var n=(()=>{var s=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(s=s||__filename),function(i){i=i||{};function a(){return Z.buffer!=Ve&&Me(Z.buffer),$e}function o(){return Z.buffer!=Ve&&Me(Z.buffer),Ae}function u(){return Z.buffer!=Ve&&Me(Z.buffer),Te}function l(){return Z.buffer!=Ve&&Me(Z.buffer),Ue}function c(){return Z.buffer!=Ve&&Me(Z.buffer),qe}var h=typeof i<"u"?i:{},d,p;h.ready=new Promise(function(me,Pe){d=me,p=Pe});var f;typeof process<"u"&&process.listeners&&(f={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var m=Object.assign({},h),g=(me,Pe)=>{throw Pe},y=typeof window=="object",b=typeof importScripts=="function",x=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",w=h.ENVIRONMENT_IS_PTHREAD||!1,v="";function S(me){return h.locateFile?h.locateFile(me,v):v+me}var E,C,I;function _(me){me instanceof Ze||P("exiting due to exception: "+me)}if(x){var A=AR(),k=iq();b?v=k.dirname(v)+"/":v=__dirname+"/",E=(Pe,ct)=>(Pe=V(Pe)?new URL(Pe):k.normalize(Pe),A.readFileSync(Pe,ct?void 0:"utf8")),I=Pe=>{var ct=E(Pe,!0);return ct.buffer||(ct=new Uint8Array(ct)),ct},C=(Pe,ct,Ht)=>{Pe=V(Pe)?new URL(Pe):k.normalize(Pe),A.readFile(Pe,function(Yt,tr){Yt?Ht(Yt):ct(tr.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(Pe){if(!(Pe instanceof Ze))throw Pe}),process.on("unhandledRejection",function(Pe){throw Pe}),g=(Pe,ct)=>{if(Oe())throw process.exitCode=Pe,ct;_(ct),process.exit(Pe)},h.inspect=function(){return"[Emscripten Module object]"};let me;try{me=$Ae()}catch(Pe){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Pe}global.Worker=me.Worker}else(y||b)&&(b?v=self.location.href:typeof document<"u"&&document.currentScript&&(v=document.currentScript.src),typeof s<"u"&&s&&(v=s),v.indexOf("blob:")!==0?v=v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):v="",x||(E=me=>{var Pe=new XMLHttpRequest;return Pe.open("GET",me,!1),Pe.send(null),Pe.responseText},b&&(I=me=>{var Pe=new XMLHttpRequest;return Pe.open("GET",me,!1),Pe.responseType="arraybuffer",Pe.send(null),new Uint8Array(Pe.response)}),C=(me,Pe,ct)=>{var Ht=new XMLHttpRequest;Ht.open("GET",me,!0),Ht.responseType="arraybuffer",Ht.onload=()=>{if(Ht.status==200||Ht.status==0&&Ht.response){Pe(Ht.response);return}ct()},Ht.onerror=ct,Ht.send(null)}));x&&typeof performance>"u"&&(global.performance=RAe().performance);var N=console.log.bind(console),D=console.warn.bind(console);x&&(N=me=>A.writeSync(1,me+`
`),D=me=>A.writeSync(2,me+`
`));var F=h.print||N,P=h.printErr||D;Object.assign(h,m),m=null,h.arguments&&h.arguments,h.thisProgram&&h.thisProgram,h.quit&&(g=h.quit);var G;h.wasmBinary&&(G=h.wasmBinary);var Y=h.noExitRuntime||!0;typeof WebAssembly!="object"&&Gr("no native wasm support detected");var Z,ee,se=!1,re;function J(me,Pe){me||Gr(Pe)}var le=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function he(me,Pe,ct){Pe>>>=0;for(var Ht=Pe+ct,Yt=Pe;me[Yt]&&!(Yt>=Ht);)++Yt;if(Yt-Pe>16&&me.buffer&&le)return le.decode(me.buffer instanceof SharedArrayBuffer?me.slice(Pe,Yt):me.subarray(Pe,Yt));for(var tr="";Pe<Yt;){var wt=me[Pe++];if(!(wt&128)){tr+=String.fromCharCode(wt);continue}var Ft=me[Pe++]&63;if((wt&224)==192){tr+=String.fromCharCode((wt&31)<<6|Ft);continue}var Ir=me[Pe++]&63;if((wt&240)==224?wt=(wt&15)<<12|Ft<<6|Ir:wt=(wt&7)<<18|Ft<<12|Ir<<6|me[Pe++]&63,wt<65536)tr+=String.fromCharCode(wt);else{var gi=wt-65536;tr+=String.fromCharCode(55296|gi>>10,56320|gi&1023)}}return tr}function xe(me,Pe){return me>>>=0,me?he(o(),me,Pe):""}function Fe(me,Pe,ct,Ht){if(ct>>>=0,!(Ht>0))return 0;for(var Yt=ct,tr=ct+Ht-1,wt=0;wt<me.length;++wt){var Ft=me.charCodeAt(wt);if(Ft>=55296&&Ft<=57343){var Ir=me.charCodeAt(++wt);Ft=65536+((Ft&1023)<<10)|Ir&1023}if(Ft<=127){if(ct>=tr)break;Pe[ct++>>>0]=Ft}else if(Ft<=2047){if(ct+1>=tr)break;Pe[ct++>>>0]=192|Ft>>6,Pe[ct++>>>0]=128|Ft&63}else if(Ft<=65535){if(ct+2>=tr)break;Pe[ct++>>>0]=224|Ft>>12,Pe[ct++>>>0]=128|Ft>>6&63,Pe[ct++>>>0]=128|Ft&63}else{if(ct+3>=tr)break;Pe[ct++>>>0]=240|Ft>>18,Pe[ct++>>>0]=128|Ft>>12&63,Pe[ct++>>>0]=128|Ft>>6&63,Pe[ct++>>>0]=128|Ft&63}}return Pe[ct>>>0]=0,ct-Yt}function Le(me,Pe,ct){return Fe(me,o(),Pe,ct)}var Ve,$e,Ae,Te,Ue,qe;w&&(Ve=h.buffer);function Me(me){Ve=me,h.HEAP8=$e=new Int8Array(me),h.HEAP16=new Int16Array(me),h.HEAP32=Te=new Int32Array(me),h.HEAPU8=Ae=new Uint8Array(me),h.HEAPU16=new Uint16Array(me),h.HEAPU32=Ue=new Uint32Array(me),h.HEAPF32=new Float32Array(me),h.HEAPF64=qe=new Float64Array(me)}var ie=h.INITIAL_MEMORY||16777216;if(w)Z=h.wasmMemory,Ve=h.buffer;else if(h.wasmMemory)Z=h.wasmMemory;else if(Z=new WebAssembly.Memory({initial:ie/65536,maximum:65536,shared:!0}),!(Z.buffer instanceof SharedArrayBuffer))throw P("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),x&&P("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Z&&(Ve=Z.buffer),ie=Ve.byteLength,Me(Ve);var K,pe=[],_e=[],We=[];function Oe(){return Y}function nt(){if(h.preRun)for(typeof h.preRun=="function"&&(h.preRun=[h.preRun]);h.preRun.length;)Et(h.preRun.shift());ze(pe)}function rt(){!w&&ze(_e)}function pt(){if(!w){if(h.postRun)for(typeof h.postRun=="function"&&(h.postRun=[h.postRun]);h.postRun.length;)Mt(h.postRun.shift());ze(We)}}function Et(me){pe.unshift(me)}function ht(me){_e.unshift(me)}function Mt(me){We.unshift(me)}var it=0,kt=null;function Lt(me){it++,h.monitorRunDependencies&&h.monitorRunDependencies(it)}function wn(me){if(it--,h.monitorRunDependencies&&h.monitorRunDependencies(it),it==0&&kt){var Pe=kt;kt=null,Pe()}}function Gr(me){h.onAbort&&h.onAbort(me),me="Aborted("+me+")",P(me),se=!0,re=1,me+=". Build with -sASSERTIONS for more info.";var Pe=new WebAssembly.RuntimeError(me);throw p(Pe),Pe}var lr="data:application/octet-stream;base64,";function Pr(me){return me.startsWith(lr)}function V(me){return me.startsWith("file://")}var H;H="tfjs-backend-wasm-threaded-simd.wasm",Pr(H)||(H=S(H));function ae(me){try{if(me==H&&G)return new Uint8Array(G);if(I)return I(me);throw"both async and sync fetching of the wasm failed"}catch(Pe){Gr(Pe)}}function ce(){if(!G&&(y||b)){if(typeof fetch=="function"&&!V(H))return fetch(H,{credentials:"same-origin"}).then(function(me){if(!me.ok)throw"failed to load wasm binary file at '"+H+"'";return me.arrayBuffer()}).catch(function(){return ae(H)});if(C)return new Promise(function(me,Pe){C(H,function(ct){me(new Uint8Array(ct))},Pe)})}return Promise.resolve().then(function(){return ae(H)})}function ve(){var me={env:ty,wasi_snapshot_preview1:ty};function Pe(wt,Ft){var Ir=wt.exports;if(h.asm=Ir,br(h.asm._emscripten_tls_init),K=h.asm.__indirect_function_table,ht(h.asm.__wasm_call_ctors),ee=Ft,!w){var gi=X.unusedWorkers.length;X.unusedWorkers.forEach(function(lo){X.loadWasmModuleToWorker(lo,function(){--gi||wn()})})}}w||Lt();function ct(wt){Pe(wt.instance,wt.module)}function Ht(wt){return ce().then(function(Ft){return WebAssembly.instantiate(Ft,me)}).then(function(Ft){return Ft}).then(wt,function(Ft){P("failed to asynchronously prepare wasm: "+Ft),Gr(Ft)})}function Yt(){return!G&&typeof WebAssembly.instantiateStreaming=="function"&&!Pr(H)&&!V(H)&&!x&&typeof fetch=="function"?fetch(H,{credentials:"same-origin"}).then(function(wt){var Ft=WebAssembly.instantiateStreaming(wt,me);return Ft.then(ct,function(Ir){return P("wasm streaming compile failed: "+Ir),P("falling back to ArrayBuffer instantiation"),Ht(ct)})}):Ht(ct)}if(h.instantiateWasm)try{var tr=h.instantiateWasm(me,Pe);return tr}catch(wt){P("Module.instantiateWasm callback failed with error: "+wt),p(wt)}return Yt().catch(p),{}}var He={};function Ze(me){this.name="ExitStatus",this.message="Program terminated with exit("+me+")",this.status=me}function dt(me){var Pe=X.pthreads[me];delete X.pthreads[me],Pe.terminate(),kf(me),X.runningWorkers.splice(X.runningWorkers.indexOf(Pe),1),Pe.pthread_ptr=0}function Bt(me){var Pe=X.pthreads[me];Pe.postMessage({cmd:"cancel"})}function Ut(me){var Pe=X.pthreads[me];J(Pe),X.returnWorkerToPool(Pe)}function Tr(me){var Pe=X.getNewWorker();if(!Pe)return 6;X.runningWorkers.push(Pe),X.pthreads[me.pthread_ptr]=Pe,Pe.pthread_ptr=me.pthread_ptr;var ct={cmd:"run",start_routine:me.startRoutine,arg:me.arg,pthread_ptr:me.pthread_ptr};return Pe.runPthread=()=>{x&&Pe.ref(),Pe.postMessage(ct,me.transferList),delete Pe.runPthread},Pe.loaded&&Pe.runPthread(),0}function $(me){if(w)return uo(1,1,me);re=me,Oe()||(X.terminateAllThreads(),h.onExit&&h.onExit(me),se=!0),g(me,new Ze(me))}function B(me,Pe){if(re=me,!Pe&&w)throw Ye(me),"unwind";$(me)}var z=B;function W(me){if(me instanceof Ze||me=="unwind")return re;g(1,me)}var X={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){w?X.initWorker():X.initMainThread()},initMainThread:function(){for(var me=8;me--;)X.allocateUnusedWorker()},initWorker:function(){Y=!1},setExitStatus:function(me){re=me},terminateAllThreads:function(){for(var me of Object.values(X.pthreads))X.returnWorkerToPool(me);for(var me of X.unusedWorkers)me.terminate();X.unusedWorkers=[]},returnWorkerToPool:function(me){var Pe=me.pthread_ptr;delete X.pthreads[Pe],X.unusedWorkers.push(me),X.runningWorkers.splice(X.runningWorkers.indexOf(me),1),me.pthread_ptr=0,x&&me.unref(),kf(Pe)},receiveObjectTransfer:function(me){},threadInitTLS:function(){X.tlsInitFunctions.forEach(me=>me())},loadWasmModuleToWorker:function(me,Pe){me.onmessage=tr=>{var wt=tr.data,Ft=wt.cmd;if(me.pthread_ptr&&(X.currentProxiedOperationCallerThread=me.pthread_ptr),wt.targetThread&&wt.targetThread!=eh()){var Ir=X.pthreads[wt.targetThread];Ir?Ir.postMessage(wt,wt.transferList):P('Internal error! Worker sent a message "'+Ft+'" to target pthread '+wt.targetThread+", but that thread no longer exists!"),X.currentProxiedOperationCallerThread=void 0;return}Ft==="processProxyingQueue"?Sf(wt.queue):Ft==="spawnThread"?Tr(wt):Ft==="cleanupThread"?Ut(wt.thread):Ft==="killThread"?dt(wt.thread):Ft==="cancelThread"?Bt(wt.thread):Ft==="loaded"?(me.loaded=!0,x&&me.unref(),Pe&&Pe(me),me.runPthread&&me.runPthread()):Ft==="print"?F("Thread "+wt.threadId+": "+wt.text):Ft==="printErr"?P("Thread "+wt.threadId+": "+wt.text):Ft==="alert"?alert("Thread "+wt.threadId+": "+wt.text):wt.target==="setimmediate"?me.postMessage(wt):Ft==="callHandler"?h[wt.handler](...wt.args):Ft&&P("worker sent an unknown command "+Ft),X.currentProxiedOperationCallerThread=void 0},me.onerror=tr=>{var wt="worker sent an error!";throw P(wt+" "+tr.filename+":"+tr.lineno+": "+tr.message),tr},x&&(me.on("message",function(tr){me.onmessage({data:tr})}),me.on("error",function(tr){me.onerror(tr)}),me.on("detachedExit",function(){}));var ct=[],Ht=["onExit","onAbort","print","printErr"];for(var Yt of Ht)h.hasOwnProperty(Yt)&&ct.push(Yt);me.postMessage({cmd:"load",handlers:ct,urlOrBlob:h.mainScriptUrlOrBlob||s,wasmMemory:Z,wasmModule:ee})},allocateUnusedWorker:function(){var me,Pe=S("tfjs-backend-wasm-threaded-simd.worker.js");me=new Worker(Pe),X.unusedWorkers.push(me)},getNewWorker:function(){return X.unusedWorkers.length==0&&(X.allocateUnusedWorker(),X.loadWasmModuleToWorker(X.unusedWorkers[0])),X.unusedWorkers.pop()}};h.PThread=X;function ze(me){for(;me.length>0;)me.shift()(h)}function Ge(){var me=eh(),Pe=u()[me+52>>>2],ct=u()[me+56>>>2],Ht=Pe-ct;ny(Pe,Ht),Wo(Pe)}h.establishStackSpace=Ge;function Ye(me){if(w)return uo(2,0,me);try{z(me)}catch(Pe){W(Pe)}}var Je=[];function At(me){var Pe=Je[me];return Pe||(me>=Je.length&&(Je.length=me+1),Je[me]=Pe=K.get(me)),Pe}function Er(me,Pe){var ct=At(me)(Pe);Oe()?X.setExitStatus(ct):th(ct)}h.invokeEntryPoint=Er;function br(me){X.tlsInitFunctions.push(me)}function Vn(me){Zv(me,!b,1,!y),X.threadInitTLS()}function Ia(me){w?postMessage({cmd:"cleanupThread",thread:me}):Ut(me)}function Tu(me,Pe,ct,Ht){return w?uo(3,1,me,Pe,ct,Ht):Ur(me,Pe,ct,Ht)}function Ur(me,Pe,ct,Ht){if(typeof SharedArrayBuffer>"u")return P("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Yt=[],tr=0;if(w&&(Yt.length===0||tr))return Tu(me,Pe,ct,Ht);var wt={startRoutine:ct,pthread_ptr:me,arg:Ht,transferList:Yt};return w?(wt.cmd="spawnThread",postMessage(wt,Yt),0):Tr(wt)}function ka(){return 65536}var Au=!0;function Jc(){return Au}function Sf(me){Atomics.store(u(),me>>2,1),eh()&&ry(me),Atomics.compareExchange(u(),me>>2,1,0)}h.executeNotifiedProxyingQueue=Sf;function K0(me,Pe,ct,Ht){if(me==Pe)setTimeout(()=>Sf(Ht));else if(w)postMessage({targetThread:me,cmd:"processProxyingQueue",queue:Ht});else{var Yt=X.pthreads[me];if(!Yt)return;Yt.postMessage({cmd:"processProxyingQueue",queue:Ht})}return 1}function X0(me,Pe,ct){return-1}function Uv(){Gr("")}function Ls(me){Ls.shown||(Ls.shown={}),Ls.shown[me]||(Ls.shown[me]=1,x&&(me="warning: "+me),P(me))}function Na(){x||b||Ls("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function Qc(){return Date.now()}function Cf(){return 4294901760}function Y0(){return Cf()}var _f;x?_f=()=>{var me=process.hrtime();return me[0]*1e3+me[1]/1e6}:_f=()=>performance.timeOrigin+performance.now();function Z0(me,Pe,ct){o().copyWithin(me>>>0,Pe>>>0,Pe+ct>>>0)}function Ta(){return x?OAe().cpus().length:navigator.hardwareConcurrency}function Wv(me){var Pe=Nf(),ct=me();return Wo(Pe),ct}function uo(me,Pe){var ct=arguments.length-2,Ht=arguments;return Wv(()=>{for(var Yt=ct,tr=Tf(Yt*8),wt=tr>>3,Ft=0;Ft<ct;Ft++){var Ir=Ht[2+Ft];c()[wt+Ft>>>0]=Ir}return Jv(me,Yt,tr,Pe)})}var Ri=[];function Ef(me,Pe,ct){Ri.length=Pe;for(var Ht=ct>>3,Yt=0;Yt<Pe;Yt++)Ri[Yt]=c()[Ht+Yt>>>0];var tr=me<0,wt=tr?He[-me-1]:If[me];return wt.apply(null,Ri)}function eE(me){try{return Z.grow(me-Ve.byteLength+65535>>>16),Me(Z.buffer),1}catch{}}function Gv(me){var Pe=o().length;if(me=me>>>0,me<=Pe)return!1;var ct=Cf();if(me>ct)return!1;let Ht=(Ir,gi)=>Ir+(gi-Ir%gi)%gi;for(var Yt=1;Yt<=4;Yt*=2){var tr=Pe*(1+.2/Yt);tr=Math.min(tr,me+100663296);var wt=Math.min(ct,Ht(Math.max(me,tr),65536)),Ft=eE(wt);if(Ft)return!0}return!1}function J0(){throw"unwind"}function Hv(me){return w?uo(4,1,me):52}function jv(me,Pe,ct,Ht,Yt){return w?uo(5,1,me,Pe,ct,Ht,Yt):70}var qv=[null,[],[]];function Kv(me,Pe){var ct=qv[me];Pe===0||Pe===10?((me===1?F:P)(he(ct,0)),ct.length=0):ct.push(Pe)}function Q0(me,Pe,ct,Ht){if(w)return uo(6,1,me,Pe,ct,Ht);for(var Yt=0,tr=0;tr<ct;tr++){var wt=l()[Pe>>>2],Ft=l()[Pe+4>>>2];Pe+=8;for(var Ir=0;Ir<Ft;Ir++)Kv(me,o()[wt+Ir>>>0]);Yt+=Ft}return l()[Ht>>>2]=Yt,0}function ey(me){var Pe=h["_"+me];return Pe}function Ks(me,Pe){a().set(me,Pe>>>0)}function Xv(me,Pe,ct,Ht,Yt){var tr={string:Ps=>{var la=0;if(Ps!=null&&Ps!==0){var ay=(Ps.length<<2)+1;la=Tf(ay),Le(Ps,la,ay)}return la},array:Ps=>{var la=Tf(Ps.length);return Ks(Ps,la),la}};function wt(Ps){return Pe==="string"?xe(Ps):Pe==="boolean"?!!Ps:Ps}var Ft=ey(me),Ir=[],gi=0;if(Ht)for(var lo=0;lo<Ht.length;lo++){var sy=tr[ct[lo]];sy?(gi===0&&(gi=Nf()),Ir[lo]=sy(Ht[lo])):Ir[lo]=Ht[lo]}var Ff=Ft.apply(null,Ir);function iy(Ps){return gi!==0&&Wo(gi),wt(Ps)}return Ff=iy(Ff),Ff}function Yv(me,Pe,ct,Ht){ct=ct||[];var Yt=ct.every(wt=>wt==="number"||wt==="boolean"),tr=Pe!=="string";return tr&&Yt&&!Ht?ey(me):function(){return Xv(me,Pe,ct,arguments)}}X.init();var If=[null,$,Ye,Tu,Hv,jv,Q0],ty={__emscripten_init_main_thread_js:Vn,__emscripten_thread_cleanup:Ia,__pthread_create_js:Ur,_emscripten_default_pthread_stack_size:ka,_emscripten_get_now_is_monotonic:Jc,_emscripten_notify_task_queue:K0,_emscripten_set_offscreencanvas_size:X0,abort:Uv,emscripten_check_blocking_allowed:Na,emscripten_date_now:Qc,emscripten_get_heap_max:Y0,emscripten_get_now:_f,emscripten_memcpy_big:Z0,emscripten_num_logical_cores:Ta,emscripten_receive_on_main_thread_js:Ef,emscripten_resize_heap:Gv,emscripten_unwind_to_js_event_loop:J0,exit:z,fd_close:Hv,fd_seek:jv,fd_write:Q0,memory:Z||h.wasmMemory};ve(),h.___wasm_call_ctors=function(){return(h.___wasm_call_ctors=h.asm.__wasm_call_ctors).apply(null,arguments)},h._init=function(){return(h._init=h.asm.init).apply(null,arguments)},h._init_with_threads_count=function(){return(h._init_with_threads_count=h.asm.init_with_threads_count).apply(null,arguments)},h._get_threads_count=function(){return(h._get_threads_count=h.asm.get_threads_count).apply(null,arguments)},h._register_tensor=function(){return(h._register_tensor=h.asm.register_tensor).apply(null,arguments)},h._dispose_data=function(){return(h._dispose_data=h.asm.dispose_data).apply(null,arguments)},h._dispose=function(){return(h._dispose=h.asm.dispose).apply(null,arguments)},h._Abs=function(){return(h._Abs=h.asm.Abs).apply(null,arguments)},h._Acos=function(){return(h._Acos=h.asm.Acos).apply(null,arguments)},h._Acosh=function(){return(h._Acosh=h.asm.Acosh).apply(null,arguments)},h._Add=function(){return(h._Add=h.asm.Add).apply(null,arguments)},h._AddN=function(){return(h._AddN=h.asm.AddN).apply(null,arguments)},h._All=function(){return(h._All=h.asm.All).apply(null,arguments)},h._Any=function(){return(h._Any=h.asm.Any).apply(null,arguments)},h._ArgMax=function(){return(h._ArgMax=h.asm.ArgMax).apply(null,arguments)},h._ArgMin=function(){return(h._ArgMin=h.asm.ArgMin).apply(null,arguments)},h._Asin=function(){return(h._Asin=h.asm.Asin).apply(null,arguments)},h._Asinh=function(){return(h._Asinh=h.asm.Asinh).apply(null,arguments)},h._Atan=function(){return(h._Atan=h.asm.Atan).apply(null,arguments)},h._Atan2=function(){return(h._Atan2=h.asm.Atan2).apply(null,arguments)},h._Atanh=function(){return(h._Atanh=h.asm.Atanh).apply(null,arguments)},h._AvgPool=function(){return(h._AvgPool=h.asm.AvgPool).apply(null,arguments)},h._AvgPool3D=function(){return(h._AvgPool3D=h.asm.AvgPool3D).apply(null,arguments)},h._AvgPool3DGrad=function(){return(h._AvgPool3DGrad=h.asm.AvgPool3DGrad).apply(null,arguments)},h._AvgPoolGrad=function(){return(h._AvgPoolGrad=h.asm.AvgPoolGrad).apply(null,arguments)},h._BatchMatMul=function(){return(h._BatchMatMul=h.asm.BatchMatMul).apply(null,arguments)},h._Bincount=function(){return(h._Bincount=h.asm.Bincount).apply(null,arguments)},h._BitwiseAnd=function(){return(h._BitwiseAnd=h.asm.BitwiseAnd).apply(null,arguments)},h._Ceil=function(){return(h._Ceil=h.asm.Ceil).apply(null,arguments)},h._ClipByValue=function(){return(h._ClipByValue=h.asm.ClipByValue).apply(null,arguments)},h._Conv2D=function(){return(h._Conv2D=h.asm.Conv2D).apply(null,arguments)},h._Conv2DBackpropInput=function(){return(h._Conv2DBackpropInput=h.asm.Conv2DBackpropInput).apply(null,arguments)},h._Conv3D=function(){return(h._Conv3D=h.asm.Conv3D).apply(null,arguments)},h._Conv3DBackpropFilterV2=function(){return(h._Conv3DBackpropFilterV2=h.asm.Conv3DBackpropFilterV2).apply(null,arguments)},h._Conv3DBackpropInputV2=function(){return(h._Conv3DBackpropInputV2=h.asm.Conv3DBackpropInputV2).apply(null,arguments)},h._Cos=function(){return(h._Cos=h.asm.Cos).apply(null,arguments)},h._Cosh=function(){return(h._Cosh=h.asm.Cosh).apply(null,arguments)},h._CropAndResize=function(){return(h._CropAndResize=h.asm.CropAndResize).apply(null,arguments)},h._Cumprod=function(){return(h._Cumprod=h.asm.Cumprod).apply(null,arguments)},h._Cumsum=function(){return(h._Cumsum=h.asm.Cumsum).apply(null,arguments)},h._DenseBincount=function(){return(h._DenseBincount=h.asm.DenseBincount).apply(null,arguments)},h._DepthToSpace=function(){return(h._DepthToSpace=h.asm.DepthToSpace).apply(null,arguments)},h._DepthwiseConv2dNative=function(){return(h._DepthwiseConv2dNative=h.asm.DepthwiseConv2dNative).apply(null,arguments)},h._Diag=function(){return(h._Diag=h.asm.Diag).apply(null,arguments)},h._Dilation2D=function(){return(h._Dilation2D=h.asm.Dilation2D).apply(null,arguments)},h._Dilation2DBackpropFilter=function(){return(h._Dilation2DBackpropFilter=h.asm.Dilation2DBackpropFilter).apply(null,arguments)},h._Dilation2DBackpropInput=function(){return(h._Dilation2DBackpropInput=h.asm.Dilation2DBackpropInput).apply(null,arguments)},h._Elu=function(){return(h._Elu=h.asm.Elu).apply(null,arguments)},h._EluGrad=function(){return(h._EluGrad=h.asm.EluGrad).apply(null,arguments)},h._Equal=function(){return(h._Equal=h.asm.Equal).apply(null,arguments)},h._Erf=function(){return(h._Erf=h.asm.Erf).apply(null,arguments)},h._Exp=function(){return(h._Exp=h.asm.Exp).apply(null,arguments)},h._Expm1=function(){return(h._Expm1=h.asm.Expm1).apply(null,arguments)},h._FlipLeftRight=function(){return(h._FlipLeftRight=h.asm.FlipLeftRight).apply(null,arguments)},h._Floor=function(){return(h._Floor=h.asm.Floor).apply(null,arguments)},h._FloorDiv=function(){return(h._FloorDiv=h.asm.FloorDiv).apply(null,arguments)},h._FusedBatchNorm=function(){return(h._FusedBatchNorm=h.asm.FusedBatchNorm).apply(null,arguments)},h._FusedConv2D=function(){return(h._FusedConv2D=h.asm.FusedConv2D).apply(null,arguments)},h._FusedDepthwiseConv2D=function(){return(h._FusedDepthwiseConv2D=h.asm.FusedDepthwiseConv2D).apply(null,arguments)},h._Gather=function(){return(h._Gather=h.asm.Gather).apply(null,arguments)},h._GatherNd=function(){return(h._GatherNd=h.asm.GatherNd).apply(null,arguments)},h._Greater=function(){return(h._Greater=h.asm.Greater).apply(null,arguments)},h._GreaterEqual=function(){return(h._GreaterEqual=h.asm.GreaterEqual).apply(null,arguments)},h._IsFinite=function(){return(h._IsFinite=h.asm.IsFinite).apply(null,arguments)},h._IsInf=function(){return(h._IsInf=h.asm.IsInf).apply(null,arguments)},h._IsNan=function(){return(h._IsNan=h.asm.IsNan).apply(null,arguments)},h._LRN=function(){return(h._LRN=h.asm.LRN).apply(null,arguments)},h._LRNGrad=function(){return(h._LRNGrad=h.asm.LRNGrad).apply(null,arguments)},h._LeakyRelu=function(){return(h._LeakyRelu=h.asm.LeakyRelu).apply(null,arguments)},h._Less=function(){return(h._Less=h.asm.Less).apply(null,arguments)},h._LessEqual=function(){return(h._LessEqual=h.asm.LessEqual).apply(null,arguments)},h._LinSpace=function(){return(h._LinSpace=h.asm.LinSpace).apply(null,arguments)},h._Log=function(){return(h._Log=h.asm.Log).apply(null,arguments)},h._Log1p=function(){return(h._Log1p=h.asm.Log1p).apply(null,arguments)},h._LogicalAnd=function(){return(h._LogicalAnd=h.asm.LogicalAnd).apply(null,arguments)},h._LogicalNot=function(){return(h._LogicalNot=h.asm.LogicalNot).apply(null,arguments)},h._LogicalOr=function(){return(h._LogicalOr=h.asm.LogicalOr).apply(null,arguments)},h._LogicalXor=function(){return(h._LogicalXor=h.asm.LogicalXor).apply(null,arguments)},h._Max=function(){return(h._Max=h.asm.Max).apply(null,arguments)},h._MaxPool=function(){return(h._MaxPool=h.asm.MaxPool).apply(null,arguments)},h._MaxPool3D=function(){return(h._MaxPool3D=h.asm.MaxPool3D).apply(null,arguments)},h._MaxPool3DGrad=function(){return(h._MaxPool3DGrad=h.asm.MaxPool3DGrad).apply(null,arguments)},h._MaxPoolGrad=function(){return(h._MaxPoolGrad=h.asm.MaxPoolGrad).apply(null,arguments)},h._MaxPoolWithArgmax=function(){return(h._MaxPoolWithArgmax=h.asm.MaxPoolWithArgmax).apply(null,arguments)},h._Maximum=function(){return(h._Maximum=h.asm.Maximum).apply(null,arguments)},h._Mean=function(){return(h._Mean=h.asm.Mean).apply(null,arguments)},h._Min=function(){return(h._Min=h.asm.Min).apply(null,arguments)},h._Minimum=function(){return(h._Minimum=h.asm.Minimum).apply(null,arguments)},h._MirrorPad=function(){return(h._MirrorPad=h.asm.MirrorPad).apply(null,arguments)},h._Mod=function(){return(h._Mod=h.asm.Mod).apply(null,arguments)},h._Multinomial=function(){return(h._Multinomial=h.asm.Multinomial).apply(null,arguments)},h._Multiply=function(){return(h._Multiply=h.asm.Multiply).apply(null,arguments)},h._Neg=function(){return(h._Neg=h.asm.Neg).apply(null,arguments)},h._NonMaxSuppressionV3=function(){return(h._NonMaxSuppressionV3=h.asm.NonMaxSuppressionV3).apply(null,arguments)},h._NonMaxSuppressionV4=function(){return(h._NonMaxSuppressionV4=h.asm.NonMaxSuppressionV4).apply(null,arguments)},h._NonMaxSuppressionV5=function(){return(h._NonMaxSuppressionV5=h.asm.NonMaxSuppressionV5).apply(null,arguments)},h._NotEqual=function(){return(h._NotEqual=h.asm.NotEqual).apply(null,arguments)},h._OneHot=function(){return(h._OneHot=h.asm.OneHot).apply(null,arguments)},h._PadV2=function(){return(h._PadV2=h.asm.PadV2).apply(null,arguments)},h._Pow=function(){return(h._Pow=h.asm.Pow).apply(null,arguments)},h._Prelu=function(){return(h._Prelu=h.asm.Prelu).apply(null,arguments)},h._Prod=function(){return(h._Prod=h.asm.Prod).apply(null,arguments)},h._RealDiv=function(){return(h._RealDiv=h.asm.RealDiv).apply(null,arguments)},h._Reciprocal=function(){return(h._Reciprocal=h.asm.Reciprocal).apply(null,arguments)},h._Relu=function(){return(h._Relu=h.asm.Relu).apply(null,arguments)},h._Relu6=function(){return(h._Relu6=h.asm.Relu6).apply(null,arguments)},h._ResizeBilinear=function(){return(h._ResizeBilinear=h.asm.ResizeBilinear).apply(null,arguments)},h._ResizeBilinearGrad=function(){return(h._ResizeBilinearGrad=h.asm.ResizeBilinearGrad).apply(null,arguments)},h._ResizeNearestNeighbor=function(){return(h._ResizeNearestNeighbor=h.asm.ResizeNearestNeighbor).apply(null,arguments)},h._ResizeNearestNeighborGrad=function(){return(h._ResizeNearestNeighborGrad=h.asm.ResizeNearestNeighborGrad).apply(null,arguments)},h._Reverse=function(){return(h._Reverse=h.asm.Reverse).apply(null,arguments)},h._RotateWithOffset=function(){return(h._RotateWithOffset=h.asm.RotateWithOffset).apply(null,arguments)},h._Round=function(){return(h._Round=h.asm.Round).apply(null,arguments)},h._Rsqrt=function(){return(h._Rsqrt=h.asm.Rsqrt).apply(null,arguments)},h._ScatterNd=function(){return(h._ScatterNd=h.asm.ScatterNd).apply(null,arguments)},h._SearchSorted=function(){return(h._SearchSorted=h.asm.SearchSorted).apply(null,arguments)},h._SelectV2=function(){return(h._SelectV2=h.asm.SelectV2).apply(null,arguments)},h._Selu=function(){return(h._Selu=h.asm.Selu).apply(null,arguments)},h._Sigmoid=function(){return(h._Sigmoid=h.asm.Sigmoid).apply(null,arguments)},h._Sign=function(){return(h._Sign=h.asm.Sign).apply(null,arguments)},h._Sin=function(){return(h._Sin=h.asm.Sin).apply(null,arguments)},h._Sinh=function(){return(h._Sinh=h.asm.Sinh).apply(null,arguments)},h._Softmax=function(){return(h._Softmax=h.asm.Softmax).apply(null,arguments)},h._Softplus=function(){return(h._Softplus=h.asm.Softplus).apply(null,arguments)},h._SparseFillEmptyRows=function(){return(h._SparseFillEmptyRows=h.asm.SparseFillEmptyRows).apply(null,arguments)},h._SparseReshape=function(){return(h._SparseReshape=h.asm.SparseReshape).apply(null,arguments)},h._SparseSegmentReduction=function(){return(h._SparseSegmentReduction=h.asm.SparseSegmentReduction).apply(null,arguments)},h._SparseToDense=function(){return(h._SparseToDense=h.asm.SparseToDense).apply(null,arguments)},h._Sqrt=function(){return(h._Sqrt=h.asm.Sqrt).apply(null,arguments)},h._Square=function(){return(h._Square=h.asm.Square).apply(null,arguments)},h._SquaredDifference=function(){return(h._SquaredDifference=h.asm.SquaredDifference).apply(null,arguments)},h._Step=function(){return(h._Step=h.asm.Step).apply(null,arguments)},h._StridedSlice=function(){return(h._StridedSlice=h.asm.StridedSlice).apply(null,arguments)},h._Sub=function(){return(h._Sub=h.asm.Sub).apply(null,arguments)},h._Sum=function(){return(h._Sum=h.asm.Sum).apply(null,arguments)},h._Tan=function(){return(h._Tan=h.asm.Tan).apply(null,arguments)},h._Tanh=function(){return(h._Tanh=h.asm.Tanh).apply(null,arguments)},h._TensorScatterUpdate=function(){return(h._TensorScatterUpdate=h.asm.TensorScatterUpdate).apply(null,arguments)},h._Tile=function(){return(h._Tile=h.asm.Tile).apply(null,arguments)},h._TopK=function(){return(h._TopK=h.asm.TopK).apply(null,arguments)},h._Transform=function(){return(h._Transform=h.asm.Transform).apply(null,arguments)},h._Transpose=function(){return(h._Transpose=h.asm.Transpose).apply(null,arguments)},h.__FusedMatMul=function(){return(h.__FusedMatMul=h.asm._FusedMatMul).apply(null,arguments)},h._malloc=function(){return(h._malloc=h.asm.malloc).apply(null,arguments)},h._free=function(){return(h._free=h.asm.free).apply(null,arguments)},h.__emscripten_tls_init=function(){return(h.__emscripten_tls_init=h.asm._emscripten_tls_init).apply(null,arguments)};var eh=h._pthread_self=function(){return(eh=h._pthread_self=h.asm.pthread_self).apply(null,arguments)};h.___errno_location=function(){return(h.___errno_location=h.asm.__errno_location).apply(null,arguments)};var Zv=h.__emscripten_thread_init=function(){return(Zv=h.__emscripten_thread_init=h.asm._emscripten_thread_init).apply(null,arguments)};h.__emscripten_thread_crashed=function(){return(h.__emscripten_thread_crashed=h.asm._emscripten_thread_crashed).apply(null,arguments)},h._emscripten_main_thread_process_queued_calls=function(){return(h._emscripten_main_thread_process_queued_calls=h.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},h._emscripten_main_browser_thread_id=function(){return(h._emscripten_main_browser_thread_id=h.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var Jv=h._emscripten_run_in_main_runtime_thread_js=function(){return(Jv=h._emscripten_run_in_main_runtime_thread_js=h.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};h._emscripten_dispatch_to_thread_=function(){return(h._emscripten_dispatch_to_thread_=h.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var ry=h.__emscripten_proxy_execute_task_queue=function(){return(ry=h.__emscripten_proxy_execute_task_queue=h.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},kf=h.__emscripten_thread_free_data=function(){return(kf=h.__emscripten_thread_free_data=h.asm._emscripten_thread_free_data).apply(null,arguments)},th=h.__emscripten_thread_exit=function(){return(th=h.__emscripten_thread_exit=h.asm._emscripten_thread_exit).apply(null,arguments)},ny=h._emscripten_stack_set_limits=function(){return(ny=h._emscripten_stack_set_limits=h.asm.emscripten_stack_set_limits).apply(null,arguments)},Nf=h.stackSave=function(){return(Nf=h.stackSave=h.asm.stackSave).apply(null,arguments)},Wo=h.stackRestore=function(){return(Wo=h.stackRestore=h.asm.stackRestore).apply(null,arguments)},Tf=h.stackAlloc=function(){return(Tf=h.stackAlloc=h.asm.stackAlloc).apply(null,arguments)};h.dynCall_iijjiiii=function(){return(h.dynCall_iijjiiii=h.asm.dynCall_iijjiiii).apply(null,arguments)},h.dynCall_jiji=function(){return(h.dynCall_jiji=h.asm.dynCall_jiji).apply(null,arguments)},h.keepRuntimeAlive=Oe,h.wasmMemory=Z,h.cwrap=Yv,h.ExitStatus=Ze,h.PThread=X;var Af;kt=function me(){Af||Qv(),Af||(kt=me)};function Qv(me){if(it>0)return;if(w){d(h),rt(),startWorker(h);return}if(nt(),it>0)return;function Pe(){Af||(Af=!0,h.calledRun=!0,!se&&(rt(),d(h),h.onRuntimeInitialized&&h.onRuntimeInitialized(),pt()))}h.setStatus?(h.setStatus("Running..."),setTimeout(function(){setTimeout(function(){h.setStatus("")},1),Pe()},1)):Pe()}if(h.preInit)for(typeof h.preInit=="function"&&(h.preInit=[h.preInit]);h.preInit.length>0;)h.preInit.pop()();Qv();var Df;f&&(Df={uncaughtException:process.listeners("uncaughtException").filter(function(me){return!f.uncaughtException.indexOf(me)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(me){return!f.unhandledRejection.indexOf(me)>-1})});var kl;if(typeof WasmBackendModule<"u")kl=WasmBackendModule;else if(typeof i<"u")kl=i;else throw new Error("Could not find wasm module in post.js");if(Df){var rh=kl._dispose;kl._dispose=function(){rh(),Df.uncaughtException.forEach(function(me){process.removeListener("uncaughtException",me)}),Df.unhandledRejection.forEach(function(me){process.removeListener("unhandledRejection",me)})}}return i.ready}})();typeof r=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof r=="object"&&(r.WasmBackendModuleThreadedSimd=n)}),LAe=Jn((r,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),PAe=Jn((r,t)=>{var n=(()=>{var s=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(s=s||__filename),function(i){i=i||{};var a=typeof i<"u"?i:{},o,u;a.ready=new Promise(function(B,z){o=B,u=z});var l;typeof process<"u"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var c=Object.assign({},a),h=typeof window=="object",d=typeof importScripts=="function",p=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f="";function m(B){return a.locateFile?a.locateFile(B,f):f+B}var g,y,b;if(p){var x=AR(),w=iq();d?f=w.dirname(f)+"/":f=__dirname+"/",g=(B,z)=>(B=ie(B)?new URL(B):w.normalize(B),x.readFileSync(B,z?void 0:"utf8")),b=B=>{var z=g(B,!0);return z.buffer||(z=new Uint8Array(z)),z},y=(B,z,W)=>{B=ie(B)?new URL(B):w.normalize(B),x.readFile(B,function(X,ze){X?W(X):z(ze.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(B){if(!(B instanceof Oe))throw B}),process.on("unhandledRejection",function(B){throw B}),a.inspect=function(){return"[Emscripten Module object]"}}else(h||d)&&(d?f=self.location.href:typeof document<"u"&&document.currentScript&&(f=document.currentScript.src),s&&(f=s),f.indexOf("blob:")!==0?f=f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):f="",g=B=>{var z=new XMLHttpRequest;return z.open("GET",B,!1),z.send(null),z.responseText},d&&(b=B=>{var z=new XMLHttpRequest;return z.open("GET",B,!1),z.responseType="arraybuffer",z.send(null),new Uint8Array(z.response)}),y=(B,z,W)=>{var X=new XMLHttpRequest;X.open("GET",B,!0),X.responseType="arraybuffer",X.onload=()=>{if(X.status==200||X.status==0&&X.response){z(X.response);return}W()},X.onerror=W,X.send(null)});var v=a.print||console.log.bind(console),S=a.printErr||console.warn.bind(console);Object.assign(a,c),c=null,a.arguments&&a.arguments,a.thisProgram&&a.thisProgram,a.quit&&a.quit;var E;a.wasmBinary&&(E=a.wasmBinary),a.noExitRuntime,typeof WebAssembly!="object"&&Ue("no native wasm support detected");var C,I=!1,_=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function A(B,z,W){z>>>=0;for(var X=z+W,ze=z;B[ze]&&!(ze>=X);)++ze;if(ze-z>16&&B.buffer&&_)return _.decode(B.subarray(z,ze));for(var Ge="";z<ze;){var Ye=B[z++];if(!(Ye&128)){Ge+=String.fromCharCode(Ye);continue}var Je=B[z++]&63;if((Ye&224)==192){Ge+=String.fromCharCode((Ye&31)<<6|Je);continue}var At=B[z++]&63;if((Ye&240)==224?Ye=(Ye&15)<<12|Je<<6|At:Ye=(Ye&7)<<18|Je<<12|At<<6|B[z++]&63,Ye<65536)Ge+=String.fromCharCode(Ye);else{var Er=Ye-65536;Ge+=String.fromCharCode(55296|Er>>10,56320|Er&1023)}}return Ge}function k(B,z){return B>>>=0,B?A(G,B,z):""}function N(B,z,W,X){if(W>>>=0,!(X>0))return 0;for(var ze=W,Ge=W+X-1,Ye=0;Ye<B.length;++Ye){var Je=B.charCodeAt(Ye);if(Je>=55296&&Je<=57343){var At=B.charCodeAt(++Ye);Je=65536+((Je&1023)<<10)|At&1023}if(Je<=127){if(W>=Ge)break;z[W++>>>0]=Je}else if(Je<=2047){if(W+1>=Ge)break;z[W++>>>0]=192|Je>>6,z[W++>>>0]=128|Je&63}else if(Je<=65535){if(W+2>=Ge)break;z[W++>>>0]=224|Je>>12,z[W++>>>0]=128|Je>>6&63,z[W++>>>0]=128|Je&63}else{if(W+3>=Ge)break;z[W++>>>0]=240|Je>>18,z[W++>>>0]=128|Je>>12&63,z[W++>>>0]=128|Je>>6&63,z[W++>>>0]=128|Je&63}}return z[W>>>0]=0,W-ze}function D(B,z,W){return N(B,G,z,W)}var F,P,G,Y;function Z(B){F=B,a.HEAP8=P=new Int8Array(B),a.HEAP16=new Int16Array(B),a.HEAP32=new Int32Array(B),a.HEAPU8=G=new Uint8Array(B),a.HEAPU16=new Uint16Array(B),a.HEAPU32=Y=new Uint32Array(B),a.HEAPF32=new Float32Array(B),a.HEAPF64=new Float64Array(B)}a.INITIAL_MEMORY;var ee=[],se=[],re=[];function J(){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)xe(a.preRun.shift());nt(ee)}function le(){nt(se)}function he(){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;)Le(a.postRun.shift());nt(re)}function xe(B){ee.unshift(B)}function Fe(B){se.unshift(B)}function Le(B){re.unshift(B)}var Ve=0,$e=null;function Ae(B){Ve++,a.monitorRunDependencies&&a.monitorRunDependencies(Ve)}function Te(B){if(Ve--,a.monitorRunDependencies&&a.monitorRunDependencies(Ve),Ve==0&&$e){var z=$e;$e=null,z()}}function Ue(B){a.onAbort&&a.onAbort(B),B="Aborted("+B+")",S(B),I=!0,B+=". Build with -sASSERTIONS for more info.";var z=new WebAssembly.RuntimeError(B);throw u(z),z}var qe="data:application/octet-stream;base64,";function Me(B){return B.startsWith(qe)}function ie(B){return B.startsWith("file://")}var K;K="tfjs-backend-wasm.wasm",Me(K)||(K=m(K));function pe(B){try{if(B==K&&E)return new Uint8Array(E);if(b)return b(B);throw"both async and sync fetching of the wasm failed"}catch(z){Ue(z)}}function _e(){if(!E&&(h||d)){if(typeof fetch=="function"&&!ie(K))return fetch(K,{credentials:"same-origin"}).then(function(B){if(!B.ok)throw"failed to load wasm binary file at '"+K+"'";return B.arrayBuffer()}).catch(function(){return pe(K)});if(y)return new Promise(function(B,z){y(K,function(W){B(new Uint8Array(W))},z)})}return Promise.resolve().then(function(){return pe(K)})}function We(){var B={env:ce,wasi_snapshot_preview1:ce};function z(Ye,Je){var At=Ye.exports;a.asm=At,C=a.asm.memory,Z(C.buffer),a.asm.__indirect_function_table,Fe(a.asm.__wasm_call_ctors),Te()}Ae();function W(Ye){z(Ye.instance)}function X(Ye){return _e().then(function(Je){return WebAssembly.instantiate(Je,B)}).then(function(Je){return Je}).then(Ye,function(Je){S("failed to asynchronously prepare wasm: "+Je),Ue(Je)})}function ze(){return!E&&typeof WebAssembly.instantiateStreaming=="function"&&!Me(K)&&!ie(K)&&!p&&typeof fetch=="function"?fetch(K,{credentials:"same-origin"}).then(function(Ye){var Je=WebAssembly.instantiateStreaming(Ye,B);return Je.then(W,function(At){return S("wasm streaming compile failed: "+At),S("falling back to ArrayBuffer instantiation"),X(W)})}):X(W)}if(a.instantiateWasm)try{var Ge=a.instantiateWasm(B,z);return Ge}catch(Ye){S("Module.instantiateWasm callback failed with error: "+Ye),u(Ye)}return ze().catch(u),{}}function Oe(B){this.name="ExitStatus",this.message="Program terminated with exit("+B+")",this.status=B}function nt(B){for(;B.length>0;)B.shift()(a)}function rt(){Ue("")}function pt(){return 4294901760}function Et(){return pt()}function ht(B,z,W){G.copyWithin(B>>>0,z>>>0,z+W>>>0)}function Mt(B){try{return C.grow(B-F.byteLength+65535>>>16),Z(C.buffer),1}catch{}}function it(B){var z=G.length;B=B>>>0;var W=pt();if(B>W)return!1;let X=(At,Er)=>At+(Er-At%Er)%Er;for(var ze=1;ze<=4;ze*=2){var Ge=z*(1+.2/ze);Ge=Math.min(Ge,B+100663296);var Ye=Math.min(W,X(Math.max(B,Ge),65536)),Je=Mt(Ye);if(Je)return!0}return!1}function kt(B){return 52}function Lt(B,z,W,X,ze){return 70}var wn=[null,[],[]];function Gr(B,z){var W=wn[B];z===0||z===10?((B===1?v:S)(A(W,0)),W.length=0):W.push(z)}function lr(B,z,W,X){for(var ze=0,Ge=0;Ge<W;Ge++){var Ye=Y[z>>>2],Je=Y[z+4>>>2];z+=8;for(var At=0;At<Je;At++)Gr(B,G[Ye+At>>>0]);ze+=Je}return Y[X>>>2]=ze,0}function Pr(B){var z=a["_"+B];return z}function V(B,z){P.set(B,z>>>0)}function H(B,z,W,X,ze){var Ge={string:Ur=>{var ka=0;if(Ur!=null&&Ur!==0){var Au=(Ur.length<<2)+1;ka=Ze(Au),D(Ur,ka,Au)}return ka},array:Ur=>{var ka=Ze(Ur.length);return V(Ur,ka),ka}};function Ye(Ur){return z==="string"?k(Ur):z==="boolean"?!!Ur:Ur}var Je=Pr(B),At=[],Er=0;if(X)for(var br=0;br<X.length;br++){var Vn=Ge[W[br]];Vn?(Er===0&&(Er=ve()),At[br]=Vn(X[br])):At[br]=X[br]}var Ia=Je.apply(null,At);function Tu(Ur){return Er!==0&&He(Er),Ye(Ur)}return Ia=Tu(Ia),Ia}function ae(B,z,W,X){W=W||[];var ze=W.every(Ye=>Ye==="number"||Ye==="boolean"),Ge=z!=="string";return Ge&&ze&&!X?Pr(B):function(){return H(B,z,W,arguments)}}var ce={abort:rt,emscripten_get_heap_max:Et,emscripten_memcpy_big:ht,emscripten_resize_heap:it,fd_close:kt,fd_seek:Lt,fd_write:lr};We(),a.___wasm_call_ctors=function(){return(a.___wasm_call_ctors=a.asm.__wasm_call_ctors).apply(null,arguments)},a._init=function(){return(a._init=a.asm.init).apply(null,arguments)},a._init_with_threads_count=function(){return(a._init_with_threads_count=a.asm.init_with_threads_count).apply(null,arguments)},a._get_threads_count=function(){return(a._get_threads_count=a.asm.get_threads_count).apply(null,arguments)},a._register_tensor=function(){return(a._register_tensor=a.asm.register_tensor).apply(null,arguments)},a._dispose_data=function(){return(a._dispose_data=a.asm.dispose_data).apply(null,arguments)},a._dispose=function(){return(a._dispose=a.asm.dispose).apply(null,arguments)},a._Abs=function(){return(a._Abs=a.asm.Abs).apply(null,arguments)},a._Acos=function(){return(a._Acos=a.asm.Acos).apply(null,arguments)},a._Acosh=function(){return(a._Acosh=a.asm.Acosh).apply(null,arguments)},a._Add=function(){return(a._Add=a.asm.Add).apply(null,arguments)},a._AddN=function(){return(a._AddN=a.asm.AddN).apply(null,arguments)},a._All=function(){return(a._All=a.asm.All).apply(null,arguments)},a._Any=function(){return(a._Any=a.asm.Any).apply(null,arguments)},a._ArgMax=function(){return(a._ArgMax=a.asm.ArgMax).apply(null,arguments)},a._ArgMin=function(){return(a._ArgMin=a.asm.ArgMin).apply(null,arguments)},a._Asin=function(){return(a._Asin=a.asm.Asin).apply(null,arguments)},a._Asinh=function(){return(a._Asinh=a.asm.Asinh).apply(null,arguments)},a._Atan=function(){return(a._Atan=a.asm.Atan).apply(null,arguments)},a._Atan2=function(){return(a._Atan2=a.asm.Atan2).apply(null,arguments)},a._Atanh=function(){return(a._Atanh=a.asm.Atanh).apply(null,arguments)},a._AvgPool=function(){return(a._AvgPool=a.asm.AvgPool).apply(null,arguments)},a._AvgPool3D=function(){return(a._AvgPool3D=a.asm.AvgPool3D).apply(null,arguments)},a._AvgPool3DGrad=function(){return(a._AvgPool3DGrad=a.asm.AvgPool3DGrad).apply(null,arguments)},a._AvgPoolGrad=function(){return(a._AvgPoolGrad=a.asm.AvgPoolGrad).apply(null,arguments)},a._BatchMatMul=function(){return(a._BatchMatMul=a.asm.BatchMatMul).apply(null,arguments)},a._Bincount=function(){return(a._Bincount=a.asm.Bincount).apply(null,arguments)},a._BitwiseAnd=function(){return(a._BitwiseAnd=a.asm.BitwiseAnd).apply(null,arguments)},a._Ceil=function(){return(a._Ceil=a.asm.Ceil).apply(null,arguments)},a._ClipByValue=function(){return(a._ClipByValue=a.asm.ClipByValue).apply(null,arguments)},a._Conv2D=function(){return(a._Conv2D=a.asm.Conv2D).apply(null,arguments)},a._Conv2DBackpropInput=function(){return(a._Conv2DBackpropInput=a.asm.Conv2DBackpropInput).apply(null,arguments)},a._Conv3D=function(){return(a._Conv3D=a.asm.Conv3D).apply(null,arguments)},a._Conv3DBackpropFilterV2=function(){return(a._Conv3DBackpropFilterV2=a.asm.Conv3DBackpropFilterV2).apply(null,arguments)},a._Conv3DBackpropInputV2=function(){return(a._Conv3DBackpropInputV2=a.asm.Conv3DBackpropInputV2).apply(null,arguments)},a._Cos=function(){return(a._Cos=a.asm.Cos).apply(null,arguments)},a._Cosh=function(){return(a._Cosh=a.asm.Cosh).apply(null,arguments)},a._CropAndResize=function(){return(a._CropAndResize=a.asm.CropAndResize).apply(null,arguments)},a._Cumprod=function(){return(a._Cumprod=a.asm.Cumprod).apply(null,arguments)},a._Cumsum=function(){return(a._Cumsum=a.asm.Cumsum).apply(null,arguments)},a._DenseBincount=function(){return(a._DenseBincount=a.asm.DenseBincount).apply(null,arguments)},a._DepthToSpace=function(){return(a._DepthToSpace=a.asm.DepthToSpace).apply(null,arguments)},a._DepthwiseConv2dNative=function(){return(a._DepthwiseConv2dNative=a.asm.DepthwiseConv2dNative).apply(null,arguments)},a._Diag=function(){return(a._Diag=a.asm.Diag).apply(null,arguments)},a._Dilation2D=function(){return(a._Dilation2D=a.asm.Dilation2D).apply(null,arguments)},a._Dilation2DBackpropFilter=function(){return(a._Dilation2DBackpropFilter=a.asm.Dilation2DBackpropFilter).apply(null,arguments)},a._Dilation2DBackpropInput=function(){return(a._Dilation2DBackpropInput=a.asm.Dilation2DBackpropInput).apply(null,arguments)},a._Elu=function(){return(a._Elu=a.asm.Elu).apply(null,arguments)},a._EluGrad=function(){return(a._EluGrad=a.asm.EluGrad).apply(null,arguments)},a._Equal=function(){return(a._Equal=a.asm.Equal).apply(null,arguments)},a._Erf=function(){return(a._Erf=a.asm.Erf).apply(null,arguments)},a._Exp=function(){return(a._Exp=a.asm.Exp).apply(null,arguments)},a._Expm1=function(){return(a._Expm1=a.asm.Expm1).apply(null,arguments)},a._FlipLeftRight=function(){return(a._FlipLeftRight=a.asm.FlipLeftRight).apply(null,arguments)},a._Floor=function(){return(a._Floor=a.asm.Floor).apply(null,arguments)},a._FloorDiv=function(){return(a._FloorDiv=a.asm.FloorDiv).apply(null,arguments)},a._FusedBatchNorm=function(){return(a._FusedBatchNorm=a.asm.FusedBatchNorm).apply(null,arguments)},a._FusedConv2D=function(){return(a._FusedConv2D=a.asm.FusedConv2D).apply(null,arguments)},a._FusedDepthwiseConv2D=function(){return(a._FusedDepthwiseConv2D=a.asm.FusedDepthwiseConv2D).apply(null,arguments)},a._Gather=function(){return(a._Gather=a.asm.Gather).apply(null,arguments)},a._GatherNd=function(){return(a._GatherNd=a.asm.GatherNd).apply(null,arguments)},a._Greater=function(){return(a._Greater=a.asm.Greater).apply(null,arguments)},a._GreaterEqual=function(){return(a._GreaterEqual=a.asm.GreaterEqual).apply(null,arguments)},a._IsFinite=function(){return(a._IsFinite=a.asm.IsFinite).apply(null,arguments)},a._IsInf=function(){return(a._IsInf=a.asm.IsInf).apply(null,arguments)},a._IsNan=function(){return(a._IsNan=a.asm.IsNan).apply(null,arguments)},a._LRN=function(){return(a._LRN=a.asm.LRN).apply(null,arguments)},a._LRNGrad=function(){return(a._LRNGrad=a.asm.LRNGrad).apply(null,arguments)},a._LeakyRelu=function(){return(a._LeakyRelu=a.asm.LeakyRelu).apply(null,arguments)},a._Less=function(){return(a._Less=a.asm.Less).apply(null,arguments)},a._LessEqual=function(){return(a._LessEqual=a.asm.LessEqual).apply(null,arguments)},a._LinSpace=function(){return(a._LinSpace=a.asm.LinSpace).apply(null,arguments)},a._Log=function(){return(a._Log=a.asm.Log).apply(null,arguments)},a._Log1p=function(){return(a._Log1p=a.asm.Log1p).apply(null,arguments)},a._LogicalAnd=function(){return(a._LogicalAnd=a.asm.LogicalAnd).apply(null,arguments)},a._LogicalNot=function(){return(a._LogicalNot=a.asm.LogicalNot).apply(null,arguments)},a._LogicalOr=function(){return(a._LogicalOr=a.asm.LogicalOr).apply(null,arguments)},a._LogicalXor=function(){return(a._LogicalXor=a.asm.LogicalXor).apply(null,arguments)},a._Max=function(){return(a._Max=a.asm.Max).apply(null,arguments)},a._MaxPool=function(){return(a._MaxPool=a.asm.MaxPool).apply(null,arguments)},a._MaxPool3D=function(){return(a._MaxPool3D=a.asm.MaxPool3D).apply(null,arguments)},a._MaxPool3DGrad=function(){return(a._MaxPool3DGrad=a.asm.MaxPool3DGrad).apply(null,arguments)},a._MaxPoolGrad=function(){return(a._MaxPoolGrad=a.asm.MaxPoolGrad).apply(null,arguments)},a._MaxPoolWithArgmax=function(){return(a._MaxPoolWithArgmax=a.asm.MaxPoolWithArgmax).apply(null,arguments)},a._Maximum=function(){return(a._Maximum=a.asm.Maximum).apply(null,arguments)},a._Mean=function(){return(a._Mean=a.asm.Mean).apply(null,arguments)},a._Min=function(){return(a._Min=a.asm.Min).apply(null,arguments)},a._Minimum=function(){return(a._Minimum=a.asm.Minimum).apply(null,arguments)},a._MirrorPad=function(){return(a._MirrorPad=a.asm.MirrorPad).apply(null,arguments)},a._Mod=function(){return(a._Mod=a.asm.Mod).apply(null,arguments)},a._Multinomial=function(){return(a._Multinomial=a.asm.Multinomial).apply(null,arguments)},a._Multiply=function(){return(a._Multiply=a.asm.Multiply).apply(null,arguments)},a._Neg=function(){return(a._Neg=a.asm.Neg).apply(null,arguments)},a._NonMaxSuppressionV3=function(){return(a._NonMaxSuppressionV3=a.asm.NonMaxSuppressionV3).apply(null,arguments)},a._NonMaxSuppressionV4=function(){return(a._NonMaxSuppressionV4=a.asm.NonMaxSuppressionV4).apply(null,arguments)},a._NonMaxSuppressionV5=function(){return(a._NonMaxSuppressionV5=a.asm.NonMaxSuppressionV5).apply(null,arguments)},a._NotEqual=function(){return(a._NotEqual=a.asm.NotEqual).apply(null,arguments)},a._OneHot=function(){return(a._OneHot=a.asm.OneHot).apply(null,arguments)},a._PadV2=function(){return(a._PadV2=a.asm.PadV2).apply(null,arguments)},a._Pow=function(){return(a._Pow=a.asm.Pow).apply(null,arguments)},a._Prelu=function(){return(a._Prelu=a.asm.Prelu).apply(null,arguments)},a._Prod=function(){return(a._Prod=a.asm.Prod).apply(null,arguments)},a._RealDiv=function(){return(a._RealDiv=a.asm.RealDiv).apply(null,arguments)},a._Reciprocal=function(){return(a._Reciprocal=a.asm.Reciprocal).apply(null,arguments)},a._Relu=function(){return(a._Relu=a.asm.Relu).apply(null,arguments)},a._Relu6=function(){return(a._Relu6=a.asm.Relu6).apply(null,arguments)},a._ResizeBilinear=function(){return(a._ResizeBilinear=a.asm.ResizeBilinear).apply(null,arguments)},a._ResizeBilinearGrad=function(){return(a._ResizeBilinearGrad=a.asm.ResizeBilinearGrad).apply(null,arguments)},a._ResizeNearestNeighbor=function(){return(a._ResizeNearestNeighbor=a.asm.ResizeNearestNeighbor).apply(null,arguments)},a._ResizeNearestNeighborGrad=function(){return(a._ResizeNearestNeighborGrad=a.asm.ResizeNearestNeighborGrad).apply(null,arguments)},a._Reverse=function(){return(a._Reverse=a.asm.Reverse).apply(null,arguments)},a._RotateWithOffset=function(){return(a._RotateWithOffset=a.asm.RotateWithOffset).apply(null,arguments)},a._Round=function(){return(a._Round=a.asm.Round).apply(null,arguments)},a._Rsqrt=function(){return(a._Rsqrt=a.asm.Rsqrt).apply(null,arguments)},a._ScatterNd=function(){return(a._ScatterNd=a.asm.ScatterNd).apply(null,arguments)},a._SearchSorted=function(){return(a._SearchSorted=a.asm.SearchSorted).apply(null,arguments)},a._SelectV2=function(){return(a._SelectV2=a.asm.SelectV2).apply(null,arguments)},a._Selu=function(){return(a._Selu=a.asm.Selu).apply(null,arguments)},a._Sigmoid=function(){return(a._Sigmoid=a.asm.Sigmoid).apply(null,arguments)},a._Sign=function(){return(a._Sign=a.asm.Sign).apply(null,arguments)},a._Sin=function(){return(a._Sin=a.asm.Sin).apply(null,arguments)},a._Sinh=function(){return(a._Sinh=a.asm.Sinh).apply(null,arguments)},a._Softmax=function(){return(a._Softmax=a.asm.Softmax).apply(null,arguments)},a._Softplus=function(){return(a._Softplus=a.asm.Softplus).apply(null,arguments)},a._SparseFillEmptyRows=function(){return(a._SparseFillEmptyRows=a.asm.SparseFillEmptyRows).apply(null,arguments)},a._SparseReshape=function(){return(a._SparseReshape=a.asm.SparseReshape).apply(null,arguments)},a._SparseSegmentReduction=function(){return(a._SparseSegmentReduction=a.asm.SparseSegmentReduction).apply(null,arguments)},a._SparseToDense=function(){return(a._SparseToDense=a.asm.SparseToDense).apply(null,arguments)},a._Sqrt=function(){return(a._Sqrt=a.asm.Sqrt).apply(null,arguments)},a._Square=function(){return(a._Square=a.asm.Square).apply(null,arguments)},a._SquaredDifference=function(){return(a._SquaredDifference=a.asm.SquaredDifference).apply(null,arguments)},a._Step=function(){return(a._Step=a.asm.Step).apply(null,arguments)},a._StridedSlice=function(){return(a._StridedSlice=a.asm.StridedSlice).apply(null,arguments)},a._Sub=function(){return(a._Sub=a.asm.Sub).apply(null,arguments)},a._Sum=function(){return(a._Sum=a.asm.Sum).apply(null,arguments)},a._Tan=function(){return(a._Tan=a.asm.Tan).apply(null,arguments)},a._Tanh=function(){return(a._Tanh=a.asm.Tanh).apply(null,arguments)},a._TensorScatterUpdate=function(){return(a._TensorScatterUpdate=a.asm.TensorScatterUpdate).apply(null,arguments)},a._Tile=function(){return(a._Tile=a.asm.Tile).apply(null,arguments)},a._TopK=function(){return(a._TopK=a.asm.TopK).apply(null,arguments)},a._Transform=function(){return(a._Transform=a.asm.Transform).apply(null,arguments)},a._Transpose=function(){return(a._Transpose=a.asm.Transpose).apply(null,arguments)},a.__FusedMatMul=function(){return(a.__FusedMatMul=a.asm._FusedMatMul).apply(null,arguments)},a._malloc=function(){return(a._malloc=a.asm.malloc).apply(null,arguments)},a._free=function(){return(a._free=a.asm.free).apply(null,arguments)},a.___errno_location=function(){return(a.___errno_location=a.asm.__errno_location).apply(null,arguments)};var ve=a.stackSave=function(){return(ve=a.stackSave=a.asm.stackSave).apply(null,arguments)},He=a.stackRestore=function(){return(He=a.stackRestore=a.asm.stackRestore).apply(null,arguments)},Ze=a.stackAlloc=function(){return(Ze=a.stackAlloc=a.asm.stackAlloc).apply(null,arguments)};a.dynCall_iijjiiii=function(){return(a.dynCall_iijjiiii=a.asm.dynCall_iijjiiii).apply(null,arguments)},a.dynCall_jiji=function(){return(a.dynCall_jiji=a.asm.dynCall_jiji).apply(null,arguments)},a.cwrap=ae;var dt;$e=function B(){dt||Bt(),dt||($e=B)};function Bt(B){if(Ve>0||(J(),Ve>0))return;function z(){dt||(dt=!0,a.calledRun=!0,!I&&(le(),o(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),he()))}a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),z()},1)):z()}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();Bt();var Ut;l&&(Ut={uncaughtException:process.listeners("uncaughtException").filter(function(B){return!l.uncaughtException.indexOf(B)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(B){return!l.unhandledRejection.indexOf(B)>-1})});var Tr;if(typeof i<"u")Tr=i;else if(typeof WasmBackendModuleThreadedSimd<"u")Tr=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Ut){var $=Tr._dispose;Tr._dispose=function(){$(),Ut.uncaughtException.forEach(function(B){process.removeListener("uncaughtException",B)}),Ut.unhandledRejection.forEach(function(B){process.removeListener("unhandledRejection",B)})}}return i.ready}})();typeof r=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof r=="object"&&(r.WasmBackendModule=n)}),CC=class{constructor(r,t){this.backend=r,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(r){return this.data.has(r)||this.dataMover.moveData(this.backend,r),this.data.get(r)}set(r,t){this.dataIdsCount++,this.data.set(r,t)}has(r){return this.data.has(r)}delete(r){return this.dataIdsCount--,this.data.delete(r)}numDataIds(){return this.dataIdsCount}},Rx=class{refCount(r){return Pi("refCount")}incRef(r){return Pi("incRef")}timerAvailable(){return!0}time(r){return Pi("time")}read(r){return Pi("read")}readSync(r){return Pi("readSync")}readToGPU(r,t){return Pi("readToGPU")}numDataIds(){return Pi("numDataIds")}disposeData(r,t){return Pi("disposeData")}write(r,t,n){return Pi("write")}move(r,t,n,s,i){return Pi("move")}createTensorFromGPUData(r,t,n){return Pi("createTensorFromGPUData")}memory(){return Pi("memory")}floatPrecision(){return Pi("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Pi("dispose")}};function Pi(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function aq(r){let t=r.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,D2(r,t,n)}function BAe(r,t){if(r.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${t.length}`);let n=r.length,s=0;for(;n>0;)s=Math.random()*n|0,n--,D2(r,n,s),D2(t,n,s)}function Gb(r,t,n){return Math.max(r,Math.min(t,n))}function VAe(r){return r%2===0?r:r+1}function D2(r,t,n){let s=r[t];r[t]=r[n],r[n]=s}function zAe(r){let t=0;for(let n=0;n<r.length;n++)t+=r[n];return t}function UAe(r,t){let n=Math.random();return t*n+(1-n)*r}function WAe(r,t){let n=0;for(let s=0;s<r.length;s++){let i=Number(r[s])-Number(t[s]);n+=i*i}return n}function ue(r,t){if(!r)throw new Error(typeof t=="string"?t:t())}function di(r,t,n=""){ue(xl(r,t),()=>n+` Shapes ${r} and ${t} must match`)}function Gd(r){ue(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Jr(r){if(r.length===0)return 1;let t=r[0];for(let n=1;n<r.length;n++)t*=r[n];return t}function GAe(r){return r.length===0}function oq(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let n=0;n<r.length;n++)if(r[n]!==null&&t[n]!==null&&r[n]!==t[n])return!1;return!0}function xl(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let n=0;n<r.length;n++)if(r[n]!==t[n])return!1;return!0}function zm(r){return r%1===0}function HAe(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let t=Math.exp(2*r);return(t-1)/(t+1)}}function jAe(r){let t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function qAe(r){let t=new Uint32Array(r);for(let n=0;n<r;++n)t[n]=n;return aq(t),t}function Yy(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function KAe(r,t=i=>0,n,s){return new Promise((i,a)=>{let o=0,u=()=>{if(r()){i();return}o++;let l=t(o);if(n!=null&&o>=n){a();return}s!=null?s(u,l):setTimeout(u,l)};u()})}function XAe(r,t){let n=1,s=-1;for(let a=0;a<r.length;++a)if(r[a]>=0)n*=r[a];else if(r[a]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${a}`);s=a}else if(r[a]<0)throw Error(`Shapes can not be < 0. Found ${r[a]} at dim ${a}`);if(s===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(n===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let i=r.slice();return i[s]=t/n,i}function io(r,t){let n=t.length;return r=r==null?t.map((s,i)=>i):[].concat(r),ue(r.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${r}`),ue(r.every(s=>zm(s)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(s=>s<0?n+s:s)}function uq(r,t){let n=[],s=[],i=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||i?null:io(t,r).sort(),o=0;for(let u=0;u<r.length;++u){if(a!=null){if(a[o]===u&&r[u]!==1)throw new Error(`Can't squeeze axis ${u} since its dim '${r[u]}' is not 1`);(a[o]==null||a[o]>u)&&r[u]===1&&(n.push(r[u]),s.push(u)),a[o]<=u&&o++}r[u]!==1&&(n.push(r[u]),s.push(u))}return{newShape:n,keptDims:s}}function lq(r,t){return DR(r,t)}function DR(r,t){let n=null;if(r==null||r==="float32")n=new Float32Array(t);else if(r==="int32")n=new Int32Array(t);else if(r==="bool")n=new Uint8Array(t);else if(r==="string")n=new Array(t);else throw new Error(`Unknown data type ${r}`);return n}function cq(r,t){for(let n=0;n<r.length;n++){let s=r[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function hq(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function YAe(r,t){return!(t==="complex64"||t==="float32"&&r!=="complex64"||t==="int32"&&r!=="float32"&&r!=="complex64"||t==="bool"&&r==="bool")}function F2(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function dq(r){if(r==null)return 0;let t=0;return r.forEach(n=>t+=n.length),t}function Xl(r){return typeof r=="string"||r instanceof String}function pq(r){return typeof r=="boolean"}function fq(r){return typeof r=="number"}function Ox(r){return Array.isArray(r)?Ox(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":fq(r)?"float32":Xl(r)?"string":pq(r)?"bool":"float32"}function mc(r){return!!(r&&r.constructor&&r.call&&r.apply)}function $2(r,t){for(let n=t;n<r;++n)if(r%n===0)return n;return r}function _g(r){let t=r.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=r[t-1];for(let s=t-3;s>=0;--s)n[s]=n[s+1]*r[s+1];return n}function mq(r,t,n,s=!1){let i=new Array;if(t.length===1){let a=t[0]*(s?2:1);for(let o=0;o<a;o++)i[o]=n[r+o]}else{let a=t[0],o=t.slice(1),u=o.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<a;l++)i[l]=mq(r+l*u,o,n,s)}return i}function fm(r,t,n=!1){if(r.length===0)return t[0];let s=r.reduce((i,a)=>i*a)*(n?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return mq(0,r,t,n)}function ZAe(r,t){if(Array.isArray(r))return r;if(t==="float32")return r instanceof Float32Array?r:new Float32Array(r);if(t==="int32")return r instanceof Int32Array?r:new Int32Array(r);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(r));throw new Error(`Unknown dtype ${t}`)}function FR(r,t){let n=_C(r,t);for(let s=0;s<n.length;s++)n[s]=1;return n}function _C(r,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function JAe(r,t){let n=r.reduce((s,i)=>s*i,1);if(t==null||t==="float32")return fm(r,new Float32Array(n));if(t==="int32")return fm(r,new Int32Array(n));if(t==="bool")return fm(r,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function ua(r){r.forEach(t=>{ue(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function QAe(r,t,n){if(t===0)return 0;if(t===1)return r[0];let s=r[r.length-1];for(let i=0;i<r.length-1;++i)s+=n[i]*r[i];return s}function eDe(r,t,n){if(t===0)return[];if(t===1)return[r];let s=new Array(t);for(let i=0;i<s.length-1;++i)s[i]=Math.floor(r/n[i]),r-=s[i]*n[i];return s[s.length-1]=r,s}function EC(r){return r&&r.then&&typeof r.then=="function"}var k5="tfjsflags",gq=class{constructor(r){this.global=r,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=tDe,this.populateURLFlags()}setPlatform(r,t){this.platform!=null&&(Re().getBool("IS_TEST")||Re().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${r}.`)),this.platformName=r,this.platform=t}registerFlag(r,t,n){if(this.flagRegistry[r]={evaluationFn:t,setHook:n},this.urlFlags[r]!=null){let s=this.urlFlags[r];Re().getBool("IS_TEST")||Re().getBool("PROD")||console.warn(`Setting feature override from URL ${r}: ${s}.`),this.set(r,s)}}async getAsync(r){return r in this.flags?this.flags[r]:(this.flags[r]=await this.evaluateFlag(r),this.flags[r])}get(r){if(r in this.flags)return this.flags[r];let t=this.evaluateFlag(r);if(EC(t))throw new Error(`Flag ${r} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[r]=t,this.flags[r]}getNumber(r){return this.get(r)}getBool(r){return this.get(r)}getString(r){return this.get(r)}getFlags(){return this.flags}get features(){return this.flags}set(r,t){if(this.flagRegistry[r]==null)throw new Error(`Cannot set flag ${r} as it has not been registered.`);this.flags[r]=t,this.flagRegistry[r].setHook!=null&&this.flagRegistry[r].setHook(t)}evaluateFlag(r){if(this.flagRegistry[r]==null)throw new Error(`Cannot evaluate flag '${r}': no evaluation function found.`);return this.flagRegistry[r].evaluationFn()}setFlags(r){this.flags=Object.assign({},r)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let r=this.getQueryParams(this.global.location.search);k5 in r&&r[k5].split(",").forEach(t=>{let[n,s]=t.split(":");this.urlFlags[n]=nDe(n,s)})}};function tDe(r){let t={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>(rDe(t,s[0],s[1]),s.join("="))),t}function rDe(r,t,n){r[decodeURIComponent(t)]=decodeURIComponent(n||"")}function nDe(r,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function Re(){return $R}var $R=null;function sDe(r){$R=r}var eI;function yq(){if(eI==null){let r;if(typeof window<"u")r=window;else if(typeof global<"u")r=global;else if(typeof process<"u")r=process;else if(typeof self<"u")r=self;else throw new Error("Could not find a global object");eI=r}return eI}function iDe(){let r=yq();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function RR(r,t){let n=iDe();if(n.has(r))return n.get(r);{let s=t();return n.set(r,s),n.get(r)}}var Eg="Abs",Hd="Acos",jd="Acosh",Mc="Add",qd="AddN",Ig="All",kg="Any",Ng="ArgMax",Tg="ArgMin",Kd="Asin",Xd="Asinh",Yd="Atan",Zd="Atanh",Jd="Atan2",Qd="AvgPool",Mx="AvgPoolGrad",Ag="AvgPool3D",Lx="AvgPool3DGrad",ep="BatchMatMul",Dg="BatchToSpaceND",Fg="Bincount",$g="BitwiseAnd",bq="BroadcastTo",Px="BroadcastArgs",tp="Cast",rp="Ceil",Lc="ClipByValue",IC="Complex",Bx="ComplexAbs",Rg="Concat",np="Conv2D",kC="Conv2DBackpropFilter",sp="Conv2DBackpropInput",ip="Conv3D",Og="Conv3DBackpropFilterV2",Mg="Conv3DBackpropInputV2",ap="Cos",op="Cosh",Lg="Cumprod",up="Cumsum",Pg="CropAndResize",Vx="DenseBincount",Bg="DepthToSpace",lp="DepthwiseConv2dNative",NC="DepthwiseConv2dNativeBackpropFilter",TC="DepthwiseConv2dNativeBackpropInput",zx="Diag",cp="Dilation2D",Um="Dilation2DBackpropInput",Wm="Dilation2DBackpropFilter",AC="Draw",hp="RealDiv",DC="Einsum",dp="Elu",Vg="EluGrad",pp="Erf",zg="Equal",fp="Exp",Ug="ExpandDims",mp="Expm1",FC="FFT",Ux="Fill",Wg="FlipLeftRight",gp="Floor",yp="FloorDiv",bp="FusedBatchNorm",Gg="GatherV2",Hg="GatherNd",jg="Greater",xp="GreaterEqual",vp="Identity",$C="IFFT",RC="Imag",wp="IsFinite",Sp="IsInf",Cp="IsNan",_p="LeakyRelu",qg="Less",Kg="LessEqual",Xg="LinSpace",Ep="Log",Ip="Log1p",Yg="LogicalAnd",Zg="LogicalNot",Jg="LogicalOr",xq="LogicalXor",vq="LogSoftmax",aDe="LowerBound",kp="LRN",Qg="LRNGrad",oDe="MatrixBandPart",Np="Max",Tp="Maximum",Ap="MaxPool",Wx="MaxPoolGrad",e0="MaxPool3D",Gx="MaxPool3DGrad",Hx="MaxPoolWithArgmax",Dp="Mean",Fp="Min",$p="Minimum",Rp="MirrorPad",Op="Mod",t0="Multinomial",Mp="Multiply",r0="Neg",n0="NotEqual",s0="NonMaxSuppressionV3",i0="NonMaxSuppressionV4",a0="NonMaxSuppressionV5",o0="OnesLike",Lp="OneHot",u0="Pack",Pp="PadV2",uDe="Pool",Bp="Pow",Vp="Prelu",zp="Prod",OC="RaggedGather",MC="RaggedRange",LC="RaggedTensorToTensor",jx="Range",PC="Real",Up="Reciprocal",Wp="Relu",l0="Reshape",Gp="ResizeNearestNeighbor",c0="ResizeNearestNeighborGrad",Hp="ResizeBilinear",h0="ResizeBilinearGrad",jp="Relu6",qp="Reverse",Kp="Round",Xp="Rsqrt",d0="ScatterNd",p0="TensorScatterUpdate",f0="SearchSorted",m0="Select",Yp="Selu",g0="Slice",Zp="Sin",Jp="Sinh",Qp="Sign",ef="Sigmoid",tf="Softplus",rf="Sqrt",nf="Sum",y0="SpaceToBatchND",b0="SplitV",sf="Softmax",qx="SparseFillEmptyRows",x0="SparseReshape",Kx="SparseSegmentMean",Xx="SparseSegmentSum",v0="SparseToDense",af="SquaredDifference",Yx="Square",Zx="StaticRegexReplace",w0="StridedSlice",Jx="StringNGrams",Qx="StringSplit",ev="StringToHashBucketFast",of="Sub",uf="Tan",lf="Tanh",Pc="Tile",S0="TopK",C0="Transform",el="Transpose",tv="Unique",_0="Unpack",rv="UnsortedSegmentSum",lDe="UpperBound",E0="ZerosLike",Bc="Step",R2="FromPixels",I0="RotateWithOffset",cd="_FusedMatMul",hd="FusedConv2D",dd="FusedDepthwiseConv2D";function zl(...r){Re().getBool("IS_TEST")||Re().getBool("PROD")||console.warn(...r)}function cDe(...r){Re().getBool("IS_TEST")||Re().getBool("PROD")||console.log(...r)}var Gm=RR("kernelRegistry",()=>new Map),Hb=RR("gradRegistry",()=>new Map);function jb(r,t){let n=OR(r,t);return Gm.get(n)}function Pk(r){return Hb.get(r)}function O2(r){let t=Gm.entries(),n=[];for(;;){let{done:s,value:i}=t.next();if(s)break;let[a,o]=i,[u]=a.split("_");u===r&&n.push(o)}return n}function nv(r){let{kernelName:t,backendName:n}=r,s=OR(t,n);Gm.has(s)&&zl(`The kernel '${t}' for backend '${n}' is already registered`),Gm.set(s,r)}function wq(r){let{kernelName:t}=r;Hb.has(t)&&Re().getBool("DEBUG")&&zl(`Overriding the gradient for '${t}'`),Hb.set(t,r)}function hDe(r,t){let n=OR(r,t);if(!Gm.has(n))throw new Error(`The kernel '${r}' for backend '${t}' is not registered`);Gm.delete(n)}function dDe(r){if(!Hb.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);Hb.delete(r)}function pDe(r,t){O2(r).forEach(n=>{let s=Object.assign({},n,{backendName:t});nv(s)})}function OR(r,t){return`${t}_${r}`}var O={};ir(O,{arraysEqual:()=>xl,arraysEqualWithNull:()=>oq,assert:()=>ue,assertNonNegativeIntegerDimensions:()=>ua,assertNonNull:()=>Gd,assertShapesMatch:()=>di,bytesFromStringArray:()=>dq,bytesPerElement:()=>F2,checkConversionForErrors:()=>cq,clamp:()=>Gb,computeStrides:()=>_g,convertBackendValuesAndArrayBuffer:()=>ZAe,createScalarValue:()=>xDe,createShuffledIndices:()=>qAe,decodeString:()=>M2,distSquared:()=>WAe,encodeString:()=>iv,fetch:()=>wDe,fingerPrint64:()=>bDe,flatten:()=>gc,getArrayFromDType:()=>DR,getTypedArrayFromDType:()=>lq,hasEncodingLoss:()=>YAe,hexToLong:()=>sv,indexToLoc:()=>eDe,inferDtype:()=>Ox,inferFromImplicitShape:()=>XAe,isBoolean:()=>pq,isFunction:()=>mc,isInt:()=>zm,isNumber:()=>fq,isPromise:()=>EC,isScalarShape:()=>GAe,isString:()=>Xl,isTypedArray:()=>ys,isValidDtype:()=>hq,locToIndex:()=>QAe,makeOnesTypedArray:()=>FR,makeZerosNestedTypedArray:()=>JAe,makeZerosTypedArray:()=>_C,nearestDivisor:()=>$2,nearestLargerEven:()=>VAe,now:()=>qb,parseAxisParam:()=>io,randUniform:()=>UAe,repeatedTry:()=>KAe,rightPad:()=>Yy,shuffle:()=>aq,shuffleCombo:()=>BAe,sizeFromShape:()=>Jr,sizeToSquarishShape:()=>jAe,squeezeShape:()=>uq,sum:()=>zAe,swap:()=>D2,tanh:()=>HAe,toNestedArray:()=>fm,toTypedArray:()=>BC});function Sq(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}var N5=Oc(SAe()),Sh=N5.default||N5;function sv(r){return Sh.fromString(r,!0,16)}var Cq=sv("c3a5c85c97cb3127"),ph=sv("b492b66fbe98f273"),ei=sv("9ae16a3b2f90404f");function Bk(r){return r.xor(r.shru(47))}function _q(r,t,n){let s=r.slice(t,t+n);return Sh.fromBytes(Array.from(s),!0,!0)}function yn(r,t){return _q(r,t,8)}function T5(r,t){return _q(r,t,4)}function gs(r,t){return t===0?r:r.shru(t).or(r.shl(64-t))}function rc(r,t,n=sv("9ddfea08eb382d69")){let s=r.xor(t).mul(n);s=s.xor(s.shru(47));let i=t.xor(s).mul(n);return i=i.xor(i.shru(47)),i=i.mul(n),i}function fDe(r,t,n,s,i,a){i=i.add(r),a=gs(a.add(i).add(s),21);let o=i;return i=i.add(t),i=i.add(n),a=a.add(gs(i,44)),[i.add(s),a.add(o)]}function T1(r,t,n,s){return fDe(yn(r,t),yn(r,t+8),yn(r,t+16),yn(r,t+24),n,s)}function mDe(r,t=r.length){if(t>=8){let n=ei.add(t*2),s=yn(r,0).add(ei),i=yn(r,t-8),a=gs(i,37).mul(n).add(s),o=gs(s,25).add(i).mul(n);return rc(a,o,n)}if(t>=4){let n=ei.add(t*2),s=T5(r,0);return rc(s.shl(3).add(t),T5(r,t-4),n)}if(t>0){let n=r[0],s=r[t>>1],i=r[t-1],a=n+(s<<8),o=t+(i<<2);return Bk(ei.mul(a).xor(Cq.mul(o))).mul(ei)}return ei}function gDe(r,t=r.length){let n=ei.add(t*2),s=yn(r,0).mul(ph),i=yn(r,8),a=yn(r,t-8).mul(n),o=yn(r,t-16).mul(ei);return rc(gs(s.add(i),43).add(gs(a,30)).add(o),s.add(gs(i.add(ei),18)).add(a),n)}function yDe(r,t=r.length){let n=ei.add(t*2),s=yn(r,0).mul(ei),i=yn(r,8),a=yn(r,t-8).mul(n),o=yn(r,t-16).mul(ei),u=gs(s.add(i),43).add(gs(a,30)).add(o),l=rc(u,s.add(gs(i.add(ei),18)).add(a),n),c=yn(r,16).mul(n),h=yn(r,24),d=u.add(yn(r,t-32)).mul(n),p=l.add(yn(r,t-24)).mul(n);return rc(gs(c.add(h),43).add(gs(d,30)).add(p),c.add(gs(h.add(s),18)).add(d),n)}function bDe(r,t=r.length){let n=Sh.fromNumber(81,!0);if(t<=32)return t<=16?mDe(r,t):gDe(r,t);if(t<=64)return yDe(r,t);let s=n,i=n.mul(ph).add(113),a=Bk(i.mul(ei).add(113)).mul(ei),o=[Sh.UZERO,Sh.UZERO],u=[Sh.UZERO,Sh.UZERO];s=s.mul(ei).add(yn(r,0));let l=0,c=(t-1>>6)*64,h=c+(t-1&63)-63;do s=gs(s.add(i).add(o[0]).add(yn(r,l+8)),37).mul(ph),i=gs(i.add(o[1]).add(yn(r,l+48)),42).mul(ph),s=s.xor(u[1]),i=i.add(o[0]).add(yn(r,l+40)),a=gs(a.add(u[0]),33).mul(ph),o=T1(r,l,o[1].mul(ph),s.add(u[0])),u=T1(r,l+32,a.add(u[1]),i.add(yn(r,l+16))),[a,s]=[s,a],l+=64;while(l!==c);let d=ph.add(a.and(255).shl(1));return l=h,u[0]=u[0].add(t-1&63),o[0]=o[0].add(u[0]),u[0]=u[0].add(o[0]),s=gs(s.add(i).add(o[0]).add(yn(r,l+8)),37).mul(d),i=gs(i.add(o[1]).add(yn(r,l+48)),42).mul(d),s=s.xor(u[1].mul(9)),i=i.add(o[0].mul(9).add(yn(r,l+40))),a=gs(a.add(u[0]),33).mul(d),o=T1(r,l,o[1].mul(d),s.add(u[0])),u=T1(r,l+32,a.add(u[1]),i.add(yn(r,l+16))),[a,s]=[s,a],rc(rc(o[0],u[0],d).add(Bk(i).mul(Cq)).add(a),rc(o[1],u[1],d).add(s),d)}function xDe(r,t){return t==="string"?iv(r):BC([r],t)}function vDe(r,t){return r instanceof Float32Array&&t==="float32"||r instanceof Int32Array&&t==="int32"||r instanceof Uint8Array&&t==="bool"}function BC(r,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=gc(r)),Re().getBool("DEBUG")&&cq(r,t),vDe(r,t))return r;if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool"){let n=new Uint8Array(r.length);for(let s=0;s<n.length;++s)Math.round(r[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${t}`)}function qb(){return Re().platform.now()}function wDe(r,t){return Re().platform.fetch(r,t)}function iv(r,t="utf-8"){return t=t||"utf-8",Re().platform.encode(r,t)}function M2(r,t="utf-8"){return t=t||"utf-8",Re().platform.decode(r,t)}function ys(r){return Re().platform.isTypedArray!=null?Re().platform.isTypedArray(r):Sq(r)}function gc(r,t=[],n=!1){if(t==null&&(t=[]),typeof r=="boolean"||typeof r=="number"||typeof r=="string"||EC(r)||r==null||ys(r)&&n)t.push(r);else if(Array.isArray(r)||ys(r))for(let s=0;s<r.length;++s)gc(r[s],t,n);else{let s=-1;for(let i of Object.keys(r))/^([1-9]+[0-9]*|0)$/.test(i)&&(s=Math.max(s,Number(i)));for(let i=0;i<=s;i++)gc(r[i],t,n)}return t}var SDe=class{constructor(r,t){this.backendTimer=r,this.logger=t,t==null&&(this.logger=new _De)}profileKernel(r,t,n){let s,i=()=>{s=n()},a,o=qb();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(let u of s)u.dataSync();a=Promise.resolve({kernelMs:qb()-o})}if(Re().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){let l=s[u];l.data().then(c=>{CDe(c,l.dtype,r)})}return{kernelName:r,outputs:s,inputs:t,timeMs:a.then(u=>u.kernelMs),extraInfo:a.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(r){let{kernelName:t,outputs:n,timeMs:s,inputs:i,extraInfo:a}=r;n.forEach(o=>{Promise.all([o.data(),s,a]).then(u=>{this.logger.logKernelProfile(t,o,u[0],u[1],i,u[2])})})}};function CDe(r,t,n){if(t!=="float32")return!1;for(let s=0;s<r.length;s++){let i=r[s];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${n}'`),!0}return!1}var _De=class{logKernelProfile(r,t,n,s,i,a){let o=typeof s=="number"?Yy(`${s}ms`,9):s.error,u=Yy(r,25),l=t.rank,c=t.size,h=Yy(t.shape.toString(),14),d="";for(let p in i){let f=i[p];if(f!=null){let m=f.shape||t.shape,g=m.length;d+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${u}	%c${o}	%c${l}D ${h}	%c${c}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function EDe(r,t,n){let s={},i={};for(let l=0;l<t.length;l++)s[t[l].id]=!0;for(let l=0;l<r.length;l++){let c=r[l],h=c.inputs;for(let d in h){let p=h[d],f=!1;for(let m=0;m<t.length;m++)if(s[p.id]){c.outputs.forEach(g=>s[g.id]=!0),f=!0,i[c.id]=!0;break}if(f)break}}let a={};a[n.id]=!0;let o={};for(let l=r.length-1;l>=0;l--){let c=r[l],h=c.inputs;for(let d=0;d<c.outputs.length;d++)if(a[c.outputs[d].id]){for(let p in h)a[h[p].id]=!0,o[c.id]=!0;break}}let u=[];for(let l=0;l<r.length;l++){let c=r[l];if(i[c.id]&&o[c.id]){let h={};for(let p in c.inputs){let f=c.inputs[p];s[f.id]&&(h[p]=f)}let d=Object.assign({},c);d.inputs=h,d.outputs=c.outputs,u.push(d)}}return u}function IDe(r,t,n,s){for(let i=t.length-1;i>=0;i--){let a=t[i],o=[];if(a.outputs.forEach(l=>{let c=r[l.id];c!=null?o.push(c):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);let u=a.gradient(o);for(let l in a.inputs){if(!(l in u))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(u)}.`);let c=n(()=>u[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);let h=a.inputs[l];if(!xl(c.shape,h.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${h.shape}'`);if(r[h.id]==null)r[h.id]=c;else{let d=r[h.id];r[h.id]=s(d,c),d.dispose()}}}}var A5=20,py=3,tI=7;function kDe(r,t,n,s){let i=_g(t),a=NDe(r,t,n,i),o=t.length,u=_w(r,t,n,i,a),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(u.map(c=>"    "+c).join(`
`)),l.join(`
`)}function NDe(r,t,n,s){let i=Jr(t),a=s[s.length-1],o=new Array(a).fill(0),u=t.length,l=n==="complex64"?Dy(r):r;if(u>1)for(let c=0;c<i/a;c++){let h=c*a;for(let d=0;d<a;d++)o[d]=Math.max(o[d],Ay(l[h+d],0,n).length)}return o}function Ay(r,t,n){let s;return Array.isArray(r)?s=`${parseFloat(r[0].toFixed(tI))} + ${parseFloat(r[1].toFixed(tI))}j`:Xl(r)?s=`'${r}'`:n==="bool"?s=Eq(r):s=parseFloat(r.toFixed(tI)).toString(),Yy(s,t)}function Eq(r){return r===0?"false":"true"}function _w(r,t,n,s,i,a=!0){let o=n==="complex64"?2:1,u=t[0],l=t.length;if(l===0){if(n==="complex64"){let g=Dy(r);return[Ay(g[0],0,n)]}return n==="bool"?[Eq(r[0])]:[r[0].toString()]}if(l===1){if(u>A5){let g=py*o,y=Array.from(r.slice(0,g)),b=Array.from(r.slice((u-py)*o,u*o));return n==="complex64"&&(y=Dy(y),b=Dy(b)),["["+y.map((x,w)=>Ay(x,i[w],n)).join(", ")+", ..., "+b.map((x,w)=>Ay(x,i[u-py+w],n)).join(", ")+"]"]}return["["+(n==="complex64"?Dy(r):Array.from(r)).map((g,y)=>Ay(g,i[y],n)).join(", ")+"]"]}let c=t.slice(1),h=s.slice(1),d=s[0]*o,p=[];if(u>A5){for(let g=0;g<py;g++){let y=g*d,b=y+d;p.push(..._w(r.slice(y,b),c,n,h,i,!1))}p.push("...");for(let g=u-py;g<u;g++){let y=g*d,b=y+d;p.push(..._w(r.slice(y,b),c,n,h,i,g===u-1))}}else for(let g=0;g<u;g++){let y=g*d,b=y+d;p.push(..._w(r.slice(y,b),c,n,h,i,g===u-1))}let f=l===2?",":"";p[0]="["+(u>0?p[0]+f:"");for(let g=1;g<p.length-1;g++)p[g]=" "+p[g]+f;let m=`,
`;for(let g=2;g<l;g++)m+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":m),p}function Dy(r){let t=[];for(let n=0;n<r.length;n+=2)t.push([r[n],r[n+1]]);return t}var Xn=class{constructor(t,n,s){if(this.dtype=n,this.shape=t.slice(),this.size=Jr(t),s!=null){let i=s.length;ue(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||DR(n,this.size),this.strides=_g(t)}set(t,...n){n.length===0&&(n=[0]),ue(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);let s=this.locToIndex(n);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(let i of t){if(i<0||i>=this.shape[n]){let a=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let s=t[t.length-1];for(let i=0;i<t.length-1;++i)s+=this.strides[i]*t[i];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let s=0;s<t.length-1;++s)n+=this.strides[s]*t[s];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(t/this.strides[s]),t-=n[s]*this.strides[s];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return vo().makeTensor(this.values,this.shape,this.dtype)}},vo=null,jf=null;function TDe(r){vo=r}function ADe(r){jf=r}var ur=class{constructor(r,t,n,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=r.slice(),this.dtype=t||"float32",this.size=Jr(r),this.strides=_g(r),this.dataId=n,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let r=await this.data();return jf.buffer(this.shape,this.dtype,r)}bufferSync(){return jf.buffer(this.shape,this.dtype,this.dataSync())}async array(){let r=await this.data();return fm(this.shape,r,this.dtype==="complex64")}arraySync(){return fm(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let r=vo().read(this.dataId);if(this.dtype==="string"){let t=await r;try{return t.map(n=>M2(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return r}dataToGPU(r){return this.throwIfDisposed(),vo().readToGPU(this.dataId,r)}dataSync(){this.throwIfDisposed();let r=vo().readSync(this.dataId);if(this.dtype==="string")try{return r.map(t=>M2(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return r}async bytes(){this.throwIfDisposed();let r=await vo().read(this.dataId);return this.dtype==="string"?r:new Uint8Array(r.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),vo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(r=!1){return jf.print(this,r)}clone(){return this.throwIfDisposed(),jf.clone(this)}toString(r=!1){let t=this.dataSync();return kDe(t,this.shape,this.dtype,r)}cast(r){return this.throwIfDisposed(),jf.cast(this,r)}variable(r=!0,t,n){return this.throwIfDisposed(),vo().makeVariable(this,r,t,n)}};Object.defineProperty(ur,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function Xe(){return RR("Tensor",()=>ur)}Xe();var pd=class extends ur{constructor(r,t,n,s){super(r.shape,r.dtype,r.dataId,s),this.trainable=t,this.name=n}assign(r){if(r.dtype!==this.dtype)throw new Error(`dtype of the new value (${r.dtype}) and previous value (${this.dtype}) must match`);if(!xl(r.shape,this.shape))throw new Error(`shape of the new value (${r.shape}) and previous value (${this.shape}) must match`);vo().disposeTensor(this),this.dataId=r.dataId,vo().incRef(this,null)}dispose(){vo().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(pd,Symbol.hasInstance,{value:r=>r instanceof ur&&r.assign!=null&&r.assign instanceof Function});var No={};ir(No,{assertTypesMatch:()=>Nq,getTensorsInContainer:()=>MR,isTensorInList:()=>FDe,makeTypesMatch:()=>Pn});var Vk;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(Vk||(Vk={}));var zk;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(zk||(zk={}));var Uk;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(Uk||(Uk={}));var Wk;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(Wk||(Wk={}));var Gk;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(Gk||(Gk={}));var DDe={float32:Wk,int32:zk,bool:Uk,complex64:Gk};function va(r,t){if(r==="string"||t==="string"){if(r==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${r} with ${t}`)}return DDe[r][t]}function VC(r){return va(r,"int32")}function Iq(r){return r!=null&&typeof r=="object"&&"texture"in r&&r.texture instanceof WebGLTexture}function kq(r){return typeof GPUBuffer<"u"&&r!=null&&typeof r=="object"&&"buffer"in r&&r.buffer instanceof GPUBuffer}function Pn(r,t){if(r.dtype===t.dtype)return[r,t];let n=va(r.dtype,t.dtype);return[r.cast(n),t.cast(n)]}function Nq(r,t){ue(r.dtype===t.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${t.dtype}) input must match`)}function FDe(r,t){return t.some(n=>n.id===r.id)}function MR(r){let t=[];return Tq(r,t,new Set),t}function Tq(r,t,n){if(r==null)return;if(r instanceof ur){t.push(r);return}if(!$De(r))return;let s=r;for(let i in s){let a=s[i];n.has(a)||(n.add(a),Tq(a,t,n))}}function $De(r){return Array.isArray(r)||typeof r=="object"}function rI(r){return r.kernelName!=null}var D5=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(r=>r.name)))}}}dispose(){for(let r in this.registeredVariables)this.registeredVariables[r].dispose()}},LR=class Hk{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new D5}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let s=t[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,s=1){return t in this.registryFactory?(zl(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:s}=this.initializeBackend(t);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new SDe(this.backendInstance),!0}setupRegisteredKernels(){O2(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){O2(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let s=n.factory();if(s&&!(s instanceof Rx)&&typeof s.then=="function"){let i=++this.pendingBackendInitId,a=s.then(o=>i<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,zl(`Initialization of backend ${t} failed`),zl(o.stack||o.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return zl(`Initialization of backend ${t} failed`),zl(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let s=t[n],{success:i,asyncInit:a}=this.initializeBackend(s);if(a||i)return{name:s,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let s=this.state.tensorInfo.get(n),i=s.backend,a=this.readSync(n),o=i.refCount(n);i.disposeData(n,!0),s.backend=t,t.move(n,a,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let s=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let i;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=n(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(t,n,s){t();try{let i=s();return n(),i}catch(i){throw n(),i}}nextTensorId(){return Hk.nextTensorId++}nextVariableId(){return Hk.nextVariableId++}clone(t){let n=ye.runKernel(vp,{x:t}),s={x:t},i=o=>({x:()=>{let u="float32",l={x:o},c={dtype:u};return ye.runKernel(tp,l,c)}}),a=[];return this.addTapeNode(this.state.activeScope.name,s,[n],i,a,{}),n}runKernel(t,n,s){if(this.backendName==null&&this.backend,jb(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,s){let i=this.backend.numDataIds(),a=0;s.forEach(l=>{a+=l.dtype==="complex64"?3:1});let o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],u=i-n-a-o;if(u>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${u} data ids) after running '${t}'`)}runKernelFunc(t){let n,s=[],i=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let u;this.backendName==null&&this.backend;let l,c=rI(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(rI(t)){let{kernelName:m,inputs:g,attrs:y}=t;this.backendName==null&&this.backend;let b=jb(m,this.backendName);ue(b!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),u=()=>{let x=this.backend.numDataIds();l=b.kernelFunc({inputs:g,attrs:y,backend:this.backend});let w=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,x,w);let v=w.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(i){let S=this.getTensorsForGradient(m,g,v);s=this.saveTensorsForBackwardMode(S)}return v}}else{let{forwardFunc:m}=t,g=y=>{i&&(s=y.map(b=>this.keep(this.clone(b))))};u=()=>{let y=this.backend.numDataIds();l=this.tidy(()=>m(this.backend,g));let b=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,b),b}}let{inputs:h,attrs:d}=t,p=rI(t)?null:t.backwardsFunc,f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=u():(f=this.profiler.profileKernel(c,h,()=>u()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),n=f.outputs)}),i&&this.addTapeNode(c,h,n,p,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(m=>h[m]!=null?h[m].shape:null),outputShapes:n.map(m=>m.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,s){let i=Pk(t);if(i!=null){let a=i.inputsToSave||[],o=i.outputsToSave||[],u;i.saveAllInputs?(ue(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),u=Object.keys(n).map(c=>n[c])):u=a.map(c=>n[c]);let l=s.filter((c,h)=>o[h]);return u.concat(l)}return[]}makeTensor(t,n,s,i){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",i=i||this.backend;let a=t;s==="string"&&Xl(t[0])&&(a=t.map(l=>iv(l)));let o=i.write(a,n,s),u=new ur(n,s,o,this.nextTensorId());if(this.trackTensor(u,i),s==="string"){let l=this.state.tensorInfo.get(o),c=dq(a);this.state.numBytes+=c-l.bytes,l.bytes=c}return u}makeTensorFromDataId(t,n,s,i){s=s||"float32";let a={dataId:t,shape:n,dtype:s};return this.makeTensorFromTensorInfo(a,i)}makeTensorFromTensorInfo(t,n){let{dataId:s,shape:i,dtype:a}=t,o=new ur(i,a,s,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(t,n=!0,s,i){s=s||this.nextVariableId().toString(),i!=null&&i!==t.dtype&&(t=t.cast(i));let a=new pd(t,n,s,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*F2(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof pd||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let s=t.size*F2(t.dtype);this.state.numBytes-=s}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(let i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,s,i,a,o){let u={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:s,saved:a},l=Pk(t);l!=null&&(i=l.gradFunc),i!=null&&(u.gradient=c=>(c=c.map((h,d)=>{if(h==null){let p=s[d],f=_C(p.size,p.dtype);return this.makeTensor(f,p.shape,p.dtype)}return h}),i(c.length>1?c:c[0],a,o))),this.state.activeTape.push(u)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=MR(t),s=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){let o=this.state.activeScope.track[a];!o.kept&&!s.has(o.id)&&o.dispose()}let i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===i.id&&this.track(a)})}gradients(t,n,s,i=!1){if(ue(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);let a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));ue(a instanceof ur,()=>"The result y returned by f() must be a tensor.");let o=EDe(this.state.activeTape,n,a);if(!i&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let u={};u[a.id]=s??RDe(a.shape),IDe(u,o,c=>this.tidy(c),ODe);let l=n.map(c=>u[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(let h of c.saved)h.dispose()}),this.state.activeTape=null),{value:a,grads:l}})}customGrad(t){return ue(mc(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{ue(n.every(u=>u instanceof ur),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s,i={};n.forEach((u,l)=>{i[l]=u});let a=(u,l)=>(s=t(...n,l),ue(s.value instanceof ur,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),ue(mc(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(u,l)=>{let c=s.gradFunc(u,l),h=Array.isArray(c)?c:[c];ue(h.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),ue(h.every(p=>p instanceof ur),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let d={};return h.forEach((p,f)=>{d[f]=()=>p}),d};return this.runKernelFunc({forwardFunc:a,backwardsFunc:o,inputs:i})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=qb(),s=await this.backend.time(t);return s.wallMs=qb()-n,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new D5;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};LR.nextTensorId=0;LR.nextVariableId=0;function RDe(r){let t=FR(Jr(r),"float32");return ye.makeTensor(t,r,"float32")}function Aq(){let r=yq();if(r._tfengine==null){let t=new gq(r);r._tfengine=new LR(t)}return sDe(r._tfengine.ENV),TDe(()=>r._tfengine),r._tfengine}var ye=Aq();function ODe(r,t){let n={a:r,b:t};return ye.runKernel(Mc,n)}var av={};ir(av,{isBrowser:()=>Dq,isMobile:()=>PDe,mockIsMobile:()=>LDe});function MDe(){return typeof navigator<"u"&&navigator!=null}var jk;function LDe(r){jk=r}function PDe(r){if(jk!==void 0)return jk;if(r||MDe()){if(r||(r=navigator),r.product==="ReactNative")return!0;let t=r.userAgent||r.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=r;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Dq(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Ni=Re();Ni.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Ni.registerFlag("IS_BROWSER",()=>Dq());Ni.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Ni.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Ni.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Ni.registerFlag("PROD",()=>!1);Ni.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ni.getBool("DEBUG"));Ni.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Ni.registerFlag("IS_TEST",()=>!1);Ni.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Ni.getBool("DEBUG"));Ni.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Ni.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Ni.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function gu(r,t){let n=r;if(ys(r))return t==="string"?[]:[r.length];if(Iq(r)){let i=r.channels||"RGBA";return[r.height,r.width*i.length]}else if(kq(r))return[r.buffer.size/(t==null?4:F2(t))];if(!Array.isArray(r))return[];let s=[];for(;Array.isArray(n)||ys(n)&&t!=="string";)s.push(n.length),n=n[0];return Array.isArray(r)&&Re().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Fq(r,s,[]),s}function Fq(r,t,n){if(n=n||[],!Array.isArray(r)&&!ys(r)){ue(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}ue(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${r.length} elements`),ue(r.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${r.length} elements`);let s=t.slice(1);for(let i=0;i<r.length;++i)Fq(r[i],s,n.concat(i))}function F5(r,t,n,s){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==t||r==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${r} tensor, but got ${t} tensor`)}}function Q(r,t,n,s="numeric"){if(r instanceof Xe())return F5(s,r.dtype,t,n),r;let i=Ox(r);if(i!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(i=s),F5(s,i,t,n),r==null||!ys(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${u}'`)}let a=gu(r,i);!ys(r)&&!Array.isArray(r)&&(r=[r]);let o=i!=="string"?BC(r,i):gc(r,[],!0);return ye.makeTensor(o,a,i)}function Kb(r,t,n,s="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((i,a)=>Q(i,`${t}[${a}]`,n,s))}var PR="__op";function be(r){let t=Object.keys(r);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],s=r[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+PR;let i=(...a)=>{ye.startScope(n);try{let o=s(...a);return EC(o)&&console.error("Cannot return a Promise inside of tidy."),ye.endScope(o),o}catch(o){throw ye.endScope(null),o}};return Object.defineProperty(i,"name",{value:n,configurable:!0}),i}function BDe(r,t){let n=Q(r,"real","complex"),s=Q(t,"imag","complex");di(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);let i={real:n,imag:s};return ye.runKernel(IC,i)}var hl=be({complex_:BDe});function Vc(r,t,n,s){if(s==null)s=Ox(r);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(kq(r)||Iq(r)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return ye.backend.createTensorFromGPUData(r,t||n,s)}if(!ys(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){ua(t);let i=Jr(t),a=Jr(n);ue(i===a,()=>`Based on the provided shape, [${t}], the tensor should have ${i} values but has ${a}`);for(let o=0;o<n.length;++o){let u=n[o],l=o===n.length-1?u!==Jr(t.slice(o)):!0;ue(n[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!ys(r)&&!Array.isArray(r)&&(r=[r]),t=t||n,r=s!=="string"?BC(r,s):gc(r,[],!0),ye.makeTensor(r,t,s)}function ai(r,t,n){let s=gu(r,n);return Vc(r,t,s,n)}var fd={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},vl=class $q{static join(t){return new $q(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>ys(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let s=0;s<t.length;s++){let i=t[s];s!==t.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let a=n+i.byteLength;this.shards.push({buffer:i,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);let i=n-t,a=new ArrayBuffer(i),o=new Uint8Array(a),u=0;for(let l=s;l<this.shards.length;l++){let c=this.shards[l],h=t+u-c.start,d=u,p=Math.min(n,c.end)-c.start,f=new Uint8Array(c.buffer,h,p-h);if(o.set(f,d),u+=f.length,n<c.end)break}return a}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(i){return t<i.start?-1:t>=i.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let s=VDe(this.shards,n);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}};function VDe(r,t){let n=0,s=r.length;for(;n<=s;){let i=Math.floor((s-n)/2)+n,a=t(r[i]);if(a===0)return i;a<0?s=i:n=i+1}return-1}function zDe(){Re().set("PROD",!0)}function UDe(){Re().set("DEBUG",!0)}function WDe(){Re().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Rq(r){Re().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function GDe(){ye.disposeVariables()}function Ma(){return ye}function qk(){return ye.memory()}function HDe(r){return ye.profile(r)}function Ie(r,t){return ye.tidy(r,t)}function nr(r){MR(r).forEach(t=>t.dispose())}function ns(r){return ye.keep(r)}function jDe(r){return ye.time(r)}function qDe(r){return ye.setBackend(r)}function KDe(){return ye.ready()}function Oq(){return ye.backendName}function XDe(r){ye.removeBackend(r)}function YDe(r){return ye.findBackend(r)}function ZDe(r){return ye.findBackendFactory(r)}function zC(r,t,n=1){return ye.registerBackend(r,t,n)}function BR(){return ye.backend}function JDe(r,t){Re().setPlatform(r,t)}var yc=4;async function QDe(r,t){let n=[],s=[],i=Array.isArray(r)?r.map(o=>o.name):Object.keys(r);for(let o=0;o<i.length;++o){let u=i[o],l=Array.isArray(r)?r[o].tensor:r[u];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${u}': ${l.dtype}`);let c={name:u,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let h=new Promise(async d=>{let p=await l.bytes(),f=p.reduce((y,b)=>y+b.length,0)+yc*p.length,m=new Uint8Array(f),g=0;for(let y=0;y<p.length;y++){let b=p[y],x=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(x,g),g+=yc,m.set(b,g),g+=b.length}d(m)});s.push(h)}else s.push(l.data());t!=null&&(c.group=t),n.push(c)}let a=await Promise.all(s);return{data:rFe(a),specs:n}}function Mq(r,t){let n=new vl(r),s={},i=0;for(let a of t){let o=eFe(a,(u,l)=>n.slice(i+u,i+l));s[a.name]=Lq(a,n.slice(i,i+o)),i+=o}return s}function eFe(r,t){let n=Jr(r.shape),s;if("quantization"in r){let i=r.quantization;s=fd[i.dtype]}else if(r.dtype==="string"){let i=0;for(let a=0;a<n;a++)i+=yc+new Uint32Array(t(i,i+yc))[0];return i}else s=fd[r.dtype];return n*s}async function tFe(r,t){let n=Jr(r.shape),s;if("quantization"in r){let i=r.quantization;s=fd[i.dtype]}else if(r.dtype==="string"){let i=0;for(let a=0;a<n;a++)i+=yc+new Uint32Array(await t(i,i+yc))[0];return i}else s=fd[r.dtype];return n*s}function Lq(r,t){let n=r.name,s=r.dtype,i=r.shape,a=Jr(i),o,u=0;if("quantization"in r){let l=r.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${r.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${r.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${r.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let c=fd[l.dtype],h=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){o=new Float32Array(h.length);for(let d=0;d<h.length;d++){let p=h[d];o[d]=p*l.scale+l.min}}else if(l.dtype==="float16")o=lFe()(h);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);o=new Int32Array(h.length);for(let d=0;d<h.length;d++){let p=h[d];o[d]=Math.round(p*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);u+=a*c}else if(s==="string"){let l=Jr(r.shape);o=[];for(let c=0;c<l;c++){let h=new Uint32Array(t.slice(u,u+yc))[0];u+=yc;let d=new Uint8Array(t.slice(u,u+h));o.push(d),u+=h}}else{let l=fd[s];if(s==="float32")o=new Float32Array(t);else if(s==="int32")o=new Int32Array(t);else if(s==="bool")o=new Uint8Array(t);else if(s==="complex64"){o=new Float32Array(t);let c=new Float32Array(o.length/2),h=new Float32Array(o.length/2);for(let m=0;m<c.length;m++)c[m]=o[m*2],h[m]=o[m*2+1];let d=ai(c,i,"float32"),p=ai(h,i,"float32"),f=hl(d,p);return d.dispose(),p.dispose(),f}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);u+=a*l}return ai(o,i,s)}async function $5(r,t,n){let s=new Uint8Array(t);for(;s.byteLength<n;){let{done:i,value:a}=await r.read();if(i&&a==null){let u=n-s.byteLength;throw new Error(`Reader is done but ${u} bytes are still expected`)}let o=new Uint8Array(s.length+a.byteLength);o.set(s,0),o.set(new Uint8Array(a),s.length),s=o}return s.buffer}async function Pq(r,t){let n={},s=r.getReader(),i=new ArrayBuffer(0);for(let a of t){let o=await tFe(a,async(c,h)=>(i=await $5(s,i,h),i.slice(c,h)));i=await $5(s,i,o);let u=i.slice(0,o);i=i.slice(o);let l=Lq(a,u);if(n[a.name]=l,Oq()==="webgpu"){let c=BR();"uploadToGPU"in c&&Jr(l.shape)>=Re().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return n}function rFe(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let t=0,n=[];r.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});let s=new Uint8Array(t),i=0;return n.forEach(a=>{s.set(new Uint8Array(a.buffer),i),i+=a.byteLength}),s.buffer}var VR=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function R5(r){return VR?Buffer.byteLength(r,"utf8"):new Blob([r]).size}function nFe(r){if(VR)return Buffer.from(r).toString("base64");let t=new Uint8Array(r),n="";for(let s=0,i=t.length;s<i;s++)n+=String.fromCharCode(t[s]);return btoa(n)}function sFe(r){if(VR){let s=Buffer.from(r,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}let t=atob(r),n=new Uint8Array(t.length);for(let s=0;s<t.length;++s)n.set([t.charCodeAt(s)],s);return n.buffer}function iFe(r){return vl.join(r)}function O5(r){let t="/";for(r=r.trim();r.endsWith(t);)r=r.slice(0,r.length-1);let n=r.split(t);return n[n.length-1]}function Bq(r,t){let n={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:t};return r.signature!=null&&(n.signature=r.signature),r.userDefinedMetadata!=null&&(n.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(n.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(n.initializerSignature=r.initializerSignature),r.trainingConfig!=null&&(n.trainingConfig=r.trainingConfig),n}function Vq(r,t,n){let s={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(s.trainingConfig=r.trainingConfig),r.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=n}return r.signature!=null&&(s.signature=r.signature),r.userDefinedMetadata!=null&&(s.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(s.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(s.initializerSignature=r.initializerSignature),s}async function zR(r,t){let n,s;return r.weightsManifest!=null&&([n,s]=await t(r.weightsManifest)),Vq(r,n,s)}function ov(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:R5(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:R5(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:new vl(r.weightData).byteLength}}function Kk(r){let t=[];for(let n of r)t.push(...n.weights);return t}function aFe(){let r=n=>{let s=n<<13,i=0;for(;!(s&8388608);)i-=8388608,s<<=1;return s&=-8388609,i+=947912704,s|i},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=r(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function oFe(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let t=1;t<31;t++)r[t]=t<<23;for(let t=33;t<63;t++)r[t]=2147483648+(t-32<<23);return r}function uFe(){let r=new Uint32Array(64);for(let t=0;t<64;t++)r[t]=1024;return r[0]=r[32]=0,r}function lFe(){let r=aFe(),t=oFe(),n=uFe();return s=>{let i=new ArrayBuffer(4*s.length),a=new Uint32Array(i);for(let o=0;o<s.length;o++){let u=s[o],l=r[n[u>>10]+(u&1023)]+t[u>>10];a[o]=l}return new Float32Array(i)}}var wa=class po{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return po.instance==null&&(po.instance=new po),po.instance}static registerSaveRouter(t){po.getInstance().saveRouters.push(t)}static registerLoadRouter(t){po.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return po.getHandlers(t,"save")}static getLoadHandlers(t,n){return po.getHandlers(t,"load",n)}static getHandlers(t,n,s){let i=[];return(n==="load"?po.getInstance().loadRouters:po.getInstance().saveRouters).forEach(a=>{let o=a(t,s);o!==null&&i.push(o)}),i}},cFe=r=>wa.registerSaveRouter(r),hFe=r=>wa.registerLoadRouter(r),dFe=r=>wa.getSaveHandlers(r),pFe=(r,t)=>wa.getLoadHandlers(r,t),Xk="tensorflowjs",Yk=1,Ah="models_store",Yl="model_info_store";function zq(){if(!Re().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window>"u"?self:window,t=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Zk(r){let t=r.result;t.createObjectStore(Ah,{keyPath:"modelPath"}),t.createObjectStore(Yl,{keyPath:"modelPath"})}var md=class{constructor(r){if(this.indexedDB=zq(),r==null||!r)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=r}async save(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,r)}async load(){return this.databaseAction(this.modelPath)}databaseAction(r,t){return new Promise((n,s)=>{let i=this.indexedDB.open(Xk,Yk);i.onupgradeneeded=()=>Zk(i),i.onsuccess=()=>{let a=i.result;if(t==null){let o=a.transaction(Ah,"readonly"),u=o.objectStore(Ah).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(u.result.modelArtifacts)},u.onerror=l=>(a.close(),s(u.error)),o.oncomplete=()=>a.close()}else{t.weightData=vl.join(t.weightData);let o=ov(t),u=a.transaction(Yl,"readwrite"),l=u.objectStore(Yl),c;try{c=l.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(d){return s(d)}let h;c.onsuccess=()=>{h=a.transaction(Ah,"readwrite");let d=h.objectStore(Ah),p;try{p=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(f){return s(f)}p.onsuccess=()=>n({modelArtifactsInfo:o}),p.onerror=f=>{l=u.objectStore(Yl);let m=l.delete(this.modelPath);m.onsuccess=()=>(a.close(),s(p.error)),m.onerror=g=>(a.close(),s(p.error))}},c.onerror=d=>(a.close(),s(c.error)),u.oncomplete=()=>{h==null?a.close():h.oncomplete=()=>a.close()}}},i.onerror=a=>s(i.error)})}};md.URL_SCHEME="indexeddb://";var Uq=r=>Re().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(md.URL_SCHEME)?fFe(r.slice(md.URL_SCHEME.length)):null;wa.registerSaveRouter(Uq);wa.registerLoadRouter(Uq);function fFe(r){return new md(r)}function mFe(r){return r.startsWith(md.URL_SCHEME)?r.slice(md.URL_SCHEME.length):r}var gFe=class{constructor(){this.indexedDB=zq()}async listModels(){return new Promise((r,t)=>{let n=this.indexedDB.open(Xk,Yk);n.onupgradeneeded=()=>Zk(n),n.onsuccess=()=>{let s=n.result,i=s.transaction(Yl,"readonly"),a=i.objectStore(Yl).getAll();a.onsuccess=()=>{let o={};for(let u of a.result)o[u.modelPath]=u.modelArtifactsInfo;r(o)},a.onerror=o=>(s.close(),t(a.error)),i.oncomplete=()=>s.close()},n.onerror=s=>t(n.error)})}async removeModel(r){return r=mFe(r),new Promise((t,n)=>{let s=this.indexedDB.open(Xk,Yk);s.onupgradeneeded=()=>Zk(s),s.onsuccess=()=>{let i=s.result,a=i.transaction(Yl,"readwrite"),o=a.objectStore(Yl),u=o.get(r),l;u.onsuccess=()=>{if(u.result==null)return i.close(),n(new Error(`Cannot find model with path '${r}' in IndexedDB.`));{let c=o.delete(r),h=()=>{l=i.transaction(Ah,"readwrite");let d=l.objectStore(Ah).delete(r);d.onsuccess=()=>t(u.result.modelArtifactsInfo),d.onerror=p=>n(u.error)};c.onsuccess=h,c.onerror=d=>(h(),i.close(),n(u.error))}},u.onerror=c=>(i.close(),n(u.error)),a.oncomplete=()=>{l==null?i.close():l.oncomplete=()=>i.close()}},s.onerror=i=>n(s.error)})}},Gu="/",qf="tensorflowjs_models",Wq="info",yFe="model_topology",bFe="weight_specs",xFe="weight_data",vFe="model_metadata";function Gq(r){return{info:[qf,r,Wq].join(Gu),topology:[qf,r,yFe].join(Gu),weightSpecs:[qf,r,bFe].join(Gu),weightData:[qf,r,xFe].join(Gu),modelMetadata:[qf,r,vFe].join(Gu)}}function Hq(r){for(let t of Object.values(r))window.localStorage.removeItem(t)}function wFe(r){let t=r.split(Gu);if(t.length<3)throw new Error(`Invalid key format: ${r}`);return t.slice(1,t.length-1).join(Gu)}function SFe(r){return r.startsWith(gd.URL_SCHEME)?r.slice(gd.URL_SCHEME.length):r}var gd=class{constructor(r){if(!Re().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,r==null||!r)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=r,this.keys=Gq(this.modelPath)}async save(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(r.modelTopology),n=JSON.stringify(r.weightSpecs),s=ov(r),i=vl.join(r.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,nFe(i));let a={format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,signature:r.signature!=null?r.signature:void 0,userDefinedMetadata:r.userDefinedMetadata!=null?r.userDefinedMetadata:void 0,modelInitializer:r.modelInitializer!=null?r.modelInitializer:void 0,initializerSignature:r.initializerSignature!=null?r.initializerSignature:void 0,trainingConfig:r.trainingConfig!=null?r.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch{throw Hq(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){let r=JSON.parse(this.LS.getItem(this.keys.info));if(r==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(r.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;let i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){let o=JSON.parse(i);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(t.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=sFe(a),t}};gd.URL_SCHEME="localstorage://";var jq=r=>Re().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(gd.URL_SCHEME)?CFe(r.slice(gd.URL_SCHEME.length)):null;wa.registerSaveRouter(jq);wa.registerLoadRouter(jq);function CFe(r){return new gd(r)}var _Fe=class{constructor(){ue(Re().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),ue(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let r={},t=qf+Gu,n=Gu+Wq;for(let s=0;s<this.LS.length;++s){let i=this.LS.key(s);if(i.startsWith(t)&&i.endsWith(n)){let a=wFe(i);r[a]=JSON.parse(this.LS.getItem(i))}}return r}async removeModel(r){r=SFe(r);let t=Gq(r);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${r}'`);let n=JSON.parse(this.LS.getItem(t.info));return Hq(t),n}},mm="://",bc=class Fl{constructor(){this.managers={}}static getInstance(){return Fl.instance==null&&(Fl.instance=new Fl),Fl.instance}static registerManager(t,n){ue(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(mm)&&(t=t.slice(0,t.indexOf(mm))),ue(t.length>0,()=>"scheme must not be an empty string.");let s=Fl.getInstance();ue(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=n}static getManager(t){let n=Fl.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(Fl.getInstance().managers)}};function Ew(r){if(r.indexOf(mm)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${bc.getSchemes().join(",")}`);return{scheme:r.split(mm)[0],path:r.split(mm)[1]}}async function qq(r,t,n=!1){ue(r!==t,()=>`Old path and new path are the same: '${r}'`);let s=wa.getLoadHandlers(r);ue(s.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),ue(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${r}.`);let i=s[0],a=wa.getSaveHandlers(t);ue(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),ue(a.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`);let o=a[0],u=Ew(r).scheme,l=Ew(r).path,c=u===Ew(r).scheme,h=await i.load();n&&c&&await bc.getManager(u).removeModel(l);let d=await o.save(h);return n&&!c&&await bc.getManager(u).removeModel(l),d.modelArtifactsInfo}async function EFe(){let r=bc.getSchemes(),t={};for(let n of r){let s=await bc.getManager(n).listModels();for(let i in s){let a=n+mm+i;t[a]=s[i]}}return t}async function IFe(r){let t=Ew(r);return bc.getManager(t.scheme).removeModel(t.path)}async function kFe(r,t){return qq(r,t,!1)}async function NFe(r,t){return qq(r,t,!0)}var TFe=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(r,t){return fetch(r,t)}now(){return performance.now()}encode(r,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(r)}decode(r,t){return new TextDecoder(t).decode(r)}setTimeoutCustom(r,t){if(typeof window>"u"||!Re().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(r,t);return}this.functionRefs.push(r),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let s=this.functionRefs[n.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(r){return Sq(r)}};if(Re().get("IS_BROWSER")){Re().setPlatform("browser",new TFe);try{bc.registerManager(gd.URL_SCHEME,new _Fe)}catch{}try{bc.registerManager(md.URL_SCHEME,new gFe)}catch{}}var AFe={importFetch:()=>CAe()},nI,DFe=class{constructor(){this.util=_Ae(),this.textEncoder=new this.util.TextEncoder}fetch(r,t){return Re().global.fetch!=null?Re().global.fetch(r,t):(nI==null&&(nI=AFe.importFetch()),nI(r,t))}now(){let r=process.hrtime();return r[0]*1e3+r[1]/1e6}encode(r,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(r)}decode(r,t){return r.length===0?"":new this.util.TextDecoder(t).decode(r)}isTypedArray(r){return this.util.types.isFloat32Array(r)||this.util.types.isInt32Array(r)||this.util.types.isUint8Array(r)||this.util.types.isUint8ClampedArray(r)}};Re().get("IS_NODE")&&!Re().get("IS_BROWSER")&&Re().setPlatform("node",new DFe);function pr(r,t="float32",n){return t=t||"float32",ua(r),new Xn(r,t,n)}function FFe(r,t){let n=Q(r,"x","cast");if(!hq(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let s={x:n},i={dtype:t};return ye.runKernel(tp,s,i)}var at=be({cast_:FFe});function $Fe(r){let t={x:Q(r,"x","clone","string_or_numeric")};return ye.runKernel(vp,t)}var au=be({clone_:$Fe});function UR(r,t=!1){console.log(r.toString(t))}Aq();var RFe={buffer:pr,cast:at,clone:au,print:UR};ADe(RFe);function OFe(r,t){let n=Q(r,"a","add"),s=Q(t,"b","add");[n,s]=Pn(n,s);let i={a:n,b:s};return ye.runKernel(Mc,i)}var Ke=be({add_:OFe});function MFe(r,t){let n=Q(r,"a","floorDiv"),s=Q(t,"b","floorDiv");[n,s]=Pn(n,s);let i={a:n,b:s};return ye.runKernel(yp,i)}var UC=be({floorDiv_:MFe});function LFe(r,t){let n=Q(r,"a","div"),s=Q(t,"b","div");if([n,s]=Pn(n,s),n.dtype==="int32"&&s.dtype==="int32")return UC(n,s);let i={a:n,b:s},a={};return ye.runKernel(hp,i,a)}var _t=be({div_:LFe});function PFe(r,t){let n=Q(r,"a","mul"),s=Q(t,"b","mul");[n,s]=Pn(n,s);let i={a:n,b:s};return ye.runKernel(Mp,i)}var Se=be({mul_:PFe});function BFe(r){let t=Q(r,"x","abs");if(t.dtype==="complex64"){let n={x:t};return ye.runKernel(Bx,n)}else{let n={x:t};return ye.runKernel(Eg,n)}}var jn=be({abs_:BFe});function VFe(r){let t={x:Q(r,"x","acos")};return ye.runKernel(Hd,t)}var WR=be({acos_:VFe});function zFe(r){let t={x:Q(r,"x","acosh")};return ye.runKernel(jd,t)}var GR=be({acosh_:zFe});function UFe(r){ue(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),ue(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let t=r.map((i,a)=>Q(i,`tensors${a}`,"addN")),n=t[0];t.forEach(i=>{if(i.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(i=>{if(!xl(i.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let s=t;return ye.runKernel(qd,s)}var Kq=be({addN_:UFe});function WFe(r,t=null,n=!1){let s={x:Q(r,"x","all","bool")},i={axis:t,keepDims:n};return ye.runKernel(Ig,s,i)}var WC=be({all_:WFe});function GFe(r,t=null,n=!1){let s={x:Q(r,"x","any","bool")},i={axis:t,keepDims:n};return ye.runKernel(kg,s,i)}var Xb=be({any_:GFe});function HFe(r,t=0){let n={x:Q(r,"x","argMax")},s={axis:t};return ye.runKernel(Ng,n,s)}var yd=be({argMax_:HFe});function jFe(r,t=0){let n={x:Q(r,"x","argMin")},s={axis:t};return ye.runKernel(Tg,n,s)}var HR=be({argMin_:jFe});function qFe(r){let t={x:Q(r,"x","asin")};return ye.runKernel(Kd,t)}var jR=be({asin_:qFe});function KFe(r){let t={x:Q(r,"x","asinh")};return ye.runKernel(Xd,t)}var qR=be({asinh_:KFe});function XFe(r){let t={x:Q(r,"x","atan")};return ye.runKernel(Yd,t)}var KR=be({atan_:XFe});function YFe(r,t){let n=Q(r,"a","atan2"),s=Q(t,"b","atan2");[n,s]=Pn(n,s);let i={a:n,b:s};return ye.runKernel(Jd,i)}var XR=be({atan2_:YFe});function ZFe(r){let t={x:Q(r,"x","atanh")};return ye.runKernel(Zd,t)}var YR=be({atanh_:ZFe});function JFe(r,t,n,s,i="NHWC",a){let o=r[3],u=[...t,o],l=Zq(i);return uv(r,u,n,a,s,null,null,l)}function Xq(r,t,n,s,i,a,o="channelsLast"){let[u,l]=Yb(t),c;if(o==="channelsLast")c=[u,l,r[3],r[3]];else if(o==="channelsFirst")c=[u,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${o}`);return uv(r,c,n,s,i,a,!1,o)}function QFe(r,t,n,s,i,a,o="NDHWC"){let[u,l,c]=Jk(t),h,d;if(o==="NDHWC")d="channelsLast",h=[u,l,c,r[4],r[4]];else if(o==="NCDHW")d="channelsFirst",h=[u,l,c,r[1],r[1]];else throw new Error(`Unknown dataFormat ${o}`);return Yq(r,h,n,s,i,!1,d,a)}function uv(r,t,n,s,i,a,o=!1,u="channelsLast"){let[l,c,h,d]=[-1,-1,-1,-1];if(u==="channelsLast")[l,c,h,d]=r;else if(u==="channelsFirst")[l,d,c,h]=r;else throw new Error(`Unknown dataFormat ${u}`);let[p,f,,m]=t,[g,y]=Yb(n),[b,x]=Yb(s),w=gm(p,b),v=gm(f,x),{padInfo:S,outHeight:E,outWidth:C}=r$e(i,c,h,g,y,w,v,a,u),I=o?m*d:m,_;return u==="channelsFirst"?_=[l,I,E,C]:u==="channelsLast"&&(_=[l,E,C,I]),{batchSize:l,dataFormat:u,inHeight:c,inWidth:h,inChannels:d,outHeight:E,outWidth:C,outChannels:I,padInfo:S,strideHeight:g,strideWidth:y,filterHeight:p,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:x,inShape:r,outShape:_,filterShape:t}}function Yq(r,t,n,s,i,a=!1,o="channelsLast",u){let[l,c,h,d,p]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,h,d,p]=r;else if(o==="channelsFirst")[l,p,c,h,d]=r;else throw new Error(`Unknown dataFormat ${o}`);let[f,m,g,,y]=t,[b,x,w]=Jk(n),[v,S,E]=Jk(s),C=gm(f,v),I=gm(m,S),_=gm(g,E),{padInfo:A,outDepth:k,outHeight:N,outWidth:D}=n$e(i,c,h,d,b,x,w,C,I,_,u),F=a?y*p:y,P;return o==="channelsFirst"?P=[l,F,k,N,D]:o==="channelsLast"&&(P=[l,k,N,D,F]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:h,inWidth:d,inChannels:p,outDepth:k,outHeight:N,outWidth:D,outChannels:F,padInfo:A,strideDepth:b,strideHeight:x,strideWidth:w,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:C,effectiveFilterHeight:I,effectiveFilterWidth:_,dilationDepth:v,dilationHeight:S,dilationWidth:E,inShape:r,outShape:P,filterShape:t}}function e$e(r,t,n,s,i){s==null&&(s=ZR(r,t,n));let a=r[0],o=r[1],u=Zb((a-t+2*s)/n+1,i),l=Zb((o-t+2*s)/n+1,i);return[u,l]}function t$e(r,t,n,s,i,a){i==null&&(i=ZR(r,t[0],s[0]));let o=[0,0,0,n];for(let u=0;u<3;u++)r[u]+2*i>=t[u]&&(o[u]=Zb((r[u]-t[u]+2*i)/s[u]+1,a));return o}function ZR(r,t,n,s=1){let i=gm(t,s);return Math.floor((r[0]*(n-1)-n+i)/2)}function Yb(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function Jk(r){return typeof r=="number"?[r,r,r]:r}function gm(r,t){return t<=1?r:r+(r-1)*(t-1)}function r$e(r,t,n,s,i,a,o,u,l){let c,h,d;if(typeof r=="number"){c={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let p=e$e([t,n],a,s,r,u);h=p[0],d=p[1]}else if(r==="same"){h=Math.ceil(t/s),d=Math.ceil(n/i);let p=Math.max(0,(h-1)*s+a-t),f=Math.max(0,(d-1)*i+o-n),m=Math.floor(p/2),g=p-m,y=Math.floor(f/2),b=f-y;c={top:m,bottom:g,left:y,right:b,type:"SAME"}}else if(r==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-a+1)/s),d=Math.ceil((n-o+1)/i);else if(typeof r=="object"){let p=l==="channelsLast"?r[1][0]:r[2][0],f=l==="channelsLast"?r[1][1]:r[2][1],m=l==="channelsLast"?r[2][0]:r[3][0],g=l==="channelsLast"?r[2][1]:r[3][1];c={top:p,bottom:f,left:m,right:g,type:p===0&&f===0&&m===0&&g===0?"VALID":"EXPLICIT"},h=Zb((t-a+p+f)/s+1,u),d=Zb((n-o+m+g)/i+1,u)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:c,outHeight:h,outWidth:d}}function n$e(r,t,n,s,i,a,o,u,l,c,h){let d,p,f,m;if(r==="valid"&&(r=0),typeof r=="number"){d={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=t$e([t,n,s,1],[u,l,c],1,[i,a,o],r,h);p=g[0],f=g[1],m=g[2]}else if(r==="same"){p=Math.ceil(t/i),f=Math.ceil(n/a),m=Math.ceil(s/o);let g=(p-1)*i+u-t,y=(f-1)*a+l-n,b=(m-1)*o+c-s,x=Math.floor(g/2),w=g-x,v=Math.floor(y/2),S=y-v,E=Math.floor(b/2),C=b-E;d={top:v,bottom:S,left:E,right:C,front:x,back:w,type:"SAME"}}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:d,outDepth:p,outHeight:f,outWidth:m}}function Zb(r,t){if(!t)return Math.trunc(r);switch(t){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${t}`)}}function xc(r){let[t,n,s]=Yb(r);return t===1&&n===1&&s===1}function Eu(r,t){return xc(r)||xc(t)}function bd(r){return Yb(r).every(t=>t>0)}function Zq(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function pi(r,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")ue(zm(t),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(i=>{ue(zm(i),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${n} but got pad ${i}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${t}`)}}function s$e(r,t){let n={x:Q(r,"x","reshape","string_or_numeric")},s={shape:t};return ye.runKernel(l0,n,s)}var Ee=be({reshape_:s$e});function i$e(r,t,n,s,i){let a=Q(r,"x","avgPool","float32"),o=1;ue(Eu(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let u=a,l=!1;a.rank===3&&(l=!0,u=Ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ue(u.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${u.rank}.`),pi("avgPool",s,i);let c={x:u},h={filterSize:t,strides:n,pad:s,dimRoundingMode:i},d=ye.runKernel(Qd,c,h);return d=at(d,a.dtype),l?Ee(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var wl=be({avgPool_:i$e});function a$e(r,t,n,s,i,a="NDHWC"){let o=Q(r,"x","avgPool3d","float32"),u=o,l=!1;o.rank===4&&(l=!0,u=Ee(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ue(u.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${u.rank}.`),ue(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),ue(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),pi("avgPool3d",s,i);let c={x:u},h={filterSize:t,strides:n,pad:s,dimRoundingMode:i,dataFormat:a},d=ye.runKernel(Ag,c,h);return d=at(d,u.dtype),l?Ee(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var JR=be({avgPool3d_:a$e});function o$e(r,t=0){ue(r.length>=1,()=>"Pass at least one tensor to concat");let n=Kb(r,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return au(n[0]);let s=n,i={axis:t};return ye.runKernel(Rg,s,i)}var an=be({concat_:o$e});function u$e(r,t,n=!1,s=!1){let i=Q(r,"a","matMul"),a=Q(t,"b","matMul");[i,a]=Pn(i,a);let o={a:i,b:a},u={transposeA:n,transposeB:s};return ye.runKernel(ep,o,u)}var cr=be({matMul_:u$e});function l$e(r){let t={x:Q(r,"x","sigmoid","float32")};return ye.runKernel(ef,t)}var Xa=be({sigmoid_:l$e});function c$e(r,t,n){let s=Q(r,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");let i={x:s},a={begin:t,size:n};return ye.runKernel(g0,i,a)}var vr=be({slice_:c$e});function h$e(r){let t={x:Q(r,"x","tanh","float32")};return ye.runKernel(lf,t)}var vc=be({tanh_:h$e});function d$e(r,t,n,s,i,a){let o=Q(r,"forgetBias","basicLSTMCell"),u=Q(t,"lstmKernel","basicLSTMCell"),l=Q(n,"lstmBias","basicLSTMCell"),c=Q(s,"data","basicLSTMCell"),h=Q(i,"c","basicLSTMCell"),d=Q(a,"h","basicLSTMCell"),p=an([c,d],1),f=cr(p,u),m=Ke(f,l),g=m.shape[0],y=m.shape[1]/4,b=[g,y],x=vr(m,[0,0],b),w=vr(m,[0,y],b),v=vr(m,[0,y*2],b),S=vr(m,[0,y*3],b),E=Ke(Se(Xa(x),vc(w)),Se(h,Xa(Ke(o,v)))),C=Se(vc(E),Xa(S));return[E,C]}var Jq=be({basicLSTMCell_:d$e});function p$e(r,t,n){let s=Q(r,"x","batchToSpaceND"),i=t.reduce((u,l)=>u*l);ue(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),ue(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),ue(s.shape[0]%i===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${i}`);let a={x:s},o={blockShape:t,crops:n};return ye.runKernel(Dg,a,o)}var lv=be({batchToSpaceND_:p$e});function f$e(r){let t;return r.rank===0||r.rank===1?t=Ee(r,[1,1,1,r.size]):r.rank===2?t=Ee(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?t=Ee(r,[1,r.shape[0],r.shape[1],r.shape[2]]):t=r,t}function m$e(r,t,n,s,i,a){a==null&&(a=.001);let o=Q(r,"x","batchNorm"),u=Q(t,"mean","batchNorm"),l=Q(n,"variance","batchNorm"),c;i!=null&&(c=Q(i,"scale","batchNorm"));let h;s!=null&&(h=Q(s,"offset","batchNorm")),ue(u.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ue(h==null||u.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ue(c==null||u.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:f$e(o),scale:c,offset:h,mean:u,variance:l},p={varianceEpsilon:a},f=ye.runKernel(bp,d,p);return Ee(f,o.shape)}var cf=be({batchNorm_:m$e});function g$e(r,t,n,s,i,a){let o=Q(r,"x","batchNorm"),u=Q(t,"mean","batchNorm"),l=Q(n,"variance","batchNorm"),c;i!=null&&(c=Q(i,"scale","batchNorm"));let h;return s!=null&&(h=Q(s,"offset","batchNorm")),ue(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),ue(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`),ue(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&ue(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&ue(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),cf(o,u,l,h,c,a)}var QR=be({batchNorm2d_:g$e});function y$e(r,t,n,s,i,a){let o=Q(r,"x","batchNorm"),u=Q(t,"mean","batchNorm"),l=Q(n,"variance","batchNorm"),c;i!=null&&(c=Q(i,"scale","batchNorm"));let h;return s!=null&&(h=Q(s,"offset","batchNorm")),ue(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),ue(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`),ue(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&ue(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&ue(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),cf(o,u,l,h,c,a)}var e3=be({batchNorm3d_:y$e});function b$e(r,t,n,s,i,a){let o=Q(r,"x","batchNorm"),u=Q(t,"mean","batchNorm"),l=Q(n,"variance","batchNorm"),c;i!=null&&(c=Q(i,"scale","batchNorm"));let h;return s!=null&&(h=Q(s,"offset","batchNorm")),ue(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),ue(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`),ue(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&ue(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&ue(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),cf(o,u,l,h,c,a)}var t3=be({batchNorm4d_:b$e});function x$e(r,t,n){let s=Q(r,"x","bincount"),i=Q(t,"weights","bincount");ue(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),ue(n>=0,()=>`size must be non-negative, but got ${n}.`),ue(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);let a={x:s,weights:i},o={size:n};return ye.runKernel(Fg,a,o)}var r3=be({bincount_:x$e});function v$e(r,t){let n=Q(r,"x","bitwiseAnd"),s=Q(t,"y","bitwiseAnd");if(!xl(n.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${s.shape}`);if(n.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${s.dtype}`);let i={a:n,b:s};return ye.runKernel($g,i)}var Qq=be({bitwiseAnd_:v$e});function w$e(r,t){let n=Q(r,"s0","broadcastArgs","int32"),s=Q(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);let i={s0:n,s1:s};return ye.runKernel(Px,i)}var eK=be({broadcastArgs_:w$e});function S$e(r,t){let n=Q(r,"broadcastTo","x"),s=n.shape;if(ua(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=Ee(n,l)}let i=n.shape,a=Array.from(t);for(let l=t.length-1;l>=0;l--)if(i[l]===t[l])a[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(a.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return au(n);let o={x:n},u={reps:a};return ye.runKernel(Pc,o,u)}var Mh=be({broadcastTo_:S$e});function C$e(r){let t={x:Q(r,"x","ceil","float32")};return ye.runKernel(rp,t)}var n3=be({ceil_:C$e});function Qi(r,t,n){ua(r),n=n||Ox(t);let s={shape:r,value:t,dtype:n};return ye.runKernel(Ux,{},s)}function _$e(r,t,n){let s=Q(r,"x","clipByValue");if(ue(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Qi(s.shape,t,s.dtype);let i={x:s},a={clipValueMin:t,clipValueMax:n};return ye.runKernel(Lc,i,a)}var Us=be({clipByValue_:_$e});function E$e(r){return an(r,0)}var s3=be({concat1d_:E$e});function I$e(r,t){return an(r,t)}var i3=be({concat2d_:I$e});function k$e(r,t){return an(r,t)}var a3=be({concat3d_:k$e});function N$e(r,t){return an(r,t)}var o3=be({concat4d_:N$e});function T$e(r,t,n,s,i="NHWC",a=[1,1],o){let u=Q(r,"x","conv2d","float32"),l=Q(t,"filter","conv2d","float32"),c=u,h=!1;u.rank===3&&(h=!0,c=Ee(u,[1,u.shape[0],u.shape[1],u.shape[2]])),ue(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),ue(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),pi("conv2d",s,o);let d=i==="NHWC"?c.shape[3]:c.shape[1];ue(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),ue(Eu(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),ue(bd(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),ue(bd(n),()=>"Error in conv2D: Strides should be larger than 0.");let p={x:c,filter:l},f={strides:n,pad:s,dataFormat:i,dilations:a,dimRoundingMode:o},m=ye.runKernel(np,p,f);return h?Ee(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var ui=be({conv2d_:T$e});function A$e(r,t,n,s,i="NWC",a=1,o){let u=Q(r,"x","conv1d"),l=Q(t,"filter","conv1d"),c=u,h=!1;u.rank===2&&(h=!0,c=Ee(u,[1,u.shape[0],u.shape[1]])),ue(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),ue(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),pi("conv1d",s,o),ue(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),ue(Eu(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),ue(bd(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),ue(bd(n),()=>"Error in conv1D: Stride should be larger than 0."),ue(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);let d=Ee(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=Ee(c,[c.shape[0],1,c.shape[1],c.shape[2]]),f=ui(p,d,[1,n],s,"NHWC",[1,a],o);return h?Ee(f,[f.shape[2],f.shape[3]]):Ee(f,[f.shape[0],f.shape[2],f.shape[3]])}var GC=be({conv1d_:A$e});function D$e(r,t,n,s,i,a="NHWC",o){ue(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let u=r,l=t,c=!1;t.rank===3&&(c=!0,l=Ee(t,[1,t.shape[0],t.shape[1],t.shape[2]]),u=[1,r[0],r[1],r[2]]),ue(u.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${u.length}.`),ue(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),ue(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let h=a==="NHWC"?u[3]:u[1],d=a==="NHWC"?l.shape[3]:l.shape[1];ue(h===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[2]}.`),ue(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),pi("conv2dDerInput",i,o);let p={dy:l,filter:n},f={strides:s,pad:i,dataFormat:a,dimRoundingMode:o,inputShape:u},m=ye.runKernel(sp,p,f);return c?Ee(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var u3=be({conv2DBackpropInput_:D$e});function F$e(r,t,n,s,i,a){let o=Q(r,"x","conv2dTranspose"),u=Q(t,"filter","conv2dTranspose");return u3(n,o,u,s,i,"NHWC",a)}var HC=be({conv2dTranspose_:F$e});function $$e(r,t,n,s,i="NDHWC",a=[1,1,1]){let o=Q(r,"x","conv3d"),u=Q(t,"filter","conv3d"),l=o,c=!1;o.rank===4&&(c=!0,l=Ee(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ue(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),ue(u.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${u.rank}.`),ue(l.shape[4]===u.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${u.shape[3]}.`),ue(Eu(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),ue(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),ue(bd(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),ue(bd(n),()=>"Error in conv3D: Strides should be larger than 0.");let h={x:l,filter:u},d={strides:n,pad:s,dataFormat:i,dilations:a},p=ye.runKernel(ip,h,d);return c?Ee(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var l3=be({conv3d_:$$e});function R$e(r,t,n,s,i){ue(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let a=r,o=t,u=!1;t.rank===4&&(u=!0,o=Ee(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,r[0],r[1],r[2],r[3]]);let l=a[4],c=o.shape[4];ue(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),ue(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),ue(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),ue(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),ue(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);let h={dy:o,filter:n},d={pad:i,strides:s,inputShape:a},p=ye.runKernel(Mg,h,d);return u?Ee(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var tK=be({conv3DBackpropInput_:R$e});function O$e(r,t,n,s,i){let a=Q(r,"x","conv3dTranspose"),o=Q(t,"filter","conv3dTranspose");return tK(n,a,o,s,i)}var c3=be({conv3dTranspose_:O$e});function M$e(r){let t={x:Q(r,"x","cos","float32")};return ye.runKernel(ap,t)}var cv=be({cos_:M$e});function L$e(r){let t={x:Q(r,"x","cosh","float32")};return ye.runKernel(op,t)}var jC=be({cosh_:L$e});function P$e(r,t=0,n=!1,s=!1){let i={x:Q(r,"x","cumprod")},a={axis:t,exclusive:n,reverse:s};return ye.runKernel(Lg,i,a)}var Jb=be({cumprod_:P$e});function B$e(r,t=0,n=!1,s=!1){let i={x:Q(r,"x","cumsum")},a={axis:t,exclusive:n,reverse:s};return ye.runKernel(up,i,a)}var qC=be({cumsum_:B$e});function V$e(r,t,n,s=!1){let i=Q(r,"x","denseBincount"),a=Q(t,"weights","denseBincount");ue(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),ue(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),ue(n>=0,()=>`size must be non-negative, but got ${n}.`),ue(a.size===i.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${a.shape}.`);let o={x:i,weights:a},u={size:n,binaryOutput:s};return ye.runKernel(Vx,o,u)}var L2=be({denseBincount_:V$e});function z$e(r,t,n="NHWC"){let s=Q(r,"x","depthToSpace","float32"),i=n==="NHWC"?s.shape[1]:s.shape[2],a=n==="NHWC"?s.shape[2]:s.shape[3],o=n==="NHWC"?s.shape[3]:s.shape[1];ue(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),ue(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t}  for depthToSpace with input shape
    ${s.shape}`),ue(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${s.shape}`),ue(o%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`);let u={x:s},l={blockSize:t,dataFormat:n};return ye.runKernel(Bg,u,l)}var h3=be({depthToSpace_:z$e});function U$e(r,t,n,s,i="NHWC",a=[1,1],o){let u=Q(r,"x","depthwiseConv2d","float32"),l=Q(t,"filter","depthwiseConv2d","float32"),c=u,h=!1;u.rank===3&&(h=!0,c=Ee(u,[1,u.shape[0],u.shape[1],u.shape[2]])),ue(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),ue(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let d=i==="NHWC"?c.shape[3]:c.shape[1];ue(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),pi("depthwiseConv2d",s,o);let p={x:c,filter:l},f={strides:n,pad:s,dataFormat:i,dilations:a,dimRoundingMode:o},m=ye.runKernel(lp,p,f);return h?Ee(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var hf=be({depthwiseConv2d_:U$e});function W$e(r){let t={x:Q(r,"x","diag")};return ye.runKernel(zx,t)}var rK=be({diag_:W$e});function G$e(r,t,n,s,i=[1,1],a="NHWC"){let o=Q(r,"x","dilation2d"),u=Q(t,"filter","dilation2d");ue(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),ue(u.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${u.rank}.`),ue(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=o,c=!1;o.rank===3&&(l=Ee(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),ue(l.shape[3]===u.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${u.shape[2]}`);let h={x:l,filter:u},d={strides:n,pad:s,dilations:i},p=ye.runKernel(cp,h,d);return c?Ee(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var d3=be({dilation2d_:G$e}),k0={};ir(k0,{assertAndGetBroadcastShape:()=>un,getBroadcastDims:()=>nK,getReductionAxes:()=>Zn});function nK(r,t){let n=r.length,s=[];for(let i=0;i<n;i++){let a=n-1-i,o=r[a]||1;(t[t.length-1-i]||1)>1&&o===1&&s.unshift(a)}return s}function Zn(r,t){let n=[];for(let s=0;s<t.length;s++){let i=r[r.length-s-1],a=t.length-s-1,o=t[a];(i==null||i===1&&o>1)&&n.unshift(a)}return n}function un(r,t){let n=Math.max(r.length,t.length),s=new Array(n);for(let i=0;i<n;i++){let a=r[r.length-i-1];a==null&&(a=1);let o=t[t.length-i-1];if(o==null&&(o=1),a===1)s[n-i-1]=o;else if(o===1)s[n-i-1]=a;else if(a!==o){let u=`Operands could not be broadcast together with shapes ${r} and ${t}.`;throw Error(u)}else s[n-i-1]=a}return s}function H$e(r,t){let n=Q(r,"a","equal","string_or_numeric"),s=Q(t,"b","equal","string_or_numeric");[n,s]=Pn(n,s),un(n.shape,s.shape);let i={a:n,b:s};return ye.runKernel(zg,i)}var ra=be({equal_:H$e});function j$e(r,t,n){let s=Q(t,"a","where"),i=Q(n,"b","where"),a=Q(r,"condition","where","bool"),o=un(un(a.shape,s.shape),i.shape),u=Mh(a,o),l=Mh(s,o),c=Mh(i,o),h={condition:u,t:l,e:c};return ye.runKernel(m0,h)}var Ss=be({where_:j$e});function q$e(r){let t={x:Q(r,"x","zerosLike")};return ye.runKernel(E0,t)}var Cr=be({zerosLike_:q$e});function K$e(r,t){let n=Q(r,"a","div"),s=Q(t,"b","div");[n,s]=Pn(n,s);let i=_t(n,s),a=Cr(i),o=ra(s,a);return Ss(o,a,i)}var p3=be({divNoNan_:K$e});function X$e(r,t){let n=Q(r,"t1","dot"),s=Q(t,"t2","dot");ue((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);let i=n.rank===1?n.size:n.shape[1],a=s.rank===1?s.size:s.shape[0];if(ue(i===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${a}.`),n.rank===1&&s.rank===1){let o=Ee(n,[1,-1]),u=Ee(s,[-1,1]),l=cr(o,u);return Ee(l,[])}else if(n.rank===1&&s.rank===2){let o=Ee(n,[1,-1]),u=Ee(s,[s.shape[0],s.shape[1]]),l=cr(o,u);return Ee(l,[l.size])}else if(n.rank===2&&s.rank===1){let o=Ee(s,[-1,1]),u=cr(n,o);return Ee(u,[u.size])}else{let o=Ee(s,[s.shape[0],s.shape[1]]);return cr(n,o)}}var f3=be({dot_:X$e});function Y$e(r,...t){let n=t.map((i,a)=>Q(i,`tensors${a}`,"einsum")),s={equation:r};return ye.runKernel(DC,n,s)}var Ch=be({einsum_:Y$e});function Z$e(r){let t={x:Q(r,"x","elu","float32")};return ye.runKernel(dp,t)}var N0=be({elu_:Z$e});function J$e(r,t){let n=Q(r,"x","ensureShape","string_or_numeric");if(!oq(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return r}var sK=be({ensureShape_:J$e});function Q$e(r){let t=Q(r,"x","erf");ue(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=at(t,"float32"));let n={x:t};return ye.runKernel(pp,n)}var KC=be({erf_:Q$e});function m3(r,t){for(let n=0;n<r.length;++n)if(r[r.length-n-1]!==t-1-n)return!1;return!0}function iK(r,t,n){let s=r.length+t.length,i=[],a=0,o=0;for(let u=0;u<s;u++)n.indexOf(u)===-1?i.push(r[a++]):i.push(t[o++]);return i}function aK(r,t){let n=[],s=r.length;for(let a=0;a<s;a++)t.indexOf(a)===-1&&n.push(r[a]);let i=t.map(a=>r[a]);return[n,i]}function xd(r,t){let n=t.map(s=>1);return iK(r,n,t)}function eRe(r,t,n){ue(m3(t,n),()=>`${r} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function oK(r,t){if(m3(r,t))return null;let n=[];for(let s=0;s<t;++s)r.indexOf(s)===-1&&n.push(s);return r.forEach(s=>n.push(s)),n}function g3(r){return r.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function tRe(r,t){let n=[];for(let s=t-r;s<t;++s)n.push(s);return n}function rRe(r,t=null,n=!1){let s={x:Q(r,"x","max")},i={reductionIndices:t,keepDims:n};return ye.runKernel(Np,s,i)}var ya=be({max_:rRe});function nRe(r,t=null,n=!1){let s={x:Q(r,"x","min")},i={axis:t,keepDims:n};return ye.runKernel(Fp,s,i)}var Hm=be({min_:nRe});function sRe(r,t){let n=Q(r,"base","pow"),s=Q(t,"exp","pow");[n,s]=Pn(n,s);let i={a:n,b:s};return ye.runKernel(Bp,i)}var yu=be({pow_:sRe});function Pt(r,t){if((ys(r)&&t!=="string"||Array.isArray(r))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&ys(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Vc(r,[],[],t)}function iRe(r){let t={x:Q(r,"x","sqrt","float32")};return ye.runKernel(rf,t)}var _s=be({sqrt_:iRe});function aRe(r){let t=Q(r,"x","square"),n={};return ye.runKernel("Square",{x:t},n)}var rn=be({square_:aRe});function oRe(r,t=null,n=!1){let s=Q(r,"x","sum");s.dtype==="bool"&&(s=at(s,"int32"));let i={x:s},a={axis:t,keepDims:n};return ye.runKernel(nf,i,a)}var Tt=be({sum_:oRe});function uRe(r,t="euclidean",n=null,s=!1){r=Q(r,"x","norm");let i=uK(r,t,n),a=i.shape;if(s){let o=io(n,r.shape);a=xd(i.shape,o)}return Ee(i,a)}function uK(r,t,n=null){if(r.rank===0)return jn(r);if(r.rank!==1&&n===null)return uK(Ee(r,[-1]),t,n);if(r.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return Tt(jn(r),n);if(t===1/0)return ya(jn(r),n);if(t===-1/0)return Hm(jn(r),n);if(t==="euclidean"||t===2)return _s(Tt(yu(jn(r),Pt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return ya(Tt(jn(r),n[0]),n[1]-1);if(t===1/0)return ya(Tt(jn(r),n[1]),n[0]);if(t===-1/0)return Hm(Tt(jn(r),n[1]),n[0]);if(t==="fro"||t==="euclidean")return _s(Tt(rn(r),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var T0=be({norm_:uRe});function lRe(r,t=null,n=!1){return T0(r,"euclidean",t,n)}var y3=be({euclideanNorm_:lRe});function cRe(r){let t={x:Q(r,"x","exp")};return ye.runKernel(fp,t)}var Ws=be({exp_:cRe});function hRe(r,t=0){let n=Q(r,"x","expandDims","string_or_numeric");ue(t<=n.rank,()=>"Axis must be <= rank of the tensor");let s={input:n},i={dim:t};return ye.runKernel(Ug,s,i)}var bs=be({expandDims_:hRe});function dRe(r){let t={x:Q(r,"x","expm1")};return ye.runKernel(mp,t)}var b3=be({expm1_:dRe});function pRe(r,t){let n=Q(r,"x","tile","string_or_numeric");ue(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let s={x:n},i={reps:t};return ye.runKernel(Pc,s,i)}var Zi=be({tile_:pRe});function fRe(r,t,n,s="float32"){t==null&&(t=r);let i=pr([r,t],s),a=r<=t?r:t;for(let u=0;u<a;++u)i.set(1,u,u);let o=Ee(i.toTensor(),[r,t]);if(n==null)return o;if(n.length===1)return Zi(bs(o,0),[n[0],1,1]);if(n.length===2)return Zi(bs(bs(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return Zi(bs(bs(bs(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var XC=be({eye_:fRe});function mRe(r){let t={x:Q(r,"x","floor","float32")};return ye.runKernel(gp,t)}var A0=be({floor_:mRe});function gRe(r,t,n=0,s=0){let i=Q(r,"x","gather"),a=Q(t,"indices","gather","int32"),o={x:i,indices:a},u={axis:n,batchDims:s};return ye.runKernel(Gg,o,u)}var D0=be({gather_:gRe});function yRe(r,t){let n=Q(r,"a","greater","string_or_numeric"),s=Q(t,"b","greater","string_or_numeric");[n,s]=Pn(n,s),un(n.shape,s.shape);let i={a:n,b:s};return ye.runKernel(jg,i)}var fi=be({greater_:yRe});function bRe(r,t){let n=Q(r,"a","greaterEqual","string_or_numeric"),s=Q(t,"b","greaterEqual","string_or_numeric");[n,s]=Pn(n,s),un(n.shape,s.shape);let i={a:n,b:s};return ye.runKernel(xp,i)}var Sl=be({greaterEqual_:bRe});function xRe(r){let t={input:Q(r,"input","imag")};return ye.runKernel(RC,t)}var hv=be({imag_:xRe});function vRe(r){let t={x:Q(r,"x","isFinite")};return ye.runKernel(wp,t)}var x3=be({isFinite_:vRe});function wRe(r){let t={x:Q(r,"x","isInf")};return ye.runKernel(Sp,t)}var v3=be({isInf_:wRe});function SRe(r){let t={x:Q(r,"x","isNaN")};return ye.runKernel(Cp,t)}var w3=be({isNaN_:SRe});function CRe(r,t=.2){let n={x:Q(r,"x","leakyRelu")},s={alpha:t};return ye.runKernel(_p,n,s)}var dv=be({leakyRelu_:CRe});function _Re(r,t){let n=Q(r,"a","less","string_or_numeric"),s=Q(t,"b","less","string_or_numeric");[n,s]=Pn(n,s),un(n.shape,s.shape);let i={a:n,b:s};return ye.runKernel(qg,i)}var jm=be({less_:_Re});function ERe(r,t){let n=Q(r,"a","lessEqual","string_or_numeric"),s=Q(t,"b","lessEqual","string_or_numeric");[n,s]=Pn(n,s),un(n.shape,s.shape);let i={a:n,b:s};return ye.runKernel(Kg,i)}var zc=be({lessEqual_:ERe});function lK(r,t,n){if(n<=0)throw new Error("The number of values should be positive.");let s={start:r,stop:t,num:n};return ye.runKernel(Xg,{},s)}function IRe(r,t=5,n=1,s=1,i=.5){let a=Q(r,"x","localResponseNormalization");ue(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),ue(zm(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=a,u=!1;a.rank===3&&(u=!0,o=Ee(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let l={x:o},c={depthRadius:t,bias:n,alpha:s,beta:i},h=ye.runKernel(kp,l,c);return u?Ee(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var S3=be({localResponseNormalization_:IRe});function kRe(r){let t={x:Q(r,"x","log","float32")};return ye.runKernel(Ep,t)}var na=be({log_:kRe});function NRe(r){let t={x:Q(r,"x","log1p")};return ye.runKernel(Ip,t)}var pv=be({log1p_:NRe});function TRe(r){return ue(mc(r),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let s=Q(t,"x","tf.grad","string_or_numeric"),i=n!=null?Q(n,"dy","tf.grad"):null;return ye.tidy(()=>{let{value:a,grads:o}=ye.gradients(()=>r(s),[s],i);return i!=null&&di(a.shape,i.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),YC(o),o[0]})}}function ARe(r){return ue(mc(r),()=>"The f passed in grads(f) must be a function"),(t,n)=>{ue(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let s=Kb(t,"args","tf.grads","string_or_numeric"),i=n!=null?Q(n,"dy","tf.grads"):null;return ye.tidy(()=>{let{value:a,grads:o}=ye.gradients(()=>r(...s),s,i);return i!=null&&di(a.shape,i.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),YC(o),o})}}function DRe(r){return ue(mc(r),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{ue(t instanceof ur,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),ue(n==null||n instanceof ur,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:s,value:i}=ye.gradients(()=>r(t),[t],n);return YC(s),{grad:s[0],value:i}}}function FRe(r){return ue(mc(r),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{ue(Array.isArray(t)&&t.every(i=>i instanceof ur),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),ue(n==null||n instanceof ur,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let s=ye.gradients(()=>r(...t),t,n);return n!=null&&di(s.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),YC(s.grads),s}}function cK(r,t){ue(mc(r),()=>"The f passed in variableGrads(f) must be a function"),ue(t==null||Array.isArray(t)&&t.every(c=>c instanceof pd),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let c in ye.registeredVariables)t.push(ye.registeredVariables[c])}let s=n?t.filter(c=>!c.trainable):null,i=t.length;t=t.filter(c=>c.trainable),ue(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);let a=!0,{value:o,grads:u}=ye.gradients(r,t,null,a);ue(u.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),ue(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);let l={};return t.forEach((c,h)=>{u[h]!=null&&(l[c.name]=u[h])}),s!=null&&s.forEach(c=>l[c.name]=null),{value:o,grads:l}}function bu(r){return ye.customGrad(r)}function YC(r){if(r.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function $Re(r){let t={x:Q(r,"x","neg")};return ye.runKernel(r0,t)}var xn=be({neg_:$Re});function RRe(r){let t={x:Q(r,"x","softplus")};return ye.runKernel(tf,t)}var df=be({softplus_:RRe});function ORe(r){let t=Q(r,"x","logSigmoid");return bu(n=>({value:xn(df(xn(n))),gradFunc:s=>Se(s,Xa(xn(n)))}))(t)}var C3=be({logSigmoid_:ORe});function MRe(r,t){let n=Q(r,"a","sub"),s=Q(t,"b","sub");[n,s]=Pn(n,s);let i={a:n,b:s};return ye.runKernel(of,i)}var vt=be({sub_:MRe});function LRe(r,t=-1){let n=Q(r,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return bu((s,i)=>{let a=ya(s,t,!0),o=vt(s,a),u=vt(at(o,"float32"),na(Tt(Ws(o),t,!0)));return i([u]),{value:u,gradFunc:(l,c)=>{let[h]=c,d=!0,p=Ws(h);return vt(l,Se(Tt(l,t,d),p))}}})(n)}var ZC=be({logSoftmax_:LRe});function PRe(r,t=null,n=!1){let s=Q(r,"x","logSumExp"),i=io(t,s.shape),a=ya(s,i,!0),o=vt(s,a),u=Ws(o),l=Tt(u,i),c=na(l),h=Ke(Ee(a,c.shape),c);if(n){let d=xd(h.shape,i);return Ee(h,d)}return h}var fv=be({logSumExp_:PRe});function BRe(r,t){let n=Q(r,"a","logicalAnd","bool"),s=Q(t,"b","logicalAnd","bool");un(n.shape,s.shape);let i={a:n,b:s};return ye.runKernel(Yg,i)}var Za=be({logicalAnd_:BRe});function VRe(r){let t={x:Q(r,"x","logicalNot","bool")};return ye.runKernel(Zg,t)}var mv=be({logicalNot_:VRe});function zRe(r,t){let n=Q(r,"a","logicalOr","bool"),s=Q(t,"b","logicalOr","bool");un(n.shape,s.shape);let i={a:n,b:s};return ye.runKernel(Jg,i)}var JC=be({logicalOr_:zRe});function URe(r,t){let n=Q(r,"a","logicalXor","bool"),s=Q(t,"b","logicalXor","bool");return un(n.shape,s.shape),Za(JC(r,t),mv(Za(r,t)))}var _3=be({logicalXor_:URe}),A1=2147483648;function WRe(r,t,n="left"){let s=Q(r,"sortedSequence","searchSorted"),i=Q(t,"values","searchSorted"),a=s.shape[s.shape.length-1],o=i.shape[i.shape.length-1],u=Ee(s,[-1,a]),l=Ee(i,[-1,o]);if(u.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(u.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Jr(l.shape)>=A1)throw new Error(`values tensor size must less than ${A1}`);if(u.shape[1]>=A1)throw new Error(`trailing dim_size must less than ${A1} for int32 output type, was ${u.shape[1]}`);let c={sortedSequence:u,values:l},h={side:n};return ye.runKernel(f0,c,h)}var QC=be({searchSorted_:WRe});function hK(r,t){return QC(r,t,"left")}function GRe(r,t,n,s,i){let a=Q(r,"x","maxPool"),o=1,u=a,l=!1;a.rank===3&&(l=!0,u=Ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ue(u.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${u.rank}.`),ue(Eu(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),pi("maxPool",s,i);let c={x:u},h={filterSize:t,strides:n,pad:s,dimRoundingMode:i},d=ye.runKernel(Ap,c,h);return l?Ee(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var ps=be({maxPool_:GRe});function HRe(r,t=[1,1,1],n,s,i,a="NDHWC"){let o=Q(r,"x","maxPool3d"),u=o,l=!1;o.rank===4&&(l=!0,u=Ee(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ue(u.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${u.rank}.`),ue(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),pi("maxPool3d",s,i);let c={x:u},h={filterSize:t,strides:n,pad:s,dimRoundingMode:i,dataFormat:a},d=ye.runKernel(e0,c,h);return l?Ee(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var E3=be({maxPool3d_:HRe});function jRe(r,t,n,s,i=!1){let a={x:Q(r,"x","maxPoolWithArgmax")},o={filterSize:t,strides:n,pad:s,includeBatchInIndex:i},u=ye.runKernel(Hx,a,o);return{result:u[0],indexes:u[1]}}var dK=be({maxPoolWithArgmax_:jRe});function qRe(r,t){let n=Q(r,"a","maximum"),s=Q(t,"b","maximum");[n,s]=Pn(n,s),n.dtype==="bool"&&(n=at(n,"int32"),s=at(s,"int32")),un(n.shape,s.shape);let i={a:n,b:s};return ye.runKernel(Tp,i)}var Iu=be({maximum_:qRe});function KRe(r,t=null,n=!1){let s={x:Q(r,"x","mean")},i={axis:t,keepDims:n};return ye.runKernel(Dp,s,i)}var Rn=be({mean_:KRe});function On(r,t="float32"){if(ua(r),t==="complex64"){let s=On(r,"float32"),i=On(r,"float32");return hl(s,i)}let n=_C(Jr(r),t);return ye.makeTensor(n,r,t)}function Ci(r,t="float32"){if(ua(r),t==="complex64"){let s=Ci(r,"float32"),i=On(r,"float32");return hl(s,i)}let n=FR(Jr(r),t);return ye.makeTensor(n,r,t)}function pK(r,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(r===void 0)return[];let s=Q(r,"x","meshgrid",r instanceof ur?r.dtype:"float32");if(t===void 0)return[s];let i=Q(t,"y","meshgrid",t instanceof ur?t.dtype:"float32"),a=Jr(s.shape),o=Jr(i.shape);return n==="xy"?(s=Ee(s,[1,-1]),i=Ee(i,[-1,1]),[cr(Ci([o,1],s.dtype),s),cr(i,Ci([1,a],i.dtype))]):(s=Ee(s,[-1,1]),i=Ee(i,[1,-1]),[cr(s,Ci([1,o],s.dtype)),cr(Ci([a,1],i.dtype),i)])}function XRe(r,t){let n=Q(r,"a","minimum"),s=Q(t,"b","minimum");[n,s]=Pn(n,s),n.dtype==="bool"&&(n=at(n,"int32"),s=at(s,"int32")),un(n.shape,s.shape);let i={a:n,b:s};return ye.runKernel($p,i)}var wc=be({minimum_:XRe});function YRe(r,t,n){ue(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let s=Q(r,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");ue(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);let i=n==="reflect"?1:0;for(let u=0;u<s.rank;u++)ue(t[u].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ue(t[u][0]>=0&&t[u][0]<=s.shape[u]-i&&t[u][1]>=0&&t[u][1]<=s.shape[u]-i,()=>`Padding in dimension ${u} cannot be greater than or equal to ${s.shape[u]-i} or less than 0 for input of shape ${s.shape}`);let a={paddings:t,mode:n},o={x:s};return ye.runKernel(Rp,o,a)}var I3=be({mirrorPad_:YRe});function ZRe(r,t){let n=Q(r,"a","mod"),s=Q(t,"b","mod");[n,s]=Pn(n,s);let i={a:n,b:s};return ye.runKernel(Op,i)}var k3=be({mod_:ZRe});function JRe(r,t=null,n=!1){r=Q(r,"x","moments");let s=io(t,r.shape),i=Rn(r,s,n),a=i.shape;n||(a=xd(i.shape,s));let o=rn(vt(at(r,"float32"),Ee(i,a))),u=Rn(o,s,n);return{mean:i,variance:u}}var gv=be({moments_:JRe});function QRe(r,t,n,s){let i=Q(t,"data","multiRNNCell"),a=Kb(n,"c","multiRNNCell"),o=Kb(s,"h","multiRNNCell"),u=i,l=[];for(let d=0;d<r.length;d++){let p=r[d](u,a[d],o[d]);l.push(p[0]),l.push(p[1]),u=p[1]}let c=[],h=[];for(let d=0;d<l.length;d+=2)c.push(l[d]),h.push(l[d+1]);return[c,h]}var fK=be({multiRNNCell_:QRe});function e3e(r,t,n,s=!1){let i=Q(r,"logits","multinomial"),a=i.size,o=i.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();let u={logits:o===1?Ee(i,[1,-1]):i},l={numSamples:t,seed:n,normalized:s},c=ye.runKernel(t0,u,l);return o===1?Ee(c,[c.size]):c}var mK=be({multinomial_:e3e});function t3e(r,t){let n=Q(r,"a","notEqual","string_or_numeric"),s=Q(t,"b","notEqual","string_or_numeric");[n,s]=Pn(n,s),un(n.shape,s.shape);let i={a:n,b:s};return ye.runKernel(n0,i)}var vd=be({notEqual_:t3e});function r3e(r,t,n=1,s=0,i="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let a={indices:Q(r,"indices","oneHot","int32")},o={dtype:i,depth:t,onValue:n,offValue:s};return ye.runKernel(Lp,a,o)}var qm=be({oneHot_:r3e});function n3e(r){let t={x:Q(r,"x","onesLike")};return ye.runKernel(o0,t)}var sa=be({onesLike_:n3e});function s3e(r,t){let n=Q(r,"v1","outerProduct"),s=Q(t,"v2","outerProduct");ue(n.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${s.rank}.`);let i=Ee(n,[-1,1]),a=Ee(s,[1,-1]);return cr(i,a)}var gK=be({outerProduct_:s3e});function i3e(r,t,n=0){let s=Q(r,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let i={paddings:t,constantValue:n},a={x:s};return ye.runKernel(Pp,a,i)}var zo=be({pad_:i3e});function a3e(r,t,n=0){return ue(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),zo(r,[t],n)}var yK=be({pad1d_:a3e});function o3e(r,t,n=0){return ue(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zo(r,t,n)}var bK=be({pad2d_:o3e});function u3e(r,t,n=0){return ue(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zo(r,t,n)}var xK=be({pad3d_:u3e});function l3e(r,t,n=0){return ue(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zo(r,t,n)}var vK=be({pad4d_:l3e});function c3e(r,t,n){let s=Q(r,"x","spaceToBatchND");ue(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),ue(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),ue(s.shape.reduce((o,u,l)=>l>0&&l<=t.length?o&&(u+n[l-1][0]+n[l-1][1])%t[l-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let i={x:s},a={blockShape:t,paddings:n};return ye.runKernel(y0,i,a)}var yv=be({spaceToBatchND_:c3e});function h3e(r,t,n,s,i,a,o){i==null&&(i=[1,1]),a==null&&(a=1),s===0&&(s="valid");let u=Q(r,"x","maxPool"),l=u,c=!1;u.rank===3&&(c=!0,l=Ee(u,[1,u.shape[0],u.shape[1],u.shape[2]])),ue(Eu(a,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${i}'`);let h=Xq(l.shape,t,a,i,s),d=[h.dilationHeight,h.dilationWidth],p;s==="same"?p=p3e([h.filterHeight,h.filterWidth],d):p=[[0,0],[0,0]];let f=d[0]===1&&d[1]===1,[m,g]=d3e([h.inHeight,h.inWidth],d,p),y=f?s:"valid",b=f?l:yv(l,d,m),x=(n==="avg"?()=>wl(b,t,a,y,o):()=>ps(b,t,a,y,o))(),w=f?x:lv(x,d,g);return c?Ee(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function d3e(r,t,n){let s=n.map(h=>h[0]),i=n.map(h=>h[1]),a=r.concat(s,i),o=t.map((h,d)=>(h-a[d]%h)%h),u=i.map((h,d)=>h+o[d]),l=t.map((h,d)=>[s[d],u[d]]),c=t.map((h,d)=>[0,o[d]]);return[l,c]}function p3e(r,t){let n=r.map((a,o)=>a+(a-1)*(t[o]-1)).map(a=>a-1),s=n.map(a=>Math.floor(a/2)),i=n.map((a,o)=>a-s[o]);return n.map((a,o)=>[s[o],i[o]])}var N3=be({pool_:h3e});function f3e(r,t){let n=Q(r,"x","prelu"),s=Q(t,"alpha","prelu"),i={x:n,alpha:s};return ye.runKernel(Vp,i)}var bv=be({prelu_:f3e});function m3e(r,t=null,n=!1){let s=Q(r,"x","prod");s.dtype==="bool"&&(s=at(s,"int32"));let i={x:s},a={axis:t,keepDims:n};return ye.runKernel(zp,i,a)}var T3=be({prod_:m3e});function g3e(r,t,n,s){let i=r.map((h,d)=>Q(h,`tensors${d}`,"raggedGather","int32")),a=Q(t,"paramsDenseValues","raggedGather"),o=Q(n,"indices","raggedGather","int32"),u={paramsNestedSplits:i,paramsDenseValues:a,indices:o},l={outputRaggedRank:s},c=ye.runKernel(OC,u,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}var wK=be({raggedGather_:g3e});function y3e(r,t,n){let s=Q(r,"starts","raggedRange"),i=Q(t,"limits","raggedRange",s.dtype),a=Q(n,"deltas","raggedRange",s.dtype),o={starts:s,limits:i,deltas:a},u=ye.runKernel(MC,o);return{rtNestedSplits:u[0],rtDenseValues:u[1]}}var SK=be({raggedRange_:y3e});function b3e(r,t,n,s,i){let a=Q(r,"shape","raggedTensorToTensor","int32"),o=Q(t,"values","raggedTensorToTensor"),u=Q(n,"defaultValue","raggedTensorToTensor",o.dtype),l=s.map((d,p)=>Q(d,`tensors${p}`,"raggedTensorToTensor","int32")),c={shape:a,values:o,defaultValue:u,rowPartitionTensors:l},h={rowPartitionTypes:i};return ye.runKernel(LC,c,h)}var CK=be({raggedTensorToTensor_:b3e});function x3e(r,t,n){ua(r);let s=Jr(r),i=null;if(n==null||n==="float32")i=new Float32Array(s);else if(n==="int32")i=new Int32Array(s);else if(n==="bool")i=new Uint8Array(s);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<s;a++)i[a]=t();return ye.makeTensor(i,r,n)}var _K=be({rand_:x3e}),A3=Oc(SC()),EK={};ir(EK,{TEST_EPSILON_FLOAT16:()=>IK,createVideoElement:()=>k3e,encodeStrings:()=>kK,expectArrayBuffersEqual:()=>I3e,expectArraysClose:()=>w3e,expectArraysEqual:()=>C3e,expectNumbersClose:()=>_3e,expectPromiseToFail:()=>S3e,expectValuesInRange:()=>E3e,play:()=>N3e,testEpsilon:()=>D3});var v3e=.001,IK=.1;function w3e(r,t,n){return n==null&&(n=D3()),Qk(r,t,(s,i)=>F3(s,i,n))}function D3(){return ye.backend.floatPrecision()===32?v3e:IK}function Qk(r,t,n){let s=!0;if((ys(r)||ys(t))&&(s=!1),ys(r)&&ys(t)&&(s=!0),s){let o=r.constructor.name,u=t.constructor.name;if(o!==u)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${u}`)}if(Array.isArray(r)&&Array.isArray(t)){let o=gu(r),u=gu(t);if(!xl(o,u))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${u}]`)}let i=ys(r)?r:gc(r),a=ys(t)?t:gc(t);if(i.length!==a.length)throw new Error(`Arrays have different lengths actual: ${i.length} vs expected: ${a.length}.
Actual:   ${i}.
Expected: ${a}.`);for(let o=0;o<a.length;++o){let u=i[o],l=a[o];if(!n(u,l))throw new Error(`Arrays differ: actual[${o}] = ${u}, expected[${o}] = ${l}.
Actual:   ${i}.
Expected: ${a}.`)}typeof expect<"u"&&expect().nothing()}function S3e(r,t){r().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function C3e(r,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Xl(r)||Xl(r[0])||Xl(t)||Xl(t[0])?Qk(r,n,(s,i)=>s==i):Qk(r,t,(s,i)=>F3(s,i,0))}function _3e(r,t,n){if(n==null&&(n=D3()),!F3(r,t,n))throw new Error(`Numbers differ: actual === ${r}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function F3(r,t,n){return!isFinite(r)&&!isFinite(t)?!0:!(isNaN(r)||isNaN(t)||Math.abs(r-t)>n)}function E3e(r,t,n){for(let s=0;s<r.length;s++)if(r[s]<t||r[s]>n)throw new Error(`Value out of range:${r[s]} low: ${t}, high: ${n}`)}function I3e(r,t){let n=new Float32Array(r),s=new Float32Array(t);if(n.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${n.length}`);for(let i=0;i<s.length;i++)if(n[i]!==s[i])throw new Error(`Expected ArrayBuffer value at ${i} to be ${s[i]} but got ${n[i]} instead`)}function kK(r){for(let t=0;t<r.length;t++){let n=r[t];Array.isArray(n)?kK(n):r[t]=iv(n)}return r}function k3e(r){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(r),new Promise(n=>{t.addEventListener("loadeddata",s=>n(t)),t.load()})}async function N3e(r){await r.play(),"requestVideoFrameCallback"in r&&await new Promise(t=>{r.requestVideoFrameCallback(t)})}var $3=class{constructor(r,t,n,s,i){this.mean=r,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=i||Math.random();this.random=A3.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let s=this.nextVal;return this.nextVal=NaN,s}let r,t,n=!1;for(;!n;){let s,i,a;do s=2*this.random()-1,i=2*this.random()-1,a=s*s+i*i;while(a>=1||a===0);let o=Math.sqrt(-2*Math.log(a)/a);r=this.mean+this.stdDev*s*o,t=this.mean+this.stdDev*i*o,(!this.truncated||this.isValidTruncated(r))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(r)}convertValue(r){return this.dtype==null||this.dtype==="float32"?r:Math.round(r)}isValidTruncated(r){return r<=this.upper&&r>=this.lower}},T3e=class{constructor(r,t,n,s){this.alpha=r,this.beta=1/t,this.dtype=n;let i=s||Math.random();this.randu=A3.alea(i.toString()),this.randn=new $3(0,1,n,!1,this.randu()),r<1?this.d=r+2/3:this.d=r-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let r,t,n,s,i,a;for(;;){do s=this.randn.nextValue(),a=1+this.c*s;while(a<=0);if(a*=a*a,r=s*s,t=1-.331*r*r,n=.5*r+this.d*(1-a+Math.log(a)),i=this.randu(),i<t||Math.log(i)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(r){return this.dtype==="float32"?r:Math.round(r)}},A3e=class{constructor(r=0,t=1,n,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=r,this.range=t-r,this.dtype=n,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${r} - ${t} <= 1 and dtype is not float`);this.random=A3.alea(s)}convertValue(r){return this.canReturnFloat()?r:Math.round(r)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function D3e(r,t,n=1,s="float32",i){if(ua(r),n==null&&(n=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);let a=new T3e(t,n,s,i),o=pr(r,s);for(let u=0;u<o.values.length;u++)o.values[u]=a.nextValue();return o.toTensor()}var NK=be({randomGamma_:D3e});function F3e(r,t=0,n=1,s,i){if(ua(r),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);let a=new $3(t,n,s,!1,i),o=pr(r,s);for(let u=0;u<o.values.length;u++)o.values[u]=a.nextValue();return o.toTensor()}var e_=be({randomNormal_:F3e});function $3e(r,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return e_(r,0,1,t,n)}var TK=be({randomStandardNormal_:$3e});function R3e(r,t=0,n=1,s="float32",i){ua(r);let a=pr(r,s),o=new A3e(t,n,null,i);for(let u=0;u<a.values.length;u++)a.values[u]=o.nextValue();return a.toTensor()}var Uc=be({randomUniform_:R3e});function O3e(r,t,n,s){return Uc(r,t,n,"int32",s)}var AK=be({randomUniformInt_:O3e});function wd(r,t,n=1,s="float32"){if(n===0)throw new Error("Cannot have a step of zero");let i={start:r,stop:t,step:n,dtype:s};return ye.runKernel(jx,{},i)}function M3e(r){let t={input:Q(r,"input","real")};return ye.runKernel(PC,t)}var Km=be({real_:M3e});function L3e(r){let t={x:Q(r,"x","reciprocal")};return ye.runKernel(Up,t)}var R3=be({reciprocal_:L3e});function P3e(r){let t={x:Q(r,"x","relu")};return ye.runKernel(Wp,t)}var Yr=be({relu_:P3e});function B3e(r){let t={x:Q(r,"x","relu6")};return ye.runKernel(jp,t)}var t_=be({relu6_:B3e});function V3e(r,t){let n={x:Q(r,"x","reverse")},s={dims:t};return ye.runKernel(qp,n,s)}var Sa=be({reverse_:V3e});function z3e(r){let t=Q(r,"x","reverse");return ue(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Sa(t,0)}var DK=be({reverse1d_:z3e});function U3e(r,t){let n=Q(r,"x","reverse");return ue(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Sa(n,t)}var FK=be({reverse2d_:U3e});function W3e(r,t){let n=Q(r,"x","reverse");return ue(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Sa(n,t)}var $K=be({reverse3d_:W3e});function G3e(r,t){let n=Q(r,"x","reverse");return ue(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Sa(n,t)}var RK=be({reverse4d_:G3e});function H3e(r){let t={x:Q(r,"x","round")};return ye.runKernel(Kp,t)}var r_=be({round_:H3e});function j3e(r){let t={x:Q(r,"x","rsqrt","float32")};return ye.runKernel(Xp,t)}var n_=be({rsqrt_:j3e});function q3e(r){let t={x:Q(r,"x","selu")};return ye.runKernel(Yp,t)}var s_=be({selu_:q3e});function K3e(r,t,n,s,i,a=[1,1],o="NHWC"){let u=Q(r,"x","separableConv2d"),l=Q(t,"depthwiseFilter","separableConv2d"),c=Q(n,"pointwiseFilter","separableConv2d"),h=u,d=!1;if(u.rank===3&&(d=!0,h=Ee(u,[1,u.shape[0],u.shape[1],u.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ue(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),ue(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),ue(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),ue(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),ue(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);let p=l.shape[2],f=l.shape[3];ue(c.shape[2]===p*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*f}, but got ${c.shape[2]}.`);let m=hf(h,l,s,i,o,a),g=ui(m,c,1,"valid",o);return d?Ee(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var F0=be({separableConv2d_:K3e});async function X3e(r,t){let n=Q(r,"x","setdiff1d"),s=Q(t,"y","setdiff1d");ue(n.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`),ue(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),ue(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);let i=await n.data(),a=await s.data(),o=new Set(a),u=0;for(let h=0;h<i.length;h++)o.has(i[h])||u++;let l=new Xn([u],n.dtype),c=new Xn([u],"int32");for(let h=0,d=0;h<i.length;h++)o.has(i[h])||(l.values[d]=i[h],c.values[d]=h,d++);return[l.toTensor(),c.toTensor()]}var OK=X3e;function Y3e(r){let t={x:Q(r,"x","sign")};return ye.runKernel(Qp,t)}var O3=be({sign_:Y3e});function Z3e(r){let t={x:Q(r,"x","sin","float32")};return ye.runKernel(Zp,t)}var i_=be({sin_:Z3e});function J3e(r){let t={x:Q(r,"x","sinh")};return ye.runKernel(Jp,t)}var a_=be({sinh_:J3e});function Q3e(r,t,n){let s=Q(r,"x","slice1d");return ue(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),vr(s,[t],[n])}var xv=be({slice1d_:Q3e});function eOe(r,t,n){let s=Q(r,"x","slice2d");return ue(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),vr(s,t,n)}var o_=be({slice2d_:eOe});function tOe(r,t,n){let s=Q(r,"x","slice3d");return ue(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),vr(s,t,n)}var $0=be({slice3d_:tOe});function rOe(r,t,n){let s=Q(r,"x","slice4d");return ue(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),vr(s,t,n)}var Xm=be({slice4d_:rOe});function nOe(r,t=-1){let n=Q(r,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let s={logits:n},i={dim:t};return ye.runKernel(sf,s,i)}var Wc=be({softmax_:nOe});function sOe(r){ue(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let t={input:r};return ye.runKernel(FC,t)}var vv=be({fft_:sOe});function iOe(r){ue(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let t={input:r};return ye.runKernel($C,t)}var Ym=be({ifft_:iOe});function aOe(r){let t=r.shape[r.shape.length-1],n=r.size/t,s;if(t<=2){let i=Ee(r,[n,t]);s=Ym(i)}else{let i=[n,2*(t-1)],a=Ee(Km(r),[n,t]),o=Ee(hv(r),[n,t]),u=Sa(vr(a,[0,1],[n,t-2]),1),l=Se(Sa(vr(o,[0,1],[n,t-2]),1),Pt(-1)),c=an([a,u],1),h=an([o,l],1),d=Ee(hl(c,h),[i[0],i[1]]);s=Ym(d)}if(s=Km(s),r.rank===3&&r.shape[0]!==0){let i=s,a=r.shape[0];s=Ee(s,[a,s.shape[0]/a,s.shape[1]]),i.dispose()}return s}var u_=be({irfft_:aOe});function oOe(r,t,n=0){let s={x:Q(r,"x","split")},i={numOrSizeSplits:t,axis:n};return ye.runKernel(b0,s,i)}var _i=be({split_:oOe});function uOe(r,t){ue(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let n=r.shape[r.shape.length-1],s=r.size/n,i;if(t!=null&&t<n){let m=r.shape.map(y=>0),g=r.shape.map(y=>y);g[r.shape.length-1]=t,i=vr(r,m,g),n=t}else if(t!=null&&t>n){let m=r.shape.map(g=>g);m[r.shape.length-1]=t-n,i=an([r,On(m)],r.shape.length-1),n=t}else i=r;let a=Cr(i),o=Ee(hl(i,a),[s,n]),u=vv(o),l=Math.floor(n/2)+1,c=Km(u),h=hv(u),d=_i(c,[l,n-l],c.shape.length-1),p=_i(h,[l,n-l],h.shape.length-1),f=i.shape.slice();return f[i.shape.length-1]=l,Ee(hl(d[0],p[0]),f)}var wv=be({rfft_:uOe});function lOe(r,t){let n=Q(r,"a","squaredDifference"),s=Q(t,"b","squaredDifference");[n,s]=Pn(n,s),un(n.shape,s.shape);let i={a:n,b:s},a={};return ye.runKernel(af,i,a)}var l_=be({squaredDifference_:lOe});function cOe(r,t){let n=Q(r,"x","squeeze","string_or_numeric");return Ee(n,uq(n.shape,t).newShape)}var Gc=be({squeeze_:cOe});function hOe(r,t=0){let n=Kb(r,"tensors","stack","string_or_numeric");ue(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&ue(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let s=n,i={axis:t};return ye.runKernel(u0,s,i)}var Yn=be({stack_:hOe});function dOe(r,t=0){let n={x:Q(r,"x","step")},s={alpha:t};return ye.runKernel(Bc,n,s)}var pf=be({step_:dOe});function pOe(r,t,n,s,i=0,a=0,o=0,u=0,l=0){let c={x:Q(r,"x","stridedSlice","string_or_numeric")},h={begin:t,end:n,strides:s,beginMask:i,endMask:a,ellipsisMask:o,newAxisMask:u,shrinkAxisMask:l};return ye.runKernel(w0,c,h)}var M3=be({stridedSlice_:pOe});function fOe(r){let t={x:Q(r,"x","tan","float32")};return ye.runKernel(uf,t)}var L3=be({tan_:fOe});function qr(r,t){Gd(r);let n=gu(r,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Vc(r,null,n,t)}function ou(r,t,n){if(Gd(r),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let s=gu(r,n);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Vc(r,t,s,n)}function c_(r,t,n){if(Gd(r),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let s=gu(r,n);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Vc(r,t,s,n)}function Sc(r,t,n){if(Gd(r),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let s=gu(r,n);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Vc(r,t,s,n)}function MK(r,t,n){if(Gd(r),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let s=gu(r,n);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Vc(r,t,s,n)}function LK(r,t,n){if(Gd(r),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let s=gu(r,n);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||s,Vc(r,t,s,n)}var h_={};ir(h_,{calculateShapes:()=>PK,validateInput:()=>d_,validateUpdateShape:()=>P3});function P3(r,t,n){let s=t.rank>1?t.shape[t.rank-1]:1,i=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${r}, sliceDim: ${s}, and batchDim: ${i}.`;if(n.rank<i)throw new Error(a+` update.rank < ${i}. `);if(r.length<s+(n.rank-i))throw new Error(a+` Output shape length < ${s+(n.rank-i)}`);if(n.rank!==i+r.length-s)throw new Error(a+` update.rank != ${i+r.length-s}`);for(let o=0;o<i;++o)if(n.shape[o]!==t.shape[o])throw new Error(a+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<n.rank-i;++o)if(n.shape[o+i]!==r[o+s])throw new Error(a+` updates.shape[${o+i}] (${n.shape[o+i]}) != shape[${o+i}] (${r[o+i]})`)}function d_(r,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}P3(n,t,r)}function PK(r,t,n){let s=t.shape.length,i=s>1?t.shape[s-1]:1,a=n.length,o=1;for(let d=i;d<a;++d)o*=n[d];let u=i<1?1:i,l=Jr(t.shape)/u,c=[..._g(n.slice(0,i)),1],h=Jr(n);return{sliceRank:i,numUpdates:l,sliceSize:o,strides:c,outputSize:h}}function mOe(r,t,n){let s=Q(r,"tensor","tensorScatterupdate"),i=Q(t,"indices","tensorScatterupdate","int32"),a=Q(n,"updates","tensorScatterupdate");if(d_(a,i,s.shape),s.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${a.dtype}.`);let o={tensor:s,indices:i,updates:a},u={};return ye.runKernel(p0,o,u)}var BK=be({tensorScatterUpdate_:mOe});function gOe(r,t=1,n=!0){let s=Q(r,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let i=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${t}`);let a={x:s},o={k:t,sorted:n},[u,l]=ye.runKernel(S0,a,o);return{values:u,indices:l}}var B3=be({topk_:gOe});function yOe(r,t=0,n=1,s,i){if(ua(r),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");let a=new $3(t,n,s,!0,i),o=pr(r,s);for(let u=0;u<o.values.length;u++)o.values[u]=a.nextValue();return o.toTensor()}var p_=be({truncatedNormal_:yOe});function bOe(r,t=0){let n=Q(r,"x","unique","string_or_numeric");ue(n.rank>0,()=>"The input tensor must be at least 1D");let s={x:n},i={axis:t},[a,o]=ye.runKernel(tv,s,i);return{values:a,indices:o}}var V3=be({unique_:bOe});function xOe(r,t,n){let s=Q(r,"x","unsortedSegmentSum"),i=Q(t,"segmentIds","unsortedSegmentSum","int32");ue(zm(n),()=>"numSegments must be of dtype int");let a={x:s,segmentIds:i},o={numSegments:n};return ye.runKernel(rv,a,o)}var f_=be({unsortedSegmentSum_:xOe});function vOe(r,t=0){let n=Q(r,"x","unstack","string_or_numeric");ue(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let s={value:n},i={axis:t};return ye.runKernel(_0,s,i)}var Bn=be({unstack_:vOe});function VK(r,t){return QC(r,t,"right")}function z3(r,t=!0,n,s){return ye.makeVariable(r,t,n,s)}function zK(r,t){let n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);let s=pr(r,"int32"),i=pr([n.length,r.length],"int32");for(let a=0;a<n.length;a++){let o=s.indexToLoc(n[a]),u=a*r.length;i.values.set(o,u)}return i.toTensor()}async function wOe(r){let t=Q(r,"condition","whereAsync","bool"),n=await t.data(),s=zK(t.shape,n);return r!==t&&t.dispose(),s}var U3=wOe;async function SOe(r,t,n){let s=Q(r,"tensor","boolMask"),i=Q(t,"mask","boolMask","bool"),a=n??0,o=i.rank,u=s.shape;ue(o>0,()=>"mask cannot be scalar"),di(u.slice(a,a+o),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=a;g<a+o;g++)l*=u[g];let c=u.slice(0,a).concat([l],u.slice(a+o)),h=Ee(s,c),d=Ee(i,[-1]),p=await U3(d),f=Gc(p,[1]),m=D0(h,f,a);return r!==s&&s.dispose(),t!==i&&i.dispose(),f.dispose(),h.dispose(),d.dispose(),p.dispose(),m}var UK=SOe;function COe(r,t,n){let s=Q(r,"x","transpose");if(t==null&&(t=s.shape.map((o,u)=>u).reverse()),ue(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{ue(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();let i={x:s},a={perm:t};return s.dtype==="complex64"?Ie(()=>{let o=Km(s),u=hv(s);return o=ye.runKernel(el,{x:o},a),u=ye.runKernel(el,{x:u},a),n&&(u=xn(u)),hl(o,u)}):ye.runKernel(el,i,a)}var dr=be({transpose_:COe});function _Oe(r,t,n,s,i=!0){let a=Q(r,"v","movingAverage"),o=Q(t,"x","movingAverage"),u=Q(n,"decay","movingAverage");Nq(a,o),ue(xl(a.shape,o.shape),()=>"Shape mismatch in v and x");let l=Pt(1),c=vt(l,u),h=Se(vt(o,a),c);if(i){ue(s!=null,()=>"When using zeroDebias: true, step is required.");let d=Q(s,"step","movingAverage");h=_t(h,vt(l,yu(u,d)))}return Ke(a,h)}var WK=be({movingAverage_:_Oe});function EOe(r,t,n){ua(n);let s=Q(r,"indices","scatterND","int32"),i=Q(t,"updates","scatterND");d_(i,s,n);let a={indices:s,updates:i},o={shape:n};return ye.runKernel(d0,a,o)}var GK=be({scatterND_:EOe});function IOe(r,t,n,s){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let i=r.rank>0?r.shape[0]:1,a=r.rank>1?r.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);let o=t.size;if(!(t.rank===0||t.rank===1&&o===i))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${i}]`);if(t.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function kOe(r,t,n,s=0){ua(n);let i=Q(r,"sparseIndices","sparseToDense","int32"),a=Q(t,"sparseValues","sparseToDense","string_or_numeric"),o=Q(s,"defaultValue","sparseToDense",a.dtype);IOe(i,a,n,o);let u={sparseIndices:i,sparseValues:a,defaultValue:o},l={outputShape:n};return ye.runKernel(v0,u,l)}var HK=be({sparseToDense_:kOe});function NOe(r,t){let n=Q(t,"indices","gatherND","int32"),s={params:Q(r,"x","gatherND","string_or_numeric"),indices:n};return ye.runKernel(Hg,s)}var jK=be({gatherND_:NOe});function TOe(r,t){if(t==null)return r.shape.slice();if(xl(r.shape,t))return t;if(r.shape.length===t.length){let n=[];for(let s=0;s<r.shape.length;s++)t[s]==null&&r.shape[s]!=null?n.push(r.shape[s]):n.push(t[s]);return n}return t}function AOe(r,t,n,s){let i=Q(r,"x","dropout");if(ue(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),ue(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return r instanceof ur?i.clone():i;let a=TOe(i,n),o=1-t,u=_t(A0(Ke(Uc(a,0,1,"float32",s),o)),o);return Se(i,u)}var W3=be({dropout_:AOe});function G3(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function m_(r,t,n){let s=1-r%2,i=new Float32Array(r);for(let a=0;a<r;++a){let o=2*Math.PI*a/(r+s-1);i[a]=t-n*Math.cos(o)}return qr(i,"float32")}async function DOe(r,t,n=1){let s=Q(r,"predictions","inTopK"),i=Q(t,"targets","inTopK");ue(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),ue(s.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${i.rank}`),di(s.shape.slice(0,s.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let a=s.shape[s.shape.length-1];ue(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);let o=await s.data(),u=await i.data(),[l,c]=[o.length/a,a],h=lq("bool",l);for(let d=0;d<l;d++){let p=d*c,f=o.subarray(p,p+c),m=[];for(let g=0;g<f.length;g++)m.push({value:f[g],index:g});m.sort((g,y)=>y.value-g.value),h[d]=0;for(let g=0;g<n;g++)if(m[g].index===u[d]){h[d]=1;break}}return r!==s&&s.dispose(),t!==i&&i.dispose(),ai(h,i.shape,"bool")}var qK=DOe,Zm={};ir(Zm,{conv2d:()=>ROe,depthwiseConv2d:()=>POe,matMul:()=>VOe});function FOe(r,t,n,s,i,a="NHWC",o){let u=r;r.rank===3&&(u=Ee(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let l=t;l.rank===3&&(l=Ee(t,[1,t.shape[0],t.shape[1],t.shape[2]])),ue(u.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${u.shape}.`),ue(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),ue(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let c=a==="NHWC"?u.shape[3]:u.shape[1],h=a==="NHWC"?l.shape[3]:l.shape[1];ue(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),ue(h===n[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${n[3]}).`),pi("conv2dDerFilter",i,o);let d={x:u,dy:l},p={strides:s,pad:i,dataFormat:a,dimRoundingMode:o,filterShape:n};return ye.runKernel(kC,d,p)}var H3=be({conv2DBackpropFilter_:FOe});function g_(r,t,n){if(n==null||n==="linear")return r;if(n==="relu")return Se(r,pf(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function y_(r,t){let n=t,s=Zn(r.shape,t.shape);return s.length>0&&(n=Tt(n,s)),Ee(n,r.shape)}function b_(r,t,n,s){if(t==="linear")return r;if(t==="relu")return Yr(r);if(t==="elu")return N0(r);if(t==="relu6")return t_(r);if(t==="prelu")return bv(r,n);if(t==="leakyrelu")return dv(r,s);if(t==="sigmoid")return Xa(r);throw new Error(`Unknown fused activation ${t}.`)}var x_=(r,t)=>!(r>0)||t==="linear";function $Oe({x:r,filter:t,strides:n,pad:s,dataFormat:i="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:u,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(l=l||"linear",x_(ye.state.gradientDepth,l)===!1){ue(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let E=ui(r,t,n,s,i,a,o);return u!=null&&(E=Ke(E,u)),b_(E,l,c,h)}let d=Q(r,"x","conv2d","float32"),p=Q(t,"filter","conv2d","float32"),f=d,m=!1;d.rank===3&&(m=!0,f=Ee(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ue(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),ue(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),pi("fused conv2d",s,o);let g=i==="NHWC"?f.shape[3]:f.shape[1];ue(p.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`),ue(Eu(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let y=uv(f.shape,p.shape,n,a,s,o),b;u!=null&&(b=Q(u,"bias","fused conv2d"),[b]=Pn(b,d),i==="NHWC"?un(y.outShape,b.shape):(ue(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),ue(b.shape.length===0||b.shape[0]===y.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let x;if(c!=null){let E=c.shape;if(ue(E.length<=1||E.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${E.length}.`),E.length===1)ue(E[0]===1||E[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the number of output channels (${y.outChannels}).`);else if(E.length===3)try{un(E,y.outShape)}catch{let I=`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(I)}x=Q(c,"prelu weights","fused conv2d")}let w=(E,C)=>{ue(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);let[I,_,A,k]=C,N=g_(E,A,l);ue(xc(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let D=u3(_.shape,N,I,n,s),F=H3(_,N,I.shape,n,s),P=[D,F];if(k!=null){let G=y_(k,N);P.push(G)}return P},v={x:f,filter:p,bias:b,preluActivationWeights:x},S={strides:n,pad:s,dataFormat:i,dilations:a,dimRoundingMode:o,activation:l,leakyreluAlpha:h};return u==null?bu((E,C,I)=>{let _=ye.runKernel(hd,v,S);return I([C,E,_]),m&&(_=Ee(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:w}})(f,p):bu((E,C,I,_)=>{let A=ye.runKernel(hd,v,S);return _([C,E,A,I]),m&&(A=Ee(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:w}})(f,p,b)}var ROe=be({fusedConv2d_:$Oe});function OOe(r,t,n,s,i,a=[1,1],o){let u=r;r.rank===3&&(u=Ee(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let l=t;l.rank===3&&(l=Ee(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let c={x:u,dy:l},h={strides:s,pad:i,dimRoundingMode:o,dilations:a,filterShape:n};return ye.runKernel(NC,c,h)}var KK=be({depthwiseConv2dNativeBackpropFilter_:OOe});function MOe(r,t,n,s,i,a=[1,1],o){let u=t,l=!1;t.rank===3&&(l=!0,u=Ee(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let c={dy:u,filter:n},h={strides:s,pad:i,dimRoundingMode:o,dilations:a,inputShape:r},d=ye.runKernel(TC,c,h);return l?Ee(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var XK=be({depthwiseConv2dNativeBackpropInput_:MOe});function LOe({x:r,filter:t,strides:n,pad:s,dataFormat:i="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:u,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(x_(ye.state.gradientDepth,l)===!1){let S=hf(r,t,n,s,i,a,o);return u!=null&&(S=Ke(S,u)),b_(S,l,c,h)}let d=Q(r,"x","depthwiseConv2d","float32"),p=Q(t,"filter","depthwiseConv2d","float32"),f=d,m=!1;d.rank===3&&(m=!0,f=Ee(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ue(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),ue(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),ue(f.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),a==null&&(a=[1,1]),ue(Eu(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),pi("fused depthwiseConv2d",s,o);let g=uv(f.shape,p.shape,n,a,s,o,!0),y;u!=null&&(y=Q(u,"bias","fused conv2d"),[y]=Pn(y,d),un(g.outShape,y.shape));let b;c!=null&&(b=Q(c,"prelu weights","fused depthwiseConv2d"));let x=(S,E)=>{ue(xc(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[C,I,_,A]=E,k=g_(S,_,l),N=XK(I.shape,k,C,n,s,a,o),D=KK(I,k,C.shape,n,s,a,o);if(A!=null){let F=y_(y,k);return[N,D,F]}return[N,D]},w={x:f,filter:p,bias:y,preluActivationWeights:b},v={strides:n,pad:s,dataFormat:i,dilations:a,dimRoundingMode:o,activation:l,leakyreluAlpha:h};return u==null?bu((S,E,C)=>{let I=ye.runKernel(dd,w,v);return C([E,S,I]),m&&(I=Ee(I,[I.shape[1],I.shape[2],I.shape[3]])),{value:I,gradFunc:x}})(f,p):bu((S,E,C,I)=>{let _=ye.runKernel(dd,w,v);return I([E,S,_,C]),m&&(_=Ee(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:x}})(f,p,y)}var POe=be({fusedDepthwiseConv2d_:LOe});function BOe({a:r,b:t,transposeA:n=!1,transposeB:s=!1,bias:i,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:u=.2}){if(x_(ye.state.gradientDepth,a)===!1){let A=cr(r,t,n,s);return i!=null&&(A=Ke(A,i)),b_(A,a,o,u)}let l=Q(r,"a","fused matMul"),c=Q(t,"b","fused matMul");[l,c]=Pn(l,c);let h=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?c.shape[c.rank-1]:c.shape[c.rank-2],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],f=s?c.shape[c.rank-2]:c.shape[c.rank-1],m=l.shape.slice(0,-2),g=c.shape.slice(0,-2),y=Jr(m),b=Jr(g);ue(h===d,()=>`Error in fused matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${s} must match.`);let x=un(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,f]),w=n?Ee(l,[y,h,p]):Ee(l,[y,p,h]),v=s?Ee(c,[b,f,d]):Ee(c,[b,d,f]),S;i!=null&&(S=Q(i,"bias","fused matMul"),[S]=Pn(S,l),un(x,S.shape));let E;o!=null&&(E=Q(o,"prelu weights","fused matMul"));let C=(A,k)=>{let[N,D,F,P]=k,G=g_(Ee(A,F.shape),F,a),Y,Z;if(!n&&!s?(Y=cr(G,D,!1,!0),Z=cr(N,G,!0,!1)):!n&&s?(Y=cr(G,D,!1,!1),Z=cr(G,N,!0,!1)):n&&!s?(Y=cr(D,G,!1,!0),Z=cr(N,G,!1,!1)):(Y=cr(D,G,!0,!0),Z=cr(G,N,!0,!0)),i!=null){let ee=y_(P,G);return[Y,Z,ee]}else return[Y,Z]},I={a:w,b:v,bias:S,preluActivationWeights:E},_={transposeA:n,transposeB:s,activation:a,leakyreluAlpha:u};return i==null?bu((A,k,N)=>{let D=ye.runKernel(cd,I,_);return N([A,k,D]),{value:Ee(D,x),gradFunc:C}})(w,v):bu((A,k,N,D)=>{let F=ye.runKernel(cd,I,_);return D([A,k,F,N]),{value:Ee(F,x),gradFunc:C}})(w,v,S)}var VOe=be({fusedMatMul_:BOe});function zOe(r){return m_(r,.54,.46)}var UOe=be({hammingWindow_:zOe});function WOe(r){return m_(r,.5,.5)}var YK=be({hannWindow_:WOe});function GOe(r,t,n,s=!1,i=0){let a=0,o=[];for(;a+t<=r.size;)o.push(vr(r,a,t)),a+=n;if(s)for(;a<r.size;){let u=a+t-r.size,l=an([vr(r,a,t-u),Qi([u],i)]);o.push(l),a+=n}return o.length===0?ou([],[0,t]):Ee(an(o),[o.length,t])}var ZK=be({frame_:GOe});function HOe(r,t,n,s,i=YK){s==null&&(s=G3(t));let a=ZK(r,t,n),o=Se(a,i(t));return wv(o,s)}var jOe=be({stft_:HOe});function qOe(r,t,n,s,i="bilinear",a=0){let o=Q(r,"image","cropAndResize"),u=Q(t,"boxes","cropAndResize","float32"),l=Q(n,"boxInd","cropAndResize","int32"),c=u.shape[0];ue(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),ue(u.rank===2&&u.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${u.shape}.`),ue(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${u.shape}.`),ue(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),ue(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),ue(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);let h={image:o,boxes:u,boxInd:l},d={method:i,extrapolationValue:a,cropSize:s};return ye.runKernel(Pg,h,d)}var KOe=be({cropAndResize_:qOe});function XOe(r){let t=Q(r,"image","flipLeftRight","float32");ue(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return ye.runKernel(Wg,n,{})}var YOe=be({flipLeftRight_:XOe});function ZOe(r){let t=Q(r,"image","grayscaleToRGB"),n=t.rank-1,s=t.shape[n];ue(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),ue(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);let i=new Array(t.rank);return i.fill(1,0,n),i[n]=3,Zi(t,i)}var JOe=be({grayscaleToRGB_:ZOe});function QOe(r){let t=Q(r,"image","RGBToGrayscale"),n=t.rank-1,s=t.shape[n];ue(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),ue(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);let i=t.dtype,a=at(t,"float32"),o=qr([.2989,.587,.114]),u;switch(t.rank){case 2:u=Ch("ij,j->i",a,o);break;case 3:u=Ch("ijk,k->ij",a,o);break;case 4:u=Ch("ijkl,l->ijk",a,o);break;case 5:u=Ch("ijklm,m->ijkl",a,o);break;case 6:u=Ch("ijklmn,n->ijklm",a,o);break;default:throw new Error("Not a valid tensor rank.")}return u=bs(u,-1),at(u,i)}var eMe=be({rgbToGrayscale_:QOe});function tMe(r,t,n=0,s=.5){let i=Q(r,"image","rotateWithOffset","float32");ue(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);let a={image:i},o={radians:t,fillValue:n,center:s};return ye.runKernel(I0,a,o)}var rMe=be({rotateWithOffset_:tMe});function R0(r,t,n,s,i,a){s==null&&(s=.5),i==null&&(i=Number.NEGATIVE_INFINITY),a==null&&(a=0);let o=r.shape[0];return n=Math.min(n,o),ue(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),ue(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),ue(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),ue(t.rank===1,()=>"scores must be a 1D tensor"),ue(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),ue(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:i,softNmsSigma:a}}function nMe(r,t,n,s=.5,i=Number.NEGATIVE_INFINITY){let a=Q(r,"boxes","nonMaxSuppression","float32"),o=Q(t,"scores","nonMaxSuppression","float32"),u=R0(a,o,n,s,i);n=u.maxOutputSize,s=u.iouThreshold,i=u.scoreThreshold;let l={maxOutputSize:n,iouThreshold:s,scoreThreshold:i};return ye.runKernel(s0,{boxes:a,scores:o},l)}var sMe=be({nonMaxSuppression_:nMe});function iMe(r,t,n){let s=aMe(r,t,n),i=s<0?-(s+1):s;r.splice(i,0,t)}function aMe(r,t,n){return uMe(r,t,n||oMe)}function oMe(r,t){return r>t?1:r<t?-1:0}function uMe(r,t,n){let s=0,i=r.length,a=0,o=!1;for(;s<i;){a=s+(i-s>>>1);let u=n(t,r[a]);u>0?s=a+1:(i=a,o=!u)}return o?s:-s-1}function JK(r,t,n,s,i){return j3(r,t,n,s,i,0)}function QK(r,t,n,s,i,a){return j3(r,t,n,s,i,0,!1,a,!0)}function eX(r,t,n,s,i,a){return j3(r,t,n,s,i,a,!0)}function j3(r,t,n,s,i,a,o=!1,u=!1,l=!1){let c=[];for(let y=0;y<t.length;y++)t[y]>i&&c.push({score:t[y],boxIndex:y,suppressBeginIndex:0});c.sort(M5);let h=a>0?-.5/a:0,d=[],p=[];for(;d.length<n&&c.length>0;){let y=c.pop(),{score:b,boxIndex:x,suppressBeginIndex:w}=y;if(b<i)break;let v=!1;for(let S=d.length-1;S>=w;--S){let E=lMe(r,x,d[S]);if(E>=s){v=!0;break}if(y.score=y.score*cMe(s,h,E),y.score<=i)break}y.suppressBeginIndex=d.length,v||(y.score===b?(d.push(x),p.push(y.score)):y.score>i&&iMe(c,y,M5))}let f=d.length,m=n-f;u&&m>0&&(d.push(...new Array(m).fill(0)),p.push(...new Array(m).fill(0)));let g={selectedIndices:d};return o&&(g.selectedScores=p),l&&(g.validOutputs=f),g}function lMe(r,t,n){let s=r.subarray(t*4,t*4+4),i=r.subarray(n*4,n*4+4),a=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),u=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(i[0],i[2]),h=Math.min(i[1],i[3]),d=Math.max(i[0],i[2]),p=Math.max(i[1],i[3]),f=(u-a)*(l-o),m=(d-c)*(p-h);if(f<=0||m<=0)return 0;let g=Math.max(a,c),y=Math.max(o,h),b=Math.min(u,d),x=Math.min(l,p),w=Math.max(b-g,0)*Math.max(x-y,0);return w/(f+m-w)}function cMe(r,t,n){let s=Math.exp(t*n*n);return n<=r?s:0}function M5(r,t){return r.score-t.score||r.score===t.score&&t.boxIndex-r.boxIndex}async function hMe(r,t,n,s=.5,i=Number.NEGATIVE_INFINITY){let a=Q(r,"boxes","nonMaxSuppressionAsync"),o=Q(t,"scores","nonMaxSuppressionAsync"),u=R0(a,o,n,s,i);n=u.maxOutputSize,s=u.iouThreshold,i=u.scoreThreshold;let l=await Promise.all([a.data(),o.data()]),c=l[0],h=l[1],{selectedIndices:d}=JK(c,h,n,s,i);return a!==r&&a.dispose(),o!==t&&o.dispose(),qr(d,"int32")}var dMe=hMe;function pMe(r,t,n,s=.5,i=Number.NEGATIVE_INFINITY,a=0){let o=Q(r,"boxes","nonMaxSuppression"),u=Q(t,"scores","nonMaxSuppression"),l=R0(o,u,n,s,i,a);n=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,a=l.softNmsSigma;let c={boxes:o,scores:u},h={maxOutputSize:n,iouThreshold:s,scoreThreshold:i,softNmsSigma:a},d=ye.runKernel(a0,c,h);return{selectedIndices:d[0],selectedScores:d[1]}}var fMe=be({nonMaxSuppressionWithScore_:pMe});async function mMe(r,t,n,s=.5,i=Number.NEGATIVE_INFINITY,a=0){let o=Q(r,"boxes","nonMaxSuppressionAsync"),u=Q(t,"scores","nonMaxSuppressionAsync"),l=R0(o,u,n,s,i,a);n=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,a=l.softNmsSigma;let c=await Promise.all([o.data(),u.data()]),h=c[0],d=c[1],{selectedIndices:p,selectedScores:f}=eX(h,d,n,s,i,a);return o!==r&&o.dispose(),u!==t&&u.dispose(),{selectedIndices:qr(p,"int32"),selectedScores:qr(f)}}var gMe=mMe;function yMe(r,t,n,s=.5,i=Number.NEGATIVE_INFINITY,a=!1){let o=Q(r,"boxes","nonMaxSuppression"),u=Q(t,"scores","nonMaxSuppression"),l=R0(o,u,n,s,i,null),c=l.maxOutputSize,h=l.iouThreshold,d=l.scoreThreshold,p={boxes:o,scores:u},f={maxOutputSize:c,iouThreshold:h,scoreThreshold:d,padToMaxOutputSize:a},m=ye.runKernel(i0,p,f);return{selectedIndices:m[0],validOutputs:m[1]}}var bMe=be({nonMaxSuppressionPadded_:yMe});async function xMe(r,t,n,s=.5,i=Number.NEGATIVE_INFINITY,a=!1){let o=Q(r,"boxes","nonMaxSuppressionAsync"),u=Q(t,"scores","nonMaxSuppressionAsync"),l=R0(o,u,n,s,i,null),c=l.maxOutputSize,h=l.iouThreshold,d=l.scoreThreshold,[p,f]=await Promise.all([o.data(),u.data()]),{selectedIndices:m,validOutputs:g}=QK(p,f,c,h,d,a);return o!==r&&o.dispose(),u!==t&&u.dispose(),{selectedIndices:qr(m,"int32"),validOutputs:Pt(g,"int32")}}var vMe=xMe;function wMe(r,t,n=!1,s=!1){let i=Q(r,"images","resizeBilinear");ue(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),ue(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),ue(s===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=i,o=!1;i.rank===3&&(o=!0,a=Ee(i,[1,i.shape[0],i.shape[1],i.shape[2]]));let u={images:a},l={alignCorners:n,halfPixelCenters:s,size:t},c=ye.runKernel(Hp,u,l);return o?Ee(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var tX=be({resizeBilinear_:wMe});function SMe(r,t,n=!1,s=!1){let i=Q(r,"images","resizeNearestNeighbor");ue(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),ue(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),ue(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),ue(s===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=i,o=!1;i.rank===3&&(o=!0,a=Ee(i,[1,i.shape[0],i.shape[1],i.shape[2]]));let u={images:a},l={alignCorners:n,halfPixelCenters:s,size:t},c=ye.runKernel(Gp,u,l);return o?Ee(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var rX=be({resizeNearestNeighbor_:SMe});function CMe(r,t="binary",n=!1,s=.5){let i=Q(r,"image","threshold"),a=.2989,o=.587,u=.114,l=i.shape[0]*i.shape[1],c=Se(qr([s]),255),h,d,p,f;if(ue(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),ue(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),ue(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),ue(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),i.shape[2]===3){[h,d,p]=_i(i,[1,1,1],-1);let g=Se(h,a),y=Se(d,o),b=Se(p,u);f=Ke(Ke(g,y),b)}else f=r;if(t==="otsu"){let g=r3(at(r_(f),"int32"),ai([]),256);c=_Me(g,l)}let m=n?zc(f,c):fi(f,c);return at(Se(m,255),"int32")}function _Me(r,t){let n=qr([-1]),s=qr([0]),i=qr([0]),a,o,u,l,c,h;for(let d=0;d<r.size-1;d++){a=vr(r,0,d+1),o=vr(r,d+1),c=_t(Tt(a),t),h=_t(Tt(o),t);let p=Tt(Se(a,wd(0,a.size)));u=_t(p,Tt(a));let f=Qi(o.shape,a.size),m=Ke(wd(0,o.size),f),g=Se(o,m);l=_t(Tt(g),Tt(o));let y=vt(u,l),b=vt(u,l),x=Se(c,h);i=Se(Se(x,y),b);let w=fi(i,s);s=Ss(w,i,s),n=Ss(w,qr([d]),n)}return n}var EMe=be({threshold_:CMe});function IMe(r,t,n="nearest",s="constant",i=0,a){let o=Q(r,"image","transform","float32"),u=Q(t,"transforms","transform","float32");ue(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),ue(u.rank===2&&(u.shape[0]===o.shape[0]||u.shape[0]===1)&&u.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),ue(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);let l={image:o,transforms:u},c={interpolation:n,fillMode:s,fillValue:i,outputShape:a};return ye.runKernel(C0,l,c)}var kMe=be({transform_:IMe});function NMe(r,t,n){let s=Q(r,"a","bandPart");ue(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);let i=s.shape,[a,o]=s.shape.slice(-2),u,l;typeof t=="number"?(ue(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),ue(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),u=Q(t<0?a:t,"numLower","bandPart")):(ue(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),u=Ss(jm(t,0),a,wc(t,a))),typeof n=="number"?(ue(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),ue(n<=o,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`),l=Q(n<0?o:n,"numUpper","bandPart")):(ue(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Ss(jm(n,0),o,wc(n,o)));let c=Ee(wd(0,a,1,"int32"),[-1,1]),h=wd(0,o,1,"int32"),d=vt(c,h),p=Za(zc(d,u),Sl(d,xn(l))),f=On([a,o],s.dtype);return Ee(Yn(Bn(Ee(s,[-1,a,o])).map(m=>Ss(p,m,f))),i)}var TMe=be({bandPart_:NMe});function AMe(r){let t;if(Array.isArray(r)){t=!1,ue(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let i=r[0].shape[0];for(let a=1;a<r.length;++a)ue(r[a].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[a].shape[0]} vs. ${i})`)}else t=!0,r=_i(r,r.shape[0],0).map(i=>Gc(i,[0]));ue(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let n=[],s=r;for(let i=0;i<r.length;++i)n.push(ye.tidy(()=>{let a=s[i];if(i>0)for(let o=0;o<i;++o){let u=Se(Tt(Se(n[o],a)),n[o]);a=vt(a,u)}return _t(a,T0(a,"euclidean"))}));return t?Yn(n,0):n}var DMe=be({gramSchmidt_:AMe});function FMe(r,t=!1){if(ue(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return L5(r,t);{let n=r.shape.slice(0,r.shape.length-2).reduce((l,c)=>l*c),s=Bn(Ee(r,[n,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),i=[],a=[];s.forEach(l=>{let[c,h]=L5(l,t);i.push(c),a.push(h)});let o=Ee(Yn(i,0),r.shape),u=Ee(Yn(a,0),r.shape);return[o,u]}}function L5(r,t=!1){return ye.tidy(()=>{ue(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let n=r.shape[0],s=r.shape[1],i=XC(n),a=au(r),o=ou([[1]],[1,1]),u=au(o),l=n>=s?s:n;for(let c=0;c<l;++c){let h=a,d=u,p=i;[u,a,i]=ye.tidy(()=>{let f=vr(a,[c,c],[n-c,1]),m=T0(f),g=vr(a,[c,c],[1,1]),y=Ss(fi(g,0),ou([[-1]]),ou([[1]])),b=vt(g,Se(y,m)),x=_t(f,b);x.shape[0]===1?u=au(o):u=an([o,vr(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);let w=xn(_t(cr(y,b),m)),v=vr(a,[c,0],[n-c,s]),S=Se(w,u),E=dr(u);if(c===0)a=vt(v,cr(S,cr(E,v)));else{let _=vt(v,cr(S,cr(E,v)));a=an([vr(a,[0,0],[c,s]),_],0)}let C=dr(S),I=vr(i,[0,c],[n,i.shape[1]-c]);if(c===0)i=vt(I,cr(cr(I,u),C));else{let _=vt(I,cr(cr(I,u),C));i=an([vr(i,[0,0],[n,c]),_],1)}return[u,a,i]}),nr([h,d,p])}return!t&&n>s&&(i=vr(i,[0,0],[n,s]),a=vr(a,[0,0],[s,s])),[i,a]})}var $Me=be({qr_:FMe}),ni;(function(r){r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ni||(ni={}));function RMe(r,t,n=ni.SUM_BY_NONZERO_WEIGHTS){let s=Q(r,"losses","computeWeightedLoss"),i=null;t!=null&&(i=Q(t,"weights","computeWeightedLoss"));let a=i==null?s:Se(s,i);if(n===ni.NONE)return a;if(n===ni.SUM)return Tt(a);if(n===ni.MEAN){if(i==null)return Rn(a);{let o=s.size/i.size,u=_t(Tt(a),Tt(i));return o>1?_t(u,Pt(o)):u}}if(n===ni.SUM_BY_NONZERO_WEIGHTS){if(i==null)return _t(Tt(a),Pt(s.size));{let o=Se(i,Ci(s.shape)),u=at(Tt(vd(o,Pt(0))),"float32");return _t(Tt(a),u)}}throw Error(`Unknown reduction: ${n}`)}var Cl=be({computeWeightedLoss_:RMe});function OMe(r,t,n,s=ni.SUM_BY_NONZERO_WEIGHTS){let i=Q(r,"labels","absoluteDifference"),a=Q(t,"predictions","absoluteDifference"),o=null;n!=null&&(o=Q(n,"weights","absoluteDifference")),di(i.shape,a.shape,"Error in absoluteDifference: ");let u=jn(vt(i,a));return Cl(u,o,s)}var MMe=be({absoluteDifference_:OMe});function LMe(r,t,n,s,i=ni.SUM_BY_NONZERO_WEIGHTS){let a=Q(r,"labels","cosineDistance"),o=Q(t,"predictions","cosineDistance"),u=null;s!=null&&(u=Q(s,"weights","cosineDistance")),di(a.shape,o.shape,"Error in cosineDistance: ");let l=Pt(1),c=vt(l,Tt(Se(a,o),n,!0));return Cl(c,u,i)}var PMe=be({cosineDistance_:LMe});function BMe(r,t,n,s=ni.SUM_BY_NONZERO_WEIGHTS){let i=Q(r,"labels","hingeLoss"),a=Q(t,"predictions","hingeLoss"),o=null;n!=null&&(o=Q(n,"weights","hingeLoss")),di(i.shape,a.shape,"Error in hingeLoss: ");let u=Pt(1);i=vt(Se(Pt(2),i),u);let l=Yr(vt(u,Se(i,a)));return Cl(l,o,s)}var VMe=be({hingeLoss_:BMe});function zMe(r,t,n,s=1,i=ni.SUM_BY_NONZERO_WEIGHTS){let a=Q(r,"labels","huberLoss"),o=Q(t,"predictions","huberLoss"),u=null;n!=null&&(u=Q(n,"weights","huberLoss")),di(a.shape,o.shape,"Error in huberLoss: ");let l=Pt(s),c=jn(vt(o,a)),h=wc(c,l),d=vt(c,h),p=Ke(Se(Pt(.5),rn(h)),Se(l,d));return Cl(p,u,i)}var UMe=be({huberLoss_:zMe});function WMe(r,t,n,s=1e-7,i=ni.SUM_BY_NONZERO_WEIGHTS){let a=Q(r,"labels","logLoss"),o=Q(t,"predictions","logLoss"),u=null;n!=null&&(u=Q(n,"weights","logLoss")),di(a.shape,o.shape,"Error in logLoss: ");let l=Pt(1),c=Pt(s),h=xn(Se(a,na(Ke(o,c)))),d=Se(vt(l,a),na(Ke(vt(l,o),c))),p=vt(h,d);return Cl(p,u,i)}var GMe=be({logLoss_:WMe});function HMe(r,t,n,s=ni.SUM_BY_NONZERO_WEIGHTS){let i=Q(r,"labels","meanSquaredError"),a=Q(t,"predictions","meanSquaredError"),o=null;n!=null&&(o=Q(n,"weights","meanSquaredError")),di(i.shape,a.shape,"Error in meanSquaredError: ");let u=l_(i,a);return Cl(u,o,s)}var jMe=be({meanSquaredError_:HMe});function qMe(r,t){let n=Q(r,"labels","sigmoidCrossEntropyWithLogits"),s=Q(t,"logits","sigmoidCrossEntropyWithLogits");di(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");let i=Yr(s),a=Se(s,n),o=pv(Ws(xn(jn(s))));return Ke(vt(i,a),o)}function KMe(r,t,n,s=0,i=ni.SUM_BY_NONZERO_WEIGHTS){let a=Q(r,"multiClassLabels","sigmoidCrossEntropy"),o=Q(t,"logits","sigmoidCrossEntropy"),u=null;if(n!=null&&(u=Q(n,"weights","sigmoidCrossEntropy")),di(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){let c=Pt(s),h=Pt(1),d=Pt(.5);a=Ke(Se(a,vt(h,c)),Se(d,c))}let l=qMe(a,o);return Cl(l,u,i)}var XMe=be({sigmoidCrossEntropy_:KMe});function YMe(r,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return bu((s,i,a)=>{let o=fv(i,[n],!0),u=vt(at(i,"float32"),o);a([s,u]);let l=xn(Se(u,s));return{value:Tt(l,[n]),gradFunc:(c,h)=>{let[d,p]=h,f=xd(c.shape,[n]);return[Se(Ee(c,f),vt(at(d,"float32"),Ws(p))),Se(Ee(c,f),vt(Ws(p),at(d,"float32")))]}}})(r,t)}function ZMe(r,t,n,s=0,i=ni.SUM_BY_NONZERO_WEIGHTS){let a=Q(r,"onehotLabels","softmaxCrossEntropy"),o=Q(t,"logits","softmaxCrossEntropy"),u=null;if(n!=null&&(u=Q(n,"weights","softmaxCrossEntropy")),di(a.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){let c=Pt(s),h=Pt(1),d=Pt(a.shape[1]);a=Ke(Se(a,vt(h,c)),_t(c,d))}let l=YMe(a,o);return Cl(l,u,i)}var JMe=be({softmaxCrossEntropy_:ZMe});function QMe(r,t,n,s){let i=Q(r,"indices","sparseFillEmptyRows","int32"),a=Q(t,"values","sparseFillEmptyRows"),o=Q(n,"denseShape","sparseFillEmptyRows","int32"),u=Q(s,"defaultValue","sparseFillEmptyRows",a.dtype);if(i.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(u.rank!==0)throw new Error(`Default value should be a scalar but received shape ${u.shape}`);let l={indices:i,values:a,denseShape:o,defaultValue:u},c=ye.runKernel(qx,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}var eLe=be({sparseFillEmptyRows_:QMe});function tLe(r,t,n){let s=Q(r,"inputIndices","sparseReshape","int32"),i=Q(t,"inputShape","sparseReshape","int32"),a=Q(n,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(i.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);let o={inputIndices:s,inputShape:i,newShape:a},u=ye.runKernel(x0,o);return{outputIndices:u[0],outputShape:u[1]}}var rLe=be({sparseReshape_:tLe});function nLe(r,t,n){let s=Q(r,"data","sparseSegmentMean"),i=Q(t,"indices","sparseSegmentMean","int32"),a=Q(n,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);let o={data:s,indices:i,segmentIds:a};return ye.runKernel(Kx,o)}var sLe=be({sparseSegmentMean_:nLe});function iLe(r,t,n){let s=Q(r,"data","sparseSegmentSum"),i=Q(t,"indices","sparseSegmentSum","int32"),a=Q(n,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);let o={data:s,indices:i,segmentIds:a};return ye.runKernel(Xx,o)}var aLe=be({sparseSegmentSum_:iLe});function oLe(r,t,n,s,i,a,o,u){let l=Q(r,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let c=Q(t,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let h={separator:n,nGramWidths:s,leftPad:i,rightPad:a,padWidth:o,preserveShortSequences:u},d={data:l,dataSplits:c},p=ye.runKernel(Jx,d,h);return{nGrams:p[0],nGramsSplits:p[1]}}var uLe=be({stringNGrams_:oLe});function lLe(r,t,n=!0){let s=Q(r,"input","stringSplit","string"),i=Q(t,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(i.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);let a={skipEmpty:n},o={input:s,delimiter:i},u=ye.runKernel(Qx,o,a);return{indices:u[0],values:u[1],shape:u[2]}}var cLe=be({stringSplit_:lLe});function hLe(r,t){let n=Q(r,"input","stringToHashBucketFast","string"),s={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let i={input:n};return ye.runKernel(ev,i,s)}var dLe=be({stringToHashBucketFast_:hLe});function pLe(r,t,n,s=!0){let i=Q(r,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:s};return ye.runKernel(Zx,{x:i},a)}var fLe=be({staticRegexReplace_:pLe}),nX={fft:vv,ifft:Ym,rfft:wv,irfft:u_},sX={hammingWindow:UOe,hannWindow:YK,frame:ZK,stft:jOe},pa={flipLeftRight:YOe,grayscaleToRGB:JOe,resizeNearestNeighbor:rX,resizeBilinear:tX,rgbToGrayscale:eMe,rotateWithOffset:rMe,cropAndResize:KOe,nonMaxSuppression:sMe,nonMaxSuppressionAsync:dMe,nonMaxSuppressionWithScore:fMe,nonMaxSuppressionWithScoreAsync:gMe,nonMaxSuppressionPadded:bMe,nonMaxSuppressionPaddedAsync:vMe,threshold:EMe,transform:kMe},q3={bandPart:TMe,gramSchmidt:DMe,qr:$Me},iX={absoluteDifference:MMe,computeWeightedLoss:Cl,cosineDistance:PMe,hingeLoss:VMe,huberLoss:UMe,logLoss:GMe,meanSquaredError:jMe,sigmoidCrossEntropy:XMe,softmaxCrossEntropy:JMe},aX={sparseFillEmptyRows:eLe,sparseReshape:rLe,sparseSegmentMean:sLe,sparseSegmentSum:aLe},oX={stringNGrams:uLe,stringSplit:cLe,stringToHashBucketFast:dLe,staticRegexReplace:fLe},et={};ir(et,{Serializable:()=>uX,SerializationMap:()=>lX,getRegisteredName:()=>gLe,registerClass:()=>cX});var mLe=new Map,eN=new Map,uX=class{getClassName(){return this.constructor.className}static fromConfig(r,t){return new r(t)}},lX=class Kf{constructor(){this.classNameMap={}}static getMap(){return Kf.instance==null&&(Kf.instance=new Kf),Kf.instance}static register(t){Kf.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function cX(r,t,n){ue(r.className!=null,()=>"Class being registered does not have the static className property defined."),ue(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),ue(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=r.className);let s=n,i=t+">"+s;return lX.register(r),mLe.set(i,r),eN.set(r,i),r}function gLe(r){return eN.has(r)?eN.get(r):r.className}var _l=class extends uX{minimize(r,t=!1,n){let{value:s,grads:i}=this.computeGradients(r,n);if(n!=null){let a=n.map(o=>({name:o.name,tensor:i[o.name]}));this.applyGradients(a)}else this.applyGradients(i);return nr(i),t?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(r,t){return cK(r,t)}dispose(){this.iterations_!=null&&nr(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Pt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(r){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(r){return this.iterations_=(await r[0].tensor.data())[0],r.slice(1)}};Object.defineProperty(_l,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var K3=class extends _l{static get className(){return"Adadelta"}constructor(r,t,n=null){super(),this.learningRate=r,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=ye.backend.epsilon())}applyGradients(r){(Array.isArray(r)?r.map(t=>t.name):Object.keys(r)).forEach((t,n)=>{let s=ye.registeredVariables[t],i=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:Ie(()=>Cr(s).variable(i))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:Ie(()=>Cr(s).variable(i))});let a=Array.isArray(r)?r[n].tensor:r[t];if(a==null)return;let o=this.accumulatedGrads[n].variable,u=this.accumulatedUpdates[n].variable;Ie(()=>{let l=Ke(Se(o,this.rho),Se(rn(a),1-this.rho)),c=Se(_t(_s(Ke(u,this.epsilon)),_s(Ke(o,this.epsilon))),a),h=Ke(Se(u,this.rho),Se(rn(c),1-this.rho));o.assign(l),u.assign(h);let d=Ke(Se(c,-this.learningRate),s);s.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(nr(this.accumulatedGrads.map(r=>r.variable)),nr(this.accumulatedUpdates.map(r=>r.variable)))}async getWeights(){let r=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(r.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(r){r=await this.extractIterations(r);let t=r.length/2,n=!1;this.accumulatedGrads=r.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(n)})),this.accumulatedUpdates=r.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(r,t){return new r(t.learningRate,t.rho,t.epsilon)}},X3=class extends _l{static get className(){return"Adagrad"}constructor(r,t=.1){super(),this.learningRate=r,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(r){(Array.isArray(r)?r.map(t=>t.name):Object.keys(r)).forEach((t,n)=>{let s=ye.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:Ie(()=>Qi(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(r)?r[n].tensor:r[t];if(i==null)return;let a=this.accumulatedGrads[n].variable;Ie(()=>{let o=Ke(a,rn(i));a.assign(o);let u=Ke(Se(_t(i,_s(Ke(o,ye.backend.epsilon()))),-this.learningRate),s);s.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&nr(this.accumulatedGrads.map(r=>r.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(r=>({name:r.originalName,tensor:r.variable})))}async setWeights(r){r=await this.extractIterations(r);let t=!1;this.accumulatedGrads=r.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(r,t){return new r(t.learningRate,t.initialAccumulatorValue)}},Y3=class extends _l{static get className(){return"Adam"}constructor(r,t,n,s=null){super(),this.learningRate=r,this.beta1=t,this.beta2=n,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Ie(()=>{this.accBeta1=Pt(t).variable(),this.accBeta2=Pt(n).variable()}),s==null&&(this.epsilon=ye.backend.epsilon())}applyGradients(r){let t=Array.isArray(r)?r.map(n=>n.name):Object.keys(r);Ie(()=>{let n=vt(1,this.accBeta1),s=vt(1,this.accBeta2);t.forEach((i,a)=>{let o=ye.registeredVariables[i],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:Ie(()=>Cr(o).variable(u))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${i}/v`,variable:Ie(()=>Cr(o).variable(u))});let l=Array.isArray(r)?r[a].tensor:r[i];if(l==null)return;let c=this.accumulatedFirstMoment[a].variable,h=this.accumulatedSecondMoment[a].variable,d=Ke(Se(c,this.beta1),Se(l,1-this.beta1)),p=Ke(Se(h,this.beta2),Se(rn(l),1-this.beta2)),f=_t(d,n),m=_t(p,s);c.assign(d),h.assign(p);let g=Ke(Se(_t(f,Ke(_s(m),this.epsilon)),-this.learningRate),o);o.assign(g)}),this.accBeta1.assign(Se(this.accBeta1,this.beta1)),this.accBeta2.assign(Se(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&nr(this.accumulatedFirstMoment.map(r=>r.variable)),this.accumulatedSecondMoment!=null&&nr(this.accumulatedSecondMoment.map(r=>r.variable))}async getWeights(){let r=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(r.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(r){r=await this.extractIterations(r),Ie(()=>{this.accBeta1.assign(yu(this.beta1,this.iterations_+1)),this.accBeta2.assign(yu(this.beta2,this.iterations_+1))});let t=r.length/2,n=!1;this.accumulatedFirstMoment=r.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(n)})),this.accumulatedSecondMoment=r.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(r,t){return new r(t.learningRate,t.beta1,t.beta2,t.epsilon)}},Z3=class extends _l{static get className(){return"Adamax"}constructor(r,t,n,s=null,i=0){super(),this.learningRate=r,this.beta1=t,this.beta2=n,this.epsilon=s,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Ie(()=>{this.iteration=Pt(0).variable(),this.accBeta1=Pt(t).variable()}),s==null&&(this.epsilon=ye.backend.epsilon())}applyGradients(r){let t=Array.isArray(r)?r.map(n=>n.name):Object.keys(r);Ie(()=>{let n=vt(1,this.accBeta1),s=_t(-this.learningRate,Ke(Se(this.iteration,this.decay),1));t.forEach((i,a)=>{let o=ye.registeredVariables[i],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:Cr(o).variable(u)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${i}/v`,variable:Cr(o).variable(u)});let l=Array.isArray(r)?r[a].tensor:r[i];if(l==null)return;let c=this.accumulatedFirstMoment[a].variable,h=this.accumulatedWeightedInfNorm[a].variable,d=Ke(Se(c,this.beta1),Se(l,1-this.beta1)),p=Se(h,this.beta2),f=jn(l),m=Iu(p,f);c.assign(d),h.assign(m);let g=Ke(Se(_t(s,n),_t(d,Ke(m,this.epsilon))),o);o.assign(g)}),this.iteration.assign(Ke(this.iteration,1)),this.accBeta1.assign(Se(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&nr(this.accumulatedFirstMoment.map(r=>r.variable)),this.accumulatedWeightedInfNorm!=null&&nr(this.accumulatedWeightedInfNorm.map(r=>r.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(r){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(r,t){return new r(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},v_=class extends _l{static get className(){return"SGD"}constructor(r){super(),this.learningRate=r,this.setLearningRate(r)}applyGradients(r){(Array.isArray(r)?r.map(t=>t.name):Object.keys(r)).forEach((t,n)=>{let s=Array.isArray(r)?r[n].tensor:r[t];if(s==null)return;let i=ye.registeredVariables[t];Ie(()=>{let a=Ke(Se(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(r){this.learningRate=r,this.c!=null&&this.c.dispose(),this.c=ns(Pt(-r))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(r){if(r=await this.extractIterations(r),r.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(r,t){return new r(t.learningRate)}},J3=class extends v_{static get className(){return"Momentum"}constructor(r,t,n=!1){super(r),this.learningRate=r,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Pt(this.momentum)}applyGradients(r){(Array.isArray(r)?r.map(t=>t.name):Object.keys(r)).forEach((t,n)=>{let s=ye.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:Ie(()=>Cr(s).variable(!1))});let i=this.accumulations[n].variable,a=Array.isArray(r)?r[n].tensor:r[t];a!=null&&Ie(()=>{let o,u=Ke(Se(this.m,i),a);this.useNesterov?o=Ke(Se(this.c,Ke(a,Se(u,this.m))),s):o=Ke(Se(this.c,u),s),i.assign(u),s.assign(o)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&nr(this.accumulations.map(r=>r.variable))}setMomentum(r){this.momentum=r}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(r=>({name:r.originalName,tensor:r.variable})))}async setWeights(r){r=await this.extractIterations(r);let t=!1;this.accumulations=r.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(r,t){return new r(t.learningRate,t.momentum,t.useNesterov)}},Q3=class extends _l{static get className(){return"RMSProp"}constructor(r,t=.9,n=0,s=null,i=!1){if(super(),this.learningRate=r,this.decay=t,this.momentum=n,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,s==null&&(this.epsilon=ye.backend.epsilon()),r==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(r){(Array.isArray(r)?r.map(t=>t.name):Object.keys(r)).forEach((t,n)=>{let s=ye.registeredVariables[t],i=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:Ie(()=>Cr(s).variable(i))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:Ie(()=>Cr(s).variable(i))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:Ie(()=>Cr(s).variable(i))});let a=Array.isArray(r)?r[n].tensor:r[t];if(a==null)return;let o=this.accumulatedMeanSquares[n].variable,u=this.accumulatedMoments[n].variable;Ie(()=>{let l=Ke(Se(o,this.decay),Se(rn(a),1-this.decay));if(this.centered){let c=this.accumulatedMeanGrads[n].variable,h=Ke(Se(c,this.decay),Se(a,1-this.decay)),d=_t(Se(a,this.learningRate),_s(vt(l,Ke(rn(h),this.epsilon)))),p=Ke(Se(u,this.momentum),d);o.assign(l),c.assign(h),u.assign(p);let f=vt(s,p);s.assign(f)}else{let c=Ke(Se(o,this.decay),Se(rn(a),1-this.decay)),h=Ke(Se(u,this.momentum),_t(Se(a,this.learningRate),_s(Ke(c,this.epsilon))));o.assign(c),u.assign(h);let d=vt(s,h);s.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&nr(this.accumulatedMeanSquares.map(r=>r.variable)),this.accumulatedMeanGrads!=null&&this.centered&&nr(this.accumulatedMeanGrads.map(r=>r.variable)),this.accumulatedMoments!=null&&nr(this.accumulatedMoments.map(r=>r.variable))}async getWeights(){let r=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&r.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(r.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(r){r=await this.extractIterations(r);let t=this.centered?r.length/3:r.length/2,n=!1;this.accumulatedMeanSquares=r.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(n)})),this.accumulatedMoments=r.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=r.slice(t*2,t*3).map(s=>({originalName:s.name,variable:s.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(r,t){return new r(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},yLe=[K3,X3,Y3,Z3,J3,Q3,v_];function bLe(){for(let r of yLe)cX(r)}var $s={};ir($s,{CompositeArrayBuffer:()=>vl,browserFiles:()=>ELe,browserHTTPRequest:()=>DLe,concatenateArrayBuffers:()=>iFe,copyModel:()=>kFe,decodeWeights:()=>Mq,decodeWeightsStream:()=>Pq,encodeWeights:()=>QDe,fromMemory:()=>$Le,fromMemorySync:()=>mX,getLoadHandlers:()=>pFe,getModelArtifactsForJSON:()=>zR,getModelArtifactsForJSONSync:()=>Vq,getModelArtifactsInfoForJSON:()=>ov,getSaveHandlers:()=>dFe,getWeightSpecs:()=>Kk,http:()=>tO,isHTTPScheme:()=>rN,listModels:()=>EFe,loadWeights:()=>kLe,moveModel:()=>NFe,registerLoadRouter:()=>hFe,registerSaveRouter:()=>cFe,removeModel:()=>IFe,weightsLoaderFactory:()=>dX,withSaveHandler:()=>RLe,withSaveHandlerSync:()=>OLe});var xLe="model",vLe=".json",wLe=".weights.bin";function P5(r){return new Promise(t=>setTimeout(t)).then(r)}var P2=class tN{constructor(t){if(!Re().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(tN.URL_SCHEME)&&(t=t.slice(tN.URL_SCHEME.length)),(t==null||t.length===0)&&(t=xLe),this.modelJsonFileName=t+vLe,this.weightDataFileName=t+wLe}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=vl.join(t.weightData),s=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let i=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],a=Bq(t,i),o=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),u=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(u.download=this.modelJsonFileName,u.href=o,await P5(()=>u.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await P5(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ov(t)}}}};P2.URL_SCHEME="downloads://";var SLe=class{constructor(r){if(r==null||r.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${r}`);this.jsonFile=r[0],this.weightsFiles=r.slice(1)}async load(){return new Promise((r,t)=>{let n=new FileReader;n.onload=s=>{let i=JSON.parse(s.target.result),a=i.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){r({modelTopology:a});return}let o=zR(i,u=>this.loadWeights(u));r(o)},n.onerror=s=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(r){let t=[],n=[];for(let a of r)t.push(...a.weights),n.push(...a.paths);let s=this.checkManifestAndWeightFiles(r),i=n.map(a=>this.loadWeightsFile(a,s[a]));return Promise.all(i).then(a=>[t,a])}loadWeightsFile(r,t){return new Promise((n,s)=>{let i=new FileReader;i.onload=a=>{let o=a.target.result;n(o)},i.onerror=a=>s(`Failed to weights data from file of path '${r}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(r){let t=[],n=this.weightsFiles.map(i=>O5(i.name)),s={};for(let i of r)i.paths.forEach(a=>{let o=O5(a);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),n.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);s[a]=this.weightsFiles[n.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}},CLe=r=>Re().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(P2.URL_SCHEME)?_Le(r.slice(P2.URL_SCHEME.length)):null;wa.registerSaveRouter(CLe);function _Le(r="model"){return new P2(r)}function ELe(r){return new SLe(r)}function B5(r,t,n,s){o(r),n=n??0,s=s??1,u(n,s);let i=0,a=l=>(l.then(c=>{let h=n+ ++i/r.length*(s-n);return t(h),c}),l);function o(l){ue(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function u(l,c){ue(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),ue(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),ue(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(r.map(a))}async function hX(r,t){t==null&&(t={});let n=t.fetchFunc==null?Re().platform.fetch:t.fetchFunc,s=r.map(a=>n(a,t.requestInit,{isBinary:!0})),i=(t.onProgress==null?await Promise.all(s):await B5(s,t.onProgress,0,.5)).map(a=>a.arrayBuffer());return t.onProgress==null?await Promise.all(i):await B5(i,t.onProgress,.5,1)}function ILe(r,t){var n;let s=t.fetchFunc==null?Re().platform.fetch:t.fetchFunc,i=0,a;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async o=>{for(var u;i<r.length;){a||(a=(await s(r[i],t.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:c}=await a.read();if(l){i++,a=void 0,(u=t.onProgress)===null||u===void 0||u.call(t,i/r.length);continue}o.enqueue(c);return}o.close()}})}async function kLe(r,t="",n,s){return dX(i=>hX(i,{requestInit:s}))(r,t,n)}function dX(r){return async(t,n="",s)=>{let i=t.map(()=>!1),a={},o=s!=null?s.map(()=>!1):[],u=[];if(t.forEach((f,m)=>{let g=0;f.weights.forEach(y=>{let b="quantization"in y?y.quantization.dtype:y.dtype,x=fd[b]*Jr(y.shape),w=()=>{i[m]=!0,a[m]==null&&(a[m]=[]),a[m].push({manifestEntry:y,groupOffset:g,sizeBytes:x})};s!=null?s.forEach((v,S)=>{v===y.name&&(w(),o[S]=!0)}):w(),u.push(y.name),g+=x})}),!o.every(f=>f)){let f=s.filter((m,g)=>!o[g]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${u.join(", ")}.`)}let l=i.reduce((f,m,g)=>(m&&f.push(g),f),[]),c=[];l.forEach(f=>{t[f].paths.forEach(m=>{let g=n+(n.endsWith("/")?"":"/")+m;c.push(g)})});let h=await r(c),d={},p=0;return l.forEach(f=>{let m=t[f].paths.length,g=new vl(h.slice(p,p+m));a[f].forEach(y=>{let b=g.slice(y.groupOffset,y.groupOffset+y.sizeBytes),x=Mq(b,[y.manifestEntry]);for(let w in x)d[w]=x[w]}),p+=m}),d}}var NLe="application/octet-stream",TLe="application/json",eO=class{constructor(r,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(ue(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Re().platform.fetch,ue(r!=null&&r.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(r)&&ue(r.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${r.length}).`),this.path=r,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:r.weightSpecs}],s=Bq(r,n);if(t.body.append("model.json",new Blob([JSON.stringify(s)],{type:TLe}),"model.json"),r.weightData!=null){let a=vl.join(r.weightData);t.body.append("model.weights.bin",new Blob([a],{type:NLe}),"model.weights.bin")}let i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:ov(r),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){let r=await this.fetch(this.path,this.requestInit);if(!r.ok)throw new Error(`Request to ${this.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await r.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let n=t.modelTopology,s=t.weightsManifest;if(n==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let r=await this.loadModelJSON();return zR(r,t=>this.loadWeights(t))}async loadStream(){let r=await this.loadModelJSON(),t=await this.getWeightUrls(r.weightsManifest),n=Kk(r.weightsManifest),s=()=>ILe(t,this.loadOptions);return Object.assign(Object.assign({},r),{weightSpecs:n,getWeightStream:s})}async getWeightUrls(r){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,s]=ALe(t),i=this.weightPathPrefix||n,a=[],o=[];for(let u of r)for(let l of u.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(l)):a.push(i+l+s);return this.weightUrlConverter&&a.push(...await Promise.all(o)),a}async loadWeights(r){let t=await this.getWeightUrls(r),n=Kk(r),s=await hX(t,this.loadOptions);return[n,s]}};eO.URL_SCHEME_REGEX=/^https?:\/\//;function ALe(r){let t=r.lastIndexOf("/"),n=r.lastIndexOf("?"),s=r.substring(0,t),i=n>t?r.substring(n):"";return[s+"/",i]}function rN(r){return r.match(eO.URL_SCHEME_REGEX)!=null}var pX=(r,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(r)?n=r.every(s=>rN(s)):n=rN(r),n)return tO(r,t)}return null};wa.registerSaveRouter(pX);wa.registerLoadRouter(pX);function tO(r,t){return new eO(r,t)}function DLe(r,t){return tO(r,t)}var sI=class{constructor(r){this.modelArtifacts=r}load(){return this.modelArtifacts}},fX=class{constructor(r){this.saveHandler=r}save(r){return this.saveHandler(r)}},FLe=class{constructor(r){r.load&&(this.load=()=>Promise.resolve(r.load())),r.save&&(this.save=t=>Promise.resolve(r.save(t)))}};function $Le(r,t,n,s){let i=arguments;return new FLe(mX(...i))}function mX(r,t,n,s){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new sI(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new sI({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new sI({modelTopology:r,weightSpecs:t,weightData:n,trainingConfig:s}))}function RLe(r){return new fX(r)}function OLe(r){return new fX(r)}var gX={};ir(gX,{confusionMatrix:()=>LLe});function MLe(r,t,n){let s=Q(r,"labels","confusionMatrix"),i=Q(t,"predictions","confusionMatrix");ue(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),ue(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),ue(i.rank===1,()=>`Expected the rank of predictions to be 1, but got ${i.rank}`),ue(s.shape[0]===i.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`),ue(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let a=qm(at(s,"int32"),n),o=qm(at(i,"int32"),n),u=dr(a),l=cr(u,o);return at(l,"int32")}var LLe=be({confusionMatrix_:MLe}),Sv={};ir(Sv,{draw:()=>HLe,fromPixels:()=>jLe,fromPixelsAsync:()=>ULe,toPixels:()=>GLe});var ah,V5=!1;function yX(r,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,s=!1,i=!1,a=!1,o=!1,u=!1;if(r.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&r instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement)a=!0;else if(r.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&r instanceof ImageBitmap)u=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(jb(R2,ye.backendName)!=null){let p={pixels:r},f={numChannels:t};return ye.runKernel(R2,p,f)}let[l,c]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],h;if(o)h=r.getContext("2d").getImageData(0,0,l,c).data;else if(s||n)h=r.data;else if(a||i||u){if(ah==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")ah=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else ah=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ah.canvas.width=l,ah.canvas.height=c,ah.drawImage(r,0,0,l,c),h=ah.getImageData(0,0,l,c).data}let d;if(t===4)d=new Int32Array(h);else{let p=l*c;d=new Int32Array(p*t);for(let f=0;f<p;f++)for(let m=0;m<t;++m)d[f*t+m]=h[f*4+m]}return c_(d,[c,l,t],"int32")}function PLe(r){return r!=null&&r.data instanceof Uint8Array}function BLe(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function VLe(r){return r!=null&&r.width!==0&&r.height!==0}function zLe(r){return BLe()&&!(r instanceof ImageBitmap)&&VLe(r)&&!PLe(r)}async function ULe(r,t=3){let n=null;if(Re().getBool("WRAP_TO_IMAGEBITMAP")&&zLe(r)){let s;try{s=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===r.width&&s.height===r.height?n=s:n=r}else n=r;return yX(n,t)}function bX(r){if(r.rank!==2&&r.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${r.rank}.`);let t=r.rank===2?1:r.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(r.dtype!=="float32"&&r.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${r.dtype}. Please use float32 or int32 tensors.`)}function WLe(r){let t=(r==null?void 0:r.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function GLe(r,t){let n=Q(r,"img","toPixels");if(!(r instanceof ur)){let c=n;n=at(c,"int32"),c.dispose()}bX(n);let[s,i]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2],o=await n.data(),u=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(i*s*4);for(let c=0;c<s*i;++c){let h=[0,0,0,255];for(let p=0;p<a;p++){let f=o[c*a+p];if(n.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(n.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);a===1?(h[0]=f*u,h[1]=f*u,h[2]=f*u):h[p]=f*u}let d=c*4;l[d+0]=Math.round(h[0]),l[d+1]=Math.round(h[1]),l[d+2]=Math.round(h[2]),l[d+3]=Math.round(h[3])}if(t!=null){V5||jb(AC,ye.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),V5=!0),t.width=i,t.height=s;let c=t.getContext("2d"),h=new ImageData(l,i,s);c.putImageData(h,0,0)}return n!==r&&n.dispose(),l}function HLe(r,t,n){let s=Q(r,"img","draw");if(!(r instanceof ur)){let o=s;s=at(o,"int32"),o.dispose()}bX(s),WLe(n==null?void 0:n.imageOptions);let i={image:s},a={canvas:t,options:n};ye.runKernel(AC,i,a)}var jLe=be({fromPixels_:yX}),rO={};ir(rO,{prepareAndValidate:()=>xX});function xX(r,t){let n=r.shape.length,s=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${n}`);if(Jr(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let i=t.shape,a=i[i.length-1],o=1;for(let d=0;d<i.length-1;++d)o*=i[d];let u=r.shape,l=i.slice();l.pop();let c=1;for(let d=a;d<n;++d)c*=u[d],l.push(u[d]);let h=[..._g(r.shape).map(d=>d/c),1].slice(0,a);return[l,o,c,h]}var is={};ir(is,{assertParamsValid:()=>KLe,computeFlatOffset:()=>QLe,computeOutShape:()=>YLe,getNormalizedAxes:()=>ZLe,isSliceContinous:()=>JLe,maskToAxes:()=>XLe,parseSliceParams:()=>NX,sliceInfo:()=>ePe,startForAxis:()=>IX,startIndicesWithElidedDims:()=>CX,stopForAxis:()=>kX,stopIndicesWithElidedDims:()=>_X,stridesForAxis:()=>EX,stridesWithElidedDims:()=>vX});var nN=-2,qLe=-1;function KLe(r,t,n){let s=r.shape.length;ue(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),ue(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let i=0;i<s;++i)ue(t[i]+n[i]<=r.shape[i],()=>`Error in slice${s}D: begin[${i}] + size[${i}] (${t[i]+n[i]}) would overflow input.shape[${i}] (${r.shape[i]})`)}function XLe(r){let t=[],n=0;for(;r>0;)r&1&&t.push(n),r/=2,n++;return t}function YLe(r,t,n){let s=[];for(let i=0;i<r.length;i++)s[i]=Math.ceil((t[i]-r[i])/n[i]);return s}function vX(r,t,n,s){let i=[...r];for(let a=i.length;a<s.length;a++)i.push(1);for(let a=0;a<n;a++)a===0?i[t]=1:(i.splice(t,0,1),i.pop());return i}function wX(r,t,n){return n<=r?n:n-(t-1)}function SX(r,t){let n=[];for(let s=0;s<r;s++)n.push(t+s);return n}function ZLe(r,t,n,s,i,a,o,u,l){let c=r.length,h=new Array(c),d=new Array(c),p=new Array(c);if(t.length&&n>0){let f=t[0],m=n+1;h=CX(o,f,m,s,r),d=_X(u,f,m,i,r),p=vX(a,f,m,r)}else for(let f=0;f<c;f++)h[f]=IX(o,s,a,r,f,l),d[f]=kX(u,i,a,r,f,l),p[f]=EX(a,f,l);return{begin:h,end:d,strides:p}}function CX(r,t,n,s,i){let a=[...i],o=SX(n,t);for(let u=0;u<a.length;u++)if(o.indexOf(u)>-1)a[u]=0;else{let l=wX(t,n,u),c=s[l];r&1<<l&&(c=0),a[u]=c}return a}function _X(r,t,n,s,i){let a=[...i],o=SX(n,t);for(let u=0;u<a.length;u++)if(o.indexOf(u)>-1)a[u]=Number.MAX_SAFE_INTEGER;else{let l=wX(t,n,u),c=s[l];r&1<<l&&(c=Number.MAX_SAFE_INTEGER),a[u]=c}for(let u=0;u<a.length;u++){let l=i[u];a[u]<0&&(a[u]+=l),a[u]=Gb(0,a[u],i[u])}return a}function EX(r,t,n){let s=r[t];return(n&1<<t||s==null)&&(s=1),s}function IX(r,t,n,s,i,a){let o=t[i],u=n[i]||1;(r&1<<i||a&1<<i||o==null)&&(u>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);let l=s[i];return o<0&&(o+=l),o=Gb(0,o,l-1),o}function kX(r,t,n,s,i,a){let o=t[i],u=n[i]||1;(r&1<<i||a&1<<i||o==null)&&(u>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);let l=s[i];return o<0&&(o+=l),u>0?o=Gb(0,o,l):o=Gb(-1,o,l-1),o}function JLe(r,t,n){let s=n.length;for(let i=0;i<n.length;i++)if(n[i]>1){s=i;break}for(let i=s+1;i<n.length;i++)if(t[i]>0||n[i]!==r[i])return!1;return!0}function QLe(r,t){let n=r.length>0?r[r.length-1]:1;for(let s=0;s<r.length-1;s++)n+=r[s]*t[s];return n}function NX(r,t,n){let s,i=r.shape.length;typeof t=="number"?s=[t,...new Array(i-1).fill(0)]:t.length<i?s=t.concat(new Array(i-t.length).fill(0)):s=t.slice(),s.forEach(o=>{ue(o!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(i).fill(-1):typeof n=="number"?a=[n,...new Array(i-1).fill(-1)]:n.length<i?a=n.concat(new Array(i-n.length).fill(-1)):a=n,a=a.map((o,u)=>o>=0?o:(ue(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${u}.`),r.shape[u]-s[u])),[s,a]}function ePe(r,t,n,s,i,a,o,u,l){let c;if(s==null?(c=new Array(t.length),c.fill(1)):c=s,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1,d={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:i,endMask:a,ellipsisMask:o,newAxisMask:u,shrinkAxisMask:l};for(let x=0;x<d.dims;x++)h&&1<<x&u&&d.numAddAxisAfterEllipsis++,1<<x&o&&(h=!0);h||(d.ellipsisMask|=1<<d.dims,d.dims++);let p={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};tPe(d,p);let f=!0,m=!0,g=!0,y=[],b=[];for(let x=0;x<r.length;++x){if(p.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);let w=!!(p.shrinkAxisMask&1<<x),v=r[x];if(v===-1){y.push(w?1:-1);continue}let S=[p.beginMask&1<<x,p.endMask&1<<x],E=[p.strides[x]>0?0:-1,p.strides[x]>0?v:v-1];if(w&&p.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&p.strides[x]===1;let C=!!(p.beginMask&1<<x&&p.endMask&1<<x);if(p.beginValid&&p.endValid){if(w){let k=p.begin[x]<0?v+p.begin[x]:p.begin[x];if(p.begin[x]=k,p.end[x]=p.begin[x]+1,k<0||k>=v)throw Error(`slice index ${p.begin[x]} of dimension ${x} out of bounds.`)}else p.begin[x]=z5(p.begin[x],0,p.strides[x],v,S,E),p.end[x]=z5(p.end[x],1,p.strides[x],v,S,E);let A=p.strides[x]===1&&p.begin[x]===0&&p.end[x]===v;f=f&&A,m=m&&(x===0&&p.strides[x]===1||A)}else f=f&&p.strides[x]===1&&C,m=m&&(x===0&&p.strides[x]===1||C);let I,_=!1;if(p.beginValid&&p.endValid?(I=p.end[x]-p.begin[x],_=!0):w?(I=1,_=!0):C&&v>=0&&(p.strides[x]<0?I=-v:I=v,_=!0),_){let A;I===0||I<0!=p.strides[x]<0?A=0:A=Math.trunc(I/p.strides[x])+(I%p.strides[x]!==0?1:0),y.push(A)}else y.push(-1)}for(let x=0;x<p.finalShapeGatherIndices.length;++x){let w=p.finalShapeGatherIndices[x];w>=0?b.push(y[w]):w===nN&&b.push(1)}return{finalShapeSparse:b.filter((x,w)=>p.finalShapeGatherIndices[w]!==nN),finalShape:b,isIdentity:f,sliceDim0:m,isSimpleSlice:g,begin:p.begin,end:p.end,strides:p.strides}}function tPe(r,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=r.begin!=null,t.endValid=r.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<r.dims;s++)if(1<<s&r.ellipsisMask){let i=Math.min(t.dims-(r.dims-s)+1+r.numAddAxisAfterEllipsis,t.dims);for(;n<i;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=s}else if(1<<s&r.newAxisMask)t.finalShapeGatherIndices.push(nN),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);r.begin!=null&&(t.begin[n]=r.begin[s]),r.end!=null&&(t.end[n]=r.end[s]),t.strides[n]=r.strides[s],r.beginMask&1<<s&&(t.beginMask|=1<<n),r.endMask&1<<s&&(t.endMask|=1<<n),r.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(qLe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[n]=s,n++}}function z5(r,t,n,s,i,a){if(i[t])return n>0?a[t]:a[t+1&1];{let o=r<0?s+r:r;return o<a[0]?a[0]:o>a[1]?a[1]:o}}var rPe="4.22.0",TX=class{static sgd(r){return new v_(r)}static momentum(r,t,n=!1){return new J3(r,t,n)}static rmsprop(r,t=.9,n=0,s=null,i=!1){return new Q3(r,t,n,s,i)}static adam(r=.001,t=.9,n=.999,s=null){return new Y3(r,t,n,s)}static adadelta(r=.001,t=.95,n=null){return new K3(r,t,n)}static adamax(r=.002,t=.9,n=.999,s=null,i=0){return new Z3(r,t,n,s,i)}static adagrad(r,t=.1){return new X3(r,t)}},fh=TX,nPe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:r=>r();function nO(){return new Promise(r=>nPe(()=>r()))}var q={};ir(q,{ERF_A1:()=>bPe,ERF_A2:()=>xPe,ERF_A3:()=>vPe,ERF_A4:()=>wPe,ERF_A5:()=>SPe,ERF_P:()=>yPe,PARALLELIZE_THRESHOLD:()=>sO,RowPartitionType:()=>Zo,SELU_SCALE:()=>DX,SELU_SCALEALPHA:()=>AX,applyActivation:()=>b_,assertAndGetBroadcastShape:()=>un,assertAxesAreInnerMostDims:()=>eRe,assertParamsConsistent:()=>sPe,assignToTypedArray:()=>NPe,axesAreInnerMostDims:()=>m3,calculateShapes:()=>PK,checkEinsumDimSizes:()=>RPe,checkPadOnDimRoundingMode:()=>pi,combineLocations:()=>iK,combineRaggedTensorToTensorShapes:()=>aPe,complexWithEvenIndex:()=>EPe,complexWithOddIndex:()=>IPe,computeConv2DInfo:()=>uv,computeConv3DInfo:()=>Yq,computeDefaultPad:()=>ZR,computeDilation2DInfo:()=>JFe,computeOptimalWindowSize:()=>cPe,computeOutAndReduceShapes:()=>aK,computeOutShape:()=>iPe,computePool2DInfo:()=>Xq,computePool3DInfo:()=>QFe,convertConv2DDataFormat:()=>Zq,decodeEinsumEquation:()=>FPe,eitherStridesOrDilationsAreOne:()=>Eu,expandShapeToKeepDim:()=>xd,exponent:()=>APe,exponents:()=>TPe,fromStringArrayToUint8:()=>tBe,fromUint8ToStringArray:()=>eBe,getAxesPermutation:()=>oK,getBroadcastDims:()=>nK,getComplexWithIndex:()=>kPe,getEinsumComputePath:()=>OPe,getEinsumPermutation:()=>$Pe,getFusedBiasGradient:()=>y_,getFusedDyActivation:()=>g_,getImageCenter:()=>hPe,getInnerMostAxes:()=>tRe,getPermuted:()=>pPe,getRaggedRank:()=>uPe,getReductionAxes:()=>Zn,getReshaped:()=>dPe,getReshapedPermuted:()=>fPe,getRowPartitionTypesHelper:()=>oPe,getSliceBeginCoords:()=>mPe,getSliceSize:()=>gPe,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>BPe,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>VPe,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>zPe,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>GPe,getSparseReshapeInputOutputMismatchErrorMessage:()=>jPe,getSparseReshapeInputOutputMultipleErrorMessage:()=>HPe,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>UPe,getSparseReshapeNegativeOutputDimErrorMessage:()=>WPe,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>YPe,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>qPe,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>KPe,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>XPe,getUndoAxesPermutation:()=>g3,isIdentityPermutation:()=>MPe,log:()=>cDe,mergeRealAndImagArrays:()=>CPe,prepareAndValidate:()=>xX,prepareSplitSize:()=>PPe,segment_util:()=>FX,shouldFuse:()=>x_,slice_util:()=>is,splitRealAndImagArrays:()=>_Pe,stridesOrDilationsArePositive:()=>bd,tupleValuesAreOne:()=>xc,upcastType:()=>va,validateDefaultValueShape:()=>lPe,validateInput:()=>d_,validateUpdateShape:()=>P3,warn:()=>zl});function sPe(r,t){let n=r[0].length;r.forEach((i,a)=>{ue(i.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),ue(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let s=r[0];r.forEach((i,a)=>{for(let o=0;o<n;o++)ue(o===t||i[o]===s[o],()=>`Error in concat${n}D: Shape of tensors[${a}] (${i}) does not match the shape of the rest (${s}) along the non-concatenated axis ${a}.`)})}function iPe(r,t){let n=r[0].slice();for(let s=1;s<r.length;s++)n[t]+=r[s][t];return n}var Zo;(function(r){r[r.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",r[r.VALUE_ROWIDS=1]="VALUE_ROWIDS",r[r.ROW_LENGTHS=2]="ROW_LENGTHS",r[r.ROW_SPLITS=3]="ROW_SPLITS",r[r.ROW_LIMITS=4]="ROW_LIMITS",r[r.ROW_STARTS=5]="ROW_STARTS"})(Zo||(Zo={}));function aPe(r,t,n){let s=new Array;if(n==null&&t==null)return s;if(t==null)for(;s.length<r+n.length;)s.push(-1);else s=t.slice();if(n==null)return s;if(r+n.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${r+n.length}, but shape.rank = ${s.length}`);for(let i=1;i<n.length;++i){let a=n[i],o=s[s.length-n.length+i],u=s[o];if(a>=0)if(u>=0){if(u!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${i+r}] = ${a} but shape[${i+r}] = ${u}`)}else s[o]=a}return s}function oPe(r){let t={FIRST_DIM_SIZE:Zo.FIRST_DIM_SIZE,VALUE_ROWIDS:Zo.VALUE_ROWIDS,ROW_LENGTHS:Zo.ROW_LENGTHS,ROW_SPLITS:Zo.ROW_SPLITS,ROW_LIMITS:Zo.ROW_LIMITS,ROW_STARTS:Zo.ROW_STARTS},n=[];for(let s of r)if(s in t)n.push(t[s]);else break;return n}function uPe(r){return r.length===0?0:r[0]===Zo.FIRST_DIM_SIZE?r.length-1:r.length}function lPe(r,t){if(r==null||t==null)return;let n=r.length,s=t.length;if(n>=s)throw new Error(`defaultValue.shape=${r} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);for(let i=0;i<Math.min(n,s-1);++i){let a=r[i],o=t[i+1];if(a>=0&&o>=0&&a!==1&&a!==o)throw new Error(`defaultValue.shape=${r}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${i-r.length}] = ${a} but ragged tensor input.flatValues.shape[${i-r.length}] = ${o}`)}}var sO=30;function cPe(r){return r<=sO?r:$2(r,Math.floor(Math.sqrt(r)))}function hPe(r,t,n){let s=n*(typeof r=="number"?r:r[0]),i=t*(typeof r=="number"?r:r[1]);return[s,i]}function dPe(r,t,n,s=!0){let i=[];if(s)i=i.concat(t.slice(0)),i.push(r[0]/n),i=i.concat(r.slice(1));else{i=i.concat(r[0]);let a=t.length;for(let o=0;o<a;++o)i=i.concat([r[o+1]/t[o],t[o]]);i=i.concat(r.slice(a+1))}return i}function pPe(r,t,n=!0){let s=[];if(n){s.push(t);for(let i=t+1;i<r;++i)i<=2*t?(s.push(i),s.push(i-(t+1))):s.push(i)}else{let i=[],a=[];for(let o=1;o<r;++o)o>=t*2+1||o%2===1?a.push(o):i.push(o);s.push(...i),s.push(0),s.push(...a)}return s}function fPe(r,t,n,s=!0){let i=[];s?i.push(r[0]/n):i.push(r[0]*n);for(let a=1;a<r.length;++a)a<=t.length?s?i.push(t[a-1]*r[a]):i.push(r[a]/t[a-1]):i.push(r[a]);return i}function mPe(r,t){let n=[0];for(let s=0;s<t;++s)n.push(r[s][0]);return n}function gPe(r,t,n){let s=r.slice(0,1);for(let i=0;i<n;++i)s.push(r[i+1]-t[i][0]-t[i][1]);return s}var AX=1.7580993408473768,DX=1.0507009873554805,yPe=.3275911,bPe=.254829592,xPe=-.284496736,vPe=1.421413741,wPe=-1.453152027,SPe=1.061405429;function CPe(r,t){if(r.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${t.length}.`);let n=new Float32Array(r.length*2);for(let s=0;s<n.length;s+=2)n[s]=r[s/2],n[s+1]=t[s/2];return n}function _Pe(r){let t=new Float32Array(r.length/2),n=new Float32Array(r.length/2);for(let s=0;s<r.length;s+=2)t[s/2]=r[s],n[s/2]=r[s+1];return{real:t,imag:n}}function EPe(r){let t=Math.ceil(r.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let i=0;i<r.length;i+=4)n[Math.floor(i/4)]=r[i],s[Math.floor(i/4)]=r[i+1];return{real:n,imag:s}}function IPe(r){let t=Math.floor(r.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let i=2;i<r.length;i+=4)n[Math.floor(i/4)]=r[i],s[Math.floor(i/4)]=r[i+1];return{real:n,imag:s}}function kPe(r,t){let n=r[t*2],s=r[t*2+1];return{real:n,imag:s}}function NPe(r,t,n,s){r[s*2]=t,r[s*2+1]=n}function TPe(r,t){let n=new Float32Array(r/2),s=new Float32Array(r/2);for(let i=0;i<Math.ceil(r/2);i++){let a=(t?2:-2)*Math.PI*(i/r);n[i]=Math.cos(a),s[i]=Math.sin(a)}return{real:n,imag:s}}function APe(r,t,n){let s=(n?2:-2)*Math.PI*(r/t),i=Math.cos(s),a=Math.sin(s);return{real:i,imag:a}}var iI="->",DPe=/->/g,U5=",",W5="...";function FPe(r,t){r=r.replace(/\s/g,"");let n=(r.length-r.replace(DPe,"").length)/iI.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${iI}").`);let[s,i]=r.split(iI);ue(s.indexOf(W5)===-1,()=>`The ellipsis notation ("${W5}") is not supported yet.`);let a=s.split(U5),o=a.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let u=[];for(let p=0;p<i.length;++p){let f=i[p];if(!a.some(m=>m.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);u.indexOf(f)===-1&&u.push(f)}for(let p=0;p<s.length;++p){let f=s[p];u.indexOf(f)===-1&&f!==U5&&u.push(f)}let l=new Array(a.length);for(let p=0;p<o;++p){if(new Set(a[p].split("")).size!==a[p].length)throw new Error(`Found duplicate axes in input component ${a[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let f=0;f<a[p].length;++f)l[p].push(u.indexOf(a[p][f]))}let c=u.length,h=i.length,d=[];for(let p=h;p<c;++p)d.push(p);return{allDims:u,summedDims:d,idDims:l}}function $Pe(r,t){let n=new Array(r);n.fill(-1);for(let i=0;i<t.length;++i)n[t[i]]=i;let s=[];for(let i=0;i<r;++i)n[i]===-1&&s.push(i);return n=n.filter(i=>i!==-1),{permutationIndices:n,expandDims:s}}function RPe(r,t,n){let s=new Array(r);for(let i=0;i<n.length;++i){let a=n[i].shape;for(let o=0;o<t[i].length;++o)s[t[i][o]]===void 0?s[t[i][o]]=a[o]:ue(s[t[i][o]]===a[o],()=>`Expected dimension ${s[t[i][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function OPe(r,t){let n=r,s=[],i=0;r.length===0&&n.push(-1),i=r.length+1;for(let o=0;o<i;++o)s.push([]);let a=[];for(let o=0;o<n.length;++o){let u=n[o],l=LPe(t,u);for(let c of l)a.indexOf(c)===-1&&(s[o].push(c),a.push(c))}return{path:n,steps:s}}function MPe(r){return r.every((t,n)=>t===n)}function LPe(r,t){let n=[];for(let s=0;s<r.length;++s)(r[s].length===0||r[s].indexOf(t)!==-1||t===-1)&&n.push(s);return n}function PPe(r,t,n=0){let s=[];if(typeof t=="number")ue(r.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(r.shape[n]/t);else{let i=t.reduce((o,u)=>(u===-1&&(o+=1),o),0);ue(i<=1,()=>"There should be only one negative value in split array.");let a=t.indexOf(-1);if(a!==-1){let o=t.reduce((u,l)=>l>0?u+l:u);t[a]=r.shape[n]-o}ue(r.shape[n]===t.reduce((o,u)=>o+u),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}function BPe(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function VPe(r,t){return`indices(${r}, 0) is invalid: ${t} < 0`}function zPe(r,t,n){return`indices(${r}, 0) is invalid: ${t} >= ${n}`}function UPe(r,t){return`only one output dimension may be -1, not both ${r} and ${t}`}function WPe(r,t){return`size ${r} must be non-negative, not ${t}`}function GPe(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function HPe(r,t){let n=Jr(r),s=Jr(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${r} outputShape= ${t}`}function jPe(r,t){let n=Jr(r),s=Jr(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${r} outputShape=${t}`}function qPe(){return"segment ids must be >= 0"}function KPe(){return"segment ids are not increasing"}function XPe(r,t){return`Segment id ${r} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function YPe(r,t,n){return`Bad: indices[${r}] == ${t} out of range [0, ${n})`}var FX={};ir(FX,{collectGatherOpShapeInfo:()=>QPe,computeOutShape:()=>JPe,segOpComputeOptimalWindowSize:()=>ZPe});function ZPe(r,t){let n=!1,s;for(r<=sO?(s=r,n=!0):s=$2(r,Math.floor(Math.sqrt(r)));!n;)s>t||s===r?n=!0:s=$2(r,s+1);return s}function JPe(r,t,n){let s=[],i=r.length;for(let a=0;a<i;a++)a!==t?s.push(r[a]):s.push(n);return s}function QPe(r,t,n,s){let i=t.shape.length,a=r.shape.length;if(s!==0&&(s<-i||s>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${s}`);if(s<0&&(s+=i),s>a)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${a}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let d=0;d<s;++d)if(r.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${r.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let o=r.shape[n],u=[],l=1,c=1,h=1;for(let d=0;d<s;++d)u.push(r.shape[d]),l*=r.shape[d];for(let d=s;d<n;d++)u.push(r.shape[d]),c*=r.shape[d];for(let d=s;d<i;d++)u.push(t.shape[d]);for(let d=n+1;d<a;d++)u.push(r.shape[d]),h*=r.shape[d];return{batchSize:l,sliceSize:h,outerSize:c,dimSize:o,outputShape:u}}function eBe(r){try{return r.map(t=>M2(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function tBe(r){return r.map(t=>iv(t))}var ku={};ir(ku,{nonMaxSuppressionV3Impl:()=>JK,nonMaxSuppressionV4Impl:()=>QK,nonMaxSuppressionV5Impl:()=>eX,whereImpl:()=>zK});bLe();var $X={kernelName:Eg,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Se(r,pf(at(n,"float32"),-1))}}},rBe={kernelName:Hd,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>{let s=rn(at(n,"float32")),i=_s(vt(Pt(1),s));return xn(_t(r,i))}}}},nBe={kernelName:jd,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>{let s=_s(vt(rn(at(n,"float32")),1));return _t(r,s)}}}},sBe={kernelName:Mc,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[n,s]=t,i=un(n.shape,s.shape);return{a:()=>{let a=r,o=Zn(n.shape,i);return o.length>0&&(a=Tt(a,o)),Ee(a,n.shape)},b:()=>{let a=r,o=Zn(s.shape,i);return o.length>0&&(a=Tt(a,o)),Ee(a,s.shape)}}}},iBe={kernelName:qd,saveAllInputs:!0,gradFunc:(r,t)=>{let n={};return t.forEach((s,i)=>{n[i]=()=>r.clone()}),n}},aBe={kernelName:Ng,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Cr(n)}}},oBe={kernelName:Tg,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Cr(n)}}},uBe={kernelName:Kd,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>_t(r,_s(vt(Pt(1),rn(at(n,"float32")))))}}},lBe={kernelName:Xd,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>{let s=_s(Ke(Pt(1),rn(at(n,"float32"))));return _t(r,s)}}}},cBe={kernelName:Jd,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[n,s]=t,i=un(n.shape,s.shape);return{a:()=>{let a=Ke(rn(n),rn(s)),o=Se(r,_t(s,a)),u=Zn(n.shape,i);return u.length>0&&(o=Tt(o,u)),Ee(o,n.shape)},b:()=>{let a=Ke(rn(n),rn(s)),o=xn(Se(r,_t(n,a))),u=Zn(s.shape,i);return u.length>0&&(o=Tt(o,u)),Ee(o,s.shape)}}}},hBe={kernelName:Yd,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>_t(r,Ke(rn(at(n,"float32")),1))}}},dBe={kernelName:Zd,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>_t(r,vt(Pt(1),rn(at(n,"float32"))))}}};function pBe(r,t,n,s,i,a){let o=Q(r,"dy","avgPool3dGrad"),u=Q(t,"input","avgPool3dGrad"),l=o,c=u,h=!1;u.rank===4&&(h=!0,l=Ee(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=Ee(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),ue(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),ue(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),pi("avgPool3dGrad",i,a);let d={dy:l,input:c},p={filterSize:n,strides:s,pad:i,dimRoundingMode:a},f=ye.runKernel(Lx,d,p);return h?Ee(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var fBe=be({avgPool3dGrad_:pBe}),mBe={kernelName:Ag,inputsToSave:["x"],gradFunc:(r,t,n)=>{let[s]=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=n;return{x:()=>fBe(r,s,i,a,o,u)}}};function gBe(r,t,n,s,i){let a=Q(r,"dy","avgPoolGrad"),o=Q(t,"input","avgPoolGrad");ue(o.rank===a.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${a.rank})`);let u=o,l=a,c=!1;o.rank===3&&(c=!0,u=Ee(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=Ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ue(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),ue(u.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${u.rank}.`);let h={dy:l,input:u},d={filterSize:n,strides:s,pad:i},p=ye.runKernel(Mx,h,d);return c?Ee(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var yBe=be({avgPoolGrad_:gBe}),bBe={kernelName:Qd,inputsToSave:["x"],gradFunc:(r,t,n)=>{let[s]=t,{filterSize:i,strides:a,pad:o}=n;return{x:()=>yBe(r,s,i,a,o)}}},xBe={kernelName:ep,inputsToSave:["a","b"],gradFunc:(r,t,n)=>{let[s,i]=t,{transposeA:a,transposeB:o}=n;return!a&&!o?{a:()=>cr(r,i,!1,!0),b:()=>cr(s,r,!0,!1)}:!a&&o?{a:()=>cr(r,i,!1,!1),b:()=>cr(r,s,!0,!1)}:a&&!o?{a:()=>cr(i,r,!1,!0),b:()=>cr(s,r,!1,!1)}:{a:()=>cr(i,r,!0,!0),b:()=>cr(r,s,!0,!0)}}},vBe={kernelName:Dg,gradFunc:(r,t,n)=>{let{blockShape:s,crops:i}=n;return{x:()=>yv(r,s,i)}}},wBe={kernelName:bq,gradFunc:(r,t,n)=>{let s=n,i=s.inputShape,a=s.shape,o=Array.from(a);for(let l=i.length-1;l>=0;l--)if(i[l]===a[l])o[l]=1;else if(i[l]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${a}].`);let u=[];for(let l=0;l<o.length;l++)o[l]>1&&u.push(l);return{x:()=>Tt(r,u,!0)}}},SBe={kernelName:tp,gradFunc:r=>({x:()=>r.clone()})},CBe={kernelName:rp,gradFunc:r=>({x:()=>Cr(r)})},_Be={kernelName:Lc,inputsToSave:["x"],gradFunc:(r,t,n)=>{let[s]=t,{clipValueMin:i,clipValueMax:a}=n;return{x:()=>Ss(Za(Sl(s,i),zc(s,a)),r,Cr(r))}}},EBe={kernelName:Bx,inputsToSave:["x"],gradFunc:$X.gradFunc},IBe={kernelName:Rg,saveAllInputs:!0,gradFunc:(r,t,n)=>{let s=t.map(u=>u.shape),{axis:i}=n,a=io(i,t[0].shape)[0],o=s.map(u=>u[a]);return _i(r,o,a).map(u=>()=>u)}},kBe={kernelName:np,inputsToSave:["x","filter"],gradFunc:(r,t,n)=>{let[s,i]=t,{dilations:a,strides:o,pad:u,dataFormat:l}=n;return ue(xc(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>u3(s.shape,r,i,o,u,l),filter:()=>H3(s,r,i.shape,o,u,l)}}},NBe={kernelName:sp,inputsToSave:["dy","filter"],gradFunc:(r,t,n)=>{let[s,i]=t,{strides:a,pad:o,dataFormat:u,dimRoundingMode:l}=n;return{dy:()=>ui(r,i,a,o,u,1,l),filter:()=>H3(r,s,i.shape,a,o,u,l)}}};function TBe(r,t,n,s,i){let a=r;r.rank===4&&(a=Ee(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let o=t;o.rank===4&&(o=Ee(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),ue(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),ue(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),ue(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),ue(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),ue(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`);let u={x:a,dy:o},l={strides:s,pad:i,filterShape:n};return ye.runKernel(Og,u,l)}var ABe=be({conv3DBackpropFilter_:TBe}),DBe={kernelName:ip,inputsToSave:["x","filter"],gradFunc:(r,t,n)=>{let{dilations:s,strides:i,pad:a}=n;ue(xc(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let[o,u]=t;return{x:()=>tK(o.shape,r,u,i,a),filter:()=>ABe(o,r,u.shape,i,a)}}},FBe={kernelName:ap,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Se(xn(i_(at(n,"float32"))),r)}}},$Be={kernelName:op,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Se(a_(at(n,"float32")),r)}}},RBe={kernelName:up,inputsToSave:["x"],gradFunc:(r,t,n)=>{let[s]=t,{axis:i,exclusive:a,reverse:o}=n;return{x:()=>{let u=oK([i],s.rank),l=qC(r,i,a,!o);return u!=null&&(l=dr(l,u)),l}}}},OBe={kernelName:lp,inputsToSave:["x","filter"],gradFunc:(r,t,n)=>{let{dilations:s,strides:i,pad:a,dimRoundingMode:o}=n,u=s??[1,1];ue(xc(u),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${u}'`);let[l,c]=t;return ue(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),ue(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),ue(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),ue(Eu(i,u),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${u}'.`),pi("depthwiseConv2d",a,o),{x:()=>XK(l.shape,r,c,i,a,u,o),filter:()=>KK(l,r,c.shape,i,a,u,o)}}},MBe={kernelName:cp,inputsToSave:["x","filter"],gradFunc:(r,t,n)=>{let[s,i]=t,a={x:s,filter:i,dy:r},o={x:s,filter:i,dy:r};return{x:()=>ye.runKernel(Um,a,n),filter:()=>ye.runKernel(Wm,o,n)}}},LBe={kernelName:dp,outputsToSave:[!0],gradFunc:(r,t)=>{let[n]=t,s={dy:r,y:n};return{x:()=>ye.runKernel(Vg,s)}}},PBe={kernelName:pp,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t,s=Se(Ws(xn(rn(n))),2/Math.sqrt(Math.PI));return{x:()=>Se(r,s)}}},BBe={kernelName:fp,outputsToSave:[!0],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Se(r,n)}}},VBe={kernelName:Ug,inputsToSave:["input"],gradFunc:(r,t)=>{let[n]=t;return{input:()=>Ee(r,n.shape)}}},zBe={kernelName:mp,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Se(r,Ws(n))}}},UBe={kernelName:gp,gradFunc:r=>({x:()=>Cr(r)})},WBe={kernelName:yp,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[n,s]=t,i=un(n.shape,s.shape);return{a:()=>{let a=_t(r,at(s,"float32")),o=Zn(n.shape,i);return o.length>0?Ee(Tt(a,o),n.shape):a},b:()=>{let a=Se(r,at(n,"float32")),o=Zn(s.shape,i);o.length>0&&(a=Ee(Tt(a,o),s.shape));let u=rn(s);return xn(_t(a,at(u,"float32")))}}}},GBe={kernelName:bp,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,t,n)=>{let{varianceEpsilon:s}=n,[i,a,o,u]=t,l=u??Pt(1),c=Zn(a.shape,i.shape),h=[];if(a.rank===1){for(let g=0;g<i.shape.length-1;++g)h.push(i.shape[g]);h.push(1)}let d=vt(i,a),p=Se(r,l),f=n_(Ke(o,Pt(s))),m=Se(Se(Se(f,f),f),Pt(-.5));return{x:()=>a.rank===1?Ee(Se(Se(r,Zi(Ee(f,[1,1,1,a.shape[0]]),h)),l),i.shape):Ee(Se(Se(r,f),l),i.shape),mean:()=>{let g=Se(Se(f,Pt(-1)),p);return a.rank===1&&(g=Tt(g,c)),Ee(g,a.shape)},variance:()=>{let g=Se(Se(m,d),p);return a.rank===1&&(g=Tt(g,c)),Ee(g,a.shape)},scale:()=>{let g=Se(d,f),y=Se(r,g);return a.rank===1&&(y=Tt(y,c)),Ee(y,a.shape)},offset:()=>{let g=r;return a.rank===1&&(g=Tt(g,c)),Ee(g,a.shape)}}}},HBe={kernelName:Gg,inputsToSave:["x","indices"],gradFunc:(r,t,n)=>{let[s,i]=t,{axis:a,batchDims:o}=n,u=io(a,s.shape)[0],l=(c,h,d)=>()=>{let p=c.shape,f=h.size,m=p.slice(0,u),g=m.length,y=p.slice(a,p.length).slice(1),b=y.length,x=G5(0,g),w=G5(g+1,g+1+b),v=H5([m,[f],y]),S=Ee(d,v),E=Ee(h,[f]),C=H5([[g],x,w]),I=dr(S,C),_=f_(I,E,c.shape[u]),A=g3(C);return _=dr(_,A),_};if(o===1){let c=s.shape[0],h=s.split(c,0);return{x:()=>Yn(h.map((d,p)=>l(d,i.slice(p,1),r.slice(p,1))())).reshape(s.shape),indices:()=>i}}else return{x:l(s,i,r),indices:()=>i}}};function G5(r,t){let n=[];for(let s=r;s<t;++s)n.push(s);return n}function H5(r){let t=[];for(let n=0;n<r.length;++n)for(let s=0;s<r[n].length;++s)t.push(r[n][s]);return t}var jBe={kernelName:xp,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[n,s]=t;return{a:()=>Cr(n),b:()=>Cr(s)}}},qBe={kernelName:vp,gradFunc:r=>({x:()=>at(r,"float32")})},KBe={kernelName:wp,gradFunc:r=>({x:()=>Cr(r)})},XBe={kernelName:Sp,gradFunc:r=>({x:()=>Cr(r)})},YBe={kernelName:Cp,gradFunc:r=>({x:()=>Cr(r)})},ZBe={kernelName:_p,inputsToSave:["x"],gradFunc:(r,t,n)=>{let[s]=t,{alpha:i}=n,a=fi(s,0);return{x:()=>Ss(a,r,Se(r,i))}}},JBe={kernelName:Ip,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>_t(r,Ke(n,1))}}},QBe={kernelName:Ep,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>_t(r,at(n,"float32"))}}},e4e={kernelName:vq,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,t,n)=>{let[s]=t,{axis:i}=n;return{logits:()=>{let a=Ws(s);return vt(r,Se(Tt(r,i,!0),a))}}}};function t4e(r,t,n,s=5,i=1,a=1,o=.5){let u={x:r,y:t,dy:n},l={depthRadius:s,bias:i,alpha:a,beta:o};return ye.runKernel(Qg,u,l)}var r4e=be({localResponseNormalizationBackprop_:t4e}),n4e={kernelName:kp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,n)=>{let[s,i]=t,{depthRadius:a,bias:o,alpha:u,beta:l}=n;return{x:()=>r4e(s,i,r,a,o,u,l)}}};function RX(r,t,n,s){return t.rank<n.rank&&(t=Ee(t,xd(t.shape,s))),r.rank<n.rank&&(r=Ee(r,xd(r.shape,s))),{x:()=>Se(r,at(ra(n,t),r.dtype))}}var j5={kernelName:Np,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,n)=>{let s=n,{reductionIndices:i}=s,a=t[0],o=t[1],u=io(i,a.shape),l=RX(r,o,a,u);return{x:()=>l.x()}}},s4e={kernelName:Tp,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[n,s]=t;return{a:()=>Se(r,at(Sl(n,s),"float32")),b:()=>Se(r,at(jm(n,s),"float32"))}}};function i4e(r,t,n,s,i,a,o){let u=Q(r,"dy","maxPool3dGrad"),l=Q(t,"input","maxPool3dGrad"),c=Q(n,"output","maxPool3dGrad"),h=u,d=l,p=c,f=!1;l.rank===4&&(f=!0,h=Ee(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=Ee(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=Ee(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),ue(h.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),ue(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),ue(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),pi("maxPool3dGrad",a,o);let m={dy:h,input:d,output:p},g={filterSize:s,strides:i,pad:a,dimRoundingMode:o},y=ye.runKernel(Gx,m,g);return f?Ee(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}var a4e=be({maxPool3dGrad_:i4e}),o4e={kernelName:e0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,n)=>{let[s,i]=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=n;return{x:()=>a4e(r,s,i,a,o,u,l)}}};function u4e(r,t,n,s,i,a,o){let u=Q(r,"dy","maxPoolGrad"),l=Q(t,"input","maxPoolGrad"),c=Q(n,"output","maxPoolGrad");ue(l.rank===u.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${u.rank})`),ue(u.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),ue(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),pi("maxPoolGrad",a,o);let h={dy:u,input:l,output:c},d={filterSize:s,strides:i,pad:a,dimRoundingMode:o};return ye.runKernel(Wx,h,d)}var l4e=be({maxPoolGrad_:u4e}),c4e={kernelName:Ap,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,n)=>{let[s,i]=t,{filterSize:a,strides:o,pad:u}=n;return{x:()=>l4e(r,s,i,a,o,u)}}},h4e={kernelName:Dp,inputsToSave:["x"],gradFunc:(r,t,n)=>{let[s]=t,{axis:i}=n,a=io(i,s.shape),o=aK(s.shape,a)[1],u=Jr(o);return{x:()=>{let l=s.shape.slice();a.forEach(h=>{l[h]=1});let c=Ee(r,l);return _t(Se(c,Ci(s.shape,"float32")),u)}}}},d4e={kernelName:Fp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,n)=>{let s=n,{axis:i}=s,[a,o]=t,u=io(i,a.shape),l=RX(r,o,a,u);return{x:()=>l.x()}}},p4e={kernelName:$p,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[n,s]=t;return{a:()=>Se(r,at(zc(n,s),"float32")),b:()=>Se(r,at(fi(n,s),"float32"))}}},f4e={kernelName:Rp,inputsToSave:["x"],gradFunc:(r,t,n)=>{let s=t[0],{paddings:i}=n,a=i.map(o=>o[0]);return{x:()=>vr(r,a,s.shape)}}},m4e={kernelName:Op,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[n,s]=t,i=un(n.shape,s.shape);return{a:()=>{let a=Zn(n.shape,i);return a.length>0?Ee(Tt(r,a),n.shape):r},b:()=>{let a=Se(r,xn(A0(_t(n,s)))),o=Zn(s.shape,i);return o.length>0?Ee(Tt(a,o),s.shape):a}}}},g4e={kernelName:Mp,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[n,s]=t,i=un(n.shape,s.shape);return{a:()=>{let a=Se(r,at(s,"float32")),o=Zn(n.shape,i);return o.length>0?Ee(Tt(a,o),n.shape):a},b:()=>{let a=Se(r,at(n,"float32")),o=Zn(s.shape,i);return o.length>0?Ee(Tt(a,o),s.shape):a}}}},y4e={kernelName:r0,gradFunc:r=>({x:()=>xn(r)})},b4e={kernelName:Lp,inputsToSave:["indices"],gradFunc:(r,t)=>{let n=t[0];return{indices:()=>On(n.shape,"float32")}}},x4e={kernelName:o0,gradFunc:r=>({x:()=>Cr(r)})},v4e={kernelName:u0,saveAllInputs:!0,gradFunc:(r,t,n)=>{let{axis:s}=n;return Bn(r,s).map(i=>()=>i)}},q5={kernelName:Pp,inputsToSave:["x"],gradFunc:(r,t,n)=>{let s=t[0],{paddings:i}=n,a=i.map(o=>o[0]);return{x:()=>vr(r,a,s.shape)}}},w4e={kernelName:Bp,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,t)=>{let[n,s,i]=t,a=n,o=s,u=un(a.shape,o.shape);return{a:()=>{let l=at(o,"float32"),c=Se(r,Se(l,yu(a,vt(l,Pt(1))))),h=Zn(a.shape,u);return h.length>0&&(c=Tt(c,h)),Ee(c,a.shape)},b:()=>{let l=fi(a,0),c=Ss(l,na(a),Cr(a)),h=Se(r,Se(i,c)),d=Zn(o.shape,u);return d.length>0&&(h=Tt(h,d)),Ee(h,o.shape)}}}},S4e={kernelName:Vp,inputsToSave:["x","alpha"],gradFunc:(r,t)=>{let[n,s]=t,i=fi(n,0);return{x:()=>Ss(i,r,Se(r,s)),alpha:()=>{let a=Ss(i,Cr(r),Se(r,n)),o=Zn(s.shape,r.shape);return o.length>0&&(a=Tt(a,o)),Ee(a,s.shape)}}}};function C4e(r,t,n){let s=r.shape.slice();s[n]=1;let i=Ee(t,s),a=Jb(r,n,!0,!1),o=Jb(r,n,!0,!0),u=Se(a,o);return Se(i,u)}function _4e(r,t,n){let s=r.shape.length,i=s-n.length,a=q.getAxesPermutation(n,s),o=r;a!=null&&(o=dr(r,a));let u=o.shape.slice(),l=u.splice(s-n.length,n.length).reduce((d,p)=>d*p,1);u.push(l);let c=o.reshape(u),h=C4e(c,t,i);if(h=h.reshape(o.shape),a!=null){let d=q.getUndoAxesPermutation(a);h=dr(h,d)}return h}var E4e={kernelName:zp,inputsToSave:["x"],gradFunc:(r,t,n)=>{let[s]=t,{axis:i}=n,a=[];return i==null?a=s.shape.map((o,u)=>u):typeof i=="number"?a=[i]:a=i,{x:()=>_4e(s,r,a)}}},I4e={kernelName:hp,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[n,s]=t,i=un(n.shape,s.shape);return{a:()=>{let a=_t(r,at(s,"float32")),o=Zn(n.shape,i);return o.length>0?Ee(Tt(a,o),n.shape):a},b:()=>{let a=Se(r,at(n,"float32")),o=Zn(s.shape,i);o.length>0&&(a=Ee(Tt(a,o),s.shape));let u=rn(s);return xn(_t(a,at(u,"float32")))}}}},k4e={kernelName:Up,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>_t(r,xn(rn(n)))}}},N4e={kernelName:jp,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t,s=Se(zc(n,6),pf(n));return{x:()=>Se(r,at(s,"float32"))}}},T4e={kernelName:Wp,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Se(r,at(pf(n),"float32"))}}},A4e={kernelName:l0,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Ee(r,n.shape)}}},D4e={kernelName:Hp,inputsToSave:["images"],gradFunc:(r,t,n)=>{let[s]=t,i={dy:r,images:s};return{images:()=>ye.runKernel(h0,i,n)}}},F4e={kernelName:Gp,inputsToSave:["images"],gradFunc:(r,t,n)=>{let[s]=t,i={dy:r,images:s};return{images:()=>ye.runKernel(c0,i,n)}}},$4e={kernelName:qp,gradFunc:(r,t,n)=>{let{dims:s}=n,i=io(s,r.shape);return{x:()=>Sa(r,i)}}},R4e={kernelName:Kp,gradFunc:r=>({x:()=>Cr(r)})},O4e={kernelName:Xp,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>xn(_t(r,Se(yu(n,1.5),2)))}}},M4e={kernelName:m0,inputsToSave:["condition"],gradFunc:(r,t)=>{let[n]=t;return{condition:()=>at(Cr(n),"float32"),t:()=>Se(r,at(n,r.dtype)),e:()=>Se(r,at(mv(n),r.dtype))}}},L4e={kernelName:Yp,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>{let s=fi(n,Pt(0)),i=Pt(AX),a=Pt(DX),o=Se(r,a),u=Se(Se(r,i),Ws(at(n,"float32")));return Ss(s,o,u)}}}},P4e={kernelName:ef,outputsToSave:[!0],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Se(r,Se(n,vt(Pt(1),n)))}}},B4e={kernelName:Qp,gradFunc:r=>({x:()=>Cr(r)})},V4e={kernelName:Zp,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Se(cv(at(n,"float32")),r)}}},z4e={kernelName:Jp,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Se(jC(at(n,"float32")),r)}}},U4e={kernelName:g0,inputsToSave:["x"],gradFunc:(r,t,n)=>{let[s]=t,{begin:i,size:a}=n,o=s.shape,[u,l]=NX(s,i,a),c=[];for(let h=0;h<r.rank;h++)c.push([u[h],o[h]-u[h]-l[h]]);return{x:()=>zo(r,c)}}},W4e={kernelName:sf,outputsToSave:[!0],gradFunc:(r,t,n)=>{let[s]=t,{dim:i}=n,a=!0,o=Se(r,s);return{logits:()=>vt(o,Se(Tt(o,[i],a),s))}}},G4e={kernelName:tf,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Se(r,Xa(n))}}},K5={kernelName:y0,gradFunc:(r,t,n)=>{let{blockShape:s,paddings:i}=n;return{x:()=>lv(r,s,i)}}},X5={kernelName:b0,gradFunc:(r,t,n)=>{let{axis:s}=n;return{x:()=>an(r,s)}}},H4e={kernelName:rf,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>_t(r,Se(_s(at(n,"float32")),2))}}},j4e={kernelName:Yx,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Se(r,Se(at(n,"float32"),2))}}},q4e={kernelName:af,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[n,s]=t,i=Pt(2);return{a:()=>Se(r,Se(i,vt(n,s))),b:()=>Se(r,Se(i,vt(s,n)))}}},K4e={kernelName:Bc,gradFunc:r=>({x:()=>Cr(r)})},X4e={kernelName:of,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[n,s]=t,i=un(n.shape,s.shape);return{a:()=>{let a=r,o=Zn(n.shape,i);return o.length>0&&(a=Tt(a,o)),Ee(a,n.shape)},b:()=>{let a=r,o=Zn(s.shape,i);return o.length>0&&(a=Tt(a,o)),Ee(xn(a),s.shape)}}}},Y4e={kernelName:nf,inputsToSave:["x"],gradFunc:(r,t,n)=>{let[s]=t,i=s.shape.slice(),{axis:a}=n;io(a,s.shape).forEach(l=>{i[l]=1});let o=Ee(r,i),u=Se(o,Ci(s.shape,"float32"));return{x:()=>u}}},Z4e={kernelName:uf,inputsToSave:["x"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>_t(r,rn(cv(n)))}}},J4e={kernelName:lf,outputsToSave:[!0],gradFunc:(r,t)=>{let[n]=t;return{x:()=>Se(vt(Pt(1),rn(n)),r)}}},Q4e={kernelName:Pc,inputsToSave:["x"],gradFunc:(r,t,n)=>{let[s]=t,{reps:i}=n;return{x:()=>{let a=Cr(s);if(s.rank===1)for(let o=0;o<i[0];++o)a=Ke(a,vr(r,[o*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let o=0;o<i[0];++o)for(let u=0;u<i[1];++u)a=Ke(a,vr(r,[o*s.shape[0],u*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let o=0;o<i[0];++o)for(let u=0;u<i[1];++u)for(let l=0;l<i[2];++l)a=Ke(a,vr(r,[o*s.shape[0],u*s.shape[1],l*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let o=0;o<i[0];++o)for(let u=0;u<i[1];++u)for(let l=0;l<i[2];++l)for(let c=0;c<i[3];++c)a=Ke(a,vr(r,[o*s.shape[0],u*s.shape[1],l*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return a}}}},e5e={kernelName:el,gradFunc:(r,t,n)=>{let s=n,{perm:i}=s,a=g3(i);return{x:()=>dr(r,a)}}},t5e={kernelName:_0,gradFunc:(r,t,n)=>{let s=n,{axis:i}=s;return{value:()=>Yn(r,i)}}},r5e={kernelName:rv,inputsToSave:["segmentIds"],gradFunc:(r,t)=>{let[n]=t;return{x:()=>n5e(r,n)}}};function n5e(r,t){let n=Iu(t,Cr(t)),s=D0(r,n),i=Sl(t,Pt(0,"int32")),a=s.rank-i.rank;for(let u=0;u<a;++u)i=bs(i,u+1);i=Za(i,Ci(s.shape,"bool"));let o=Cr(s);return Ss(i,s,o)}var s5e={kernelName:E0,gradFunc:r=>({x:()=>Cr(r)})},i5e=[$X,rBe,nBe,sBe,iBe,aBe,oBe,uBe,lBe,cBe,hBe,dBe,mBe,bBe,xBe,vBe,wBe,SBe,CBe,_Be,EBe,IBe,NBe,kBe,DBe,FBe,$Be,RBe,OBe,MBe,I4e,LBe,PBe,BBe,VBe,zBe,WBe,UBe,GBe,HBe,jBe,qBe,KBe,XBe,YBe,ZBe,JBe,QBe,e4e,n4e,j5,j5,s4e,o4e,c4e,h4e,d4e,p4e,f4e,m4e,g4e,y4e,b4e,x4e,v4e,q5,q5,w4e,S4e,E4e,k4e,N4e,T4e,A4e,D4e,F4e,$4e,R4e,O4e,M4e,L4e,P4e,B4e,V4e,z4e,U4e,W4e,G4e,K5,K5,X5,X5,H4e,q4e,j4e,K4e,X4e,Y4e,Z4e,J4e,Q4e,e5e,t5e,r5e,s5e];for(let r of i5e)wq(r);Xe().prototype.abs=function(){return this.throwIfDisposed(),jn(this)};Xe().prototype.acos=function(){return this.throwIfDisposed(),WR(this)};Xe().prototype.acosh=function(){return this.throwIfDisposed(),GR(this)};Xe().prototype.add=function(r){return this.throwIfDisposed(),Ke(this,r)};Xe().prototype.all=function(r,t){return this.throwIfDisposed(),WC(this,r,t)};Xe().prototype.any=function(r,t){return this.throwIfDisposed(),Xb(this,r,t)};Xe().prototype.argMax=function(r){return this.throwIfDisposed(),yd(this,r)};Xe().prototype.argMin=function(r){return this.throwIfDisposed(),HR(this,r)};Xe().prototype.asScalar=function(){return this.throwIfDisposed(),ue(this.size===1,()=>"The array must have only 1 element."),Ee(this,[])};Xe().prototype.asType=function(r){return this.throwIfDisposed(),at(this,r)};Xe().prototype.as1D=function(){return this.throwIfDisposed(),Ee(this,[this.size])};Xe().prototype.as2D=function(r,t){return this.throwIfDisposed(),Ee(this,[r,t])};Xe().prototype.as3D=function(r,t,n){return this.throwIfDisposed(),Ee(this,[r,t,n])};Xe().prototype.as4D=function(r,t,n,s){return this.throwIfDisposed(),Ee(this,[r,t,n,s])};Xe().prototype.as5D=function(r,t,n,s,i){return this.throwIfDisposed(),Ee(this,[r,t,n,s,i])};Xe().prototype.asin=function(){return this.throwIfDisposed(),jR(this)};Xe().prototype.asinh=function(){return this.throwIfDisposed(),qR(this)};Xe().prototype.atan=function(){return this.throwIfDisposed(),KR(this)};Xe().prototype.atan2=function(r){return this.throwIfDisposed(),XR(this,r)};Xe().prototype.atanh=function(){return this.throwIfDisposed(),YR(this)};Xe().prototype.avgPool=function(r,t,n,s){return this.throwIfDisposed(),wl(this,r,t,n,s)};Xe().prototype.batchToSpaceND=function(r,t){return this.throwIfDisposed(),lv(this,r,t)};Xe().prototype.batchNorm=function(r,t,n,s,i){return this.throwIfDisposed(),cf(this,r,t,n,s,i)};Xe().prototype.broadcastTo=function(r){return this.throwIfDisposed(),Mh(this,r)};Xe().prototype.cast=function(r){return this.throwIfDisposed(),at(this,r)};Xe().prototype.ceil=function(){return this.throwIfDisposed(),n3(this)};Xe().prototype.clipByValue=function(r,t){return this.throwIfDisposed(),Us(this,r,t)};Xe().prototype.concat=function(r,t){return this.throwIfDisposed(),r instanceof ur&&(r=[r]),an([this,...r],t)};Xe().prototype.conv1d=function(r,t,n,s,i,a){return this.throwIfDisposed(),GC(this,r,t,n,s,i,a)};Xe().prototype.conv2dTranspose=function(r,t,n,s,i){return this.throwIfDisposed(),HC(this,r,t,n,s,i)};Xe().prototype.conv2d=function(r,t,n,s,i,a){return this.throwIfDisposed(),ui(this,r,t,n,s,i,a)};Xe().prototype.cos=function(){return this.throwIfDisposed(),cv(this)};Xe().prototype.cosh=function(){return this.throwIfDisposed(),jC(this)};Xe().prototype.cumprod=function(r,t,n){return this.throwIfDisposed(),Jb(this,r,t,n)};Xe().prototype.cumsum=function(r,t,n){return this.throwIfDisposed(),qC(this,r,t,n)};Xe().prototype.depthToSpace=function(r,t){return this.throwIfDisposed(),h3(this,r,t)};Xe().prototype.depthwiseConv2d=function(r,t,n,s,i,a){return this.throwIfDisposed(),hf(this,r,t,n,s,i,a)};Xe().prototype.dilation2d=function(r,t,n,s,i){return this.throwIfDisposed(),d3(this,r,t,n,s,i)};Xe().prototype.divNoNan=function(r){return this.throwIfDisposed(),p3(this,r)};Xe().prototype.div=function(r){return this.throwIfDisposed(),_t(this,r)};Xe().prototype.dot=function(r){return this.throwIfDisposed(),f3(this,r)};Xe().prototype.elu=function(){return this.throwIfDisposed(),N0(this)};Xe().prototype.equal=function(r){return this.throwIfDisposed(),ra(this,r)};Xe().prototype.erf=function(){return this.throwIfDisposed(),KC(this)};Xe().prototype.euclideanNorm=function(r,t){return this.throwIfDisposed(),y3(this,r,t)};Xe().prototype.exp=function(){return this.throwIfDisposed(),Ws(this)};Xe().prototype.expandDims=function(r){return this.throwIfDisposed(),bs(this,r)};Xe().prototype.expm1=function(){return this.throwIfDisposed(),b3(this)};Xe().prototype.fft=function(){return this.throwIfDisposed(),vv(this)};Xe().prototype.flatten=function(){return this.throwIfDisposed(),Ee(this,[this.size])};Xe().prototype.floor=function(){return this.throwIfDisposed(),A0(this)};Xe().prototype.floorDiv=function(r){return this.throwIfDisposed(),UC(this,r)};Xe().prototype.gather=function(r,t,n){return this.throwIfDisposed(),D0(this,r,t,n)};Xe().prototype.greaterEqual=function(r){return this.throwIfDisposed(),Sl(this,r)};Xe().prototype.greater=function(r){return this.throwIfDisposed(),fi(this,r)};Xe().prototype.ifft=function(){return this.throwIfDisposed(),Ym(this)};Xe().prototype.irfft=function(){return this.throwIfDisposed(),u_(this)};Xe().prototype.isFinite=function(){return this.throwIfDisposed(),x3(this)};Xe().prototype.isInf=function(){return this.throwIfDisposed(),v3(this)};Xe().prototype.isNaN=function(){return this.throwIfDisposed(),w3(this)};Xe().prototype.leakyRelu=function(r){return this.throwIfDisposed(),dv(this,r)};Xe().prototype.lessEqual=function(r){return this.throwIfDisposed(),zc(this,r)};Xe().prototype.less=function(r){return this.throwIfDisposed(),jm(this,r)};Xe().prototype.localResponseNormalization=function(r,t,n,s){return this.throwIfDisposed(),S3(this,r,t,n,s)};Xe().prototype.logSigmoid=function(){return this.throwIfDisposed(),C3(this)};Xe().prototype.logSoftmax=function(r){return this.throwIfDisposed(),ZC(this,r)};Xe().prototype.logSumExp=function(r,t){return this.throwIfDisposed(),fv(this,r,t)};Xe().prototype.log=function(){return this.throwIfDisposed(),na(this)};Xe().prototype.log1p=function(){return this.throwIfDisposed(),pv(this)};Xe().prototype.logicalAnd=function(r){return this.throwIfDisposed(),Za(this,r)};Xe().prototype.logicalNot=function(){return this.throwIfDisposed(),mv(this)};Xe().prototype.logicalOr=function(r){return this.throwIfDisposed(),JC(this,r)};Xe().prototype.logicalXor=function(r){return this.throwIfDisposed(),_3(this,r)};Xe().prototype.matMul=function(r,t,n){return this.throwIfDisposed(),cr(this,r,t,n)};Xe().prototype.maxPool=function(r,t,n,s){return this.throwIfDisposed(),ps(this,r,t,n,s)};Xe().prototype.max=function(r,t){return this.throwIfDisposed(),ya(this,r,t)};Xe().prototype.maximum=function(r){return this.throwIfDisposed(),Iu(this,r)};Xe().prototype.mean=function(r,t){return this.throwIfDisposed(),Rn(this,r,t)};Xe().prototype.min=function(r,t){return this.throwIfDisposed(),Hm(this,r,t)};Xe().prototype.minimum=function(r){return this.throwIfDisposed(),wc(this,r)};Xe().prototype.mirrorPad=function(r,t){return this.throwIfDisposed(),I3(this,r,t)};Xe().prototype.mod=function(r){return this.throwIfDisposed(),k3(this,r)};Xe().prototype.mul=function(r){return this.throwIfDisposed(),Se(this,r)};Xe().prototype.neg=function(){return this.throwIfDisposed(),xn(this)};Xe().prototype.norm=function(r,t,n){return this.throwIfDisposed(),T0(this,r,t,n)};Xe().prototype.notEqual=function(r){return this.throwIfDisposed(),vd(this,r)};Xe().prototype.oneHot=function(r,t=1,n=0){return this.throwIfDisposed(),qm(this,r,t,n)};Xe().prototype.onesLike=function(){return this.throwIfDisposed(),sa(this)};Xe().prototype.pad=function(r,t){return this.throwIfDisposed(),zo(this,r,t)};Xe().prototype.pool=function(r,t,n,s,i,a){return this.throwIfDisposed(),N3(this,r,t,n,s,i,a)};Xe().prototype.pow=function(r){return this.throwIfDisposed(),yu(this,r)};Xe().prototype.prelu=function(r){return this.throwIfDisposed(),bv(this,r)};Xe().prototype.prod=function(r,t){return this.throwIfDisposed(),T3(this,r,t)};Xe().prototype.reciprocal=function(){return this.throwIfDisposed(),R3(this)};Xe().prototype.relu=function(){return this.throwIfDisposed(),Yr(this)};Xe().prototype.relu6=function(){return this.throwIfDisposed(),t_(this)};Xe().prototype.reshapeAs=function(r){return this.throwIfDisposed(),Ee(this,r.shape)};Xe().prototype.reshape=function(r){return this.throwIfDisposed(),Ee(this,r)};Xe().prototype.resizeBilinear=function(r,t,n){return this.throwIfDisposed(),tX(this,r,t,n)};Xe().prototype.resizeNearestNeighbor=function(r,t,n){return this.throwIfDisposed(),rX(this,r,t,n)};Xe().prototype.reverse=function(r){return this.throwIfDisposed(),Sa(this,r)};Xe().prototype.rfft=function(){return this.throwIfDisposed(),wv(this)};Xe().prototype.round=function(){return this.throwIfDisposed(),r_(this)};Xe().prototype.rsqrt=function(){return this.throwIfDisposed(),n_(this)};Xe().prototype.selu=function(){return this.throwIfDisposed(),s_(this)};Xe().prototype.separableConv2d=function(r,t,n,s,i,a){return this.throwIfDisposed(),F0(this,r,t,n,s,i,a)};Xe().prototype.sigmoid=function(){return this.throwIfDisposed(),Xa(this)};Xe().prototype.sign=function(){return this.throwIfDisposed(),O3(this)};Xe().prototype.sin=function(){return this.throwIfDisposed(),i_(this)};Xe().prototype.sinh=function(){return this.throwIfDisposed(),a_(this)};Xe().prototype.slice=function(r,t){return this.throwIfDisposed(),vr(this,r,t)};Xe().prototype.softmax=function(r){return this.throwIfDisposed(),Wc(this,r)};Xe().prototype.softplus=function(){return this.throwIfDisposed(),df(this)};Xe().prototype.spaceToBatchND=function(r,t){return this.throwIfDisposed(),yv(this,r,t)};Xe().prototype.split=function(r,t){return this.throwIfDisposed(),_i(this,r,t)};Xe().prototype.sqrt=function(){return this.throwIfDisposed(),_s(this)};Xe().prototype.square=function(){return this.throwIfDisposed(),rn(this)};Xe().prototype.squaredDifference=function(r){return this.throwIfDisposed(),l_(this,r)};Xe().prototype.squeeze=function(r){return this.throwIfDisposed(),Gc(this,r)};Xe().prototype.stack=function(r,t){this.throwIfDisposed();let n=r instanceof ur?[this,r]:[this,...r];return Yn(n,t)};Xe().prototype.step=function(r){return this.throwIfDisposed(),pf(this,r)};Xe().prototype.stridedSlice=function(r,t,n,s,i,a,o,u){return this.throwIfDisposed(),M3(this,r,t,n,s,i,a,o,u)};Xe().prototype.sub=function(r){return this.throwIfDisposed(),vt(this,r)};Xe().prototype.sum=function(r,t){return this.throwIfDisposed(),Tt(this,r,t)};Xe().prototype.tan=function(){return this.throwIfDisposed(),L3(this)};Xe().prototype.tanh=function(){return this.throwIfDisposed(),vc(this)};Xe().prototype.tile=function(r){return this.throwIfDisposed(),Zi(this,r)};Xe().prototype.toBool=function(){return this.throwIfDisposed(),at(this,"bool")};Xe().prototype.toFloat=function(){return this.throwIfDisposed(),at(this,"float32")};Xe().prototype.toInt=function(){return this.throwIfDisposed(),at(this,"int32")};Xe().prototype.topk=function(r,t){return this.throwIfDisposed(),B3(this,r,t)};Xe().prototype.transpose=function(r){return this.throwIfDisposed(),dr(this,r)};Xe().prototype.unique=function(r){return this.throwIfDisposed(),V3(this,r)};Xe().prototype.unsortedSegmentSum=function(r,t){return this.throwIfDisposed(),f_(this,r,t)};Xe().prototype.unstack=function(r){return this.throwIfDisposed(),Bn(this,r)};Xe().prototype.where=function(r,t){return this.throwIfDisposed(),Ss(r,this,t)};Xe().prototype.zerosLike=function(){return this.throwIfDisposed(),Cr(this)};var Ll=class OX extends Error{constructor(t){super(t),Object.setPrototypeOf(this,OX.prototype)}},ru=class MX extends Error{constructor(t){super(t),Object.setPrototypeOf(this,MX.prototype)}},ke=class LX extends Error{constructor(t){super(t),Object.setPrototypeOf(this,LX.prototype)}},gr=class PX extends Error{constructor(t){super(t),Object.setPrototypeOf(this,PX.prototype)}},a5e=class BX extends Error{constructor(t){super(t),Object.setPrototypeOf(this,BX.prototype)}},VX=class{constructor(r){this.maxEntries=r||100,this.cache=new Map}get(r){let t;return this.cache.has(r)&&(t=this.cache.get(r),this.cache.delete(r),this.cache.set(r,t)),t}put(r,t){if(this.cache.has(r))this.cache.delete(r);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(r,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(r){if(r<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${r}.`);if(this.maxEntries>r)for(let t=0;t<this.maxEntries-r;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=r}};function Sd(r,t){if(Array.isArray(r)){let n=[];for(let s=0;s<t;s++)n=n.concat(r);return n}else{let n=new Array(t);return n.fill(r),n}}function Jo(r,t){if(!r)throw new a5e(t)}function Y5(r,t){let n=0;for(let s of r)s===t&&n++;return n}function wi(r){return r.length===1?r[0]:r}function Kr(r){return Array.isArray(r)?r:[r]}function Lu(r){let t=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function _h(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var Ra={};function iO(r){if(r==null)return null;let t={};return t.className=r.getClassName(),t.config=r.getConfig(),t}function sN(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(t=>sN(t));else{let t=Object.keys(r);for(let n of t){let s=r[n];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?r[n]=s.value:sN(s))}}}function Cv(r,t={},n={},s="object",i=!1){if(typeof r=="string"){let a=r,o;if(a in n)o=n[a];else if(a in Ra)o=Ra[a];else if(o=t[a],o==null)throw new ke(`Unknown ${s}: ${r}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{let a=r;if(a.className==null||a.config==null)throw new ke(`${s}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);let o=a.className,u,l;if(o in n?[u,l]=n[o]:o in Ra?[u,l]=Ra.className:o in t&&([u,l]=t[o]),u==null)throw new ke(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let c={};for(let f of Object.keys(Ra))c[f]=Ra[f];for(let f of Object.keys(n))c[f]=n[f];let h=a.config;h.customObjects=c;let d=Object.assign({},Ra);for(let f of Object.keys(n))Ra[f]=n[f];sN(a.config);let p=l(u,a.config,n,i);return Ra=Object.assign({},d),p}else{let c=Object.assign({},Ra);for(let d of Object.keys(n))Ra[d]=n[d];let h=new u(a.config);return Ra=Object.assign({},c),h}}}function o5e(r,t){return r<t?-1:r>t?1:0}function D1(r,t){return-1*o5e(r,t)}function nc(r){if(r==null)return r;let t=[];for(let n of r)t.indexOf(n)===-1&&t.push(n);return t}function u5e(r){if(r==null)throw new ke(`Invalid value in obj: ${JSON.stringify(r)}`);for(let t in r)if(r.hasOwnProperty(t))return!1;return!0}function ff(r,t,n){if(n!=null&&r.indexOf(n)<0)throw new ke(`${n} is not a valid ${t}.  Valid values are ${r} or null/undefined.`)}function aO(r,t,n=0,s=1/0){return Jo(n>=0),Jo(s>=n),Array.isArray(r)&&r.length>=n&&r.length<=s&&r.every(i=>typeof i===t)}function vs(r,t){Array.isArray(r)?(O.assert(r.length>0,()=>`${t} is unexpectedly an empty array.`),r.forEach((n,s)=>vs(n,`element ${s+1} of ${t}`))):O.assert(Number.isInteger(r)&&r>0,()=>`Expected ${t} to be a positive integer, but got ${zX(r)}.`)}function zX(r){return r===null?"null":Array.isArray(r)?"["+r.map(t=>zX(t)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function l5e(r,t,n){let s=n!=null?n():O.now(),i;return(...a)=>{let o=n!=null?n():O.now();return o-s<t||(s=o,i=r(...a)),i}}function UX(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}var c5e=0;function WX(){return c5e++}var F1={};function w_(r=""){return r in F1||(F1[r]=0),F1[r]+=1,r+F1[r].toString()}var h5e=["channelsFirst","channelsLast"],d5e=["nearest","bilinear"],p5e=["valid","same","causal"],f5e=["max","avg"],m5e=["sum","mul","concat","ave"],Pf=new Map;function Gn(r){ff(h5e,"DataFormat",r)}function g5e(r){ff(d5e,"InterpolationFormat",r)}function Ea(r){ff(p5e,"PaddingMode",r)}function GX(r){ff(f5e,"PoolMode",r)}var Zy=[],Z5="/";function Lh(r,t){Zy.push(r);try{let n=t();return Zy.pop(),n}catch(n){throw Zy.pop(),n}}function y5e(){return Zy.length===0?"":Zy.join(Z5)+Z5}function HX(r){if(!qX(r))throw new Error("Not a valid tensor name: '"+r+"'");return y5e()+r}function jX(r){if(!qX(r))throw new Error("Not a valid tensor name: '"+r+"'");Pf.has(r)||Pf.set(r,0);let t=Pf.get(r);if(Pf.set(r,Pf.get(r)+1),t>0){let n=`${r}_${t}`;return Pf.set(n,1),n}else return r}var b5e=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function qX(r){return!!r.match(b5e)}function x5e(r){return r===parseInt(r.toString(),10)}function sc(r,t,n){t==null&&(t=0),n==null&&(n=r.length);let s=1;for(let i=t;i<n;++i)s*=r[i];return s}function Jm(r){if(r.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<r.length;n++){let s=r[n];s<t&&(t=s)}return t}function Cc(r){if(r.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<r.length;n++){let s=r[n];s>t&&(t=s)}return t}function Ro(r,t){if(t<r)throw new ke(`end (${t}) < begin (${r}) is forbidden.`);let n=[];for(let s=r;s<t;++s)n.push(s);return n}var aI;function ss(){return aI==null&&(aI=BR().epsilon()),aI}function Oo(){return"channelsLast"}function dl(r,t){return at(r,t)}function _v(r,t=-1){let n=r.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Ee(r,n)}function v5e(r,t){return Ie(()=>{if(r.shape.length!==2)throw new ke(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let n=_v(r,1);return iN(n,[1,t,1])})}function w5e(r){let t=[sc(r.shape)];return Ee(r,t)}function S5e(r){if(r.rank<=1)throw new ke(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let t=[r.shape[0],sc(r.shape,1)];return Ee(r,t)}function Ph(r,t,n){return Ie(()=>{switch(r.rank){case 1:return xv(r,t,n);case 2:return o_(r,[t,0],[n,r.shape[1]]);case 3:return $0(r,[t,0,0],[n,r.shape[1],r.shape[2]]);case 4:return Xm(r,[t,0,0,0],[n,r.shape[1],r.shape[2],r.shape[3]]);case 5:return vr(r,[t,0,0,0,0],[n,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return vr(r,[t,0,0,0,0,0],[n,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new ke(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function oI(r,t,n){return Ie(()=>{switch(r.rank){case 1:return xv(r,t,n);case 2:return o_(r,[0,t],[r.shape[0],n]);case 3:return $0(r,[0,0,t],[r.shape[0],r.shape[1],n]);case 4:return Xm(r,[0,0,0,t],[r.shape[0],r.shape[1],r.shape[2],n]);default:throw new ke(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function $1(r,t,n,s){return Ie(()=>{switch(r.rank){case 1:return xv(r,t,n);case 2:switch(s){case 1:return Ph(r,t,n);case 2:return oI(r,t,n);default:throw new ke(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Ph(r,t,n);case 2:return $0(r,[0,t,0],[r.shape[0],n,r.shape[2]]);case 3:return oI(r,t,n);default:throw new ke(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Ph(r,t,n);case 2:return Xm(r,[0,t,0,0],[r.shape[0],n,r.shape[2],r.shape[3]]);case 3:return Xm(r,[0,0,t,0],[r.shape[0],r.shape[1],n,r.shape[3]]);case 4:return oI(r,t,n);default:throw new ke(`The axis is not within the rank of the tensor ${s}`)}default:throw new ke(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function oO(r,t=-1){let n;return t<0&&(n=r[0].rank,n!==0?t=n:t=0),t===r[0].rank&&(t=-1),an(r,t)}function J5(r,t){switch(r.rank){case 1:return s3([r,t]);case 2:return i3([r,t],0);case 3:return a3([r,t],0);case 4:return o3([r,t],0);default:throw new ke(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function iN(r,t){if(Array.isArray(t)||(t=[t]),r.rank!==t.length)throw new ke(`The length of input n (${t.length}) does not match the number of dimensions in input x (${r.rank})`);return Zi(r,t)}function S_(r,t=0,n=1,s,i){return e_(r,t,n,s,i)}function uu(r,t,n,s){if(r.rank<2||t.rank<2)throw new gr(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${t.shape}`);if(t.rank>=3){let i=r.shape.slice(-1)[0],a=t.shape.slice(-2)[0];if(i!==a)throw new gr(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${t.shape}`)}if(r.rank===2&&t.rank===2)return Zm.matMul({a:r,b:t,transposeA:!1,transposeB:!1,bias:s?aN(r.rank,s,Oo()):null,activation:n});{let i=r.shape.slice(),a=i.pop();r=Ee(r,[-1,a]);let o=t.shape.slice(),u=o.pop(),l=o.pop(),c=[...o,u],h=Array.from({length:t.rank},(p,f)=>f===0?t.rank-2:f<=t.rank-2?f-1:f);t=Ee(dr(t,h),[l,-1]);let d=[...i,...c];return Ee(Zm.matMul({a:r,b:t,transposeA:!1,transposeB:!1,bias:s?aN(r.rank,s,Oo()):null,activation:n}),d)}}function KX(r,t,n){return Ie(()=>(Array.isArray(t)?t=qr(t,"int32"):t=at(t,"int32"),D0(r,t,n)))}function Ev(r){return Se(r,r)}function aN(r,t,n){let s=t.shape;if(t.rank!==1&&t.rank!==r)throw new ke(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${r}`);if(r===5){if(n==="channelsFirst")return s.length===1?Ee(t,[1,s[0],1,1,1]):Ee(t,[1,s[3],s[0],s[1],s[2]]);if(n==="channelsLast")return s.length===1?Ee(t,[1,1,1,1,s[0]]):Ee(t,[1].concat(s))}else if(r===4){if(n==="channelsFirst")return s.length===1?Ee(t,[1,s[0],1,1]):Ee(t,[1,s[2],s[0],s[1]]);if(n==="channelsLast")return s.length===1?Ee(t,[1,1,1,s[0]]):Ee(t,[1].concat(s))}else if(r===3){if(n==="channelsFirst")return s.length===1?Ee(t,[1,s[0],1]):Ee(t,[1,s[1],s[0]]);if(n==="channelsLast")return s.length===1?Ee(t,[1,1,s[0]]):Ee(t,[1].concat(s))}else if(r<3)return t;throw new ke(`Unsupported input rank by biasAdd: ${t.rank}`)}function Uo(r,t,n){return Ie(()=>(n==null&&(n=Oo()),Gn(n),Ke(r,aN(r.rank,t,n))))}function C5e(r,t=1){if(t!==1)throw new gr(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return N0(r)}function _5e(r){return Ie(()=>_t(r,Ke(jn(r),1)))}function XX(r,t,n,s){return Ie(()=>W3(r,t,n,s))}function E5e(r){return Ie(()=>{let t=Ke(.5,Se(.2,r));return Us(t,0,1)})}function Iv(r,t,n=!1){return n?r():t()}var I5e=["fanIn","fanOut","fanAvg"],k5e=["normal","uniform","truncatedNormal"];function N5e(r){ff(I5e,"FanMode",r)}function T5e(r){ff(k5e,"Distribution",r)}var ao=class extends et.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},uO=class extends ao{apply(r,t){return On(r,t)}};uO.className="Zeros";et.registerClass(uO);var C_=class extends ao{apply(r,t){return Ci(r,t)}};C_.className="Ones";et.registerClass(C_);var lO=class extends ao{constructor(r){if(super(),typeof r!="object")throw new ke(`Expected argument of type ConstantConfig but got ${r}`);if(r.value===void 0)throw new ke(`config must have value set but got ${r}`);this.value=r.value}apply(r,t){return Ie(()=>Se(Pt(this.value),Ci(r,t)))}getConfig(){return{value:this.value}}};lO.className="Constant";et.registerClass(lO);var cO=class extends ao{constructor(r){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=r.minval||this.DEFAULT_MINVAL,this.maxval=r.maxval||this.DEFAULT_MAXVAL,this.seed=r.seed}apply(r,t){return Uc(r,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};cO.className="RandomUniform";et.registerClass(cO);var hO=class extends ao{constructor(r){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=r.mean||this.DEFAULT_MEAN,this.stddev=r.stddev||this.DEFAULT_STDDEV,this.seed=r.seed}apply(r,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new gr(`randomNormal does not support dType ${t}.`);return S_(r,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};hO.className="RandomNormal";et.registerClass(hO);var dO=class extends ao{constructor(r){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=r.mean||this.DEFAULT_MEAN,this.stddev=r.stddev||this.DEFAULT_STDDEV,this.seed=r.seed}apply(r,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new gr(`truncatedNormal does not support dType ${t}.`);return p_(r,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};dO.className="TruncatedNormal";et.registerClass(dO);var pO=class extends ao{constructor(r){super(),this.gain=r.gain!=null?r.gain:1}apply(r,t){return Ie(()=>{if(r.length!==2||r[0]!==r[1])throw new ke("Identity matrix initializer can only be used for 2D square matrices.");return Se(this.gain,XC(r[0]))})}getConfig(){return{gain:this.gain}}};pO.className="Identity";et.registerClass(pO);function A5e(r,t="channelsLast"){let n,s;if(Gn(t),r.length===2)n=r[0],s=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(t==="channelsFirst"){let i=sc(r,2);n=r[1]*i,s=r[0]*i}else if(t==="channelsLast"){let i=sc(r,0,r.length-2);n=r[r.length-2]*i,s=r[r.length-1]*i}}else{let i=sc(r);n=Math.sqrt(i),s=Math.sqrt(i)}return[n,s]}var Ti=class extends ao{constructor(r){if(super(),r.scale<0)throw new ke(`scale must be a positive float. Got: ${r.scale}`);this.scale=r.scale==null?1:r.scale,this.mode=r.mode==null?"fanIn":r.mode,N5e(this.mode),this.distribution=r.distribution==null?"normal":r.distribution,T5e(this.distribution),this.seed=r.seed}apply(r,t){let n=A5e(r),s=n[0],i=n[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,s):this.mode==="fanOut"?a/=Math.max(1,i):a/=Math.max(1,(s+i)/2),this.distribution==="normal"){let o=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new gr(`${this.getClassName()} does not support dType ${t}.`);return p_(r,0,o,t,this.seed)}else{let o=Math.sqrt(3*a);return Uc(r,-o,o,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Ti.className="VarianceScaling";et.registerClass(Ti);var __=class extends Ti{constructor(r){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:r==null?null:r.seed})}getClassName(){return Ti.className}};__.className="GlorotUniform";et.registerClass(__);var E_=class extends Ti{constructor(r){super({scale:1,mode:"fanAvg",distribution:"normal",seed:r==null?null:r.seed})}getClassName(){return Ti.className}};E_.className="GlorotNormal";et.registerClass(E_);var I_=class extends Ti{constructor(r){super({scale:2,mode:"fanIn",distribution:"normal",seed:r==null?null:r.seed})}getClassName(){return Ti.className}};I_.className="HeNormal";et.registerClass(I_);var k_=class extends Ti{constructor(r){super({scale:2,mode:"fanIn",distribution:"uniform",seed:r==null?null:r.seed})}getClassName(){return Ti.className}};k_.className="HeUniform";et.registerClass(k_);var N_=class extends Ti{constructor(r){super({scale:1,mode:"fanIn",distribution:"normal",seed:r==null?null:r.seed})}getClassName(){return Ti.className}};N_.className="LeCunNormal";et.registerClass(N_);var T_=class extends Ti{constructor(r){super({scale:1,mode:"fanIn",distribution:"uniform",seed:r==null?null:r.seed})}getClassName(){return Ti.className}};T_.className="LeCunUniform";et.registerClass(T_);var fO=class extends ao{constructor(r){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=r.gain==null?this.DEFAULT_GAIN:r.gain,this.seed=r.seed}apply(r,t){return Ie(()=>{if(r.length<2)throw new gr("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=O.sizeFromShape(r.slice(0,-1)),s=r[r.length-1],i=n*s;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);let a=[Math.max(s,n),Math.min(s,n)],o=S_(a,0,1,t,this.seed),u=q3.qr(o,!1),l=u[0],c=u[1].flatten().stridedSlice([0],[Math.min(s,n)*Math.min(s,n)],[Math.min(s,n)+1]);return l=Se(l,c.sign()),n<s&&(l=l.transpose()),Se(Pt(this.gain),l.reshape(r))})}getConfig(){return{gain:this.gain,seed:this.seed}}};fO.className="Orthogonal";et.registerClass(fO);var Q5={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function eV(r,t={}){return Cv(r,et.SerializationMap.getMap().classNameMap,t,"initializer")}function Mn(r){return iO(r)}function kn(r){if(typeof r=="string"){let t=r in Q5?Q5[r]:r;if(t==="GlorotNormal")return new E_;if(t==="GlorotUniform")return new __;if(t==="HeNormal")return new I_;if(t==="HeUniform")return new k_;if(t==="LeCunNormal")return new N_;if(t==="LeCunUniform")return new T_;{let n={};return n.className=t,n.config={},eV(n)}}else return r instanceof ao?r:eV(r)}function oN(r){return Array.isArray(r)&&Array.isArray(r[0])}function B2(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function Xt(r){let t;if(Array.isArray(r)){if(r.length!==1)throw new ke(`Expected Tensor length to be 1; got ${r.length}`);t=r[0]}else t=r;return t}function Mr(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new ke(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function V2(r){let t=0;for(let n of r)n.shape.length===0?t+=1:t+=n.shape.reduce((s,i)=>s*i);return t}var tV="Variable",YX=class{constructor(r,t="float32",n=tV,s=!0,i=null){this.dtype=t??"float32",this.shape=r.shape,this.id=WX(),n=n??tV,this.originalName=HX(n),this.name=jX(this.originalName),this.trainable_=s,this.constraint=i,this.val=z3(r,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(r){return this.assertNotDisposed(),D5e(this.val,r),this.val.id!==r.id&&(this.val.assign(r),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(r){this.trainable_=r,this.val.trainable=r}};function D5e(r,t){if(r.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(t.shape))}function uN(r){return r.map(t=>t.read())}function mO(r){r.forEach(t=>{t[0].write(t[1])})}var Kn=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},Mo=class{constructor(r,t,n,s,i,a,o){this.dtype=r,this.shape=t,this.sourceLayer=n,this.inputs=s,this.callArgs=i,this.outputTensorIndex=o,this.id=WX(),a!=null&&(this.originalName=HX(a),this.name=jX(this.originalName)),this.rank=t.length}},F5e=0,A_=class{constructor(r,t){this.callArgs=t,this.id=F5e++,this.outboundLayer=r.outboundLayer,this.inboundLayers=r.inboundLayers,this.nodeIndices=r.nodeIndices,this.tensorIndices=r.tensorIndices,this.inputTensors=r.inputTensors,this.outputTensors=r.outputTensors,this.inputMasks=r.inputMasks,this.outputMasks=r.outputMasks,this.inputShapes=r.inputShapes,this.outputShapes=r.outputShapes;for(let n of r.inboundLayers)n!=null&&n.outboundNodes.push(this);r.outboundLayer.inboundNodes.push(this)}getConfig(){let r=[];for(let t of this.inboundLayers)t!=null?r.push(t.name):r.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:r,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},$5e=0,yr=class extends et.Serializable{constructor(r={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=$5e++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=r.name;if(!t){let n=this.getClassName();t=Lu(n)+"_"+w_(n)}if(this.name=t,this.trainable_=r.trainable==null?!0:r.trainable,r.inputShape!=null||r.batchInputShape!=null){let n;if(r.batchInputShape!=null)n=r.batchInputShape;else if(r.inputShape!=null){let i=null;r.batchSize!=null&&(i=r.batchSize),n=[i].concat(r.inputShape)}this.batchInputShape=n;let s=r.dtype;s==null&&(s=r.inputDType),s==null&&(s="float32"),this.dtype=s}r.weights!=null?this.initialWeights=r.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(r,t){return r.name+"_ib-"+t.toString()}getNodeAtIndex(r,t){if(this.inboundNodes.length===0)throw new ru(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=r)throw new ke(`Asked to get ${t} at node ${r}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[r]}getInputAt(r){return wi(this.getNodeAtIndex(r,"input").inputTensors)}getOutputAt(r){return wi(this.getNodeAtIndex(r,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ll(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ll(`Layer ${this.name} is not connected, no input to return.`);return wi(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ll(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ll(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return wi(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(r=>r())}get updates(){return this._updates}get built(){return this._built}set built(r){this._built=r}get trainable(){return this.trainable_}set trainable(r){this._trainableWeights.forEach(t=>t.trainable=r),this.trainable_=r}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(r=>r.trainable):[]}set trainableWeights(r){this._trainableWeights=r}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(r=>!r.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(r){this._nonTrainableWeights=r}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(r){let t=Kr(r);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=Kr(this.inputSpec);if(t.length!==n.length)throw new ke(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${r}`);for(let s=0;s<t.length;s++){let i=t[s],a=n[s];if(a==null)continue;let o=i.rank;if(a.ndim!=null&&o!==a.ndim)throw new ke(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${o}`);if(a.maxNDim!=null&&o>a.maxNDim)throw new ke(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${o}`);if(a.minNDim!=null&&o<a.minNDim)throw new ke(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${o}.`);if(a.dtype!=null&&i.dtype!==a.dtype)throw new ke(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${i.dtype}.`);if(a.axes){let u=i.shape;for(let l in a.axes){let c=Number(l),h=a.axes[l],d=c>=0?u[c]:u[u.length+c];if(h!=null&&[h,null].indexOf(d)===-1)throw new ke(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${u}.`)}}if(a.shape!=null)for(let u=0;u<a.shape.length;++u){let l=a.shape[u],c=i.shape[u];if(l!=null&&c!=null&&l!==c)throw new ke(`Input ${s} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${i.shape}.`)}}}call(r,t){return r}invokeCallHook(r,t){this._callHook!=null&&this._callHook(r,t)}setCallHook(r){this._callHook=r}clearCallHook(){this._callHook=null}apply(r,t){t=t||{},this.assertNotDisposed();let n=Kr(r),s=M5e(r),i=L5e(r);if(s===i)throw new ke("Arguments to apply() must be all SymbolicTensors or all Tensors");return Lh(this.name,()=>{if(!this.built){this.assertInputCompatibility(r);let a=[];for(let o of Kr(r))a.push(o.shape);this.build(wi(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(r),i){let a=this.call(r,t);this.supportsMasking&&this.setMaskMetadata(r,a);let o=Kr(a),u=[];for(let l of o)n.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(a=wi(u),this.activityRegularizer!=null)throw new gr("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=R5e(r),o=this.computeOutputShape(a),u,l=O5e(r);if(this.warnOnIncompatibleInputShape(Array.isArray(r)?a[0]:a),o!=null&&o.length>0&&Array.isArray(o[0])?u=o.map((c,h)=>new Mo(l,c,this,Kr(r),t,this.name,h)):u=new Mo(l,o,this,Kr(r),t,this.name),this.addInboundNode(r,u,null,null,a,o,t),this._refCount++,this.activityRegularizer!=null)throw new gr("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(r){if(this.batchInputShape!=null)if(r.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(r)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,s)=>{n!=null&&r[s]!=null&&r[s]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(r)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ll(`The layer ${this.name} has never been called and thus has no defined output shape.`);let r=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);r.indexOf(n)===-1&&r.push(n)}if(r.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Ll(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ru(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return V2(this.weights)}build(r){this.built=!0}getWeights(r=!1){return uN(r?this.trainableWeights:this.weights)}setWeights(r){Ie(()=>{let t=this.weights;if(t.length!==r.length)throw new ke(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${r.length}, but the layer was expecting ${t.length} weights. Provided weights: ${r}...`);if(t.length===0)return;let n=[],s=uN(t);for(let i=0;i<s.length;++i){let a=s[i],o=t[i],u=r[i];if(!O.arraysEqual(a.shape,u.shape))throw new ke(`Layer weight shape ${a.shape} not compatible with provided weight shape ${u.shape}`);n.push([o,u])}mO(n)})}addWeight(r,t,n,s,i,a,o,u){if(this._addedWeightNames.indexOf(r)!==-1)throw new ke(`Duplicate weight name ${r} for layer ${this.name}`);this._addedWeightNames.push(r),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(s=u!=null?u():kn("zeros"));let l=s.apply(t,n),c=new YX(l,n,r,a,o);return l.dispose(),i!=null&&this.addLoss(()=>i.apply(c.read())),a==null&&(a=!0),a?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(r){this.fastWeightInitDuringBuild=r}addLoss(r){r==null||Array.isArray(r)&&r.length===0||(r=Kr(r),this._losses!==void 0&&this._losses!==null&&this.losses.push(...r))}computeOutputShape(r){return r}computeMask(r,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(r,t,n){if(!this.supportsMasking)return;let s=this.computeMask(r,n),i=Kr(t),a=Kr(s);if(i.length!==a.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let o=0;o<i.length;o++)i[o].kerasMask=a[o]}addInboundNode(r,t,n,s,i,a,o=null){let u=Kr(r);t=Kr(t),n=Kr(n),s=Kr(s),i=B2(i),a=B2(a);let l=[],c=[],h=[];for(let d of u)l.push(d.sourceLayer),c.push(d.nodeIndex),h.push(d.tensorIndex);new A_({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:h,inputTensors:u,outputTensors:t,inputMasks:n,outputMasks:s,inputShapes:i,outputShapes:a},o);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let r={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(r.batchInputShape=this.batchInputShape),this.dtype!=null&&(r.dtype=this.dtype),r}disposeWeights(){return this.weights.forEach(r=>r.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let r=0;return--this._refCount===0&&(r=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:r}}};function R5e(r){r=Kr(r);let t=[];for(let n of r)t.push(n.shape);return wi(t)}function O5e(r){return"float32"}function ZX(r,t,n){if((t==null||n!=null&&n>0)&&(t=r.sourceLayer,n=r.nodeIndex),t.inboundNodes.length===0)return[r];{let s=t.inboundNodes[n];if(s.inboundLayers.length===0)return s.inputTensors;{let i=[];for(let a=0;a<s.inboundLayers.length;a++){let o=s.inputTensors[a],u=s.inboundLayers[a],l=s.nodeIndices[a],c=ZX(o,u,l);for(let h of c)i.indexOf(h)===-1&&i.push(h)}return i}}}function M5e(r){let t=!0;for(let n of Kr(r))if(!(n instanceof Mo)){t=!1;break}return t}function L5e(r){let t=!0;for(let n of Kr(r))if(n instanceof Mo){t=!1;break}return t}var O0=class extends yr{constructor(r){if(super({dtype:r.dtype,name:r.name!=null?r.name:w_("input").toString()}),r.batchSize==null&&(r.batchSize=null),r.sparse==null&&(r.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=r.sparse,r.inputShape!=null&&r.batchInputShape!=null)throw new ke("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=r.batchInputShape;if(t==null){if(r.inputShape==null)throw new ke("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[r.batchSize].concat(r.inputShape)}else if(r.batchSize!=null)throw new ke("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=r.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let s=new Mo(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new A_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(r,t){throw new ke(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};O0.className="InputLayer";et.registerClass(O0);function JX(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new ke("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=r.batchShape;r.shape!=null&&t==null&&(t=[null].concat(r.shape));let n=r.dtype;return n==null&&(n="float32"),new O0({batchInputShape:t,name:r.name,dtype:n,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}function P5e(r,t){if(r.dtype==null||r.dtype===t.dtype)return t;try{return at(t,r.dtype)}catch{throw new ke(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var Qf=class QX{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof QX)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,s){if(this.id2Value[t.id]==null)this.id2Value[t.id]=P5e(t,n),this.name2Id[t.name]=t.id,s!=null&&(this.id2Mask[t.id]=s);else throw new ke(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Mo){if(this.id2Value[t.id]==null)throw new ke(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new ke(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof Mo){if(this.id2Value[t.id]==null)throw new ke(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new ke(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&nr(this.id2Mask)}},z2=new VX,U2=new VX;function B5e(r){z2!=null&&z2.setMaxEntries(r),U2!=null&&U2.setMaxEntries(r)}function Fy(r,t,n,s){let i=n==null?!1:n.training,a=Array.isArray(r),o=a?r:[r],u=o.map(m=>m.name),l=[],c=t.names();for(let m of u)c.indexOf(m)!==-1?l.push(t.getValue(m)):l.push(null);let h=u.join(",")+"|"+t.names().sort().join(","),d=z2.get(h),p;if(d==null){let m=V5e(o,t);d=m.sorted,p=m.recipientCounts,z2.put(h,d),U2.put(h,p)}p={},i||Object.assign(p,U2.get(h));let f=new Qf(t);for(let m=0;m<d.length;++m){let g=d[m],y=g.sourceLayer;if(y instanceof O0)continue;let b=[],x=[],w=[],v=!1;for(let _ of g.inputs){let A=f.getValue(_),k=f.getMask(_);b.push(A),x.push(k),k!=null&&(v=!0),i||(p[_.name]--,p[_.name]===0&&!t.hasKey(_)&&u.indexOf(_.name)===-1&&!A.isDisposed&&_.sourceLayer.stateful!==!0&&w.push(A))}v&&(n=n||{},n.mask=x[0]);let S=Kr(y.apply(b,n)),E=null;y.supportsMasking&&(E=y.computeMask(b,x));let C=U5e(g),I=Array.isArray(C)?C:[C];for(let _=0;_<I.length;++_){f.hasKey(I[_])||f.add(I[_],S[_],Array.isArray(E)?E[0]:E);let A=u.indexOf(I[_].name);A!==-1&&(l[A]=S[_])}i||nr(w)}return f.disposeMasks(),a?l:l[0]}function V5e(r,t){O.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(r.length===1){let i=rV(r[0],t);n=i.sorted,s=i.recipientMap}else{let i=new Set;for(let a of r){let{sorted:o,recipientMap:u}=rV(a,t);for(let l of o)i.has(l.name)||(n.push(l),i.add(l.name));for(let l in u)s[l]==null&&(s[l]=new Set),u[l].forEach(c=>s[l].add(c))}}return{sorted:n,recipientCounts:z5e(s)}}function z5e(r){let t={};for(let n in r)t[n]=r[n].size;return t}function rV(r,t){let n=new Set,s=[],i={};for(let u of t.names())n.add(u);let a=[],o=[];for(a.push(r);a.length>0;){let u=a[a.length-1];if(n.has(u.name)){a.pop();continue}let l=o[o.length-1]===a.length-1;if(u.inputs.length===0||l)a.pop(),s.push(u),n.add(u.name),l&&o.pop();else{o.push(a.length-1);for(let c of u.inputs)i[c.name]==null&&(i[c.name]=new Set),i[c.name].add(u.name),!n.has(c.name)&&a.push(c)}}return{sorted:s,recipientMap:i}}function U5e(r){let t;if(r.sourceLayer.inboundNodes.length===1)t=r.sourceLayer.output;else{let n=null;for(let s=0;s<r.sourceLayer.inboundNodes.length;++s)for(let i of r.sourceLayer.inboundNodes[s].outputTensors)if(i.id===r.id){n=s;break}t=r.sourceLayer.getOutputAt(n)}return t}var W5e=Re();W5e.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,B5e);var eY={};ir(eY,{maxNorm:()=>G5e,minMaxNorm:()=>q5e,nonNeg:()=>j5e,unitNorm:()=>H5e});function gO(r,t){return Ie(()=>_s(Tt(Se(r,r),t,!0)))}var kv=class extends et.Serializable{getConfig(){return{}}},yO=class extends kv{constructor(r){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=r.maxValue!=null?r.maxValue:this.defaultMaxValue,this.axis=r.axis!=null?r.axis:this.defaultAxis}apply(r){return Ie(()=>{let t=gO(r,this.axis),n=Us(t,0,this.maxValue);return Se(r,_t(n,Ke(ss(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};yO.className="MaxNorm";et.registerClass(yO);var bO=class extends kv{constructor(r){super(),this.defaultAxis=0,this.axis=r.axis!=null?r.axis:this.defaultAxis}apply(r){return Ie(()=>_t(r,Ke(ss(),gO(r,this.axis))))}getConfig(){return{axis:this.axis}}};bO.className="UnitNorm";et.registerClass(bO);var xO=class extends kv{apply(r){return Yr(r)}};xO.className="NonNeg";et.registerClass(xO);var vO=class extends kv{constructor(r){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=r.minValue!=null?r.minValue:this.defaultMinValue,this.maxValue=r.maxValue!=null?r.maxValue:this.defaultMaxValue,this.rate=r.rate!=null?r.rate:this.defaultRate,this.axis=r.axis!=null?r.axis:this.defaultAxis}apply(r){return Ie(()=>{let t=gO(r,this.axis),n=Ke(Se(this.rate,Us(t,this.minValue,this.maxValue)),Se(1-this.rate,t));return Se(r,_t(n,Ke(ss(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};vO.className="MinMaxNorm";et.registerClass(vO);var nV={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function as(r){return iO(r)}function sV(r,t={}){return Cv(r,et.SerializationMap.getMap().classNameMap,t,"constraint")}function os(r){if(r==null)return null;if(typeof r=="string"){let t={className:r in nV?nV[r]:r,config:{}};return sV(t)}else return r instanceof kv?r:sV(r)}function G5e(r){return new yO(r)}function H5e(r){return new bO(r)}function j5e(){return new xO}function q5e(r){return new vO(r)}var tY={};ir(tY,{constant:()=>Y5e,glorotNormal:()=>nVe,glorotUniform:()=>rVe,heNormal:()=>sVe,heUniform:()=>iVe,identity:()=>eVe,leCunNormal:()=>aVe,leCunUniform:()=>oVe,ones:()=>X5e,orthogonal:()=>uVe,randomNormal:()=>J5e,randomUniform:()=>Z5e,truncatedNormal:()=>Q5e,varianceScaling:()=>tVe,zeros:()=>K5e});function K5e(){return new uO}function X5e(){return new C_}function Y5e(r){return new lO(r)}function Z5e(r){return new cO(r)}function J5e(r){return new hO(r)}function Q5e(r){return new dO(r)}function eVe(r){return new pO(r)}function tVe(r){return new Ti(r)}function rVe(r){return new __(r)}function nVe(r){return new E_(r)}function sVe(r){return new I_(r)}function iVe(r){return new k_(r)}function aVe(r){return new N_(r)}function oVe(r){return new T_(r)}function uVe(r){return new fO(r)}var rY={};ir(rY,{Layer:()=>yr,RNN:()=>El,RNNCell:()=>Tv,activation:()=>Bze,add:()=>Kze,alphaDropout:()=>DUe,average:()=>Xze,averagePooling1d:()=>FM,averagePooling2d:()=>$M,averagePooling3d:()=>RM,avgPool1d:()=>sUe,avgPool2d:()=>aUe,avgPool3d:()=>uUe,avgPooling1d:()=>iUe,avgPooling2d:()=>oUe,avgPooling3d:()=>lUe,batchNormalization:()=>tUe,bidirectional:()=>CUe,categoryEncoding:()=>MUe,centerCrop:()=>RUe,concatenate:()=>Yze,conv1d:()=>Aze,conv2d:()=>Dze,conv2dTranspose:()=>Fze,conv3d:()=>$ze,conv3dTranspose:()=>Rze,convLstm2d:()=>xUe,convLstm2dCell:()=>vUe,cropping2D:()=>Mze,dense:()=>Vze,depthwiseConv2d:()=>Pze,dot:()=>eUe,dropout:()=>zze,elu:()=>_ze,embedding:()=>qze,flatten:()=>Wze,gaussianDropout:()=>AUe,gaussianNoise:()=>TUe,globalAveragePooling1d:()=>cUe,globalAveragePooling2d:()=>hUe,globalMaxPool1d:()=>EUe,globalMaxPool2d:()=>IUe,globalMaxPooling1d:()=>sZ,globalMaxPooling2d:()=>iZ,gru:()=>pUe,gruCell:()=>fUe,input:()=>vY,inputLayer:()=>Cze,layerNormalization:()=>rUe,leakyReLU:()=>Ize,lstm:()=>mUe,lstmCell:()=>gUe,masking:()=>FUe,maxPool1d:()=>kUe,maxPool2d:()=>NUe,maxPooling1d:()=>aZ,maxPooling2d:()=>oZ,maxPooling3d:()=>dUe,maximum:()=>Zze,minimum:()=>Jze,multiply:()=>Qze,permute:()=>jze,prelu:()=>kze,randomWidth:()=>LUe,reLU:()=>Eze,repeatVector:()=>Gze,rescaling:()=>$Ue,reshape:()=>Hze,resizing:()=>OUe,rnn:()=>wUe,separableConv2d:()=>Oze,simpleRNN:()=>yUe,simpleRNNCell:()=>bUe,softmax:()=>Nze,spatialDropout1d:()=>Uze,stackedRNNCells:()=>SUe,thresholdedReLU:()=>Tze,timeDistributed:()=>_Ue,upSampling2d:()=>Lze,zeroPadding2d:()=>nUe});async function $l(r){if(r==null)return;let t=[],n=[],s=[];for(let i in r){let a=r[i];if(typeof a!="number"){let o=a;t.push(o.data()),n.push(i),s.push(o)}}if(t.length>0){let i=await Promise.all(t);for(let a=0;a<i.length;++a)r[n[a]]=i[a][0];nr(s)}}function nY(r){if(r!=null)for(let t in r){let n=r[t];typeof n!="number"&&n.dispose()}}var iV;(function(r){r[r.SILENT=0]="SILENT",r[r.VERBOSE=1]="VERBOSE"})(iV||(iV={}));var lVe=125,Qm=class{constructor(){this.validationData=null}setParams(r){this.params=r}async onEpochBegin(r,t){}async onEpochEnd(r,t){}async onBatchBegin(r,t){}async onBatchEnd(r,t){}async onTrainBegin(r){}async onTrainEnd(r){}setModel(r){}},sY=class{constructor(r,t=10){r==null&&(r=[]),this.callbacks=r,this.queueLength=t}append(r){this.callbacks.push(r)}setParams(r){for(let t of this.callbacks)t.setParams(r)}setModel(r){for(let t of this.callbacks)t.setModel(r)}async onEpochBegin(r,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(r,t)}async onEpochEnd(r,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(r,t)}async onBatchBegin(r,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(r,t)}async onBatchEnd(r,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(r,t)}async onTrainBegin(r){r==null&&(r={});for(let t of this.callbacks)await t.onTrainBegin(r)}async onTrainEnd(r){r==null&&(r={});for(let t of this.callbacks)await t.onTrainEnd(r)}},cVe=class extends Qm{constructor(){super()}async onEpochBegin(r){this.seen=0,this.totals={}}async onBatchEnd(r,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let s in t){let i=t[s];if(typeof i=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+i*n;else{let a;s in this.totals?a=this.totals[s]:this.totals[s]=0;let o=Ie(()=>Ke(this.totals[s],Se(i,n)));this.totals[s]=o,a!=null&&a.dispose()}}}async onEpochEnd(r,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:Ie(()=>{let s=Se(_t(1,this.seen),this.totals[n]);t[n]=s,this.totals[n].dispose(),ns(t[n])}))}},iY=class extends Qm{async onTrainBegin(r){this.epoch=[],this.history={}}async onEpochEnd(r,t){t==null&&(t={}),this.epoch.push(r);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let r=[],t=[],n=[];for(let i in this.history){let a=this.history[i];for(let o=0;o<a.length;++o)if(typeof a[o]!="number"){let u=a[o];r.push(u.data()),t.push(i),n.push(o)}}let s=await Promise.all(r);for(let i=0;i<s.length;++i)this.history[t[i]][n[i]].dispose(),this.history[t[i]][n[i]]=s[i][0]}},aY=class extends Qm{constructor(r,t){if(super(),this.currentEpoch=0,this.nowFunc=r.nowFunc,this.nextFrameFunc=r.nextFrameFunc||nO,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=lVe),this.yieldEvery==="never"&&r.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");O.isNumber(this.yieldEvery)&&(this.maybeWait=l5e(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=r.onTrainBegin,this.trainEnd=r.onTrainEnd,this.epochBegin=r.onEpochBegin,this.epochEnd=r.onEpochEnd,this.batchBegin=r.onBatchBegin,this.batchEnd=r.onBatchEnd,this.yield=r.onYield}async maybeWait(r,t,n){let s=[];this.yield!=null&&(await $l(n),s.push(this.yield(r,t,n))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(r,t){this.currentEpoch=r,this.epochBegin!=null&&(await $l(t),await this.epochBegin(r,t))}async onEpochEnd(r,t){let n=[];this.epochEnd!=null&&(await $l(t),n.push(this.epochEnd(r,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(r,t){this.batchBegin!=null&&(await $l(t),await this.batchBegin(r,t))}async onBatchEnd(r,t){let n=[];this.batchEnd!=null&&(await $l(t),n.push(this.batchEnd(r,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):O.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,r,t)),await Promise.all(n)}async onTrainBegin(r){this.trainBegin!=null&&(await $l(r),await this.trainBegin(r))}async onTrainEnd(r){this.trainEnd!=null&&(await $l(r),await this.trainEnd(r))}};function oY(r,t){return r==null&&(r={}),r instanceof Qm?[r]:Array.isArray(r)&&r[0]instanceof Qm?r:Kr(r).map(n=>new aY(n,t))}var wO=class qo{constructor(){}static registerCallbackConstructor(t,n){O.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),qo.checkForDuplicate(n),qo.constructors[t]==null&&(qo.constructors[t]=[]),qo.constructors[t].push(n)}static checkForDuplicate(t){for(let n in qo.constructors)qo.constructors[+n].forEach(s=>{if(s===t)throw new ke("Duplicate callback constructor.")})}static clear(){qo.constructors={}}static createCallbacks(t){let n=[];for(let s in qo.constructors){let i=+s;t>=i&&n.push(...qo.constructors[i])}return n.map(s=>new s)}};wO.constructors={};function uY(r,t,n,s,i,a,o,u,l){let c=new iY,h=[new cVe,...wO.createCallbacks(t)];r!=null&&h.push(...r),h.push(c);let d=new sY(h);return d.setParams({epochs:n,initialEpoch:s,samples:i,steps:a,batchSize:o,verbose:t,doValidation:u,metrics:l}),{callbackList:d,history:c}}function To(r,t={},n=!1){return Cv(r,et.SerializationMap.getMap().classNameMap,t,"layer",n)}function W2(r,t){return Ie(()=>{r.dtype!=="float32"&&(r=at(r,"float32"));let n=Tt(Ev(r),t,!0),s=Qi(n.shape,ss()),i=_s(Iu(n,s));return _t(r,i)})}function mf(r,t){return Ie(()=>Rn(Ev(vt(t,r)),-1))}function D_(r,t){return Ie(()=>Rn(jn(vt(t,r)),-1))}function M0(r,t){return Ie(()=>{let n=vt(r,t),s=Us(jn(r),ss(),Number.MAX_VALUE),i=jn(_t(n,s));return Se(100,Rn(i,-1))})}function hVe(r,t){return Ie(()=>{let n=Us(t,ss(),Number.MAX_VALUE),s=na(Ke(1,n)),i=Us(r,ss(),Number.MAX_VALUE),a=na(Ke(1,i));return Rn(Ev(vt(s,a)),-1)})}function dVe(r,t){return Ie(()=>{let n=Iu(0,vt(1,Se(r,t)));return Rn(Ev(n),-1)})}function pVe(r,t){return Ie(()=>{let n=Iu(0,vt(1,Se(r,t)));return Rn(n,-1)})}function fVe(r,t){return Ie(()=>{let n=Tt(Se(r,t),-1),s=ya(Se(vt(1,r),t),-1);return Iu(0,Ke(1,vt(s,n)))})}function mVe(r,t){return Ie(()=>{let n=Math.log(2),s=vt(t,r),i=vt(Ke(s,df(Se(-2,s))),n);return Rn(i,-1)})}function Qb(r,t,n=!1){return Ie(()=>{if(n)t=Wc(t);else{let s=Tt(t,t.shape.length-1,!0);t=_t(t,s)}return t=Us(t,ss(),1-ss()),xn(Tt(Se(at(r,"float32"),na(t)),t.shape.length-1))})}function G2(r,t,n=!1){return Ie(()=>{let s=at(A0(w5e(r)),"int32");t=Us(t,ss(),1-ss());let i=t.shape,a=Ee(qm(s,i[i.length-1]),i);return Qb(a,t,n)})}function gVe(r,t){if(!O.arraysEqual(r.shape,t.shape))throw new ke(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(t.shape)}`);return Ie(()=>{let n=Yr(t),s=xn(jn(t));return Ke(vt(n,Se(t,r)),pv(Ws(s)))})}function F_(r,t){return Ie(()=>{let n;return n=Us(t,ss(),1-ss()),n=na(_t(n,vt(1,n))),Rn(gVe(r,n),-1)})}function yVe(r,t){return Ie(()=>{let n=Us(r,ss(),1),s=Us(t,ss(),1);return Tt(Se(r,na(_t(n,s))),-1)})}function bVe(r,t){return Ie(()=>{let n=na(Ke(ss(),t));return Rn(vt(t,Se(r,n)),-1)})}function SO(r,t){return Ie(()=>{let n=W2(r,-1),s=W2(t,-1),i=Se(n,s);return xn(Tt(i,-1))})}var H2={meanSquaredError:mf,meanAbsoluteError:D_,meanAbsolutePercentageError:M0,meanSquaredLogarithmicError:hVe,squaredHinge:dVe,hinge:pVe,categoricalHinge:fVe,logcosh:mVe,categoricalCrossentropy:Qb,sparseCategoricalCrossentropy:G2,binaryCrossentropy:F_,kullbackLeiblerDivergence:yVe,poisson:bVe,cosineProximity:SO};function uI(r){if(typeof r=="string"){if(r in H2)return H2[r];let t=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ke(t)}else return r}function CO(r,t){return Ie(()=>{let n=Se(.5,sa(t)),s=dl(fi(t,n),r.dtype);return Rn(ra(r,s),-1)})}function _O(r,t){return Ie(()=>dl(ra(yd(r,-1),yd(t,-1)),"float32"))}function lY(r,t){return Ie(()=>at(Tt(Za(ra(r,1),ra(t,1))),"float32"))}function xVe(r,t){return Ie(()=>at(Tt(Za(ra(r,1),ra(t,0))),"float32"))}function vVe(r,t){return Ie(()=>at(Tt(Za(ra(r,0),ra(t,1))),"float32"))}function cY(r,t){return Ie(()=>{let n=lY(r,t),s=vVe(r,t),i=Ke(n,s);return at(Ss(fi(i,0),_t(n,i),0),"float32")})}function wVe(r,t){return Ie(()=>{let n=lY(r,t),s=xVe(r,t),i=Ke(n,s);return at(Ss(fi(i,0),_t(n,i),0),"float32")})}function hY(r,t){return F_(r,t)}function dY(r,t){return r.rank===t.rank&&(r=Gc(r,[r.rank-1])),t=yd(t,-1),t.dtype!==r.dtype&&(t=at(t,r.dtype)),at(ra(r,t),"float32")}function SVe(r,t){return Ie(()=>{let n=r.sub(t).square().sum(),s=r.sub(r.mean()).square().sum();return Pt(1).sub(n.div(s))})}var CVe=mf,_Ve=mf,EVe=D_,IVe=D_,kVe=M0,NVe=M0,EO=Qb,TVe=SO,pY=G2,j2={binaryAccuracy:CO,categoricalAccuracy:_O,precision:cY,categoricalCrossentropy:EO,sparseCategoricalCrossentropy:pY,mse:CVe,MSE:_Ve,mae:EVe,MAE:IVe,mape:kVe,MAPE:NVe,cosine:TVe};function AVe(r){if(typeof r=="string"&&r in j2)return j2[r];if(typeof r!="string"&&r!=null)return r;throw new ke(`Unknown metric ${r}`)}function R1(r){if(Jo(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let t;for(let n of Object.keys(H2))if(H2[n]===r){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(j2))if(j2[n]===r){t=n;break}return t!==void 0?t:r.name}}function DVe(r){let t={Adagrad:()=>fh.adagrad(.01),Adadelta:()=>fh.adadelta(1,.95,ss()),Adam:()=>fh.adam(.001,.9,.999,ss()),Adamax:()=>fh.adamax(.002,.9,.999,ss(),0),RMSProp:()=>fh.rmsprop(.001,.9,0,ss()),SGD:()=>fh.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,r in t)return t[r]();throw new ke(`Unknown Optimizer ${r}`)}function aV(r,t,n=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!lN(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let s=JSON.stringify(r);s.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function lN(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let t=Object.keys(r);for(let n of t)if(typeof n!="string"||!lN(r[n]))return!1;return!0}else if(Array.isArray(r)){for(let t of r)if(!lN(t))return!1;return!0}else return!1;else{let t=typeof r;return t==="string"||t==="number"||t==="boolean"}}function FVe(r,t,n,s=console.log){let i=RVe(r),a=["Layer (type)","Input Shape","Output shape","Param #"];i?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(h=>Math.floor(t*h)));let o;if(!i){a.push("Receives inputs"),o=[];for(let h in r.nodesByDepth)o.push(...r.nodesByDepth[h])}s("_".repeat(t)),q2(a,n,s),s("=".repeat(t));let u=r.layers;for(let h=0;h<u.length;++h)i?OVe(u[h],n,s):MVe(u[h],n,o,s),s((h===u.length-1?"=":"_").repeat(t));r.checkTrainableWeightsConsistency();let l=$Ve(r),c=V2(r.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(t))}function $Ve(r){let t;return r.collectedTrainableWeights!=null?t=V2(r.collectedTrainableWeights):t=V2(r.trainableWeights),t}function RVe(r){let t=!0,n=[],s=[];for(let i in r.nodesByDepth)n.push(r.nodesByDepth[i]);for(let i of n){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){t=!1;break}s.push(...i)}if(t)for(let i of r.layers){let a=!1;for(let o of i.inboundNodes)if(s.indexOf(o)!==-1)if(a){t=!1;break}else a=!0;if(!t)break}return t}function q2(r,t,n=console.log){let s="";for(let i=0;i<r.length;++i)i>0&&(s=s.slice(0,s.length-1)+" "),s+=r[i],s=s.slice(0,t[i]),s+=" ".repeat(t[i]-s.length);n(s)}function OVe(r,t,n){let s,i;try{i=r.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(r.outputShape)}catch{s="multiple"}let a=r.name,o=r.getClassName(),u=[`${a} (${o})`,i,s,r.countParams().toString()];q2(u,t,n)}function MVe(r,t,n,s){let i,a;try{a=r.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{a="multiple"}try{i=JSON.stringify(r.outputShape)}catch{i="multiple"}let o=[];for(let d of r.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let p=0;p<d.inboundLayers.length;++p){let f=d.inboundLayers[p].name,m=d.nodeIndices[p],g=d.tensorIndices[p];o.push(`${f}[${m}][${g}]`)}let u=r.name,l=r.getClassName(),c=o.length===0?"":o[0],h=[`${u} (${l})`,a,i,r.countParams().toString(),c];q2(h,t,s);for(let d=1;d<o.length;++d)q2(["","","","",o[d]],t,s)}function fY(r,t,n){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&t===0&&typeof n=="string"}function ex(r,t){if(r===null)return null;if(typeof r=="string")return _h(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let n=[],s=r.length;for(let i=0;i<s;++i){let a=r[i];fY(t,i,a)?n.push(a):n.push(ex(a,t))}return n}else{let n={};for(let s of Object.keys(r)){let i=r[s];if(s==="name"&&typeof i=="string")n[s]=i;else{let a=_h(s);n[a]=ex(i,a)}}return n}}function cN(r,t){if(r==null)return null;if(typeof r=="string")return Lu(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let n=[],s=r.length;for(let i=0;i<s;++i){let a=r[i];fY(t,i,a)?n.push(a):n.push(cN(a,t))}return n}else{let n={};for(let s of Object.keys(r)){let i=r[s],a=Lu(s);(s==="name"||s==="className")&&typeof i=="string"?n[a]=i:n[a]=cN(i,s)}return n}}var IO="4.22.0",LVe=r=>{let t=Object.keys(r);if(t.length===0)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},PVe=class Ko extends yr{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let x=this.getClassName().toLowerCase();this.name=w_(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],nc(this.inputs).length!==this.inputs.length)throw new ke(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);nc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let x of this.outputs){let w=x.sourceLayer,v=x.nodeIndex,S=x.tensorIndex;this.outputLayers.push(w),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(S)}for(let x of this.inputs){let w=x.sourceLayer,v=x.nodeIndex,S=x.tensorIndex;Jo(v===0,"input layer has >1 nodes"),Jo(S===0,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(S)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){let w=this.inputLayers[x];if(!(w instanceof O0))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${x} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(let x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);let n={},s={},i={},a={},o={},u=[],l=(x,w,v,S,E,C)=>{(S==null||E==null||C==null)&&(S=x.sourceLayer,E=x.nodeIndex,C=x.tensorIndex);let I=S.inboundNodes[E];if(v.indexOf(I)!==-1)throw new ru(`The tensor ${x.name} at layer "${S.name}" is part of a cycle.`);if(w.indexOf(I)!==-1)return;this.containerNodes.add(Ko.nodeKey(S,E)),S.id in o||(o[S.id]=Object.keys(o).length),v.indexOf(I)===-1&&v.push(I);let _=I.inboundLayers.length;for(let A=0;A<_;A++){let k=I.inputTensors[A],N=I.inboundLayers[A],D=I.nodeIndices[A],F=I.tensorIndices[A];l(k,w,v,N,D,F)}for(w.push(I);v.indexOf(I)>=0;)v.splice(v.indexOf(I),1);u.push(I)},c=[],h=[];for(let x of this.outputs)l(x,c,h);let d=u.slice().reverse();for(let x of d){s[x.id]=x,x.id in n||(n[x.id]=0);let w=n[x.id],v=i[x.outboundLayer.id]==null?0:i[x.outboundLayer.id];w=Math.max(w,v),i[x.outboundLayer.id]=w,a[x.outboundLayer.id]=x.outboundLayer,n[x.id]=w;for(let S=0;S<x.inboundLayers.length;S++){let E=x.inboundLayers[S],C=x.nodeIndices[S],I=E.inboundNodes[C],_=n[I.id]==null?0:n[I.id];n[I.id]=Math.max(w+1,_),s[I.id]=I}}let p={};for(let x in n){let w=n[x];w in p||(p[w]=[]),p[w].push(s[x])}let f={};for(let x in i){let w=i[x];w in f||(f[w]=[]),f[w].push(a[x])}let m=Object.keys(f).map(x=>parseInt(x,10)).sort(D1);this.layers=[];for(let x of m){let w=f[x];w.sort((v,S)=>{let E=o[v.id],C=o[S.id];return E<C?-1:E>C?1:0});for(let v of w)v instanceof Ko&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=f,m=Object.keys(p).map(x=>parseInt(x,10)).sort(D1);let g=this.inputs.slice(),y=[];for(let x of m)for(let w of p[x]){let v=w.outboundLayer;if(v!=null){for(let S of w.inputTensors)if(g.indexOf(S)===-1)throw new ru(`Graph disconnected: cannot obtain value for tensor ${S} at layer "${v.name}". The following previous layers were accessed without issue: ${y}`);for(let S of w.outputTensors)g.push(S);y.push(v.name)}}this.nodesByDepth=p;let b=this.layers.map(x=>x.name);for(let x of b){let w=b.filter(v=>v===x).length;if(w!==1)throw new ru(`The name "${x}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new A_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new ke("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let s of this.layers)n.push(...s.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let s={},i=0,a=LVe(t);a&&this.parseWeights(t);for(let u of this.layers)for(let[l,c]of u.weights.entries()){let h=a?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(s[h]!=null)throw new ke(`Duplicate weight name: ${h}`);s[h]=c,i++}let o=[];for(let u in t){let l=u;if(s[u]==null){let c=u.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(s[l]!=null)o.push([s[l],t[u]]);else if(n)throw new ke(`Provided weight data has no target variable: ${u}`);delete s[l]}if(n){let u=[];for(let l in s)u.push(l);if(u.length>0)throw new ke(`${u.length} of ${i} weights are not set: ${u}`)}mO(o)}parseWeights(t){for(let n in Object.keys(t)){let s=n.split("/"),i=["vars","layer_checkpoint_dependencies"],a=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!i.includes(o)).join("/");a!==n&&(t[a]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${IO}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let s=cN(this.updatedConfig());return n?JSON.stringify(s):s}call(t,n){return Ie(()=>{t=Kr(t);let s=new Qf;for(let i=0;i<this.inputs.length;++i)s.add(this.inputs[i],t[i]);return Fy(this.outputs,s,n)})}computeMask(t,n){return Ie(()=>{t=Kr(t);let s;return n==null?s=Sd(null,t.length):s=Kr(n),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){let n=B2(t);if(n.length!==this.inputLayers.length)throw new ke(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let s={};for(let u=0;u<n.length;u++){let l=this.inputLayers[u],c=n[u],h=l.name+"_0_0";s[h]=c}let i=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(D1);if(i.length>1)for(let u of i){let l=this.nodesByDepth[u];for(let c of l){let h=c.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(h.id)!==-1)continue;let d=[];for(let g=0;g<c.inboundLayers.length;g++){let y=c.inboundLayers[g],b=c.nodeIndices[g],x=c.tensorIndices[g],w=`${y.name}_${b}_${x}`,v=s[w];d.push(v)}let p=h.computeOutputShape(wi(d)),f=B2(p),m=h.inboundNodes.indexOf(c);for(let g=0;g<f.length;g++){let y=`${h.name}_${m}_${g}`;s[y]=f[g]}}}let a=[],o=[];for(let u=0;u<this.outputLayers.length;u++){let l=this.outputLayers[u],c=this.outputLayersNodeIndices[u],h=this.outputLayersTensorIndices[u],d=`${l.name}_${c}_${h}`;o.push(d)}for(let u=0;u<o.length;u++){let l=o[u];Jo(l in s),a.push(s[l])}return wi(a)}runInternalGraph(t,n){n==null&&(n=Sd(null,t.length));let s={};for(let l=0;l<this.inputs.length;++l){let c=this.inputs[l],h=t[l],d=n[l];s[c.id]=[h,d]}let i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(D1);for(let l of i){let c=this.nodesByDepth[l];for(let h of c){let d=h.outboundLayer,p=h.inputTensors,f=h.outputTensors,m=new Array;for(let g of p)g.id in s&&m.push(s[g.id]);if(m.length===p.length){let g={},y,b,x,w;if(h.callArgs!=null&&(g=h.callArgs),m.length===1){let[v,S]=m[0];g.mask==null&&(g.mask=S),x=Kr(d.call(v,g)),w=Kr(d.computeMask(v,S)),y=[v],b=[S]}else y=m.map(v=>v[0]),b=m.map(v=>v[1]),g.mask==null&&(g.mask=b),x=Kr(d.call(y,g)),w=Kr(d.computeMask(y,b));if(d.activityRegularizer)throw new gr("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<f.length;++v){let S=f[v],E=x[v],C=w[v];s[S.id]=[E,C]}}}}let a=[],o=[],u=[];for(let l of this.outputs){Jo(l.id in s,`Could not compute output ${l.name} : ${l.id}`);let[c,h]=s[l.id];u.push(c.shape),a.push(c),o.push(h)}return[a,o,u]}buildNodeConversionMap(t){let n={},s;for(let i of this.layers){s=i instanceof Ko?1:0;for(let a=0;a<i.inboundNodes.length;a++){let o=Ko.nodeKey(i,a);this.containerNodes.has(o)&&(n[o]=s,s+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new ke("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let s of this.layers)if(s.name===t)return s;throw new ke(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new ke(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return Ie(()=>{let t=[];for(let n of this.layers)for(let s=0;s<n.inboundNodes.length;++s){let i=Ko.nodeKey(n,s);this.containerNodes.has(i)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),s=[];for(let o of this.layers){let u=o.getClassName(),l=o.getConfig(),c=[];for(let d=0;d<o.inboundNodes.length;d++){let p=o.inboundNodes[d],f=Ko.nodeKey(o,d),m={};if(this.containerNodes.has(f)){if(p.callArgs)try{JSON.stringify(p.callArgs),m=p.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),m={}}if(p.inboundLayers.length>0){let g=[];for(let y=0;y<p.inboundLayers.length;y++){let b=p.inboundLayers[y],x=p.nodeIndices[y],w=p.tensorIndices[y],v=Ko.nodeKey(b,x),S=n[v];S==null&&(S=0),g.push([b.name,S,w,m])}c.push(g)}}}let h={};h.name=o.name,h.className=u,h.config=l,h.inboundNodes=c,s.push(h)}t.layers=s;let i=[];for(let o=0;o<this.inputLayers.length;o++){let u=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=Ko.nodeKey(u,l);if(!this.containerNodes.has(c))continue;let h=n[c];h==null&&(h=0);let d=this.inputLayersTensorIndices[o];i.push([u.name,h,d])}t.inputLayers=i;let a=[];for(let o=0;o<this.outputLayers.length;o++){let u=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=Ko.nodeKey(u,l);if(!this.containerNodes.has(c))continue;let h=n[c];h==null&&(h=0);let d=this.outputLayersTensorIndices[o];a.push([u.name,h,d])}return t.outputLayers=a,t}static fromConfig(t,n,s={},i=!1){let a={},o={};function u(y,b){y.name in o?o[y.name].push(b):o[y.name]=[b]}function l(y,b){let x=[],w;for(let v of b){let S=v[0],E=v[1],C=v[2];if(w=v[3]==null?{}:v[3],!(S in a)){u(y,b);return}let I=a[S];if(I.inboundNodes.length<=E){u(y,b);return}let _=I.inboundNodes[E];x.push(_.outputTensors[C])}x.length>0&&y.apply(wi(x),w)}function c(y){let b=y.name,x=To(y,n.customObjects!=null?n.customObjects:{});x.setFastWeightInitDuringBuild(i),a[b]=x,y.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new ke(`Corrupted configuration, expected array for nodeData: ${w}`);u(x,w)})}let h=n.name,d=n.layers;for(let y of d)c(y);for(;!u5e(o);)for(let y of d){let b=a[y.name];if(b.name in o){let x=o[b.name];delete o[b.name];for(let w of x)l(b,w)}}let p=[],f=[],m=n.inputLayers;for(let y of m){let b=y[0],x=y[1],w=y[2];Jo(b in a);let v=a[b].inboundNodes[x].outputTensors;p.push(v[w])}let g=n.outputLayers;for(let y of g){let b=y[0],x=y[1],w=y[2];Jo(b in a);let v=a[b].inboundNodes[x].outputTensors;f.push(v[w])}return new t({inputs:p,outputs:f,name:h})}get stateful(){if(this._stateful)throw new ke("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){Ie(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function BVe(r,t,n){let s=t.length;if(r==null||Array.isArray(r)&&r.length===0)return t.map(i=>null);if(s===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&t[0]in r?[r[t[0]]]:[r];if(Array.isArray(r)){if(r.length!==s)throw new Error(`Provided ${n} is an array of ${r.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let i=[];return t.forEach(a=>{a in r?i.push(r[a]):i.push(null)}),i}else throw new Error(`The model has multiple (${s}) outputs, so ${n} must be either an array with ${s} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(r)}`)}function mY(r,t){return BVe(r,t,"classWeight")}async function gY(r,t,n,s){if(n!=null){let i=Ie(()=>{if(r.shape.length===1)return au(r);if(r.shape.length===2){if(r.shape[1]>1)return yd(r,1);if(r.shape[1]===1)return Ee(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await i.data());nr(i);let o=[];return a.forEach(u=>{if(n[u]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${u} exists in the data but not in classWeight`);o.push(n[u])}),qr(o,"float32")}else return null}function VVe(r,t){return Se(r,t)}var zVe=32;function yY(r,t){let n,s,i=t;n=i.xs,s=i.ys,O.assert(n!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let a=oV("input",r.inputNames,n),o=oV("output",r.outputNames,s),u=a[0].shape[0];O.assert(a.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),O.assert(o.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let l=0;l<a.length;l++)O.assert(a[l].shape[0]===u,()=>`Batch size mismatch: input ${r.inputNames[l]} has ${a[l].shape[0]}; expected  ${u} based on input ${r.inputNames[0]}.`);for(let l=0;l<o.length;l++)O.assert(o[l].shape[0]===u,()=>`Batch size mismatch: output ${r.outputNames[l]} has ${o[l].shape[0]}; expected  ${u} based on input ${r.inputNames[0]}.`);return{xs:a,ys:o}}function oV(r,t,n){if(n instanceof ur)return[n];if(Array.isArray(n))return O.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${r} keys ${t}.`),n;{let s=[];for(let i of t){if(n[i]==null)throw new ke(`The feature data generated by the dataset lacks the required ${r} key '${i}'.`);s.push(n[i])}return s}}function UVe(r){if(r.length===3)throw new gr("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}async function WVe(r,t,n){let s=n.batchesPerEpoch!=null;if(O.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),O.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),O.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),O.assert(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),O.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let i=n.validationData!=null,a,o;if(i)if(uV(n.validationData))O.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let y=UVe(n.validationData);a=y.xs,o=y.ys}let u=r.makeTrainFunction(),l=r.getDedupedMetricsNames(),c;i?c=l.slice().concat(l.map(y=>"val_"+y)):c=l.slice();let h=oY(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:p,history:f}=uY(h,d,n.epochs,null,null,GVe(t,n),null,i,c);p.setModel(r),r.history=f,await p.onTrainBegin(),r.stopTraining_=!1;let m=n.initialEpoch==null?0:n.initialEpoch,g=await t.iterator();for(;m<n.epochs;){let y={};await p.onEpochBegin(m);let b=0,x=0;for(s||(g=await t.iterator());!s||b<n.batchesPerEpoch;){let w=await g.next();if(s&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(w.value!=null){let{xs:v,ys:S}=yY(r,w.value),E={};E.batch=x,E.size=v[0].shape[0],await p.onBatchBegin(x,E);let C=[];if(n.classWeight!=null){let A=mY(n.classWeight,r.outputNames);for(let k=0;k<A.length;++k)C.push(await gY(S[k],null,A[k]))}let I=v.concat(S).concat(C),_=u(I);nr(I);for(let A=0;A<l.length;++A){let k=l[A],N=_[A];E[k]=N,ns(N)}await p.onBatchEnd(x,E),nY(E),x++,b++}if(s?b>=n.batchesPerEpoch:w.done){if(i){let v;uV(n.validationData)?v=Kr(await r.evaluateDataset(n.validationData,{batches:n.validationBatches})):v=Kr(r.evaluate(a,o,{batchSize:n.validationBatchSize==null?zVe:n.validationBatchSize,verbose:0}));for(let S=0;S<r.metricsNames.length;++S)y[`val_${r.metricsNames[S]}`]=v[S]}break}if(r.stopTraining_)break}if(await p.onEpochEnd(m,y),m++,r.stopTraining_)break}return await p.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}function GVe(r,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(r.size)&&(n=r.size),n}function uV(r){return typeof r.iterator=="function"}function HVe(r){return typeof r.next=="function"}async function jVe(r,t,n){n=n||{};let s=n.batches!=null,i=r.testFunction,a=[];if(n.verbose>0)throw new gr("Verbose mode is not implemented yet.");O.assert(!s||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let o=HVe(t)?t:await t.iterator(),u=0,l=0;for(;!s||l<n.batches;){let c=await o.next();if(a=Ie(()=>{if(c.value){let{xs:h,ys:d}=yY(r,c.value),p=h.concat(d),f=Ie(()=>i(p));if(nr(p),l===0)for(let g=0;g<f.length;++g)a.push(Pt(0));let m=p[0].shape[0];for(let g=0;g<f.length;++g){let y=f[g],b=a[g];a[g]=Ie(()=>Ke(a[g],Se(m,y))),l>0&&nr(b)}nr(f),u+=m,++l}return a}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<a.length;++c){let h=a[c];a[c]=_t(a[c],u),nr(h)}return wi(a)}function lI(r){O.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function fy(r,t,n){return r==null?[null]:Array.isArray(r)?r.map(s=>Ph(s,t,n-t)):Ph(r,t,n-t)}function hN(r,t){return Ie(()=>r==null?null:Array.isArray(r)?r.map(n=>hN(n,t)):KX(r,t.dtype==="int32"?t:at(t,"int32")))}function cI(r,t){let n=[],s=0,i=null;for(;s<r;)i=s+t,i>=r&&(i=r),n.push([s,i]),s=i;return n}function bY(r){let t=[];r instanceof ur&&(r=[r]);for(let n=0;n<r.length;++n){let s=r[n];if(s.rank===1)t.push(_v(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function co(r,t){if(r==null)return;let n=[];if(t instanceof ur)n.push(t.id);else if(Array.isArray(t))t.forEach(i=>n.push(i.id));else if(t!=null)for(let i in t){let a=t[i];n.push(a.id)}let s=[];if(r instanceof ur)n.indexOf(r.id)===-1&&s.push(r);else if(Array.isArray(r))r.forEach(i=>{n.indexOf(i.id)===-1&&s.push(i)});else if(r!=null)for(let i in r){let a=r[i];n.indexOf(a.id)===-1&&s.push(a)}s.forEach(i=>{i.isDisposed||i.dispose()})}function qVe(r){return r instanceof ur}function dN(r){return Array.isArray(r)}function lV(r){return!qVe(r)&&!dN(r)}function cV(r,t,n,s=!0,i=""){if(t==null||t.length===0){if(r!=null){let o=!1;if(dN(r)&&r.length>0)o=!0;else if(lV(r)){for(let u in r)if(r.hasOwnProperty(u)){o=!0;break}}else o=!0;if(o)throw new ke(`Error when checking model ${i} expected no data, but got ${r}`)}return[]}if(r==null)return t.map(o=>null);let a;if(lV(r)){r=r,a=[];for(let o of t){if(r[o]==null)throw new ke(`No data provided for "${o}". Need data for each key in: ${t}`);a.push(r[o])}}else if(dN(r)){if(r=r,r.length!==t.length)throw new ke(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);a=r}else{if(r=r,t.length>1)throw new ke(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);a=[r]}if(a=bY(a),n!=null)for(let o=0;o<t.length;++o){if(n[o]==null)continue;let u=a[o];if(u.shape.length!==n[o].length)throw new ke(`Error when checking ${i}: expected ${t[o]} to have ${n[o].length} dimension(s). but got array with shape ${u.shape}`);for(let l=0;l<n[o].length;++l){if(l===0&&!s)continue;let c=u.shape[l],h=n[o][l];if(h!=null&&h>=0&&c!==h)throw new ke(`${i} expected a batch of elements where each example has shape [${n[o].slice(1,n[o].length)}] (i.e.,tensor shape [*,${n[o].slice(1,n[o].length)}]) but the ${i} received an input with ${u.shape[0]} examples, each with shape [${u.shape.slice(1,u.shape.length)}] (tensor shape [${u.shape}])`)}}return a}function KVe(r,t,n){let s=nc(r.map(a=>a.shape[0]));s.sort();let i=nc(t.map(a=>a.shape[0]));if(i.sort(),s.length>1)throw new ke(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(a=>a.shape))}`);if(i.length>1)throw new ke(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(s.length>0&&i.length>0&&!O.arraysEqual(s,i))throw new ke(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`)}function XVe(r,t,n){let s=[mf,F_,Qb];for(let i=0;i<r.length;++i){let a=r[i],o=t[i],u=n[i];if(o!=null){if(o===Qb&&a.shape[a.shape.length-1]===1)throw new ke(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){let l=a.shape.slice(1),c=u.slice(1);for(let h=0;h<l.length;++h){let d=l[h],p=c[h];if(p!=null&&d!==p)throw new ke(`A target Tensor with shape ${a.shape} was passed for an output of shape ${u}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function hV(r,t,n,s=!0,i=""){let a;if(Array.isArray(r)){if(r.length!==t.length)throw new ke(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${r.length} Tensors(s).`);a=r}else{if(t.length>1)throw new ke(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);a=[r]}if(n!=null)for(let o=0;o<t.length;++o){if(n[o]==null)continue;let u=a[o];if(u.shape.length!==n[o].length)throw new ke(`Error when checking ${i}: expected ${t[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(u.shape)}`);for(let l=0;l<n[o].length;++l){if(l===0&&!s)continue;let c=u.shape[l],h=n[o][l];if(h!=null&&h!==c)throw new ke(`Error when checking ${i}: expected ${t[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(u.shape)}.`)}}}function YVe(r,t){if(r==null||Array.isArray(r)&&r.length===0)return t.map(s=>[]);let n;if(typeof r=="string"||typeof r=="function")n=[r];else if(Array.isArray(r)||typeof r=="object")n=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(n))return t.map(s=>n);{let s=[];for(let i of t){let a=n.hasOwnProperty(i)?n[i]:[];Array.isArray(a)||(a=[a]),s.push(a)}return s}}var ZVe="layers-model",tl=class extends PVe{constructor(r){super(r),this.isTraining=!1}summary(r,t,n=console.log){if(!this.built)throw new ke("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");FVe(this,r,t,n)}compile(r){if(r.loss==null&&(r.loss=[]),this.loss=r.loss,typeof r.optimizer=="string")this.optimizer_=DVe(r.optimizer),this.isOptimizerOwned=!0;else{if(!(r.optimizer instanceof _l))throw new ke("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=r.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(r.loss)&&typeof r.loss!="string"&&typeof r.loss!="function"){r.loss=r.loss;for(let a in r.loss)if(this.outputNames.indexOf(a)===-1)throw new ke(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)r.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(uI(r.loss[a]))}else if(Array.isArray(r.loss)){if(r.loss.length!==this.outputs.length)throw new ke(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${r.loss}.`);t=r.loss.map(a=>uI(a))}else{let a=uI(r.loss);this.outputs.forEach(o=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let o=this.internalOutputShapes[a],u=this.outputNames[a];this.feedOutputNames.push(u),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[a])}let n=[];this.metrics=r.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Lh("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let o=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([o,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let s=YVe(r.metrics,this.outputNames),i=(a,o,u)=>{this.outputNames.length>1&&(o=this.outputNames[a]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([u,a])};Lh("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let o=s[a];(u=>{let l="",c,h,d;for(let p of u){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){let m=this.internalOutputShapes[a];m[m.length-1]===1||this.lossFunctions[a]===F_?["accuracy","acc"].indexOf(p)!==-1?h=CO:["crossentropy","ce"].indexOf(p)!==-1&&(h=hY):this.lossFunctions[a]===G2?["accuracy","acc"].indexOf(p)!==-1?h=dY:["crossentropy","ce"].indexOf(p)!==-1&&(h=pY):["accuracy","acc"].indexOf(p)!==-1?h=_O:["crossentropy","ce"].indexOf(p)!==-1&&(h=EO);let g;["accuracy","acc"].indexOf(p)!==-1?g="acc":["crossentropy","ce"].indexOf(p)!==-1&&(g="ce"),d=h,c=l+g}else d=AVe(p),c=l+R1(p);let f;Lh(c,()=>{f=d}),i(a,c,f)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(r,t,n={}){let s=n.batchSize==null?32:n.batchSize;lI(s);let i=this.standardizeUserDataXY(r,t,!0,s);try{let a=i[0].concat(i[1]);this.makeTestFunction();let o=this.testFunction,u=this.testLoop(o,a,s,n.verbose,n.steps);return wi(u)}finally{co(i[0],r),co(i[1],t)}}async evaluateDataset(r,t){return this.makeTestFunction(),jVe(this,r,t)}checkNumSamples(r,t,n,s="steps"){let i;if(n!=null){if(i=null,t!=null)throw new ke(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(r!=null)Array.isArray(r)?i=r[0].shape[0]:i=r.shape[0];else throw new ke(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return i}execute(r,t){if(Array.isArray(t)&&t.length===0)throw new ke("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),s=n?t:[t],i=this.retrieveSymbolicTensors(s),a=new Qf;if(r instanceof ur&&(r=[r]),Array.isArray(r)){if(r.length!==this.inputs.length)throw new ke(`The number of inputs provided (${r.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],r[u])}else for(let u of this.inputs){let l=r[u.name];if(l==null)throw new ke(`No value is provided for the model's input ${u.name}`);a.add(u,l)}let o=Fy(i,a);return n?o:o[0]}retrieveSymbolicTensors(r){let t=Sd(null,r.length),n=r.length;for(let s of this.layers){let i=Array.isArray(s.output)?s.output:[s.output],a=i.map(o=>o.name);for(let o=0;o<r.length;++o){let u=a.indexOf(r[o]);if(u!==-1&&(t[o]=i[u],n--),n===0)break}if(n===0)break}if(n>0){let s=[];throw t.forEach((i,a)=>{i==null&&s.push(r[a])}),new ke(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return t}predictLoop(r,t=32,n=!1){return Ie(()=>{let s=this.checkNumSamples(r);if(n)throw new gr("Verbose predictLoop() is not implemented yet.");let i=cI(s,t),a=this.outputs.map(o=>[]);for(let o=0;o<i.length;++o)Ie(()=>{let u=i[o][0],l=i[o][1],c=fy(r,u,l),h=[];if(Array.isArray(c))for(let p=0;p<c.length;++p)h.push({key:this.inputs[p],value:c[p]});else h.push({key:this.inputs[0],value:c});let d=new Qf(h);return Fy(this.outputs,d)}).forEach((u,l)=>a[l].push(u));return wi(a.map(o=>an(o,0)))})}predict(r,t={}){let n=bY(r);hV(n,this.inputNames,this.feedInputShapes,!1);try{let s=t.batchSize==null?32:t.batchSize;return lI(s),this.predictLoop(n,s)}finally{co(n,r)}}predictOnBatch(r){hV(r,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(r)?r[0]:r).shape[0];return this.predictLoop(r,t)}standardizeUserDataXY(r,t,n=!0,s){if(this.optimizer_==null)throw new ru("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let i=[];for(let a=0;a<this.feedOutputShapes.length;++a){let o=this.feedOutputShapes[a];this.feedLossFns[a]===G2?i.push(o.slice(0,o.length-1).concat([1])):i.push(o)}if(r=cV(r,this.feedInputNames,this.feedInputShapes,!1,"input"),t=cV(t,this.feedOutputNames,i,!1,"target"),KVe(r,t),XVe(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&r[0].shape[0]%s!==0)throw new ke(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${r[0].shape[0]} sample(s).`);return[r,t]}async standardizeUserData(r,t,n,s,i=!0,a){let[o,u]=this.standardizeUserDataXY(r,t,i,a);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(s!=null){let c=mY(s,this.outputNames);l=[];for(let h=0;h<c.length;++h)l.push(await gY(u[h],null,c[h]))}return[o,u,l]}testLoop(r,t,n,s=0,i){return Ie(()=>{let a=this.checkNumSamples(t,n,i,"steps"),o=[];if(s>0)throw new gr("Verbose mode is not implemented yet.");if(i!=null)throw new gr("steps mode in testLoop() is not implemented yet");{let u=cI(a,n),l=qr(Ro(0,a));for(let c=0;c<u.length;++c){let h=u[c][0],d=u[c][1],p=Ph(l,h,d-h),f=hN(t,p),m=r(f);if(c===0)for(let g=0;g<m.length;++g)o.push(Pt(0));for(let g=0;g<m.length;++g){let y=m[g];o[g]=Ke(o[g],Se(d-h,y))}}for(let c=0;c<o.length;++c)o[c]=_t(o[c],a)}return o})}getDedupedMetricsNames(){let r=this.metricsNames,t=[];for(let n=0;n<r.length;++n){let s=r[n],i=s;if(Y5(r,s)>1){let a=Y5(r.slice(0,n),s);i+=`_${a}`}t.push(i)}return t}makeTrainFunction(){return r=>{let t=[],n=r.slice(0,this.inputs.length),s=r.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=r.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],o=()=>{let l=[];for(let p=0;p<this.inputs.length;++p)l.push({key:this.inputs[p],value:n[p]});let c=new Qf(l),h=Fy(this.outputs,c,{training:!0}),d;for(let p=0;p<this.lossFunctions.length;++p){let f=this.lossFunctions[p],m=f(s[p],h[p]);i[p]!=null&&(m=VVe(m,i[p]));let g=Rn(m);t.push(g),p===0?d=m:d=Ke(d,m)}for(let p=0;p<this.metricsTensors.length;++p){let f;if(this.outputs.length>1&&p<this.outputs.length)f=t[p];else{let m=this.metricsTensors[p][0],g=this.metricsTensors[p][1];f=Rn(m(s[g],h[g]))}ns(f),a.push(f)}return d=Rn(d),this.calculateLosses().forEach(p=>{d=Ke(d,p)}),d},u=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(o,!0,u)].concat(a)}}makeTestFunction(){this.testFunction=r=>Ie(()=>{let t=[],n,s=r.slice(0,this.inputs.length),i=r.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let l=0;l<this.inputs.length;++l)a.push({key:this.inputs[l],value:s[l]});let o=new Qf(a),u=Fy(this.outputs,o);for(let l=0;l<this.lossFunctions.length;++l){let c=this.lossFunctions[l],h=Rn(c(i[l],u[l]));l===0?n=h:n=Ke(n,h),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let c=this.metricsTensors[l][0],h=this.metricsTensors[l][1],d=Rn(c(i[h],u[h]));t.push(d)}return t})}async fit(r,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let s,i,a,o,u,l,c,h,d;try{let p=n.batchSize==null?32:n.batchSize;lI(p);let f=await this.standardizeUserData(r,t,n.sampleWeight,n.classWeight,!1,p);s=f[0],i=f[1],d=f[2];let m=!1,g;if(n.validationData!=null&&n.validationData.length>0){if(m=!0,n.validationData.length===2)u=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new gr("validationData including sample weights is not supported yet."):new ke(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let E=await this.standardizeUserData(u,l,null,null,!0,p);c=E[0],h=E[1],g=c.concat(h)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){m=!0;let E=Math.floor(s[0].shape[0]*(1-n.validationSplit)),C=s[0].shape[0];c=fy(s,E,C),a=s,s=fy(s,0,E),h=fy(i,E,C),o=i,i=fy(i,0,E),g=c.concat(h)}else n.validationSteps!=null&&(m=!0);let y=s.concat(i).concat(d);this.checkTrainableWeightsConsistency();let b=this.makeTrainFunction(),x=this.getDedupedMetricsNames(),w,v;m?(this.makeTestFunction(),w=this.testFunction,v=x.slice().concat(x.map(E=>"val_"+E))):(w=null,g=[],v=x.slice());let S=oY(n.callbacks,n.yieldEvery);return await this.fitLoop(b,y,x,p,n.epochs,n.verbose,S,w,g,n.shuffle,v,n.initialEpoch,null,null)}finally{this.isTraining=!1,co(s,r),co(i,t),co(a,r),co(o,t),co(c,u),co(h,l),d!=null&&nr(d)}}async fitLoop(r,t,n,s,i,a,o,u,l,c,h,d,p,f){s==null&&(s=32),i==null&&(i=1),c==null&&(c=!0),d==null&&(d=0);let m=!1;if(u!=null&&l!=null&&(m=!0),f!=null&&(m=!0,p==null))throw new ke("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=this.checkNumSamples(t,s,p,"steps_per_epoch"),y;g!=null&&(y=Ro(0,g)),a==null&&(a=1);let{callbackList:b,history:x}=uY(o,a,i,d,g,p,s,m,h);b.setModel(this),this.history=x,await b.onTrainBegin(),this.stopTraining_=!1;for(let w=d;w<i;++w){await b.onEpochBegin(w);let v={};if(p!=null)throw new gr("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new gr("batch shuffling is not implemneted yet");c&&O.shuffle(y);let S=qr(y),E=cI(g,s);for(let C=0;C<E.length;++C){let I={};if(await b.onBatchBegin(C,I),Ie(()=>{let _=E[C][0],A=E[C][1],k=Ph(S,_,A-_);I.batch=C,I.size=A-_;let N=hN(t,k),D=r(N);for(let F=0;F<n.length;++F){let P=n[F],G=D[F];I[P]=G,ns(G)}if(C===E.length-1&&m){let F=this.testLoop(u,l,s);for(let P=0;P<n.length;++P){let G=n[P],Y=F[P];ns(Y),v["val_"+G]=Y}}}),await b.onBatchEnd(C,I),nY(I),this.stopTraining_)break}S.dispose()}if(await b.onEpochEnd(w,v),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(r,t){return WVe(this,r,t)}async trainOnBatch(r,t){let n=await this.standardizeUserData(r,t),s=n[0],i=n[1],a=this.makeTrainFunction()(s.concat(i)),o=[];for(let u of a){let l=await u.data();o.push(l[0])}return nr(a),co(n[0],r),co(n[1],t),wi(o)}getNamedWeights(r){let t=[],n=r!=null&&r.trainableOnly,s=n?this.trainableWeights:this.weights,i=this.getWeights(n);for(let a=0;a<s.length;++a)n&&!s[a].trainable||t.push({name:s[a].originalName,tensor:i[a]});return t}set stopTraining(r){this.stopTraining_=r}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(r){this.optimizer_!==r&&(this.optimizer_=r,this.isOptimizerOwned=!1)}dispose(){let r=super.dispose();if(r.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=qk().numTensors;this.optimizer_.dispose(),r.numDisposedVariables+=t-qk().numTensors}return r}getLossIdentifiers(){let r;if(typeof this.loss=="string")r=Lu(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");r=this.loss.map(t=>Lu(t))}else{let t=Object.keys(this.loss);r={};let n=this.loss;for(let s of t)if(typeof n[s]=="string")r[s]=Lu(n[s]);else throw new Error("Serialization of non-string loss is not supported.")}return r}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Lu(R1(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(r=>Lu(R1(r)));{let r={};for(let t in this.metrics)r[t]=Lu(R1(this.metrics[t]));return r}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(r){if(r.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(r.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(r.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=ex(r.optimizer_config),n=To(t),s;if(typeof r.loss=="string")s=_h(r.loss);else if(Array.isArray(r.loss))s=r.loss.map(a=>_h(a));else if(r.loss!=null){s={};for(let a in r.loss)s[a]=_h(r.loss[a])}let i;if(Array.isArray(r.metrics))i=r.metrics.map(a=>_h(a));else if(r.metrics!=null){i={};for(let a in r.metrics)i[a]=_h(r.metrics[a])}this.compile({loss:s,metrics:i,optimizer:n})}async save(r,t){if(typeof r=="string"){let i=$s.getSaveHandlers(r);if(i.length===0)throw new ke(`Cannot find any save handlers for URL '${r}'`);if(i.length>1)throw new ke(`Found more than one (${i.length}) save handlers for URL '${r}'`);r=i[0]}if(r.save==null)throw new ke("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await $s.encodeWeights(this.getNamedWeights(t)),s={modelTopology:this.toJSON(null,!1),format:ZVe,generatedBy:`TensorFlow.js tfjs-layers v${IO}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){s.trainingConfig=this.getTrainingConfig();let i="optimizer",{data:a,specs:o}=await $s.encodeWeights(await this.optimizer.getWeights(),i);n.specs.push(...o),n.data=$s.concatenateArrayBuffers([n.data,a])}return this.userDefinedMetadata!=null&&(aV(this.userDefinedMetadata,this.name,!0),s.userDefinedMetadata=this.userDefinedMetadata),s.weightData=n.data,s.weightSpecs=n.specs,r.save(s)}setUserDefinedMetadata(r){aV(r,this.name),this.userDefinedMetadata=r}getUserDefinedMetadata(){return this.userDefinedMetadata}};tl.className="Model";et.registerClass(tl);var xY=class extends tl{};xY.className="Functional";et.registerClass(xY);async function JVe(r,t){"modelTopology"in r||(r={modelTopology:r}),r=r;let n=r.modelTopology;n.model_config!=null&&(n=n.model_config);let s=ex(n),i=To(s,t);if(r.weightsManifest!=null){let a=await $s.loadWeights(r.weightsManifest,r.pathPrefix,i.weights.map(u=>u.originalName)),o={};for(let u of i.weights)o[u.originalName]=a[u.originalName];i.loadWeights(o),nr(a)}return i}async function QVe(r,t){if(t==null&&(t={}),typeof r=="string"){let n=$s.getLoadHandlers(r,t);if(n.length===0)n.push($s.browserHTTPRequest(r,t));else if(n.length>1)throw new ke(`Found more than one (${n.length}) load handlers for URL '${r}'`);r=n[0]}return eze(r,void 0,t)}async function eze(r,t,n){if(n==null&&(n={}),r.load==null)throw new ke("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let s=await r.load(),i=s.modelTopology;i.model_config!=null&&(i=i.model_config);let a=n.strict==null?!0:n.strict,o=s.weightData!=null&&s.weightSpecs!=null&&a,u=To(ex(i),t,o),l=s.trainingConfig;if(l!=null&&u.loadTrainingConfig(l),s.userDefinedMetadata!=null&&u.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new ke("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:c,optimizerWeights:h}=tze(s.weightData,s.weightSpecs);u.loadWeights(c,a),u.optimizer!=null&&h.length>0&&await u.optimizer.setWeights(h),nr(c),nr(h.map(d=>d.tensor))}return u}function tze(r,t){let n=$s.decodeWeights(r,t),s={},i=[];return t.forEach(a=>{a.group==="optimizer"?i.push({name:a.name,tensor:n[a.name]}):s[a.name]=n[a.name]}),{modelWeights:s,optimizerWeights:i}}var $_=class pN extends tl{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:w_("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new ke(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof pN||t instanceof tl,s;if(n){if(s=t,s.outputs.length!==1)throw new ke("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new ke("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new ke("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let i=JX({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(i)}if(n)this.outputs=s.outputs,this.inputs=s.inputs;else{if(t.inboundNodes.length!==1)throw new ke(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new ke("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=ZX(this.outputs[0])}this.inboundNodes=[],new A_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Sd(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{let i=t.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(Mr(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new tl({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,s=console.log){this.built||this.build(),super.summary(t,n,s)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,s={}){if(!this.built)throw new ru("The model needs to be compiled before being used.");return this.model.evaluate(t,n,s)}async evaluateDataset(t,n){if(!this.built)throw new ru("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,s={}){if(!this.built)throw new ru("The model needs to be compiled before being used.");return this.model.fit(t,n,s)}async fitDataset(t,n){if(!this.built)throw new ru("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,s={},i=!1){let a,o={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new ke("Legacy serialization format not supported yet.");a=n}else O.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,o=n;let u=new t(o);if(!(u instanceof pN))throw new gr(`Sequential.fromConfig called on non-Sequential input: ${u}`);for(let l of a){let c=To(l,void 0,i);i&&c.setFastWeightInitDuringBuild(!0),u.add(c)}return u}set stopTraining(t){if(this.model==null)throw new ke("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new ke("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let s={};s.className=n.getClassName(),s.config=n.getConfig(),t.push(s)}return{name:this.name,layers:t}}};$_.className="Sequential";et.registerClass($_);function rze(r){return new tl(r)}function nze(r){return new $_(r)}function vY(r){return JX(r)}function sze(r,t){wO.registerCallbackConstructor(r,t)}var js=class extends et.Serializable{getConfig(){return{}}},wY=class extends js{apply(r,t=1){return C5e(r,t)}};wY.className="elu";et.registerClass(wY);var SY=class extends js{apply(r){return s_(r)}};SY.className="selu";et.registerClass(SY);var CY=class extends js{apply(r){return Yr(r)}};CY.className="relu";et.registerClass(CY);var _Y=class extends js{apply(r){return Ie(()=>wc(6,Yr(r)))}};_Y.className="relu6";et.registerClass(_Y);var EY=class extends js{apply(r){return r}};EY.className="linear";et.registerClass(EY);var IY=class extends js{apply(r){return Xa(r)}};IY.className="sigmoid";et.registerClass(IY);var kY=class extends js{apply(r){return E5e(r)}};kY.className="hardSigmoid";et.registerClass(kY);var NY=class extends js{apply(r){return df(r)}};NY.className="softplus";et.registerClass(NY);var TY=class extends js{apply(r){return _5e(r)}};TY.className="softsign";et.registerClass(TY);var AY=class extends js{apply(r){return vc(r)}};AY.className="tanh";et.registerClass(AY);var kO=class extends js{apply(r,t=-1){return Wc(r,t)}};kO.className="softmax";et.registerClass(kO);var DY=class extends js{apply(r,t=-1){return ZC(r,t)}};DY.className="logSoftmax";et.registerClass(DY);var FY=class extends js{apply(r){return Ie(()=>Ie(()=>{let t=Math.sqrt(2),n=Se(.5,Ke(1,KC(_t(r,t))));return Se(r,n)}))}};FY.className="gelu";et.registerClass(FY);var $Y=class extends js{apply(r){return Ie(()=>Se(.5,Se(r,Ke(1,vc(Se(_s(_t(2,Math.PI)),Ke(r,Se(.044715,yu(r,3)))))))))}};$Y.className="gelu_new";et.registerClass($Y);var RY=class extends js{apply(r){return Ie(()=>Se(r,vc(df(r))))}};RY.className="mish";et.registerClass(RY);var OY=class extends js{apply(r,t=1){return Ie(()=>Se(Xa(Se(r,t)),r))}};OY.className="swish";et.registerClass(OY);function _c(r){return r.getClassName()}function hI(r,t={}){return Cv(r,et.SerializationMap.getMap().classNameMap,t,"activation")}function Ec(r){if(r==null){let t={};return t.className="linear",t.config={},hI(t)}if(typeof r=="string"){let t={};return t.className=r,t.config={},hI(t)}else return r instanceof js?r:hI(r)}function NO(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var MY=class extends et.Serializable{},Nv=class extends MY{constructor(r){super(),NO(r),this.l1=r==null||r.l1==null?.01:r.l1,this.l2=r==null||r.l2==null?.01:r.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(r){return Ie(()=>{let t=On([1]);return this.hasL1&&(t=Ke(t,Tt(Se(this.l1,jn(r))))),this.hasL2&&(t=Ke(t,Tt(Se(this.l2,Ev(r))))),Ee(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(r,t){return new r({l1:t.l1,l2:t.l2})}};Nv.className="L1L2";et.registerClass(Nv);function ize(r){return NO(r),new Nv({l1:r!=null?r.l1:null,l2:0})}function aze(r){return NO(r),new Nv({l2:r!=null?r.l2:null,l1:0})}var dV={l1l2:"L1L2"};function dn(r){return iO(r)}function pV(r,t={}){return Cv(r,et.SerializationMap.getMap().classNameMap,t,"regularizer")}function Nn(r){if(r==null)return null;if(typeof r=="string"){let t={className:r in dV?dV[r]:r,config:{}};return pV(t)}else return r instanceof MY?r:pV(r)}var TO=class extends yr{constructor(r){super(r??{}),this.supportsMasking=!0,r!=null&&(this.maxValue=r.maxValue)}call(r,t){r=Xt(r);let n=Yr(r);return this.maxValue!=null&&(n=Us(n,0,this.maxValue)),n}computeOutputShape(r){return r}getConfig(){let r={maxValue:this.maxValue},t=super.getConfig();return Object.assign(r,t),r}};TO.className="ReLU";et.registerClass(TO);var AO=class extends yr{constructor(r){super(r??{}),this.DEFAULT_ALPHA=.3,r==null&&(r={}),this.alpha=r.alpha==null?this.DEFAULT_ALPHA:r.alpha}call(r,t){let n=Xt(r);return dv(n,this.alpha)}computeOutputShape(r){return r}getConfig(){let r={alpha:this.alpha},t=super.getConfig();return Object.assign(r,t),r}};AO.className="LeakyReLU";et.registerClass(AO);var DO=class extends yr{constructor(r){if(super(r??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",r==null&&(r={}),this.supportsMasking=!0,this.alphaInitializer=kn(r.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Nn(r.alphaRegularizer),this.alphaConstraint=os(r.alphaConstraint),r.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(r.sharedAxes))this.sharedAxes=r.sharedAxes;else if(typeof r.sharedAxes=="number")this.sharedAxes=[r.sharedAxes];else throw new ke(`Expected sharedAxes to be a number or an array of numbers, but got ${r.sharedAxes}`)}build(r){r=Mr(r);let t=r.slice(1);if(this.sharedAxes!=null)for(let s of this.sharedAxes)t[s-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let s=1;s<r.length;++s)n[s]=r[s];this.inputSpec=[new Kn({ndim:r.length,axes:n})],this.built=!0}call(r,t){return r=Xt(r),bv(r,this.alpha.read())}getConfig(){let r={alphaInitializer:Mn(this.alphaInitializer),alphaRegularizer:dn(this.alphaRegularizer),alphaConstraint:as(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(r,t),r}};DO.className="PReLU";et.registerClass(DO);var FO=class extends yr{constructor(r){if(super(r??{}),this.DEFAULT_ALPHA=1,r==null&&(r={}),r.alpha!=null&&r.alpha!==this.DEFAULT_ALPHA)throw new gr(`Non-default alpha value (${r.alpha}) is not supported by the ELU layer yet.`);this.alpha=r.alpha==null?this.DEFAULT_ALPHA:r.alpha}call(r,t){let n=Xt(r);return N0(n)}computeOutputShape(r){return r}getConfig(){let r={alpha:this.alpha},t=super.getConfig();return Object.assign(r,t),r}};FO.className="ELU";et.registerClass(FO);var $O=class extends yr{constructor(r){super(r??{}),this.DEFAULT_THETA=1,r==null&&(r={}),this.theta=r.theta==null?this.DEFAULT_THETA:r.theta}call(r,t){let n=Xt(r);return Se(n,at(fi(n,this.theta),"float32"))}computeOutputShape(r){return r}getConfig(){let r={theta:this.theta},t=super.getConfig();return Object.assign(r,t),r}};$O.className="ThresholdedReLU";et.registerClass($O);var RO=class extends yr{constructor(r){super(r??{}),this.DEFAULT_AXIS=1,r==null&&(r={}),this.softmax=new kO().apply,this.axis=r.axis==null?this.DEFAULT_AXIS:r.axis}call(r,t){return Ie(()=>{let n=Xt(r),s=t.mask;if(s!=null){let i=Se(vt(Ci(n.shape),at(s,n.dtype)),Pt(-1e9));n=Ke(n,i)}return this.axis instanceof Array?this.axis.length>1?Ws(vt(n,fv(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(r){return r}getConfig(){let r={axis:this.axis},t=super.getConfig();return Object.assign(r,t),r}};RO.className="Softmax";et.registerClass(RO);function ym(r,t,n){if(typeof r=="number")return Sd(r,t);if(r.length!==t)throw new ke(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${r.length} elements.`);for(let s=0;s<t;++s){let i=r[s];if(!x5e(i))throw new ke(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(r)} including a non-integer number ${i}`)}return r}function Ao(r,t,n,s,i=1){if(r==null)return r;let a=t+(t-1)*(i-1),o;return n==="same"?o=r:o=r-a+1,Math.floor((o+s-1)/s)}function Qo(r,t,n,s){if(r==null)return null;if(s==="valid")r=r*t+Cc([n-t,0]);else if(s==="same")r=r*t;else throw new ke(`Unsupport padding mode: ${s}.`);return r}function OO(r,t){return Ie(()=>(Gn(t),t==="channelsFirst"?dr(r,[0,2,3,1]):r))}function LY(r,t){return Ie(()=>(Gn(t),t==="channelsFirst"?dr(r,[0,2,3,4,1]):r))}function oze(r,t,n,s=1,i="valid",a,o=1){return Ie(()=>{if(a==null&&(a=Oo()),Gn(a),r.shape.length!==3)throw new ke(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(t.shape.length!==3)throw new ke(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new ke(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(a==="channelsFirst"&&(r=dr(r,[0,2,1])),i==="causal")throw new gr("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let u=GC(r,t,s,i==="same"?"same":"valid","NWC",o);return n!=null&&(u=Uo(u,n)),u})}function fV(r,t,n,s=[1,1],i="valid",a,o,u=null){return Ie(()=>{if(a==null&&(a=Oo()),Gn(a),r.rank!==3&&r.rank!==4)throw new ke(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(t.rank!==3&&t.rank!==4)throw new ke(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let l=OO(r,a);if(i==="causal")throw new gr("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Zm.conv2d({x:l,filter:t,strides:s,pad:i==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:u}),a==="channelsFirst"&&(l=dr(l,[0,3,1,2])),l})}function uze(r,t,n,s=[1,1,1],i="valid",a,o){return Ie(()=>{if(a==null&&(a=Oo()),Gn(a),r.rank!==4&&r.rank!==5)throw new ke(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(t.rank!==4&&t.rank!==5)throw new ke(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let u=LY(r,a);if(i==="causal")throw new gr("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return u=l3(u,t,s,i==="same"?"same":"valid","NDHWC",o),n!=null&&(u=Uo(u,n)),a==="channelsFirst"&&(u=dr(u,[0,4,1,2,3])),u})}var PY=class BY extends yr{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",BY.verifyArgs(n),this.rank=t,vs(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new gr(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ym(n.kernelSize,t,"kernelSize"),this.strides=ym(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,Ea(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Gn(this.dataFormat),this.activation=Ec(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=kn(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=os(n.biasConstraint),this.biasRegularizer=Nn(n.biasRegularizer),this.activityRegularizer=Nn(n.activityRegularizer),this.dilationRate=ym(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ke(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ke(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ke(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Jo("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!aO(t.kernelSize,"number",1,3))throw new ke(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:_c(this.activation),useBias:this.useBias,biasInitializer:Mn(this.biasInitializer),biasRegularizer:dn(this.biasRegularizer),activityRegularizer:dn(this.activityRegularizer),biasConstraint:as(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},R_=class VY extends PY{constructor(t,n){super(t,n),this.kernel=null,VY.verifyArgs(n),this.filters=n.filters,vs(this.filters,"filters"),this.kernelInitializer=kn(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=os(n.kernelConstraint),this.kernelRegularizer=Nn(n.kernelRegularizer)}build(t){t=Mr(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new ke(`The channel dimension of the input should be defined. Found ${t[n]}`);let s=t[n],i=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:s}}],this.built=!0}call(t,n){return Ie(()=>{t=Xt(t);let s,i=this.bias==null?null:this.bias.read(),a=UX(this.activation.getClassName());if(a!=null&&this.rank===2)s=fV(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)s=oze(t,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=fV(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=uze(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new gr("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=Mr(t);let n=[],s=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<s.length;++a){let o=Ao(s[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);n.push(o)}let i=[t[0]];return this.dataFormat==="channelsLast"?(i=i.concat(n),i.push(this.filters)):(i.push(this.filters),i=i.concat(n)),i}getConfig(){let t={filters:this.filters,kernelInitializer:Mn(this.kernelInitializer),kernelRegularizer:dn(this.kernelRegularizer),kernelConstraint:as(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new ke(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},O_=class zY extends R_{constructor(t){super(2,t),zY.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!aO(t.kernelSize,"number",1,2))throw new ke(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};O_.className="Conv2D";et.registerClass(O_);var M_=class UY extends R_{constructor(t){super(3,t),UY.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new ke(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};M_.className="Conv3D";et.registerClass(M_);var MO=class extends O_{constructor(r){if(super(r),this.inputSpec=[new Kn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ke(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(r){if(r=Mr(r),r.length!==4)throw new ke("Input should have rank 4; Received input shape: "+JSON.stringify(r));let t=this.dataFormat==="channelsFirst"?1:r.length-1;if(r[t]==null)throw new ke("The channel dimension of the inputs should be defined. Found `None`.");let n=r[t],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Kn({ndim:4,axes:{[t]:n}})],this.built=!0}call(r,t){return Ie(()=>{let n=Xt(r);if(n.shape.length!==4)throw new ke(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let s=n.shape,i=s[0],a,o;this.dataFormat==="channelsFirst"?(a=2,o=3):(a=1,o=2);let u=s[a],l=s[o],c=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],p=this.strides[1],f=Qo(u,d,c,this.padding),m=Qo(l,p,h,this.padding),g=[i,f,m,this.filters];this.dataFormat!=="channelsLast"&&(n=dr(n,[0,2,3,1]));let y=HC(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=dr(y,[0,3,1,2])),this.bias!=null&&(y=Uo(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(r){r=Mr(r);let t=r.slice(),n,s,i;this.dataFormat==="channelsFirst"?(n=1,s=2,i=3):(n=3,s=1,i=2);let a=this.kernelSize[0],o=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[s]=Qo(t[s],u,a,this.padding),t[i]=Qo(t[i],l,o,this.padding),t}getConfig(){let r=super.getConfig();return delete r.dilationRate,r}};MO.className="Conv2DTranspose";et.registerClass(MO);var LO=class extends M_{constructor(r){if(super(r),this.inputSpec=[new Kn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ke(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(r){if(r=Mr(r),r.length!==5)throw new ke("Input should have rank 5; Received input shape: "+JSON.stringify(r));let t=this.dataFormat==="channelsFirst"?1:r.length-1;if(r[t]==null)throw new ke("The channel dimension of the inputs should be defined. Found `None`.");let n=r[t],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Kn({ndim:5,axes:{[t]:n}})],this.built=!0}call(r,t){return Ie(()=>{let n=Xt(r);if(n.shape.length!==5)throw new ke(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let s=n.shape,i=s[0],a,o,u;this.dataFormat==="channelsFirst"?(u=2,a=3,o=4):(u=1,a=2,o=3);let l=s[u],c=s[a],h=s[o],d=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],b=Qo(l,m,d,this.padding),x=Qo(c,g,p,this.padding),w=Qo(h,y,f,this.padding),v=[i,b,x,w,this.filters];this.dataFormat!=="channelsLast"&&(n=dr(n,[0,2,3,4,1]));let S=c3(n,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=dr(S,[0,4,1,2,3])),this.bias!==null&&(S=Uo(S,this.bias.read(),this.dataFormat)),this.activation!==null&&(S=this.activation.apply(S)),S})}computeOutputShape(r){r=Mr(r);let t=r.slice(),n,s,i,a;this.dataFormat==="channelsFirst"?(n=1,s=2,i=3,a=4):(n=4,s=1,i=2,a=3);let o=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],h=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[s]=Qo(t[s],c,o,this.padding),t[i]=Qo(t[i],h,u,this.padding),t[a]=Qo(t[a],d,l,this.padding),t}getConfig(){let r=super.getConfig();return delete r.dilationRate,r}};LO.className="Conv3DTranspose";et.registerClass(LO);var WY=class extends R_{constructor(r,t){if(super(r,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new ke("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new ke("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new ke(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=kn(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Nn(t.depthwiseRegularizer),this.depthwiseConstraint=os(t.depthwiseConstraint),this.pointwiseInitializer=kn(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Nn(t.pointwiseRegularizer),this.pointwiseConstraint=os(t.pointwiseConstraint)}build(r){if(r=Mr(r),r.length<this.rank+2)throw new ke(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(r)}`);let t=this.dataFormat==="channelsFirst"?1:r.length-1;if(r[t]==null||r[t]<0)throw new ke(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(r[t])}`);let n=r[t],s=this.kernelSize.concat([n,this.depthMultiplier]),i=[];for(let o=0;o<this.rank;++o)i.push(1);i.push(n*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Kn({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(r,t){return Ie(()=>{r=Xt(r);let n;if(this.rank===1)throw new gr("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(r=dr(r,[0,2,3,1])),n=F0(r,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=Uo(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=dr(n,[0,3,1,2])),n})}getConfig(){let r=super.getConfig();return delete r.rank,delete r.kernelInitializer,delete r.kernelRegularizer,delete r.kernelConstraint,r.depthwiseInitializer=Mn(this.depthwiseInitializer),r.pointwiseInitializer=Mn(this.pointwiseInitializer),r.depthwiseRegularizer=dn(this.depthwiseRegularizer),r.pointwiseRegularizer=dn(this.pointwiseRegularizer),r.depthwiseConstraint=as(this.depthwiseConstraint),r.pointwiseConstraint=as(this.pointwiseConstraint),r}};WY.className="SeparableConv";var PO=class extends WY{constructor(r){super(2,r)}};PO.className="SeparableConv2D";et.registerClass(PO);var BO=class GY extends R_{constructor(t){super(1,t),GY.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!aO(t.kernelSize,"number",1,1))throw new ke(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};BO.className="Conv1D";et.registerClass(BO);var VO=class extends yr{constructor(r){super(r),typeof r.cropping=="number"?this.cropping=[[r.cropping,r.cropping],[r.cropping,r.cropping]]:typeof r.cropping[0]=="number"?this.cropping=[[r.cropping[0],r.cropping[0]],[r.cropping[1],r.cropping[1]]]:this.cropping=r.cropping,this.dataFormat=r.dataFormat===void 0?"channelsLast":r.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(r){return this.dataFormat==="channelsFirst"?[r[0],r[1],r[2]-this.cropping[0][0]-this.cropping[0][1],r[3]-this.cropping[1][0]-this.cropping[1][1]]:[r[0],r[1]-this.cropping[0][0]-this.cropping[0][1],r[2]-this.cropping[1][0]-this.cropping[1][1],r[3]]}call(r,t){return Ie(()=>{if(r=Xt(r),this.dataFormat==="channelsLast"){let n=$1(r,this.cropping[0][0],r.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return $1(n,this.cropping[1][0],r.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=$1(r,this.cropping[0][0],r.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return $1(n,this.cropping[1][0],r.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let r={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(r,t),r}};VO.className="Cropping2D";et.registerClass(VO);var zO=class extends yr{constructor(r){super(r),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=r.size==null?this.DEFAULT_SIZE:r.size,this.dataFormat=r.dataFormat==null?"channelsLast":r.dataFormat,Gn(this.dataFormat),this.interpolation=r.interpolation==null?"nearest":r.interpolation,g5e(this.interpolation)}computeOutputShape(r){if(this.dataFormat==="channelsFirst"){let t=r[2]==null?null:this.size[0]*r[2],n=r[3]==null?null:this.size[1]*r[3];return[r[0],r[1],t,n]}else{let t=r[1]==null?null:this.size[0]*r[1],n=r[2]==null?null:this.size[1]*r[2];return[r[0],t,n,r[3]]}}call(r,t){return Ie(()=>{let n=Xt(r),s=n.shape;if(this.dataFormat==="channelsFirst"){n=dr(n,[0,2,3,1]);let i=this.size[0]*s[2],a=this.size[1]*s[3],o=this.interpolation==="nearest"?pa.resizeNearestNeighbor(n,[i,a]):pa.resizeBilinear(n,[i,a]);return dr(o,[0,3,1,2])}else{let i=this.size[0]*s[1],a=this.size[1]*s[2];return this.interpolation==="nearest"?pa.resizeNearestNeighbor(n,[i,a]):pa.resizeBilinear(n,[i,a])}})}getConfig(){let r={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(r,t),r}};zO.className="UpSampling2D";et.registerClass(zO);function lze(r,t,n=[1,1],s="valid",i,a){return Ie(()=>{i==null&&(i=Oo()),Gn(i);let o=OO(r,i);if(r.rank!==4)throw new ke(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(t.rank!==4)throw new ke(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=hf(o,t,n,s==="same"?"same":"valid","NHWC",a),i==="channelsFirst"&&(o=dr(o,[0,3,1,2])),o})}var UO=class extends PY{constructor(r){super(2,r),this.depthwiseKernel=null,this.depthMultiplier=r.depthMultiplier==null?1:r.depthMultiplier,this.depthwiseInitializer=kn(r.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=os(r.depthwiseConstraint),this.depthwiseRegularizer=Nn(r.depthwiseRegularizer)}build(r){if(r=Mr(r),r.length<4)throw new ke(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(r)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(r[t]==null||r[t]<0)throw new ke(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${r[t]}).`);let n=r[t],s=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(r,t){return Ie(()=>{r=Xt(r);let n=lze(r,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=Uo(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(r){r=Mr(r);let t=this.dataFormat==="channelsFirst"?r[2]:r[1],n=this.dataFormat==="channelsFirst"?r[3]:r[2],s=this.dataFormat==="channelsFirst"?r[1]*this.depthMultiplier:r[3]*this.depthMultiplier,i=Ao(t,this.kernelSize[0],this.padding,this.strides[0]),a=Ao(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[r[0],s,i,a]:[r[0],i,a,s]}getConfig(){let r=super.getConfig();return r.depthMultiplier=this.depthMultiplier,r.depthwiseInitializer=Mn(this.depthwiseInitializer),r.depthwiseRegularizer=dn(this.depthwiseRegularizer),r.depthwiseConstraint=as(this.depthwiseRegularizer),r}};UO.className="DepthwiseConv2D";et.registerClass(UO);function HY(r,t,n,s){if(Array.isArray(r)){if(t!=null||n!=null)throw new ke("When inputs is an array, neither initialState or constants should be provided");s!=null&&(n=r.slice(r.length-s,r.length),r=r.slice(0,r.length-s)),r.length>1&&(t=r.slice(1,r.length)),r=r[0]}function i(a){return a==null||Array.isArray(a)?a:[a]}return t=i(t),n=i(n),{inputs:r,initialState:t,constants:n}}function jY(r,t,n,s=!1,i,a,o=!1,u=!1){return Ie(()=>{let l=t.shape.length;if(l<3)throw new ke(`Input should be at least 3D, but is ${l}D.`);let c=[1,0].concat(Ro(2,l));t=dr(t,c),a!=null,o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=at(at(i,"bool"),"float32"),i.rank===l-1&&(i=bs(i,-1)),i=dr(i,c)),s&&(t=Sa(t,0),i!=null&&(i=Sa(i,0)));let h=[],d,p=n,f=t.shape[0],m=Bn(t),g;i!=null&&(g=Bn(i));for(let b=0;b<f;++b){let x=m[b],w=Ie(()=>r(x,p));if(i==null)d=w[0],p=w[1];else{let v=Ie(()=>{let S=g[b],E=vt(sa(S),S),C=Ke(Se(w[0],S),Se(p[0],E)),I=p.map((_,A)=>Ke(Se(w[1][A],S),Se(_,E)));return{output:C,newStates:I}});d=v.output,p=v.newStates}u&&h.push(d)}let y;return u&&(y=Yn(h,1)),[d,y,p]})}var El=class qY extends yr{constructor(t){super(t);let n;if(t.cell==null)throw new ke("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new B_({cells:t.cell}):n=t.cell,n.stateSize==null)throw new ke("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Kn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Ro(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){oN(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let s=n[0],i;if(this.returnSequences?i=[t[0],t[1],s]:i=[t[0],s],this.returnState){let a=[];for(let o of n)a.push([t[0],o]);return[i].concat(a)}else return i}computeMask(t,n){return Ie(()=>{Array.isArray(n)&&(n=n[0]);let s=this.returnSequences?n:null;if(this.returnState){let i=this.states.map(a=>null);return[s].concat(i)}else return s})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let s=0;s<t;++s)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new gr("Constants support is not implemented in RNN yet.");oN(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new Kn({shape:[n,null,...s]});let i=[t[0]].concat(t.slice(2));this.cell.build(i);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!O.arraysEqual(this.stateSpec.map(o=>o.shape[o.shape.length-1]),a))throw new ke(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(o=>new Kn({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){Ie(()=>{if(!this.stateful)throw new Ll("Cannot call resetStates() on an RNN Layer that is not stateful.");let s=this.inputSpec[0].shape[0];if(s==null)throw new ke("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>On([s,i])):this.states_=[On([s,this.cell.stateSize])];else if(t==null)nr(this.states_),this.keptStates!=null&&(nr(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>On([s,i])):this.states_[0]=On([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ke(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):nr(this.states_);for(let i=0;i<this.states_.length;++i){let a=t[i],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,u=[s,o];if(!O.arraysEqual(a.shape,u))throw new ke(`State ${i} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${a.shape}`);this.states_[i]=a}}this.states_=this.states_.map(i=>ns(i.clone()))})}apply(t,n){let s=n==null?null:n.initialState,i=n==null?null:n.constants;n==null&&(n={});let a=HY(t,s,i,this.numConstants);t=a.inputs,s=a.initialState,i=a.constants;let o=[],u=[];if(s!=null){n.initialState=s,o=o.concat(s),this.stateSpec=[];for(let l of s)this.stateSpec.push(new Kn({shape:l.shape}));u=u.concat(this.stateSpec)}if(i!=null&&(n.constants=i,o=o.concat(i),this.numConstants=i.length),o[0]instanceof Mo){let l=[t].concat(o),c=this.inputSpec.concat(u),h=this.inputSpec;this.inputSpec=c;let d=super.apply(l,n);return this.inputSpec=h,d}else return super.apply(t,n)}call(t,n){return Ie(()=>{let s=n==null?null:n.mask,i=n==null?null:n.training,a=n==null?null:n.initialState;t=Xt(t),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(t));let o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==o)throw new ke(`RNN Layer has ${o} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let u={training:i},l=jY((f,m)=>{let g=this.cell.call([f].concat(m),u);return[g[0],g.slice(1)]},t,a,this.goBackwards,s,null,this.unroll,this.returnSequences),c=l[0],h=l[1],d=l[2];this.stateful&&this.resetStates(d,i);let p=this.returnSequences?h:c;return this.returnState?[p].concat(d):p})}getInitialState(t){return Ie(()=>{let n=On(t.shape);return n=Tt(n,[1,2]),n=_v(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?iN(n,[1,s]):n):this.cell.stateSize>1?[iN(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let s=this.cell.getConfig();return this.getClassName()===qY.className&&(n.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),t),n)}static fromConfig(t,n,s={}){let i=n.cell,a=To(i,s);return new t(Object.assign(n,{cell:a}))}};El.className="RNN";et.registerClass(El);var Tv=class extends yr{},L_=class extends Tv{constructor(r){super(r),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=r.units,vs(this.units,"units"),this.activation=Ec(r.activation==null?this.DEFAULT_ACTIVATION:r.activation),this.useBias=r.useBias==null?!0:r.useBias,this.kernelInitializer=kn(r.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kn(r.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kn(r.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nn(r.kernelRegularizer),this.recurrentRegularizer=Nn(r.recurrentRegularizer),this.biasRegularizer=Nn(r.biasRegularizer),this.kernelConstraint=os(r.kernelConstraint),this.recurrentConstraint=os(r.recurrentConstraint),this.biasConstraint=os(r.biasConstraint),this.dropout=Jm([1,Cc([0,r.dropout==null?0:r.dropout])]),this.recurrentDropout=Jm([1,Cc([0,r.recurrentDropout==null?0:r.recurrentDropout])]),this.dropoutFunc=r.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(r){r=Mr(r),this.kernel=this.addWeight("kernel",[r[r.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(r,t){return Ie(()=>{if(r=r,r.length!==2)throw new ke(`SimpleRNNCell expects 2 input Tensors, got ${r.length}.`);let n=r[1];r=r[0];let s=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ic({ones:()=>sa(r),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ic({ones:()=>sa(n),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let i,a=this.dropoutMask,o=this.recurrentDropoutMask;a!=null?i=uu(Se(r,a),this.kernel.read()):i=uu(r,this.kernel.read()),this.bias!=null&&(i=Uo(i,this.bias.read())),o!=null&&(n=Se(n,o));let u=Ke(i,uu(n,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){let r=super.getConfig(),t={units:this.units,activation:_c(this.activation),useBias:this.useBias,kernelInitializer:Mn(this.kernelInitializer),recurrentInitializer:Mn(this.recurrentInitializer),biasInitializer:Mn(this.biasInitializer),kernelRegularizer:dn(this.kernelRegularizer),recurrentRegularizer:dn(this.recurrentRegularizer),biasRegularizer:dn(this.biasRegularizer),activityRegularizer:dn(this.activityRegularizer),kernelConstraint:as(this.kernelConstraint),recurrentConstraint:as(this.recurrentConstraint),biasConstraint:as(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},r),t)}};L_.className="SimpleRNNCell";et.registerClass(L_);var WO=class extends El{constructor(r){r.cell=new L_(r),super(r)}call(r,t){return Ie(()=>{this.cell.dropoutMask!=null&&(nr(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nr(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(r,{mask:n,training:s,initialState:i})})}static fromConfig(r,t){return new r(t)}};WO.className="SimpleRNN";et.registerClass(WO);var P_=class extends Tv{constructor(r){if(super(r),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",r.resetAfter)throw new ke("GRUCell does not support reset_after parameter set to true.");this.units=r.units,vs(this.units,"units"),this.activation=Ec(r.activation===void 0?this.DEFAULT_ACTIVATION:r.activation),this.recurrentActivation=Ec(r.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:r.recurrentActivation),this.useBias=r.useBias==null?!0:r.useBias,this.kernelInitializer=kn(r.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kn(r.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kn(r.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nn(r.kernelRegularizer),this.recurrentRegularizer=Nn(r.recurrentRegularizer),this.biasRegularizer=Nn(r.biasRegularizer),this.kernelConstraint=os(r.kernelConstraint),this.recurrentConstraint=os(r.recurrentConstraint),this.biasConstraint=os(r.biasConstraint),this.dropout=Jm([1,Cc([0,r.dropout==null?0:r.dropout])]),this.recurrentDropout=Jm([1,Cc([0,r.recurrentDropout==null?0:r.recurrentDropout])]),this.dropoutFunc=r.dropoutFunc,this.implementation=r.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(r){r=Mr(r);let t=r[r.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(r,t){return Ie(()=>{if(r=r,r.length!==2)throw new ke(`GRUCell expects 2 input Tensors (inputs, h, c), got ${r.length}.`);let n=t.training==null?!1:t.training,s=r[1];r=r[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ic({ones:()=>sa(r),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ic({ones:()=>sa(s),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,o,u,l;0<this.dropout&&this.dropout<1&&(r=Se(r,i[0]));let c=uu(r,this.kernel.read());this.useBias&&(c=Uo(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Se(s,a[0]));let h=this.recurrentKernel.read(),[d,p]=_i(h,[2*this.units,this.units],h.rank-1),f=uu(s,d),[m,g,y]=_i(c,3,c.rank-1),[b,x]=_i(f,2,f.rank-1);o=this.recurrentActivation.apply(Ke(m,b)),u=this.recurrentActivation.apply(Ke(g,x));let w=uu(Se(u,s),p);l=this.activation.apply(Ke(y,w));let v=Ke(Se(o,s),Se(Ke(1,xn(o)),l));return[v,v]})}getConfig(){let r=super.getConfig(),t={units:this.units,activation:_c(this.activation),recurrentActivation:_c(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Mn(this.kernelInitializer),recurrentInitializer:Mn(this.recurrentInitializer),biasInitializer:Mn(this.biasInitializer),kernelRegularizer:dn(this.kernelRegularizer),recurrentRegularizer:dn(this.recurrentRegularizer),biasRegularizer:dn(this.biasRegularizer),activityRegularizer:dn(this.activityRegularizer),kernelConstraint:as(this.kernelConstraint),recurrentConstraint:as(this.recurrentConstraint),biasConstraint:as(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},r),t)}};P_.className="GRUCell";et.registerClass(P_);var GO=class extends El{constructor(r){r.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),r.cell=new P_(r),super(r)}call(r,t){return Ie(()=>{this.cell.dropoutMask!=null&&(nr(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nr(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(r,{mask:n,training:s,initialState:i})})}static fromConfig(r,t){return t.implmentation===0&&(t.implementation=1),new r(t)}};GO.className="GRU";et.registerClass(GO);var Av=class extends Tv{constructor(r){super(r),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=r.units,vs(this.units,"units"),this.activation=Ec(r.activation===void 0?this.DEFAULT_ACTIVATION:r.activation),this.recurrentActivation=Ec(r.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:r.recurrentActivation),this.useBias=r.useBias==null?!0:r.useBias,this.kernelInitializer=kn(r.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kn(r.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kn(r.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=r.unitForgetBias,this.kernelRegularizer=Nn(r.kernelRegularizer),this.recurrentRegularizer=Nn(r.recurrentRegularizer),this.biasRegularizer=Nn(r.biasRegularizer),this.kernelConstraint=os(r.kernelConstraint),this.recurrentConstraint=os(r.recurrentConstraint),this.biasConstraint=os(r.biasConstraint),this.dropout=Jm([1,Cc([0,r.dropout==null?0:r.dropout])]),this.recurrentDropout=Jm([1,Cc([0,r.recurrentDropout==null?0:r.recurrentDropout])]),this.dropoutFunc=r.dropoutFunc,this.implementation=r.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(r){var t;r=Mr(r);let n=r[r.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){let i=this.biasInitializer,a=this.units;s=new(t=class extends ao{apply(o,u){let l=i.apply([a]),c=new C_().apply([a]),h=i.apply([a*2]);return J5(J5(l,c),h)}},t.className="CustomInit",t)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(r,t){return Ie(()=>{let n=t.training==null?!1:t.training;if(r=r,r.length!==3)throw new ke(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${r.length}.`);let s=r[1],i=r[2];r=r[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ic({ones:()=>sa(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ic({ones:()=>sa(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,o=this.recurrentDropoutMask,u,l,c,h;0<this.dropout&&this.dropout<1&&(r=Se(r,a[0]));let d=uu(r,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Se(s,o[0])),d=Ke(d,uu(s,this.recurrentKernel.read())),this.useBias&&(d=Uo(d,this.bias.read()));let[p,f,m,g]=_i(d,4,d.rank-1);u=this.recurrentActivation.apply(p),l=this.recurrentActivation.apply(f),c=Ke(Se(l,i),Se(u,this.activation.apply(m))),h=this.recurrentActivation.apply(g);let y=Se(h,this.activation.apply(c));return[y,y,c]})}getConfig(){let r=super.getConfig(),t={units:this.units,activation:_c(this.activation),recurrentActivation:_c(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Mn(this.kernelInitializer),recurrentInitializer:Mn(this.recurrentInitializer),biasInitializer:Mn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:dn(this.kernelRegularizer),recurrentRegularizer:dn(this.recurrentRegularizer),biasRegularizer:dn(this.biasRegularizer),activityRegularizer:dn(this.activityRegularizer),kernelConstraint:as(this.kernelConstraint),recurrentConstraint:as(this.recurrentConstraint),biasConstraint:as(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},r),t)}};Av.className="LSTMCell";et.registerClass(Av);var HO=class extends El{constructor(r){r.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),r.cell=new Av(r),super(r)}call(r,t){return Ie(()=>{this.cell.dropoutMask!=null&&(nr(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nr(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(r,{mask:n,training:s,initialState:i})})}static fromConfig(r,t){return t.implmentation===0&&(t.implementation=1),new r(t)}};HO.className="LSTM";et.registerClass(HO);var B_=class extends Tv{constructor(r){super(r),this.cells=r.cells}get stateSize(){let r=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?r.push(...t.stateSize):r.push(t.stateSize);return r}call(r,t){return Ie(()=>{r=r;let n=r.slice(1),s=[];for(let o of this.cells.slice().reverse())Array.isArray(o.stateSize)?s.push(n.splice(0,o.stateSize.length)):s.push(n.splice(0,1));s.reverse();let i=[],a;for(let o=0;o<this.cells.length;++o){let u=this.cells[o];n=s[o],o===0?a=[r[0]].concat(n):a=[a[0]].concat(n),a=u.call(a,t),i.push(a.slice(1))}n=[];for(let o of i.slice().reverse())n.push(...o);return[a[0]].concat(n)})}build(r){oN(r)&&(r=r[0]),r=r;let t;this.cells.forEach((n,s)=>{Lh(`RNNCell_${s}`,()=>{n.build(r),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,r=[r[0],t]})}),this.built=!0}getConfig(){let r=super.getConfig(),t=s=>({className:s.getClassName(),config:s.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},r),n)}static fromConfig(r,t,n={}){let s=[];for(let i of t.cells)s.push(To(i,n));return new r({cells:s})}get trainableWeights(){if(!this.trainable)return[];let r=[];for(let t of this.cells)r.push(...t.trainableWeights);return r}get nonTrainableWeights(){let r=[];for(let t of this.cells)r.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(r)}return r}getWeights(){let r=[];for(let t of this.cells)r.push(...t.weights);return uN(r)}setWeights(r){let t=[];for(let n of this.cells){let s=n.weights.length,i=r.splice(s);for(let a=0;a<n.weights.length;++a)t.push([n.weights[a],i[a]])}mO(t)}};B_.className="StackedRNNCells";et.registerClass(B_);function Ic(r){let{ones:t,rate:n,training:s=!1,count:i=1,dropoutFunc:a}=r,o=()=>a!=null?a(t(),n):XX(t(),n),u=()=>Iv(o,t,s);return!i||i<=1?ns(u().clone()):Array(i).fill(void 0).map(u).map(l=>ns(l.clone()))}var cze=function(r,t){var n={};for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&t.indexOf(s)<0&&(n[s]=r[s]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,s=Object.getOwnPropertySymbols(r);i<s.length;i++)t.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(r,s[i])&&(n[s[i]]=r[s[i]]);return n},KY=class extends El{constructor(r){if(r.unroll)throw new gr("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(r.cell))throw new gr("It is not possible at the moment to stack convolutional cells.");super(r),this.inputSpec=[new Kn({ndim:5})]}call(r,t){return Ie(()=>{if(this.cell.dropoutMask!=null&&(nr(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nr(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new ke("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(r,{mask:n,training:s,initialState:i})})}computeOutputShape(r){let t=this.computeSingleOutputShape(r);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([r[0],...t.slice(-3)])]),t}getInitialState(r){return Ie(()=>{let{stateSize:t}=this.cell,n=r.shape,s=this.computeSingleOutputShape(n),i=[s[0],...s.slice(2)],a=On(i);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(r,t=!1){Ie(()=>{if(!this.stateful)throw new Ll("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,s=this.computeSingleOutputShape(n),i=[s[0],...s.slice(2)];if(n[0]==null)throw new ke("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>On(i)):this.states_=[On(i)];else if(r==null)nr(this.states_),this.keptStates!=null&&(nr(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>On(i)):this.states_[0]=On(i);else{if(Array.isArray(r)||(r=[r]),r.length!==this.states_.length)throw new ke(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${r.length} state value(s). Input received: ${r}`);t?this.keptStates.push(this.states_.slice()):nr(this.states_);for(let a=0;a<this.states_.length;++a){let o=r[a],u=i;if(!O.arraysEqual(o.shape,u))throw new ke(`State ${a} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${o.shape}`);this.states_[a]=o}}this.states_=this.states_.map(a=>ns(a.clone()))})}computeSingleOutputShape(r){let{dataFormat:t,filters:n,kernelSize:s,padding:i,strides:a,dilationRate:o}=this.cell,u=t==="channelsFirst",l=r[u?3:2],c=r[u?4:3],h=Ao(l,s[0],i,a[0],o[0]),d=Ao(c,s[1],i,a[1],o[1]);return[...r.slice(0,2),...u?[n,h,d]:[h,d,n]]}};KY.className="ConvRNN2D";var V_=class extends Av{constructor(r){let{filters:t,kernelSize:n,strides:s,padding:i,dataFormat:a,dilationRate:o}=r;super(Object.assign(Object.assign({},r),{units:t})),this.filters=t,vs(this.filters,"filters"),this.kernelSize=ym(n,2,"kernelSize"),this.kernelSize.forEach(u=>vs(u,"kernelSize")),this.strides=ym(s||1,2,"strides"),this.strides.forEach(u=>vs(u,"strides")),this.padding=i||"valid",Ea(this.padding),this.dataFormat=a||"channelsLast",Gn(this.dataFormat),this.dilationRate=ym(o||1,2,"dilationRate"),this.dilationRate.forEach(u=>vs(u,"dilationRate"))}build(r){var t;r=Mr(r);let n=this.dataFormat==="channelsFirst"?1:r.length-1;if(r[n]==null)throw new ke(`The channel dimension of the input should be defined. Found ${r[n]}`);let s=r[n],i=4,a=this.kernelSize.concat([s,this.filters*i]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let o=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){let l=this.biasInitializer,c=this.filters;u=new(t=class extends ao{apply(h,d){let p=l.apply([c]),f=Ci([c]),m=l.apply([c*2]);return oO([p,f,m])}},t.className="CustomInit",t)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(r,t){return Ie(()=>{if(r.length!==3)throw new ke(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${r.length}.`);let n=t.training||!1,s=r[0],i=r[1],a=r[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ic({ones:()=>sa(s),rate:this.dropout,training:n,count:o,dropoutFunc:this.dropoutFunc}));let u=this.dropoutMask,l=(ee,se,re)=>!se||!se[re]?ee:Se(se[re],ee),c=l(s,u,0),h=l(s,u,1),d=l(s,u,2),p=l(s,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ic({ones:()=>sa(i),rate:this.recurrentDropout,training:n,count:o,dropoutFunc:this.dropoutFunc}));let f=this.recurrentDropoutMask,m=l(i,f,0),g=l(i,f,1),y=l(i,f,2),b=l(i,f,3),x=3,[w,v,S,E]=_i(this.kernel.read(),o,x),[C,I,_,A]=this.useBias?_i(this.bias.read(),o):[null,null,null,null];c=this.inputConv(c,w,C,this.padding),h=this.inputConv(h,v,I,this.padding),d=this.inputConv(d,S,_,this.padding),p=this.inputConv(p,E,A,this.padding);let[k,N,D,F]=_i(this.recurrentKernel.read(),o,x);m=this.recurrentConv(m,k),g=this.recurrentConv(g,N),y=this.recurrentConv(y,D),b=this.recurrentConv(b,F);let P=this.recurrentActivation.apply(Ke(c,m)),G=this.recurrentActivation.apply(Ke(h,g)),Y=Ke(Se(G,a),Se(P,this.activation.apply(Ke(d,y)))),Z=Se(this.recurrentActivation.apply(Ke(p,b)),this.activation.apply(Y));return[Z,Z,Y]})}getConfig(){let r=super.getConfig(),{units:t}=r,n=cze(r,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),s)}inputConv(r,t,n,s){let i=ui(r,t,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?Uo(i,n,this.dataFormat):i}recurrentConv(r,t){return ui(r,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};V_.className="ConvLSTM2DCell";et.registerClass(V_);var jO=class extends KY{constructor(r){let t=new V_(r);super(Object.assign(Object.assign({},r),{cell:t}))}static fromConfig(r,t){return new r(t)}};jO.className="ConvLSTM2D";et.registerClass(jO);var z_=class extends yr{constructor(r){super(r),this.rate=Math.max(Math.min(r.rate,1),0),this.noiseShape=r.noiseShape,this.seed=r.seed,this.supportsMasking=!0}getNoiseShape(r){if(this.noiseShape==null)return this.noiseShape;let t=r.shape,n=[];for(let s=0;s<this.noiseShape.length;++s)n.push(this.noiseShape[s]==null?t[s]:this.noiseShape[s]);return n}call(r,t){return Ie(()=>{this.invokeCallHook(r,t);let n=Xt(r);if(0<this.rate&&this.rate<1){let s=t.training==null?!1:t.training,i=this.getNoiseShape(n);return Iv(()=>XX(n,this.rate,i,this.seed),()=>n,s)}return r})}getConfig(){let r={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(r,t),r}dispose(){return super.dispose()}};z_.className="Dropout";et.registerClass(z_);var qO=class extends z_{constructor(r){super(r),this.inputSpec=[{ndim:3}]}getNoiseShape(r){let t=r.shape;return[t[0],1,t[2]]}};qO.className="SpatialDropout1D";et.registerClass(qO);var KO=class extends yr{constructor(r){if(super(r),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",r.batchInputShape==null&&r.inputShape==null&&r.inputDim!=null){let t=null;r.batchSize!=null&&(t=r.batchSize),this.batchInputShape=[t,r.inputDim]}this.units=r.units,vs(this.units,"units"),this.activation=Ec(r.activation),r.useBias!=null&&(this.useBias=r.useBias),this.kernelInitializer=kn(r.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=kn(r.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=os(r.kernelConstraint),this.biasConstraint=os(r.biasConstraint),this.kernelRegularizer=Nn(r.kernelRegularizer),this.biasRegularizer=Nn(r.biasRegularizer),this.activityRegularizer=Nn(r.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(r){r=Mr(r);let t=r[r.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(r){r=Mr(r);let t=r.slice();return t[t.length-1]=this.units,t}call(r,t){return Ie(()=>{this.invokeCallHook(r,t);let n=Xt(r),s=UX(this.activation.getClassName()),i;return s!=null?i=uu(n,this.kernel.read(),s,this.bias?this.bias.read():null):(i=uu(n,this.kernel.read()),this.bias!=null&&(i=Uo(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){let r={units:this.units,activation:_c(this.activation),useBias:this.useBias,kernelInitializer:Mn(this.kernelInitializer),biasInitializer:Mn(this.biasInitializer),kernelRegularizer:dn(this.kernelRegularizer),biasRegularizer:dn(this.biasRegularizer),activityRegularizer:dn(this.activityRegularizer),kernelConstraint:as(this.kernelConstraint),biasConstraint:as(this.biasConstraint)},t=super.getConfig();return Object.assign(r,t),r}};KO.className="Dense";et.registerClass(KO);var XO=class extends yr{constructor(r){r=r||{},super(r),this.inputSpec=[{minNDim:3}],this.dataFormat=r.dataFormat}computeOutputShape(r){r=Mr(r);for(let t of r.slice(1))if(t==null)throw new ke(`The shape of the input to "Flatten" is not fully defined (got ${r.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[r[0],sc(r,1)]}call(r,t){return Ie(()=>{this.invokeCallHook(r,t);let n=Xt(r);if(this.dataFormat==="channelsFirst"&&n.rank>1){let s=[0];for(let i=2;i<n.rank;++i)s.push(i);s.push(1),n=dr(n,s)}return S5e(n)})}getConfig(){let r={};this.dataFormat!=null&&(r.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(r,t),r}};XO.className="Flatten";et.registerClass(XO);var YO=class extends yr{constructor(r){super(r),this.supportsMasking=!0,this.activation=Ec(r.activation)}call(r,t){return Ie(()=>{this.invokeCallHook(r,t);let n=Xt(r);return this.activation.apply(n)})}getConfig(){let r={activation:_c(this.activation)},t=super.getConfig();return Object.assign(r,t),r}};YO.className="Activation";et.registerClass(YO);var ZO=class extends yr{constructor(r){super(r),this.n=r.n,this.inputSpec=[{ndim:2}]}computeOutputShape(r){return[r[0],this.n,r[1]]}call(r,t){return Ie(()=>(r=Xt(r),v5e(r,this.n)))}getConfig(){let r={n:this.n},t=super.getConfig();return Object.assign(r,t),r}};ZO.className="RepeatVector";et.registerClass(ZO);var JO=class extends yr{constructor(r){super(r),this.targetShape=r.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(r){return r<0||r==null}fixUnknownDimension(r,t){let n="Total size of new array must be unchanged.",s=t.slice(),i=1,a=null;for(let u=0;u<s.length;++u){let l=s[u];if(this.isUnknown(l))if(a===null)a=u;else throw new ke("Can only specifiy one unknown dimension.");else i*=l}let o=sc(r);if(a!==null){if(i===0||o%i!==0)throw new ke(n);s[a]=o/i}else if(o!==i)throw new ke(n);return s}computeOutputShape(r){let t=!1;for(let n=0;n<r.length;++n)if(this.isUnknown(r[n])){t=!0;break}return t?r.slice(0,1).concat(this.targetShape):r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape))}call(r,t){return Ie(()=>{this.invokeCallHook(r,t);let n=Xt(r),s=n.shape,i=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return Ee(n,i)})}getConfig(){let r={targetShape:this.targetShape},t=super.getConfig();return Object.assign(r,t),r}};JO.className="Reshape";et.registerClass(JO);var QO=class extends yr{constructor(r){if(super(r),r.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(r.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${r.dims} instead.`);let t=Ro(1,r.dims.length+1);if(!O.arraysEqual(r.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(r.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=r.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Kn({ndim:this.dims.length+1})]}computeOutputShape(r){r=Mr(r);let t=r.slice();return this.dims.forEach((n,s)=>{t[s+1]=r[n]}),t}call(r,t){return dr(Xt(r),this.dimsIncludingBatch)}getConfig(){let r={dims:this.dims},t=super.getConfig();return Object.assign(r,t),r}};QO.className="Permute";et.registerClass(QO);var eM=class extends yr{constructor(r){super(r??{}),this.supportsMasking=!0,r!=null?this.maskValue=r.maskValue==null?0:r.maskValue:this.maskValue=0}computeOutputShape(r){return r}getConfig(){let r=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,r),t}computeMask(r,t){let n=Xt(r);return Xb(vd(n,this.maskValue),-1)}call(r,t){return Ie(()=>{this.invokeCallHook(r,t);let n=Xt(r),s=Xb(vd(n,this.maskValue),-1,!0);return Se(n,at(s,n.dtype))})}};eM.className="Masking";et.registerClass(eM);var tM=class extends yr{constructor(r){if(super(r),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",r.batchInputShape==null&&r.inputShape==null){let t=null;r.batchSize!=null&&(t=r.batchSize),r.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Kr(r.inputLength))}this.inputDim=r.inputDim,vs(this.inputDim,"inputDim"),this.outputDim=r.outputDim,vs(this.outputDim,"outputDim"),this.embeddingsInitializer=kn(r.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Nn(r.embeddingsRegularizer),this.activityRegularizer=Nn(r.activityRegularizer),this.embeddingsConstraint=os(r.embeddingsConstraint),this.maskZero=r.maskZero,this.supportsMasking=r.maskZero,this.inputLength=r.inputLength}build(r){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(r){}computeMask(r,t){return Ie(()=>this.maskZero?(r=Xt(r),vd(r,Cr(r))):null)}computeOutputShape(r){if(r=Mr(r),this.inputLength==null)return[...r,this.outputDim];let t=Kr(this.inputLength);if(t.length!==r.length-1)throw new ke(`"inputLength" is ${this.inputLength}, but received input shape has shape ${r}`);{let n=0;for(let s=0;s<t.length;++s){let i=t[s],a=r[s+1];if(i!=null&&a!=null&&i!==a)throw new ke(`"inputLength" is ${this.inputLength}, but received input shape has shape ${r}`);i==null&&(t[n]=a),n++}}return[r[0],...t,this.outputDim]}call(r,t){return Ie(()=>{this.invokeCallHook(r,t);let n=Xt(r);n.dtype!=="int32"&&(n=dl(n,"int32"));let s=KX(this.embeddings.read(),Ee(n,[n.size]));return Ee(s,Mr(this.computeOutputShape(n.shape)))})}getConfig(){let r={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Mn(this.embeddingsInitializer),embeddingsRegularizer:dn(this.embeddingsRegularizer),activityRegularizer:dn(this.activityRegularizer),embeddingsConstraint:as(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(r,t),r}};tM.className="Embedding";et.registerClass(tM);var gf=class extends yr{constructor(r){super(r||{}),this.supportsMasking=!0}mergeFunction(r){throw new gr}computeElementwiseOpOutputShape(r,t){if(r==null||t==null)return null;if(r.length<t.length)return this.computeElementwiseOpOutputShape(t,r);if(t.length===0)return r;let n=r.slice(0,r.length-t.length);for(let s=0;s<t.length;++s){let i=r[r.length-t.length+s],a=t[s];if(i==null||a==null||i<0||a<0)n.push(null);else if(i===1)n.push(a);else if(a===1)n.push(i);else{if(i!==a)throw new ke("Operands could not be broadcast together with shapes "+JSON.stringify(r)+" "+JSON.stringify(t));n.push(i)}}return n}build(r){if(Array.isArray(r)&&!Array.isArray(r[0])&&(r=[Mr(r)]),r=r,r.length<2)throw new ke(`A merge layer should be called on an Array of at least 2 inputs. Got ${r.length} input(s).`);let t=[];for(let i of r)i!=null&&i[0]!==null&&t.push(i[0]);if(t=nc(t),t.length>1)throw new ke(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(r)}.`);let n=r[0]==null?null:r[0].slice(1);for(let i=1;i<r.length;++i){let a=r[i]==null?null:r[i].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let s=r.map(i=>i.length);r.indexOf(null)===-1&&nc(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(r,t){return Ie(()=>{if(r=r,this.reshapeRequired){let n=[],s=r.map(i=>i.rank);if(s.indexOf(null)===-1){let i=Cc(s);for(let a of r){let o=a.rank;for(let u=0;u<i-o;++u)a=_v(a,1);n.push(a)}return this.mergeFunction(n)}else{let i=!1;for(let u of r){let l=u.rank;if(l==null){let c=u.shape,h=c[0],d=c.slice(1).concat([h]),p=Ee(u,[h].concat(sc(c.slice(1))));p=dr(p,[1,0]),p=Ee(p,d),n.push(p),i=!0}else if(l>1){let c=Ro(1,l).concat([0]);n.push(dr(u,c)),i=!0}else n.push(u)}let a=this.mergeFunction(n),o=a.rank;if(i){if(o==null){let u=a.shape,l=u.length,c=u[l-1],h=[c].concat(u.slice(0,u.length-1));a=Ee(dr(Ee(a,[-1,c]),[1,0]),h)}else if(o>1){let u=[o-1].concat(Ro(0,o-1));a=dr(a,u)}}return a}}else return this.mergeFunction(r)})}computeOutputShape(r){r=r;let t;r[0]==null?t=null:t=r[0].slice(1);for(let s=1;s<r.length;++s){let i=r[s]==null?null:r[s].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let n=[];for(let s of r)s!=null&&s[0]!==null&&n.push(s[0]);return n=nc(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(r,t){return Ie(()=>{if(t==null)return null;if(!Array.isArray(t))throw new ke("`mask` should be an Array");if(!Array.isArray(r))throw new ke("`inputs` should be an Array");if(t.length!==r.length)throw new ke(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${r.length} vs ${t.length})`);if(t.every(s=>s==null))return null;t=t.map(s=>s==null?s:bs(s,0));let n=t[0];for(let s=1;s<t.length-1;++s)n=Za(n,t[s]);return n})}},rM=class extends gf{constructor(r){super(r)}mergeFunction(r){return Ie(()=>{let t=r[0].clone();for(let n=1;n<r.length;++n)t=Ke(t,r[n]);return t})}};rM.className="Add";et.registerClass(rM);var nM=class extends gf{constructor(r){super(r)}mergeFunction(r){return Ie(()=>{let t=r[0].clone();for(let n=1;n<r.length;++n)t=Se(t,r[n]);return t})}};nM.className="Multiply";et.registerClass(nM);var sM=class extends gf{constructor(r){super(r)}mergeFunction(r){return Ie(()=>{let t=r[0].clone();for(let n=1;n<r.length;++n)t=Ke(t,r[n]);return Se(1/r.length,t)})}};sM.className="Average";et.registerClass(sM);var iM=class extends gf{constructor(r){super(r)}mergeFunction(r){return Ie(()=>{let t=r[0];for(let n=1;n<r.length;++n)t=Iu(t,r[n]);return t})}};iM.className="Maximum";et.registerClass(iM);var aM=class extends gf{constructor(r){super(r)}mergeFunction(r){return Ie(()=>{let t=r[0];for(let n=1;n<r.length;++n)t=wc(t,r[n]);return t})}};aM.className="Minimum";et.registerClass(aM);var oM=class extends gf{constructor(r){super(r),this.DEFAULT_AXIS=-1,r==null&&(r={}),this.axis=r.axis==null?this.DEFAULT_AXIS:r.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(r){if(!(Array.isArray(r)&&Array.isArray(r[0]))||r.length===1)throw new ke("A `Concatenate` layer should be called on a list of at least 2 inputs");r=r;let t=!0;for(let s of r)if(s!=null){t=!1;break}if(t)return;let n=[];for(let s=0;s<r.length;++s){let i=r[s].slice();i.splice(this.axis,1);let a=!1;for(let o of n)if(O.arraysEqual(o,i)){a=!0;break}a||n.push(i)}if(n.length>1)throw new ke("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(r))}mergeFunction(r){return Ie(()=>oO(r,this.axis))}computeOutputShape(r){if(!(Array.isArray(r)&&Array.isArray(r[0])))throw new ke("A `Concatenate` layer should be called on a list of inputs.");let t=r,n=t[0].slice(),s=this.axis<0?n.length+this.axis:this.axis;for(let i of t.slice(1)){if(n[s]==null||i[s]==null){n[s]=null;break}n[s]+=i[s]}return n}computeMask(r,t){if(t==null)return null;if(!Array.isArray(t))throw new ke("`mask` should be an array for Concatenate");if(!Array.isArray(r))throw new ke("`inputs` should be an array for Concatenate");if(t.length!==r.length)throw new ke(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${r.length})`);return Ie(()=>{let n=!0;if(t.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;let s=[];for(let a=0;a<r.length;++a)t[a]==null?s.push(at(sa(r[a]),"bool")):t[a].rank<r[a].rank?s.push(bs(t[a],-1)):s.push(t[a]);let i=an(s,this.axis);return WC(i,-1,!1)})}getConfig(){let r={axis:this.axis},t=super.getConfig();return Object.assign(r,t),r}};oM.className="Concatenate";et.registerClass(oM);function my(r,t){for(;r<0;)r+=t;return r}function hze(r,t,n){if(r.shape.length>3||t.shape.length>3)throw new gr("batchDot is not implemented for tensors of 4D or higher rank yet");if(O.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),O.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),r.dtype==="complex64"||t.dtype==="complex64")throw new gr("batchDot is not implemented for complex64-type Tensors yet.");let s=r.shape.length,i=t.shape.length;n==null&&(n=[s-1,i-2]);let a=n;return Ie(()=>{let o;if(s>i){o=s-i;let l=[];for(let c=0;c<o;++c)l.push(1);t=Ee(t,t.shape.concat(l))}else if(i>s){o=i-s;let l=[];for(let c=0;c<o;++c)l.push(1);r=Ee(r,r.shape.concat(l))}else o=0;let u;if(r.shape.length===2&&t.shape.length===2)a[0]===a[1]?u=Tt(Se(r,t),a[0]):u=Tt(Se(dr(r,[1,0]),t),a[1]);else{let l=a[0]!==r.shape.length-1,c=a[1]===t.shape.length-1;u=cr(r,t,l,c)}if(o>0){let l;s>i?l=s+i-3:l=s-1;let c=[];for(let h=l;h<l+o;++h)c.push(h);u=Gc(u,c)}return u.shape.length===1&&(u=bs(u,1)),u})}var uM=class extends gf{constructor(r){super(r),this.axes=r.axes,this.normalize=r.normalize==null?!1:r.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(r){O.assert(Array.isArray(r)&&r.length===2&&Array.isArray(r[0])&&Array.isArray(r[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=r[0],n=r[1];if(t.length>3||n.length>3)throw new gr("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(t,n);if(t[s[0]]!==n[s[1]])throw new ke(`Dimension incompatibility: ${t[s[0]]} !== ${n[s[1]]}`)}mergeFunction(r){if(r.length!==2)throw new ke(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${r.length} input(s).`);let t=r[0],n=r[1],s;return Array.isArray(this.axes)?s=this.axes.map((i,a)=>my(i,r[a].shape.length)):s=[my(this.axes,t.shape.length),my(this.axes,n.shape.length)],this.normalize&&(t=W2(t,s[0]),n=W2(n,s[1])),hze(t,n,s)}interpretAxes(r,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[my(this.axes,r.length),my(this.axes,t.length)],n}computeOutputShape(r){O.assert(Array.isArray(r)&&r.length===2&&Array.isArray(r[0])&&Array.isArray(r[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=r[0].slice(),n=r[1].slice();if(t.length>3||n.length>3)throw new gr("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(t,n);t.splice(s[0],1),n.splice(s[1],1),n.splice(0,1);let i=t.concat(n);return i.length===1&&i.push(1),i}computeMask(r,t){return null}getConfig(){let r={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(r,t),r}};uM.className="Dot";et.registerClass(uM);var lM=class extends yr{constructor(r){super(r),this.supportsMasking=!0,this.stddev=r.stddev}computeOutputShape(r){return r}getConfig(){let r=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,r),t}call(r,t){return Ie(()=>{this.invokeCallHook(r,t);let n=Xt(r);return Iv(()=>Ke(S_(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};lM.className="GaussianNoise";et.registerClass(lM);var cM=class extends yr{constructor(r){super(r),this.supportsMasking=!0,this.rate=r.rate}computeOutputShape(r){return r}getConfig(){let r=super.getConfig(),t={rate:this.rate};return Object.assign(t,r),t}call(r,t){return Ie(()=>{this.invokeCallHook(r,t);let n=Xt(r);return this.rate>0&&this.rate<1?Iv(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return Se(n,S_(n.shape,1,s))},()=>n,t.training||!1):n})}};cM.className="GaussianDropout";et.registerClass(cM);var hM=class extends yr{constructor(r){super(r),this.supportsMasking=!0,this.rate=r.rate,this.noiseShape=r.noiseShape}_getNoiseShape(r){return this.noiseShape||Xt(r).shape}computeOutputShape(r){return r}getConfig(){let r=super.getConfig(),t={rate:this.rate};return Object.assign(t,r),t}call(r,t){return Ie(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(r);return Iv(()=>{let s=Xt(r),i=-1.6732632423543772*1.0507009873554805,a=Sl(Uc(n),this.rate);a=dl(a,"float32");let o=((1-this.rate)*(1+this.rate*i**2))**-.5,u=-o*i*this.rate,l=Ke(Se(s,a),Se(Ke(a,-1),i));return Ke(Se(l,o),u)},()=>Xt(r),t.training||!1)}return r})}};hM.className="AlphaDropout";et.registerClass(hM);function tx(r,t,n,s,i,a=.001){let o;if(r.rank===2)o=QR(r,t,n,s,i,a);else if(r.rank===3)o=e3(r,t,n,s,i,a);else if(r.rank===4)o=t3(r,t,n,s,i,a);else throw new gr(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return o}function dze(r,t,n,s,i=.001){return Ie(()=>{let a=gv(r,s),o=a.mean,u=a.variance;return[tx(r,o,u,n,t,i),o,u]})}function pze(r,t,n,s,i=.001){return Ie(()=>{let a=gv(r,s),o=a.mean,u=a.variance,l=[];for(let f of Ro(0,r.rank))s.indexOf(f)!==-1?l.push(1):l.push(r.shape[f]);let c=Ee(o,l),h=Ee(u,l),d=t==null?null:Ee(t,l),p=n==null?null:Ee(n,l);return[tx(r,c,h,p,d,i),o,u]})}function fze(r,t,n,s,i=.001){return O.arraysEqual(s.slice().sort(),Ro(0,r.rank-1))?dze(r,t,n,s,i):pze(r,t,n,s,i)}var dM=class extends yr{constructor(r){r==null&&(r={}),super(r),this.supportsMasking=!0,this.axis=r.axis==null?-1:r.axis,this.momentum=r.momentum==null?.99:r.momentum,this.epsilon=r.epsilon==null?.001:r.epsilon,this.center=r.center==null?!0:r.center,this.scale=r.scale==null?!0:r.scale,this.betaInitializer=kn(r.betaInitializer||"zeros"),this.gammaInitializer=kn(r.gammaInitializer||"ones"),this.movingMeanInitializer=kn(r.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=kn(r.movingVarianceInitializer||"ones"),this.betaConstraint=os(r.betaConstraint),this.gammaConstraint=os(r.gammaConstraint),this.betaRegularizer=Nn(r.betaRegularizer),this.gammaRegularizer=Nn(r.gammaRegularizer)}build(r){r=Mr(r);let t=this.axis>=0?this.axis:this.axis+r.length,n=r[t];if(n==null)throw new ke(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(r)}.`);this.inputSpec=[new Kn({ndim:r.length,axes:{[t]:n}})];let s=[n];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(r,t){return Ie(()=>{let n=t.training==null?!1:t.training,s=Xt(r),i=s.shape,a=i.length,o=Ro(0,a),u=this.axis>=0?this.axis:this.axis+a;o.splice(u,1);let l=Sd(1,a);l[u]=i[u];let c=o.slice();c.sort();let h=!O.arraysEqual(c,Ro(0,a).slice(0,a-1)),d=()=>{if(h){let y=Ee(this.movingMean.read(),l),b=Ee(this.movingVariance.read(),l),x=this.center?Ee(this.beta.read(),l):null,w=this.scale?Ee(this.gamma.read(),l):null;return tx(s,y,b,x,w,this.epsilon)}else return tx(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[p,f,m]=fze(s,this.gamma.read(),this.beta.read(),o,this.epsilon),g=(y,b,x)=>{Ie(()=>{let w=1-x,v=y.read(),S=Se(vt(v,b),w);y.write(vt(v,S))})};return g(this.movingMean,f,this.momentum),g(this.movingVariance,m,this.momentum),p})}getConfig(){let r={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Mn(this.betaInitializer),gammaInitializer:Mn(this.gammaInitializer),movingMeanInitializer:Mn(this.movingMeanInitializer),movingVarianceInitializer:Mn(this.movingVarianceInitializer),betaRegularizer:dn(this.betaRegularizer),gammaRegularizer:dn(this.gammaRegularizer),betaConstraint:as(this.betaConstraint),gammaConstraint:as(this.gammaConstraint)},t=super.getConfig();return Object.assign(r,t),r}};dM.className="BatchNormalization";et.registerClass(dM);var pM=class extends yr{constructor(r){if(r==null&&(r={}),super(r),this.axis=r.axis==null?-1:r.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=r.epsilon==null?.001:r.epsilon,this.center=r.center==null?!0:r.center,this.scale=r.scale==null?!0:r.scale,this.betaInitializer=kn(r.betaInitializer||"zeros"),this.gammaInitializer=kn(r.gammaInitializer||"ones"),this.betaRegularizer=Nn(r.betaRegularizer),this.gammaRegularizer=Nn(r.gammaRegularizer),this.supportsMasking=!0}build(r){r=Mr(r);let t=r.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(let i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==nc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(i=>r[i]),s=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(r,t){let n=Xt(r),s=n.shape,i=s.length;return Ie(()=>{let{mean:a,variance:o}=gv(n,this.axis,!0),u=Sd(1,i);for(let f of this.axis)u[f]=s[f];let l=f=>f!=null&&f.shape.length!==i?Ee(f,u):f,c=this.scale?l(this.gamma.read()):null,h=this.center?l(this.beta.read()):null,d=[],p=[];for(let f=0;f<i;++f)this.axis.indexOf(f)!==-1?(d.push(s[f]),p.push(1)):(d.push(1),p.push(s[f]));return a=Zi(a,d),o=Zi(o,d),c!=null&&(c=Zi(c,p)),h!=null&&(h=Zi(h,p)),tx(n,a,o,h,c,this.epsilon)})}getConfig(){let r={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Mn(this.betaInitializer),gammaInitializer:Mn(this.gammaInitializer),betaRegularizer:dn(this.betaRegularizer),gammaRegularizer:dn(this.gammaRegularizer)},t=super.getConfig();return Object.assign(r,t),r}};pM.className="LayerNormalization";et.registerClass(pM);function mze(r,t,n){return Ie(()=>{if(r.rank!==4)throw new ke(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new ke("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Oo()),n!=="channelsLast"&&n!=="channelsFirst")throw new ke(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return n==="channelsFirst"?s=[[0,0],[0,0],t[0],t[1]]:s=[[0,0],t[0],t[1],[0,0]],zo(r,s)})}var fM=class extends yr{constructor(r){if(r==null&&(r={}),super(r),this.dataFormat=r.dataFormat==null?Oo():r.dataFormat,r.padding==null)this.padding=[[1,1],[1,1]];else if(typeof r.padding=="number")this.padding=[[r.padding,r.padding],[r.padding,r.padding]];else{if(r.padding=r.padding,r.padding.length!==2)throw new ke(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${r.padding.length} array.`);let t,n;if(typeof r.padding[0]=="number")t=[r.padding[0],r.padding[0]],n=[r.padding[1],r.padding[1]];else{if(r.padding=r.padding,r.padding[0].length!==2)throw new ke(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${r.padding[0].length} array.`);if(t=r.padding[0],r.padding[1].length!==2)throw new ke(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${r.padding[1].length} array.`);n=r.padding[1]}this.padding=[t,n]}this.inputSpec=[new Kn({ndim:4})]}computeOutputShape(r){r=Mr(r);let t,n;return this.dataFormat==="channelsFirst"?(r[2]!=null&&r[2]>=0?t=r[2]+this.padding[0][0]+this.padding[0][1]:t=null,r[3]!=null&&r[3]>=0?n=r[3]+this.padding[1][0]+this.padding[1][1]:n=null,[r[0],r[1],t,n]):(r[1]!=null&&r[1]>=0?t=r[1]+this.padding[0][0]+this.padding[0][1]:t=null,r[2]!=null&&r[2]>=0?n=r[2]+this.padding[1][0]+this.padding[1][1]:n=null,[r[0],t,n,r[3]])}call(r,t){return Ie(()=>mze(Xt(r),this.padding,this.dataFormat))}getConfig(){let r={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(r,t),r}};fM.className="ZeroPadding2D";et.registerClass(fM);function U_(r,t,n,s,i,a){return Ie(()=>{Gn(i),GX(a),Ea(s),n==null&&(n=[1,1]),s==null&&(s="valid"),i==null&&(i=Oo()),a==null&&(a="max"),r=OO(r,i);let o,u=s==="same"?"same":"valid";return a==="max"?o=ps(r,t,n,u):o=wl(r,t,n,u),i==="channelsFirst"&&(o=dr(o,[0,3,1,2])),o})}function XY(r,t,n,s,i,a){return Ie(()=>{Gn(i),GX(a),Ea(s),n==null&&(n=[1,1,1]),s==null&&(s="valid"),i==null&&(i=Oo()),a==null&&(a="max"),r=LY(r,i);let o,u=s==="same"?"same":"valid";return a==="max"?o=E3(r,t,n,u):o=JR(r,t,n,u),i==="channelsFirst"&&(o=dr(o,[0,4,1,2,3])),o})}var YY=class extends yr{constructor(r){if(r.poolSize==null&&(r.poolSize=2),super(r),typeof r.poolSize=="number")this.poolSize=[r.poolSize];else if(Array.isArray(r.poolSize)&&r.poolSize.length===1&&typeof r.poolSize[0]=="number")this.poolSize=r.poolSize;else throw new ke(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(r.poolSize)}`);if(vs(this.poolSize,"poolSize"),r.strides==null)this.strides=this.poolSize;else if(typeof r.strides=="number")this.strides=[r.strides];else if(Array.isArray(r.strides)&&r.strides.length===1&&typeof r.strides[0]=="number")this.strides=r.strides;else throw new ke(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(r.strides)}`);vs(this.strides,"strides"),this.padding=r.padding==null?"valid":r.padding,Ea(this.padding),this.inputSpec=[new Kn({ndim:3})]}computeOutputShape(r){r=Mr(r);let t=Ao(r[1],this.poolSize[0],this.padding,this.strides[0]);return[r[0],t,r[2]]}call(r,t){return Ie(()=>{this.invokeCallHook(r,t),r=_v(Xt(r),2);let n=this.poolingFunction(Xt(r),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Gc(n,[2])})}getConfig(){let r={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(r,t),r}},mM=class extends YY{constructor(r){super(r)}poolingFunction(r,t,n,s,i){return Gn(i),Ea(s),U_(r,t,n,s,i,"max")}};mM.className="MaxPooling1D";et.registerClass(mM);var gM=class extends YY{constructor(r){super(r)}poolingFunction(r,t,n,s,i){return Gn(i),Ea(s),U_(r,t,n,s,i,"avg")}};gM.className="AveragePooling1D";et.registerClass(gM);var ZY=class extends yr{constructor(r){if(r.poolSize==null&&(r.poolSize=[2,2]),super(r),this.poolSize=Array.isArray(r.poolSize)?r.poolSize:[r.poolSize,r.poolSize],r.strides==null)this.strides=this.poolSize;else if(Array.isArray(r.strides)){if(r.strides.length!==2)throw new ke(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${r.strides.length}.`);this.strides=r.strides}else this.strides=[r.strides,r.strides];vs(this.poolSize,"poolSize"),vs(this.strides,"strides"),this.padding=r.padding==null?"valid":r.padding,this.dataFormat=r.dataFormat==null?"channelsLast":r.dataFormat,Gn(this.dataFormat),Ea(this.padding),this.inputSpec=[new Kn({ndim:4})]}computeOutputShape(r){r=Mr(r);let t=this.dataFormat==="channelsFirst"?r[2]:r[1],n=this.dataFormat==="channelsFirst"?r[3]:r[2];return t=Ao(t,this.poolSize[0],this.padding,this.strides[0]),n=Ao(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[r[0],r[1],t,n]:[r[0],t,n,r[3]]}call(r,t){return Ie(()=>(this.invokeCallHook(r,t),this.poolingFunction(Xt(r),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let r={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(r,t),r}},yM=class extends ZY{constructor(r){super(r)}poolingFunction(r,t,n,s,i){return Gn(i),Ea(s),U_(r,t,n,s,i,"max")}};yM.className="MaxPooling2D";et.registerClass(yM);var bM=class extends ZY{constructor(r){super(r)}poolingFunction(r,t,n,s,i){return Gn(i),Ea(s),U_(r,t,n,s,i,"avg")}};bM.className="AveragePooling2D";et.registerClass(bM);var JY=class extends yr{constructor(r){if(r.poolSize==null&&(r.poolSize=[2,2,2]),super(r),this.poolSize=Array.isArray(r.poolSize)?r.poolSize:[r.poolSize,r.poolSize,r.poolSize],r.strides==null)this.strides=this.poolSize;else if(Array.isArray(r.strides)){if(r.strides.length!==3)throw new ke(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${r.strides.length}.`);this.strides=r.strides}else this.strides=[r.strides,r.strides,r.strides];vs(this.poolSize,"poolSize"),vs(this.strides,"strides"),this.padding=r.padding==null?"valid":r.padding,this.dataFormat=r.dataFormat==null?"channelsLast":r.dataFormat,Gn(this.dataFormat),Ea(this.padding),this.inputSpec=[new Kn({ndim:5})]}computeOutputShape(r){r=Mr(r);let t=this.dataFormat==="channelsFirst"?r[2]:r[1],n=this.dataFormat==="channelsFirst"?r[3]:r[2],s=this.dataFormat==="channelsFirst"?r[4]:r[3];return t=Ao(t,this.poolSize[0],this.padding,this.strides[0]),n=Ao(n,this.poolSize[1],this.padding,this.strides[1]),s=Ao(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[r[0],r[1],t,n,s]:[r[0],t,n,s,r[4]]}call(r,t){return Ie(()=>(this.invokeCallHook(r,t),this.poolingFunction(Xt(r),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let r={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(r,t),r}},xM=class extends JY{constructor(r){super(r)}poolingFunction(r,t,n,s,i){return Gn(i),Ea(s),XY(r,t,n,s,i,"max")}};xM.className="MaxPooling3D";et.registerClass(xM);var vM=class extends JY{constructor(r){super(r)}poolingFunction(r,t,n,s,i){return Gn(i),Ea(s),XY(r,t,n,s,i,"avg")}};vM.className="AveragePooling3D";et.registerClass(vM);var QY=class extends yr{constructor(r){super(r),this.inputSpec=[new Kn({ndim:3})]}computeOutputShape(r){return[r[0],r[2]]}call(r,t){throw new gr}},wM=class extends QY{constructor(r){super(r||{})}call(r,t){return Ie(()=>{let n=Xt(r);return Rn(n,1)})}};wM.className="GlobalAveragePooling1D";et.registerClass(wM);var SM=class extends QY{constructor(r){super(r||{})}call(r,t){return Ie(()=>{let n=Xt(r);return ya(n,1)})}};SM.className="GlobalMaxPooling1D";et.registerClass(SM);var eZ=class extends yr{constructor(r){super(r),this.dataFormat=r.dataFormat==null?"channelsLast":r.dataFormat,Gn(this.dataFormat),this.inputSpec=[new Kn({ndim:4})]}computeOutputShape(r){return r=r,this.dataFormat==="channelsLast"?[r[0],r[3]]:[r[0],r[1]]}call(r,t){throw new gr}getConfig(){let r={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(r,t),r}},CM=class extends eZ{call(r,t){return Ie(()=>{let n=Xt(r);return this.dataFormat==="channelsLast"?Rn(n,[1,2]):Rn(n,[2,3])})}};CM.className="GlobalAveragePooling2D";et.registerClass(CM);var _M=class extends eZ{call(r,t){return Ie(()=>{let n=Xt(r);return this.dataFormat==="channelsLast"?ya(n,[1,2]):ya(n,[2,3])})}};_M.className="GlobalMaxPooling2D";et.registerClass(_M);var tZ=class extends yr{constructor(r){super(r),this.layer=r.layer}build(r){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(r){this.layer!=null&&(this.layer.trainable=r)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(r){this.layer.setWeights(r)}getConfig(){let r={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(r,t),r}setFastWeightInitDuringBuild(r){super.setFastWeightInitDuringBuild(r),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(r)}static fromConfig(r,t,n={}){let s=t.layer,i=To(s,n);delete t.layer;let a={layer:i};return Object.assign(a,t),new r(a)}},EM=class extends tZ{constructor(r){super(r),this.supportsMasking=!0}build(r){if(r=Mr(r),r.length<3)throw new ke(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(r)}`);this.inputSpec=[{shape:r}];let t=[r[0]].concat(r.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(r)}computeOutputShape(r){r=Mr(r);let t=[r[0]].concat(r.slice(2)),n=this.layer.computeOutputShape(t),s=r[1];return[n[0],s].concat(n.slice(1))}call(r,t){return Ie(()=>(r=Xt(r),jY((n,s)=>[Xt(this.layer.call(n,t)),[]],r,[],!1,null,null,!1,!0)[1]))}};EM.className="TimeDistributed";et.registerClass(EM);function gze(r){ff(m5e,"BidirectionalMergeMode",r)}var yze="concat",IM=class extends tZ{constructor(r){super(r);let t=r.layer.getConfig(),n={};n.className=r.layer.getClassName(),n.config=t,this.forwardLayer=To(n),t.goBackwards=t.goBackwards!==!0;let s={};if(s.className=r.layer.getClassName(),s.config=t,this.backwardLayer=To(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=r.mergeMode===void 0?yze:r.mergeMode,gze(this.mergeMode),r.weights)throw new gr("weights support is not implemented for Bidirectional layer yet.");this._stateful=r.layer.stateful,this.returnSequences=r.layer.returnSequences,this.returnState=r.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=r.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(r){this._trainable=r,this.forwardLayer!=null&&(this.forwardLayer.trainable=r),this.backwardLayer!=null&&(this.backwardLayer.trainable=r)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(r){let t=r.length,n=Math.floor(t/2);this.forwardLayer.setWeights(r.slice(0,n)),this.backwardLayer.setWeights(r.slice(n))}computeOutputShape(r){let t=this.forwardLayer.computeOutputShape(r);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,s,i;return this.returnState&&(i=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,s=[n]):this.mergeMode==null?s=[n,n.slice()]:s=[n],this.returnState?this.mergeMode==null?s.concat(i).concat(i.slice()):[n].concat(i).concat(i.slice()):wi(s)}apply(r,t){let n=t==null?null:t.initialState,s=t==null?null:t.constants;t==null&&(t={});let i=HY(r,n,s,this.numConstants);if(r=i.inputs,n=i.initialState,s=i.constants,Array.isArray(r)&&(n=r.slice(1),r=r[0]),(n==null||n.length===0)&&s==null)return super.apply(r,t);let a=[],o=[];if(n!=null){let l=n.length;if(l%2>0)throw new ke("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);let c=n.map(h=>new Kn({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,l/2),this.backwardLayer.stateSpec=c.slice(l/2),o.push(...c)}if(s!=null)throw new gr("Support for constants in Bidirectional layers is not implemented yet.");let u=a[0]instanceof Mo;for(let l of a)if(l instanceof Mo!==u)throw new ke("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){let l=[r].concat(a),c=this.inputSpec.concat(o),h=this.inputSpec;this.inputSpec=c;let d=super.apply(l,t);return this.inputSpec=h,d}else return super.apply(r,t)}call(r,t){return Ie(()=>{let n=t.initialState,s,i;if(n==null)s=this.forwardLayer.call(r,t),i=this.backwardLayer.call(r,t);else{let u=n.slice(0,n.length/2),l=n.slice(n.length/2);s=this.forwardLayer.call(r,Object.assign(t,{initialState:u})),i=this.backwardLayer.call(r,Object.assign(t,{initialState:l}))}let a;this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(i.slice(1))),s=s[0],i=i[0]),this.returnSequences&&(i=Sa(i,1));let o;return this.mergeMode==="concat"?o=oO([s,i]):this.mergeMode==="sum"?o=Ke(s,i):this.mergeMode==="ave"?o=Se(.5,Ke(s,i)):this.mergeMode==="mul"?o=Se(s,i):this.mergeMode==null&&(o=[s,i]),this.returnState?this.mergeMode==null?o.concat(a):[o].concat(a):o})}resetStates(r){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(r){Lh(this.forwardLayer.name,()=>{this.forwardLayer.build(r)}),Lh(this.backwardLayer.name,()=>{this.backwardLayer.build(r)}),this.built=!0}computeMask(r,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(i=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(r){super.setFastWeightInitDuringBuild(r),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(r),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(r)}getConfig(){let r={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(r,t),r}static fromConfig(r,t){let n=To(t.layer);if(delete t.layer,t.numConstants!=null)throw new gr("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let s=t;return s.layer=n,new r(s)}};IM.className="Bidirectional";et.registerClass(IM);var kM=class extends yr{constructor(r){super(r),this.scale=r.scale,r.offset?this.offset=r.offset:this.offset=0}getConfig(){let r={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(r,t),r}call(r,t){return Ie(()=>(r=Xt(r),r.dtype!=="float32"&&(r=dl(r,"float32")),Ke(Se(r,this.scale),this.offset)))}};kM.className="Rescaling";et.registerClass(kM);var{resizeBilinear:bze,cropAndResize:xze}=pa,NM=class extends yr{constructor(r){super(r),this.height=r.height,this.width=r.width}centerCrop(r,t,n,s,i,a,o,u){return Ie(()=>{let l,c=!1,h=t/a,d=n/o,p=(s+t)/a,f=(i+n)/o,m=[h,d,p,f],g=[];r.rank===3?(c=!0,l=Yn([r])):l=r;for(let w=0;w<l.shape[0];w++)g.push(m);let y=ai(g,[g.length,4]),b=wd(0,g.length,1,"int32"),x=xze(l,y,b,[s,i],"nearest");return dl(c?Xt(Bn(x)):x,u)})}upsize(r,t,n,s){return Ie(()=>{let i=bze(r,[t,n]);return dl(i,s)})}call(r,t){return Ie(()=>{let n=Xt(r),s=n.dtype,i=n.shape,a=i[i.length-3],o=i[i.length-2],u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let l=0;return o!==this.width&&(l=Math.floor((o-this.width)/2),l===0&&(l=1)),u>=0&&l>=0?this.centerCrop(n,u,l,this.height,this.width,a,o,s):this.upsize(r,this.height,this.width,s)})}getConfig(){let r={height:this.height,width:this.width},t=super.getConfig();return Object.assign(r,t),r}computeOutputShape(r){r=Mr(r);let t=r.length-3,n=r.length-2;return r[t]=this.height,r[n]=this.width,r}};NM.className="CenterCrop";et.registerClass(NM);function vze(r,t,n,s){let i=Xt(r);if(i.dtype!=="int32"&&(i=dl(i,"int32")),t==="int")return i;let a=i.shape;if(i.rank===0&&(i=bs(i,-1)),t==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=bs(i,-1)),i.rank>2)throw new ke(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${i.rank}.`);let o=["multiHot","oneHot"].includes(t),u=i,l;if(typeof s<"u"&&t==="count"?l=L2(u,s,n,o):l=L2(u,[],n,o),t!=="tfIdf")return l;if(s)return Se(l,s);throw new ke("When outputMode is 'tfIdf', weights must be provided.")}var TM=class extends yr{constructor(r){super(r),this.numTokens=r.numTokens,r.outputMode?this.outputMode=r.outputMode:this.outputMode="multiHot"}getConfig(){let r={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(r,t),r}computeOutputShape(r){return r=Mr(r),r==null?[this.numTokens]:this.outputMode==="oneHot"&&r[r.length-1]!==1?(r.push(this.numTokens),r):(r[r.length-1]=this.numTokens,r)}call(r,t){return Ie(()=>{r=Xt(r),r.dtype!=="int32"&&(r=dl(r,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new ke(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Xt(t.countWeights)}let s=ya(r),i=Hm(r),a=fi(this.numTokens,s).bufferSync().get(0),o=Sl(i,0).bufferSync().get(0);if(!(a&&o))throw new ke(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return vze(r,this.outputMode,this.numTokens,n)})}};TM.className="CategoryEncoding";et.registerClass(TM);var wze=["bilinear","nearest"],mV=new Set(wze),AM=class extends yr{constructor(r){if(super(r),this.height=r.height,this.width=r.width,r.interpolation)if(mV.has(r.interpolation))this.interpolation=r.interpolation;else throw new ke(`Invalid interpolation parameter: ${r.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!r.cropToAspectRatio}computeOutputShape(r){r=Mr(r);let t=r[2];return[this.height,this.width,t]}getConfig(){let r={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(r,t),r}call(r,t){return Ie(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return pa.resizeBilinear(r,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return pa.resizeNearestNeighbor(r,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...mV]} are supported`)})}};AM.className="Resizing";et.registerClass(AM);var rZ=class{constructor(r){this.seed=r}next(){if(this.seed!==void 0)return this.seed++}};rZ.className="RandomSeed";var nZ=class extends yr{constructor(r){super(r),this.randomGenerator=new rZ(r.seed)}getConfig(){let r={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(r,t),r}};nZ.className="BaseRandomLayer";var Sze=["bilinear","nearest"],gV=new Set(Sze),DM=class extends nZ{constructor(r){super(r);let{factor:t,interpolation:n="bilinear"}=r;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ke(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ke(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ke(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(gV.has(n))this.interpolation=n;else throw new ke(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let r={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(r,t),r}computeOutputShape(r){r=Mr(r);let t=r[2];return[this.imgHeight,-1,t]}call(r,t){return Ie(()=>{let n=Xt(r);this.imgHeight=n.shape[n.shape.length-3];let s=n.shape[n.shape.length-2];this.widthFactor=Uc([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*s;i=Math.round(i);let a=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return pa.resizeBilinear(r,a);case"nearest":return pa.resizeNearestNeighbor(r,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...gV]} are supported`)}})}};DM.className="RandomWidth";et.registerClass(DM);function Cze(r){return new O0(r)}function _ze(r){return new FO(r)}function Eze(r){return new TO(r)}function Ize(r){return new AO(r)}function kze(r){return new DO(r)}function Nze(r){return new RO(r)}function Tze(r){return new $O(r)}function Aze(r){return new BO(r)}function Dze(r){return new O_(r)}function Fze(r){return new MO(r)}function $ze(r){return new M_(r)}function Rze(r){return new LO(r)}function Oze(r){return new PO(r)}function Mze(r){return new VO(r)}function Lze(r){return new zO(r)}function Pze(r){return new UO(r)}function Bze(r){return new YO(r)}function Vze(r){return new KO(r)}function zze(r){return new z_(r)}function Uze(r){return new qO(r)}function Wze(r){return new XO(r)}function Gze(r){return new ZO(r)}function Hze(r){return new JO(r)}function jze(r){return new QO(r)}function qze(r){return new tM(r)}function Kze(r){return new rM(r)}function Xze(r){return new sM(r)}function Yze(r){return new oM(r)}function Zze(r){return new iM(r)}function Jze(r){return new aM(r)}function Qze(r){return new nM(r)}function eUe(r){return new uM(r)}function tUe(r){return new dM(r)}function rUe(r){return new pM(r)}function nUe(r){return new fM(r)}function FM(r){return new gM(r)}function sUe(r){return FM(r)}function iUe(r){return FM(r)}function $M(r){return new bM(r)}function aUe(r){return $M(r)}function oUe(r){return $M(r)}function RM(r){return new vM(r)}function uUe(r){return RM(r)}function lUe(r){return RM(r)}function cUe(r){return new wM(r)}function hUe(r){return new CM(r)}function sZ(r){return new SM(r)}function iZ(r){return new _M(r)}function aZ(r){return new mM(r)}function oZ(r){return new yM(r)}function dUe(r){return new xM(r)}function pUe(r){return new GO(r)}function fUe(r){return new P_(r)}function mUe(r){return new HO(r)}function gUe(r){return new Av(r)}function yUe(r){return new WO(r)}function bUe(r){return new L_(r)}function xUe(r){return new jO(r)}function vUe(r){return new V_(r)}function wUe(r){return new El(r)}function SUe(r){return new B_(r)}function CUe(r){return new IM(r)}function _Ue(r){return new EM(r)}var EUe=sZ,IUe=iZ,kUe=aZ,NUe=oZ;function TUe(r){return new lM(r)}function AUe(r){return new cM(r)}function DUe(r){return new hM(r)}function FUe(r){return new eM(r)}function $Ue(r){return new kM(r)}function RUe(r){return new NM(r)}function OUe(r){return new AM(r)}function MUe(r){return new TM(r)}function LUe(r){return new DM(r)}var uZ={};ir(uZ,{MAPE:()=>KUe,MSE:()=>ZUe,binaryAccuracy:()=>PUe,binaryCrossentropy:()=>BUe,categoricalAccuracy:()=>zUe,categoricalCrossentropy:()=>UUe,cosineProximity:()=>HUe,mape:()=>XUe,meanAbsoluteError:()=>jUe,meanAbsolutePercentageError:()=>qUe,meanSquaredError:()=>YUe,mse:()=>JUe,precision:()=>WUe,r2Score:()=>QUe,recall:()=>GUe,sparseCategoricalAccuracy:()=>VUe});function PUe(r,t){return CO(r,t)}function BUe(r,t){return hY(r,t)}function VUe(r,t){return dY(r,t)}function zUe(r,t){return _O(r,t)}function UUe(r,t){return EO(r,t)}function WUe(r,t){return cY(r,t)}function GUe(r,t){return wVe(r,t)}function HUe(r,t){return SO(r,t)}function jUe(r,t){return D_(r,t)}function qUe(r,t){return M0(r,t)}function KUe(r,t){return M0(r,t)}function XUe(r,t){return M0(r,t)}function YUe(r,t){return mf(r,t)}function ZUe(r,t){return mf(r,t)}function JUe(r,t){return mf(r,t)}function QUe(r,t){return SVe(r,t)}var lZ={};ir(lZ,{modelFromJSON:()=>JVe});var cZ={};ir(cZ,{l1:()=>t6e,l1l2:()=>e6e,l2:()=>r6e});function e6e(r){return new Nv(r)}function t6e(r){return ize(r)}function r6e(r){return aze(r)}var hZ=class extends Qm{constructor(){super(...arguments),this.model=null}setModel(r){if(!(r instanceof tl))throw new Error("model must be a LayersModel, not some other Container");this.model=r}};function O1(r,t){return r<t}function yV(r,t){return r>t}var dZ=class extends hZ{constructor(r){if(super(),r==null&&(r={}),r.restoreBestWeights)throw new gr("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=r.monitor||"val_loss",this.minDelta=Math.abs(r.minDelta||0),this.patience=r.patience||0,this.verbose=r.verbose||0,this.mode=r.mode||"auto",this.baseline=r.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=O1:this.mode==="max"?this.monitorFunc=yV:this.monitor.indexOf("acc")!==-1?this.monitorFunc=yV:this.monitorFunc=O1,this.monitorFunc===O1&&(this.minDelta*=-1)}async onTrainBegin(r){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===O1?1/0:-1/0}async onEpochEnd(r,t){await $l(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=r,this.model.stopTraining=!0)))}async onTrainEnd(r){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(r){r==null&&(r={});let t=r[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(r)}`),t}};function n6e(r){return new dZ(r)}var s6e={earlyStopping:n6e},i6e=Re();i6e.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var zi;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF"})(zi||(zi={}));var bV;(function(r){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(bV||(bV={}));var OM={};function a6e(r,t){let n={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:t};OM[r]=n}function pZ(r){return OM[r]}function o6e(r){delete OM[r]}function M(r,t,n,s,i){let a=t.inputParams[r];if(a&&a.inputIndexStart!==void 0){let u=a.inputIndexStart,l=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?u+1:a.inputIndexEnd,c=u<0?t.inputNames.length+u:u;if(a.type==="tensor")return As(t.inputNames[c],n,s,i);if(a.type==="tensors"){let p=t.inputs.slice(u,l);return t.inputNames.slice(u,l).filter((f,m)=>{var g;return((g=p[m])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(f=>As(f,n,s,i))}let h=As(t.inputNames[c],n,s,i),d=h.dataSync();return a.type==="number"?d[0]:O.toNestedArray(h.shape,d)}let o=t.attrParams[r];return o&&o.value}function As(r,t,n,s){let[i,a]=Hi(r,n);if(s!=null){let u=s.getHashTableHandleByName(i);if(u!=null)return u}let o=n.currentContextIds.find(u=>!!t[K2(i,u)]);return o!==void 0?t[K2(i,o)][a]:void 0}function xV(r,t,n){return t[K2(r,n.currentContextId)]}function Pu(r,t){let[n,s,i]=Hi(r,t);return[K2(n,t&&t.currentContextId),s,i]}function K2(r,t){return t?`${r}-${t}`:r}function Hi(r,t){if(r==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let a=t.parseNodeNameCache.get(r);if(a!=null)return a}let s=r.split(":"),i;if(s.length===1)i=[r,0,void 0];else{let a=s[0],o=s.length===3?s[1]:void 0,u=Number(s[s.length-1]);i=[a,u,o]}return n&&t.parseNodeNameCache.set(r,i),i}function Iw(r,t,n){let s=M("pad",r,t,n);if(s==="explicit"){s=M("explicitPaddings",r,t,n);let i=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)i[a][0]=s[a*2],i[a][1]=s[a*2+1];return i}return s}function Bu(r){return r.kept?r:au(r)}var fZ={};ir(fZ,{json:()=>u6e});var u6e=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],mZ={};ir(mZ,{json:()=>l6e});var l6e=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],gZ={};ir(gZ,{json:()=>c6e});var c6e=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],yZ={};ir(yZ,{json:()=>h6e});var h6e=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],bZ={};ir(bZ,{json:()=>d6e});var d6e=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],xZ={};ir(xZ,{json:()=>p6e});var p6e=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],vZ={};ir(vZ,{json:()=>f6e});var f6e=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],wZ={};ir(wZ,{json:()=>m6e});var m6e=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],SZ={};ir(SZ,{json:()=>g6e});var g6e=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],CZ={};ir(CZ,{json:()=>y6e});var y6e=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],_Z={};ir(_Z,{json:()=>b6e});var b6e=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],EZ={};ir(EZ,{json:()=>x6e});var x6e=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],IZ={};ir(IZ,{json:()=>v6e});var v6e=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],kZ={};ir(kZ,{json:()=>w6e});var w6e=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],NZ={};ir(NZ,{json:()=>S6e});var S6e=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],TZ={};ir(TZ,{json:()=>C6e});var C6e=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],AZ={};ir(AZ,{json:()=>_6e});var _6e=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],DZ={};ir(DZ,{json:()=>E6e});var E6e=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],FZ={};ir(FZ,{json:()=>I6e});var I6e=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],vV=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let r=[fZ,mZ,gZ,yZ,bZ,xZ,vZ,wZ,SZ,CZ,_Z,EZ,IZ,kZ,NZ,TZ,AZ,DZ,FZ],t=[].concat(...r.map(n=>n.json));this.opMappers=t.reduce((n,s)=>(n[s.tfOpName]=s,n),{})}transformGraph(r,t={}){let n=r.node,s=[],i=[],a=[],o=n.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):g.op==="Const"?i.push(m[g.name]):(g.input==null||g.input.length===0)&&a.push(m[g.name]),m),{}),u=[],l=[],c={},h={};t!=null&&(c=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));let d=Object.keys(o);d.forEach(m=>{let g=o[m];g.inputNames.forEach((y,b)=>{let[x,,w]=Pu(y),v=o[x];if(v.outputs!=null){let S=v.outputs.indexOf(w);if(S!==-1){let E=`${x}:${S}`;g.inputNames[b]=E}}g.inputs.push(v),v.children.push(g)})}),Object.keys(h).length===0?d.forEach(m=>{let g=o[m];g.children.length===0&&l.push(g)}):Object.keys(h).forEach(m=>{let[g]=Pu(m),y=o[g];y!=null&&(y.signatureKey=h[m],l.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{let[g]=Pu(m),y=o[g];y&&(y.signatureKey=c[m],u.push(y))}):u=s;let p={};r.library!=null&&r.library.function!=null&&(p=r.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));let f={nodes:o,inputs:u,outputs:l,weights:i,placeholders:s,signature:t,functions:p};return a.length>0&&(f.initNodes=a),f}mapSignatureEntries(r){return Object.keys(r||{}).reduce((t,n)=>(t[r[n].name]=n,t),{})}mapNode(r){let t=pZ(r.op)||this.opMappers[r.op]||{};r.attr==null&&(r.attr={});let n={name:r.name,op:r.op,category:t.category,inputNames:(r.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:r.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((s,i)=>(s[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},s),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((s,i)=>{let a=i.type,o;switch(i.type){case"string":o=fN(r.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=fN(r.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":o=wN(r.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=wN(r.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":o=gN(r.attr,i.tfName,i.defaultValue||0),o===void 0&&i.tfDeprecatedName&&(o=gN(r.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":o=vN(r.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=vN(r.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":o=mN(r.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=mN(r.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":o=CN(r.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=CN(r.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":o=xN(r.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=xN(r.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":o=SN(r.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=SN(r.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":o=yN(r.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=yN(r.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":o=bN(r.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=bN(r.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":o=wV(r.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=wV(r.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${r.op}`)}return s[i.name]={value:o,type:a},s},{})),n}mapFunction(r){let t=r.nodeDef,n=[],s=[],i={};t!=null&&(i=t.reduce((c,h)=>(c[h.name]=this.mapNode(h),h.op==="Const"&&s.push(c[h.name]),c),{}));let a=[],o=[];r.signature.inputArg.forEach(c=>{let[h]=Pu(c.name),d={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:MM(c.type),type:"dtype"}},children:[]};d.signatureKey=c.name,a.push(d),i[h]=d}),Object.keys(i).forEach(c=>{let h=i[c];h.inputNames.forEach((d,p)=>{let[f,,m]=Pu(d),g=i[f];if(g.outputs!=null){let y=g.outputs.indexOf(m);if(y!==-1){let b=`${f}:${y}`;h.inputNames[p]=b}}h.inputs.push(g),g.children.push(h)})});let u=r.ret;r.signature.outputArg.forEach(c=>{let[h,d]=Pu(u[c.name]),p=i[h];p!=null&&(p.defaultOutput=d,o.push(p))});let l=this.mapArgsToSignature(r);return{nodes:i,inputs:a,outputs:o,weights:s,placeholders:n,signature:l}}mapArgsToSignature(r){return{methodName:r.signature.name,inputs:r.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:r.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,r.ret),t),{})}}mapArgToTensorInfo(r,t){let n=r.name;return t!=null&&(n=t[n]),{name:n,dtype:r.type}}};function k6e(r){let t=Re().global;if(typeof t.atob<"u")return t.atob(r);if(typeof Buffer<"u")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function $Z(r,t){let n=Array.isArray(r)?String.fromCharCode.apply(null,r):k6e(r);return t?n:n.toLowerCase()}function fN(r,t,n,s=!1){let i=r[t];return i!=null?$Z(i.s,s):n}function mN(r,t,n){let s=r[t];return s?s.b:n}function gN(r,t,n){let s=r[t]||{},i=s.i!=null?s.i:s.f!=null?s.f:n;return typeof i=="number"?i:parseInt(i,10)}function MM(r){switch(typeof r=="string"&&(r=zi[r]),r){case zi.DT_FLOAT:case zi.DT_HALF:return"float32";case zi.DT_INT32:case zi.DT_INT64:case zi.DT_INT8:case zi.DT_UINT8:return"int32";case zi.DT_BOOL:return"bool";case zi.DT_DOUBLE:return"float32";case zi.DT_STRING:return"string";case zi.DT_COMPLEX64:case zi.DT_COMPLEX128:return"complex64";default:return null}}function wV(r,t,n){let s=r[t];return s&&s.func?s.func.name:n}function yN(r,t,n){let s=r[t];return s&&s.type?MM(s.type):n}function bN(r,t,n){let s=r[t];return s&&s.list&&s.list.type?s.list.type.map(i=>MM(i)):n}function RZ(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function xN(r,t,n){let s=r[t];return s&&s.shape?RZ(s.shape):n}function vN(r,t,n){let s=r[t];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):n}function wN(r,t,n,s=!1){let i=r[t];return i&&i.list&&i.list.s?i.list.s.map(a=>$Z(a,s)):n}function SN(r,t,n){let s=r[t];return s&&s.list&&s.list.shape?s.list.shape.map(i=>RZ(i)):n}function CN(r,t,n){let s=r[t];return s&&s.list&&s.list.b?s.list.b:n}var N6e=class{constructor(r,t,n){this.node=r,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=r.inputNames.map(s=>this.getInput(s)),r.rawAttrs!=null&&(this.attrs=Object.keys(r.rawAttrs).reduce((s,i)=>(s[i]=this.getAttr(i),s),{}))}getInput(r){return As(r,this.tensorMap,this.context)}getAttr(r,t){let n=this.node.rawAttrs[r];if(n.tensor!=null)return As(r,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return gN(this.node.rawAttrs,r,t);if(n.s!=null)return fN(this.node.rawAttrs,r,t);if(n.b!=null)return mN(this.node.rawAttrs,r,t);if(n.shape!=null)return xN(this.node.rawAttrs,r,t);if(n.type!=null)return yN(this.node.rawAttrs,r,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return vN(this.node.rawAttrs,r,t);if(n.list.s!=null)return wN(this.node.rawAttrs,r,t);if(n.list.shape!=null)return SN(this.node.rawAttrs,r,t);if(n.list.b!=null)return CN(this.node.rawAttrs,r,t);if(n.list.type!=null)return bN(this.node.rawAttrs,r,t)}return t}},Is={};ir(Is,{OP_SCOPE_SUFFIX:()=>PR,abs:()=>jn,acos:()=>WR,acosh:()=>GR,add:()=>Ke,addN:()=>Kq,all:()=>WC,any:()=>Xb,argMax:()=>yd,argMin:()=>HR,asin:()=>jR,asinh:()=>qR,atan:()=>KR,atan2:()=>XR,atanh:()=>YR,avgPool:()=>wl,avgPool3d:()=>JR,basicLSTMCell:()=>Jq,batchNorm:()=>cf,batchNorm2d:()=>QR,batchNorm3d:()=>e3,batchNorm4d:()=>t3,batchToSpaceND:()=>lv,bincount:()=>r3,bitwiseAnd:()=>Qq,booleanMaskAsync:()=>UK,broadcastArgs:()=>eK,broadcastTo:()=>Mh,buffer:()=>pr,cast:()=>at,ceil:()=>n3,clipByValue:()=>Us,clone:()=>au,complex:()=>hl,concat:()=>an,concat1d:()=>s3,concat2d:()=>i3,concat3d:()=>a3,concat4d:()=>o3,conv1d:()=>GC,conv2d:()=>ui,conv2dTranspose:()=>HC,conv3d:()=>l3,conv3dTranspose:()=>c3,cos:()=>cv,cosh:()=>jC,cosineWindow:()=>m_,cumprod:()=>Jb,cumsum:()=>qC,denseBincount:()=>L2,depthToSpace:()=>h3,depthwiseConv2d:()=>hf,diag:()=>rK,dilation2d:()=>d3,div:()=>_t,divNoNan:()=>p3,dot:()=>f3,dropout:()=>W3,einsum:()=>Ch,elu:()=>N0,enclosingPowerOfTwo:()=>G3,ensureShape:()=>sK,equal:()=>ra,erf:()=>KC,euclideanNorm:()=>y3,exp:()=>Ws,expandDims:()=>bs,expm1:()=>b3,eye:()=>XC,fft:()=>vv,fill:()=>Qi,floor:()=>A0,floorDiv:()=>UC,fused:()=>Zm,gather:()=>D0,gatherND:()=>jK,greater:()=>fi,greaterEqual:()=>Sl,ifft:()=>Ym,imag:()=>hv,image:()=>pa,inTopKAsync:()=>qK,irfft:()=>u_,isFinite:()=>x3,isInf:()=>v3,isNaN:()=>w3,leakyRelu:()=>dv,less:()=>jm,lessEqual:()=>zc,linalg:()=>q3,linspace:()=>lK,localResponseNormalization:()=>S3,log:()=>na,log1p:()=>pv,logSigmoid:()=>C3,logSoftmax:()=>ZC,logSumExp:()=>fv,logicalAnd:()=>Za,logicalNot:()=>mv,logicalOr:()=>JC,logicalXor:()=>_3,losses:()=>iX,lowerBound:()=>hK,matMul:()=>cr,max:()=>ya,maxPool:()=>ps,maxPool3d:()=>E3,maxPoolWithArgmax:()=>dK,maximum:()=>Iu,mean:()=>Rn,meshgrid:()=>pK,min:()=>Hm,minimum:()=>wc,mirrorPad:()=>I3,mod:()=>k3,moments:()=>gv,movingAverage:()=>WK,mul:()=>Se,multiRNNCell:()=>fK,multinomial:()=>mK,neg:()=>xn,norm:()=>T0,notEqual:()=>vd,oneHot:()=>qm,ones:()=>Ci,onesLike:()=>sa,op:()=>be,outerProduct:()=>gK,pad:()=>zo,pad1d:()=>yK,pad2d:()=>bK,pad3d:()=>xK,pad4d:()=>vK,pool:()=>N3,pow:()=>yu,prelu:()=>bv,print:()=>UR,prod:()=>T3,raggedGather:()=>wK,raggedRange:()=>SK,raggedTensorToTensor:()=>CK,rand:()=>_K,randomGamma:()=>NK,randomNormal:()=>e_,randomStandardNormal:()=>TK,randomUniform:()=>Uc,randomUniformInt:()=>AK,range:()=>wd,real:()=>Km,reciprocal:()=>R3,relu:()=>Yr,relu6:()=>t_,reshape:()=>Ee,reverse:()=>Sa,reverse1d:()=>DK,reverse2d:()=>FK,reverse3d:()=>$K,reverse4d:()=>RK,rfft:()=>wv,round:()=>r_,rsqrt:()=>n_,scalar:()=>Pt,scatterND:()=>GK,searchSorted:()=>QC,selu:()=>s_,separableConv2d:()=>F0,setdiff1dAsync:()=>OK,sigmoid:()=>Xa,sign:()=>O3,signal:()=>sX,sin:()=>i_,sinh:()=>a_,slice:()=>vr,slice1d:()=>xv,slice2d:()=>o_,slice3d:()=>$0,slice4d:()=>Xm,softmax:()=>Wc,softplus:()=>df,spaceToBatchND:()=>yv,sparse:()=>aX,sparseToDense:()=>HK,spectral:()=>nX,split:()=>_i,sqrt:()=>_s,square:()=>rn,squaredDifference:()=>l_,squeeze:()=>Gc,stack:()=>Yn,step:()=>pf,stridedSlice:()=>M3,string:()=>oX,sub:()=>vt,sum:()=>Tt,tan:()=>L3,tanh:()=>vc,tensor:()=>ai,tensor1d:()=>qr,tensor2d:()=>ou,tensor3d:()=>c_,tensor4d:()=>Sc,tensor5d:()=>MK,tensor6d:()=>LK,tensorScatterUpdate:()=>BK,tile:()=>Zi,topk:()=>B3,transpose:()=>dr,truncatedNormal:()=>p_,unique:()=>V3,unsortedSegmentSum:()=>f_,unstack:()=>Bn,upperBound:()=>VK,variable:()=>z3,where:()=>Ss,whereAsync:()=>U3,zeros:()=>On,zerosLike:()=>Cr});var T6e=(r,t,n,s=Is)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(M("a",r,t,n),M("b",r,t,n))];case"AddN":return[s.addN(M("tensors",r,t,n))];case"FloorMod":case"Mod":return[s.mod(M("a",r,t,n),M("b",r,t,n))];case"Mul":return[s.mul(M("a",r,t,n),M("b",r,t,n))];case"RealDiv":case"Div":return[s.div(M("a",r,t,n),M("b",r,t,n))];case"DivNoNan":return[s.divNoNan(M("a",r,t,n),M("b",r,t,n))];case"FloorDiv":return[s.floorDiv(M("a",r,t,n),M("b",r,t,n))];case"Sub":return[s.sub(M("a",r,t,n),M("b",r,t,n))];case"Minimum":return[s.minimum(M("a",r,t,n),M("b",r,t,n))];case"Maximum":return[s.maximum(M("a",r,t,n),M("b",r,t,n))];case"Pow":return[s.pow(M("a",r,t,n),M("b",r,t,n))];case"SquaredDifference":return[s.squaredDifference(M("a",r,t,n),M("b",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}},A6e=(r,t,n,s=Is)=>{switch(r.op){case"Abs":case"ComplexAbs":return[s.abs(M("x",r,t,n))];case"Acos":return[s.acos(M("x",r,t,n))];case"Acosh":return[s.acosh(M("x",r,t,n))];case"Asin":return[s.asin(M("x",r,t,n))];case"Asinh":return[s.asinh(M("x",r,t,n))];case"Atan":return[s.atan(M("x",r,t,n))];case"Atan2":return[s.atan2(M("x",r,t,n),M("y",r,t,n))];case"Atanh":return[s.atanh(M("x",r,t,n))];case"Ceil":return[s.ceil(M("x",r,t,n))];case"Complex":return[s.complex(M("real",r,t,n),M("imag",r,t,n))];case"Cos":return[s.cos(M("x",r,t,n))];case"Cosh":return[s.cosh(M("x",r,t,n))];case"Elu":return[s.elu(M("x",r,t,n))];case"Erf":return[s.erf(M("x",r,t,n))];case"Exp":return[s.exp(M("x",r,t,n))];case"Expm1":return[s.expm1(M("x",r,t,n))];case"Floor":return[s.floor(M("x",r,t,n))];case"Log":return[s.log(M("x",r,t,n))];case"Log1p":return[s.log1p(M("x",r,t,n))];case"Imag":return[s.imag(M("x",r,t,n))];case"Neg":return[s.neg(M("x",r,t,n))];case"Reciprocal":return[s.reciprocal(M("x",r,t,n))];case"Real":return[s.real(M("x",r,t,n))];case"Relu":return[s.relu(M("x",r,t,n))];case"Round":return[s.round(M("x",r,t,n))];case"Selu":return[s.selu(M("x",r,t,n))];case"Sigmoid":return[s.sigmoid(M("x",r,t,n))];case"Sin":return[s.sin(M("x",r,t,n))];case"Sign":return[s.sign(M("x",r,t,n))];case"Sinh":return[s.sinh(M("x",r,t,n))];case"Softplus":return[s.softplus(M("x",r,t,n))];case"Sqrt":return[s.sqrt(M("x",r,t,n))];case"Square":return[s.square(M("x",r,t,n))];case"Tanh":return[s.tanh(M("x",r,t,n))];case"Tan":return[s.tan(M("x",r,t,n))];case"ClipByValue":return[s.clipByValue(M("x",r,t,n),M("clipValueMin",r,t,n),M("clipValueMax",r,t,n))];case"Relu6":return[s.relu6(M("x",r,t,n))];case"Rsqrt":return[s.rsqrt(As(r.inputNames[0],t,n))];case"LeakyRelu":return[s.leakyRelu(M("x",r,t,n),M("alpha",r,t,n))];case"Prelu":return[s.prelu(M("x",r,t,n),M("alpha",r,t,n))];case"IsNan":return[s.isNaN(As(r.inputNames[0],t,n))];case"IsInf":return[s.isInf(As(r.inputNames[0],t,n))];case"IsFinite":return[s.isFinite(As(r.inputNames[0],t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function La(r,t,n=""){if(!(typeof r=="number"||typeof t=="number")){O.assert(r.length===t.length,()=>n+` Shapes ${r} and ${t} must match`);for(let s=0;s<r.length;s++){let i=r[s],a=t[s];O.assert(i<0||a<0||i===a,()=>n+` Shapes ${r} and ${t} must match`)}}}function SV(r){return!(typeof r=="number"||r.some(t=>t<0))}function gy(r,t,n){let s=_N(r,n),i=!SV(s);if(i&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(i&&t.forEach(a=>{s=_N(a.shape,s)}),!SV(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function _N(r,t){if(typeof r=="number")return t;if(typeof t=="number")return r;if(r.length!==t.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${t}`);let n=[];for(let s=0;s<r.length;++s){let i=r[s],a=t[s];if(i>=0&&a>=0&&i!==a)throw new Error(`Incompatible shape during merge: ${r} vs. ${t}`);n[s]=i>=0?i:a}return n}var D6e=class{constructor(r,t,n,s,i,a,o){this.name=r,this.dtype=t,this.maxSize=n,this.elementShape=s,this.identicalElementShapes=i,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Pt(0),ns(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(r){this.tensors.forEach(t=>{(r==null||!r.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(r){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(r<0||r>=this.size())throw new Error(`Tried to read from index ${r}, but array size is: ${this.size()}`);let t=this.tensors[r];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${r} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(r){return r.map(t=>this.read(t))}write(r,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(r<0||!this.dynamicSize&&r>=this.maxSize)throw new Error(`Tried to write to index ${r}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[r]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${r},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),La(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${r}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${r}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${r}, because it has already been written.`);n.tensor=t,ns(t),n.written=!0,this.tensors[r]=n}writeMany(r,t){if(r.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${r.length} is not the same as tensors size: ${t.length}.`);r.forEach((n,s)=>this.write(n,t[s]))}gather(r,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(r)r=r.slice(0,this.size());else{r=[];for(let s=0;s<this.size();s++)r.push(s)}if(r.length===0)return ai([],[0].concat(this.elementShape));let n=this.readMany(r);return La(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Yn(n,0)}concat(r){if(r&&r!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${r}`);if(this.size()===0)return ai([],[0].concat(this.elementShape));let t=[];for(let s=0;s<this.size();s++)t.push(s);let n=this.readMany(t);return La(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),an(n,0)}scatter(r,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(r.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${r.length} vs. ${t.shape[0]}`);let n=Math.max(...r);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(r,Bn(t,0))}split(r,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,s=r.map(u=>(n+=u,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&r.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${r.length}), and the TensorArray is not marked as dynamically resizeable`);let i=n===0?0:t.size/n,a=[];Ie(()=>{t=Ee(t,[1,n,i]);for(let u=0;u<r.length;++u){let l=[0,u===0?0:s[u-1],0],c=[1,r[u],i];a[u]=Ee(vr(t,l,c),this.elementShape)}return a});let o=[];for(let u=0;u<r.length;u++)o[u]=u;this.writeMany(o,a)}},W_=class EN{get id(){return this.idTensor.id}constructor(t,n,s,i=-1){this.tensors=t,this.elementShape=n,this.elementDtype=s,t!=null&&t.forEach(a=>{if(s!==a.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${a.dtype}`);La(n,a.shape,"TensorList shape mismatch: "),ns(a)}),this.idTensor=Pt(0),this.maxNumElements=i,ns(this.idTensor)}copy(){return new EN([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,s=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);La(t,this.elementShape,"TensorList shape mismatch: ");let i=gy(this.elementShape,this.tensors,t);return Ie(()=>{let a=this.tensors.map(o=>Ee(o,i));return Yn(a,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let s=gy(this.elementShape,this.tensors,t),i=this.tensors.pop();return i.kept=!1,La(i.shape,t,"TensorList shape mismatch: "),Ee(i,s)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(La(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ns(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new EN([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let s=0;s<Math.min(this.tensors.length,t);++s)n.tensors[s]=this.tensors[s];return n}getItem(t,n,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);La(this.tensors[t].shape,n,"TensorList shape mismatch: ");let i=gy(this.elementShape,this.tensors,n);return Ee(this.tensors[t],i)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);La(this.elementShape,n.shape,"TensorList shape mismatch: "),ns(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,s){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);La(this.elementShape,s,"TensorList shape mismatch: "),t=t.slice(0,this.size());let i=gy(this.elementShape,this.tensors,s);return t.length===0?ai([],[0].concat(i)):Ie(()=>{let a=t.map(o=>Ee(this.tensors[o],i));return Yn(a,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);La(this.elementShape,n,"TensorList shape mismatch: ");let s=gy(this.elementShape,this.tensors,n);return this.size()===0?ai([],[0].concat(s)):Ie(()=>{let i=this.tensors.map(a=>Ee(a,s));return an(i,0)})}};function F6e(r,t,n){let s=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==n)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${n}`);let i=r.shape.slice(1);La(i,t,"TensorList shape mismatch: ");let a=Bn(r);return new W_(a,t,s)}function $6e(r,t,n,s){return new W_([],r,t,s)}function R6e(r,t,n,s){if(t.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${r.shape[0]}`);let i=Math.max(...t);if(s!=null&&s!==-1&&i>=s)throw new Error(`Max index must be < array size (${i}  vs. ${s})`);let a=new W_([],n,r.dtype,s),o=Bn(r,0);return t.forEach((u,l)=>{a.setItem(u,o[l])}),a}function O6e(r,t,n){let s=0,i=t.map(h=>(s+=h,s));if(s!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${r.shape}`);let a=r.shape.slice(1),o=_N(a,n),u=s===0?0:r.size/s,l=Ie(()=>{let h=[];r=Ee(r,[1,s,u]);for(let d=0;d<t.length;++d){let p=[0,d===0?0:i[d-1],0],f=[1,t[d],u];h[d]=Ee(vr(r,p,f),o)}return r.dispose(),h}),c=new W_([],n,r.dtype,t.length);for(let h=0;h<l.length;h++)c.setItem(h,l[h]);return c}var M6e=async(r,t,n)=>{switch(r.op){case"If":case"StatelessIf":{let s=M("thenBranch",r,t,n),i=M("elseBranch",r,t,n),a=M("cond",r,t,n),o=M("args",r,t,n);return(await a.data())[0]?n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[i].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let s=M("body",r,t,n),i=M("cond",r,t,n),a=M("args",r,t,n),o=await n.functionMap[i].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),u=a.map(h=>h.id),l=await o[0].data();o.forEach(h=>{!h.kept&&u.indexOf(h.id)===-1&&h.dispose()});let c=a;for(;l[0];){let h=c;c=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);let d=c.map(f=>f.id);h.forEach(f=>{!f.kept&&u.indexOf(f.id)===-1&&d.indexOf(f.id)===-1&&f.dispose()});let p=await n.functionMap[i].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await p[0].data(),p.forEach(f=>{!f.kept&&u.indexOf(f.id)===-1&&d.indexOf(f.id)===-1&&f.dispose()})}return c}case"LoopCond":{let s=M("pred",r,t,n);return[Bu(s)]}case"Switch":{let s=M("pred",r,t,n),i=M("data",r,t,n);return i.kept||(i=Bu(i)),(await s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{let s=r.inputNames.find(i=>As(i,t,n)!==void 0);if(s){let i=As(s,t,n);return[Bu(i)]}return}case"Enter":{let s=M("frameName",r,t,n),i=M("tensor",r,t,n);return n.enterFrame(s),[Bu(i)]}case"Exit":{let s=M("tensor",r,t,n);return n.exitFrame(),[Bu(s)]}case"NextIteration":{let s=M("tensor",r,t,n);return n.nextIteration(),[Bu(s)]}case"TensorArrayV3":{let s=M("size",r,t,n),i=M("dtype",r,t,n),a=M("elementShape",r,t,n),o=M("dynamicSize",r,t,n),u=M("clearAfterRead",r,t,n),l=M("identicalElementShapes",r,t,n),c=M("name",r,t,n),h=new D6e(c,i,s,a,l,o,u);return n.addTensorArray(h),[h.idTensor,Pt(1)]}case"TensorArrayWriteV3":{let s=M("tensorArrayId",r,t,n),i=M("index",r,t,n),a=M("tensor",r,t,n),o=n.getTensorArray(s.id);return o.write(i,a),[o.idTensor]}case"TensorArrayReadV3":{let s=M("tensorArrayId",r,t,n),i=M("index",r,t,n);return[n.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{let s=M("tensorArrayId",r,t,n),i=M("indices",r,t,n),a=M("dtype",r,t,n);return[n.getTensorArray(s.id).gather(i,a)]}case"TensorArrayScatterV3":{let s=M("tensorArrayId",r,t,n),i=M("indices",r,t,n),a=M("tensor",r,t,n),o=n.getTensorArray(s.id);return o.scatter(i,a),[o.idTensor]}case"TensorArrayConcatV3":{let s=M("tensorArrayId",r,t,n),i=n.getTensorArray(s.id),a=M("dtype",r,t,n);return[i.concat(a)]}case"TensorArraySplitV3":{let s=M("tensorArrayId",r,t,n),i=M("tensor",r,t,n),a=M("lengths",r,t,n),o=n.getTensorArray(s.id);return o.split(a,i),[o.idTensor]}case"TensorArraySizeV3":{let s=M("tensorArrayId",r,t,n),i=n.getTensorArray(s.id);return[Pt(i.size(),"int32")]}case"TensorArrayCloseV3":{let s=M("tensorArrayId",r,t,n),i=n.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{let s=M("tensorListId",r,t,n),i=M("index",r,t,n),a=M("tensor",r,t,n),o=n.getTensorList(s.id);return o.setItem(i,a),[o.idTensor]}case"TensorListGetItem":{let s=M("tensorListId",r,t,n),i=M("index",r,t,n),a=M("elementShape",r,t,n),o=M("elementDType",r,t,n);return[n.getTensorList(s.id).getItem(i,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{let s=M("indices",r,t,n),i=M("tensor",r,t,n),a=M("elementShape",r,t,n),o=M("numElements",r,t,n),u=R6e(i,s,a,o);return n.addTensorList(u),[u.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let s=M("elementShape",r,t,n),i=M("elementDType",r,t,n),a;r.op==="TensorListReserve"?a="numElements":a="maxNumElements";let o=M(a,r,t,n),u=r.op==="TensorListReserve"?-1:o,l=$6e(s,i,o,u);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let s=M("tensorListId",r,t,n),i=M("indices",r,t,n),a=M("elementShape",r,t,n),o=M("elementDType",r,t,n);return[n.getTensorList(s.id).gather(i,o,a)]}case"TensorListStack":{let s=M("tensorListId",r,t,n),i=M("elementShape",r,t,n),a=M("elementDType",r,t,n),o=M("numElements",r,t,n);return[n.getTensorList(s.id).stack(i,a,o)]}case"TensorListFromTensor":{let s=M("tensor",r,t,n),i=M("elementShape",r,t,n),a=M("elementDType",r,t,n),o=F6e(s,i,a);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let s=M("tensorListId",r,t,n),i=n.getTensorList(s.id),a=M("dtype",r,t,n),o=M("elementShape",r,t,n);return[i.concat(a,o)]}case"TensorListPushBack":{let s=M("tensorListId",r,t,n),i=M("tensor",r,t,n),a=n.getTensorList(s.id);return a.pushBack(i),[a.idTensor]}case"TensorListPopBack":{let s=M("tensorListId",r,t,n),i=M("elementShape",r,t,n),a=M("elementDType",r,t,n);return[n.getTensorList(s.id).popBack(i,a)]}case"TensorListSplit":{let s=M("tensor",r,t,n),i=M("elementShape",r,t,n),a=M("lengths",r,t,n),o=O6e(s,a,i);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{let s=M("tensorListId",r,t,n),i=n.getTensorList(s.id);return[Pt(i.size(),"int32")]}case"TensorListResize":{let s=M("tensorListId",r,t,n),i=M("size",r,t,n),a=n.getTensorList(s.id).resize(i);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function CV(r,t,n){let[s,i]=M("fusedOps",r,t,n),a=s==="biasadd",o=!a,u=i==="prelu",l=s==="fusedbatchnorm",c=M("numArgs",r,t,n);if(a){if(u&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!u&&a&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let h=M("strides",r,t,n),d=Iw(r,t,n),p=M("dataFormat",r,t,n).toUpperCase(),f=M("dilations",r,t,n),[m,g]=M("args",r,t,n);o&&(g=m,m=void 0);let y=M("leakyreluAlpha",r,t,n);return{stride:h,pad:d,dataFormat:p,dilations:f,biasArg:m,preluArg:g,activationFunc:i,leakyreluAlpha:y}}var L6e=(r,t,n,s=Is)=>{switch(r.op){case"Conv1D":{let i=M("stride",r,t,n),a=M("pad",r,t,n),o=M("dataFormat",r,t,n).toUpperCase(),u=M("dilation",r,t,n);return[s.conv1d(M("x",r,t,n),M("filter",r,t,n),i,a,o,u)]}case"Conv2D":{let i=M("strides",r,t,n),a=Iw(r,t,n),o=M("dataFormat",r,t,n).toUpperCase(),u=M("dilations",r,t,n);return[s.conv2d(M("x",r,t,n),M("filter",r,t,n),[i[1],i[2]],a,o,[u[1],u[2]])]}case"_FusedConv2D":{let{stride:i,pad:a,dataFormat:o,dilations:u,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:d}=CV(r,t,n);return[s.fused.conv2d({x:M("x",r,t,n),filter:M("filter",r,t,n),strides:[i[1],i[2]],pad:a,dataFormat:o,dilations:[u[1],u[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{let{stride:i,pad:a,dataFormat:o,dilations:u,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:d}=CV(r,t,n);return[s.fused.depthwiseConv2d({x:M("x",r,t,n),filter:M("filter",r,t,n),strides:[i[1],i[2]],pad:a,dataFormat:o,dilations:[u[1],u[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let i=M("outputShape",r,t,n),a=M("strides",r,t,n),o=Iw(r,t,n);return[s.conv2dTranspose(M("x",r,t,n),M("filter",r,t,n),i,[a[1],a[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let i=M("strides",r,t,n),a=Iw(r,t,n),o=M("dilations",r,t,n),u=M("dataFormat",r,t,n).toUpperCase();return[s.depthwiseConv2d(M("input",r,t,n),M("filter",r,t,n),[i[1],i[2]],a,u,[o[1],o[2]])]}case"Conv3D":{let i=M("strides",r,t,n),a=M("pad",r,t,n),o=M("dataFormat",r,t,n).toUpperCase(),u=M("dilations",r,t,n);return[s.conv3d(M("x",r,t,n),M("filter",r,t,n),[i[1],i[2],i[3]],a,o,[u[1],u[2],u[3]])]}case"AvgPool":{let i=M("strides",r,t,n),a=M("pad",r,t,n),o=M("kernelSize",r,t,n);return[s.avgPool(M("x",r,t,n),[o[1],o[2]],[i[1],i[2]],a)]}case"MaxPool":{let i=M("strides",r,t,n),a=M("pad",r,t,n),o=M("kernelSize",r,t,n);return[s.maxPool(M("x",r,t,n),[o[1],o[2]],[i[1],i[2]],a)]}case"MaxPoolWithArgmax":{let i=M("strides",r,t,n),a=M("pad",r,t,n),o=M("kernelSize",r,t,n),u=M("includeBatchInIndex",r,t,n),{result:l,indexes:c}=s.maxPoolWithArgmax(M("x",r,t,n),[o[1],o[2]],[i[1],i[2]],a,u);return[l,c]}case"AvgPool3D":{let i=M("strides",r,t,n),a=M("pad",r,t,n),o=M("kernelSize",r,t,n);return[s.avgPool3d(M("x",r,t,n),[o[1],o[2],o[3]],[i[1],i[2],i[3]],a)]}case"MaxPool3D":{let i=M("strides",r,t,n),a=M("pad",r,t,n),o=M("kernelSize",r,t,n);return[s.maxPool3d(M("x",r,t,n),[o[1],o[2],o[3]],[i[1],i[2],i[3]],a)]}case"Dilation2D":{let i=M("strides",r,t,n),a=M("pad",r,t,n),o=M("dilations",r,t,n),u=i[1],l=i[2],c=o[1],h=o[2];return[s.dilation2d(M("x",r,t,n),M("filter",r,t,n),[u,l],a,[c,h],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}},P6e=(r,t,n,s=Is)=>{switch(r.op){case"Fill":{let i=M("shape",r,t,n),a=M("dtype",r,t,n),o=M("value",r,t,n);return[s.fill(i,o,a)]}case"LinSpace":{let i=M("start",r,t,n),a=M("stop",r,t,n),o=M("num",r,t,n);return[s.linspace(i,a,o)]}case"Multinomial":{let i=M("logits",r,t,n),a=M("numSamples",r,t,n),o=M("seed",r,t,n);return[s.multinomial(i,a,o)]}case"OneHot":{let i=M("indices",r,t,n),a=M("depth",r,t,n),o=M("onValue",r,t,n),u=M("offValue",r,t,n),l=M("dtype",r,t,n);return[s.oneHot(i,a,o,u,l)]}case"Ones":return[s.ones(M("shape",r,t,n),M("dtype",r,t,n))];case"OnesLike":return[s.onesLike(M("x",r,t,n))];case"RandomStandardNormal":return[s.randomStandardNormal(M("shape",r,t,n),M("dtype",r,t,n),M("seed",r,t,n))];case"RandomUniform":return[s.randomUniform(M("shape",r,t,n),M("minval",r,t,n),M("maxval",r,t,n),M("dtype",r,t,n))];case"RandomUniformInt":return[s.randomUniformInt(M("shape",r,t,n),M("minval",r,t,n),M("maxval",r,t,n),M("seed",r,t,n))];case"Range":{let i=M("start",r,t,n),a=M("stop",r,t,n),o=M("step",r,t,n);return[s.range(i,a,o,M("dtype",r,t,n))]}case"TruncatedNormal":{let i=M("shape",r,t,n),a=M("mean",r,t,n),o=M("stdDev",r,t,n),u=M("seed",r,t,n);return[s.truncatedNormal(i,a,o,M("dtype",r,t,n),u)]}case"Zeros":return[s.zeros(M("shape",r,t,n),M("dtype",r,t,n))];case"ZerosLike":return[s.zerosLike(M("x",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function dI(r,t,n){let s=M("boxes",r,t,n),i=M("scores",r,t,n),a=M("maxOutputSize",r,t,n),o=M("iouThreshold",r,t,n),u=M("scoreThreshold",r,t,n),l=M("softNmsSigma",r,t,n);return{boxes:s,scores:i,maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}}var B6e=async(r,t,n,s,i=Is)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:a,scores:o,maxOutputSize:u,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=dI(r,t,n),d=await i.image.nonMaxSuppressionWithScoreAsync(a,o,u,l,c,h);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:a,scores:o,maxOutputSize:u,iouThreshold:l,scoreThreshold:c}=dI(r,t,n),h=M("padToMaxOutputSize",r,t,n),d=await i.image.nonMaxSuppressionPaddedAsync(a,o,u,l,c,h);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:a,scores:o,maxOutputSize:u,iouThreshold:l,scoreThreshold:c}=dI(r,t,n);return[await i.image.nonMaxSuppressionAsync(a,o,u,l,c)]}case"Where":{let a=i.cast(M("condition",r,t,n),"bool"),o=[await i.whereAsync(a)];return a.dispose(),o}case"ListDiff":return i.setdiff1dAsync(M("x",r,t,n),M("y",r,t,n));default:throw TypeError(`Node type ${r.op} is not implemented`)}},V6e=(r,t,n,s=Is)=>{switch(r.op){case"LowerBound":{let i=M("sortedSequence",r,t,n),a=M("values",r,t,n);return[s.lowerBound(i,a)]}case"TopKV2":{let i=M("x",r,t,n),a=M("k",r,t,n),o=M("sorted",r,t,n),u=s.topk(i,a,o);return[u.values,u.indices]}case"UpperBound":{let i=M("sortedSequence",r,t,n),a=M("values",r,t,n);return[s.upperBound(i,a)]}case"Unique":{let i=M("x",r,t,n),a=s.unique(i);return[a.values,a.indices]}case"UniqueV2":{let i=M("x",r,t,n),a=M("axis",r,t,n),o=s.unique(i,a);return[o.values,o.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}},z6e=(r,t,n,s=Is)=>{switch(r.op){case"Const":return t[r.name];case"PlaceholderWithDefault":let i=M("default",r,t,n);return[As(r.name,t,n)||i];case"Placeholder":return[As(r.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let h=M("x",r,t,n);return[Bu(h)]}case"IdentityN":return M("x",r,t,n).map(h=>Bu(h));case"Snapshot":let a=M("x",r,t,n);return[Bu(a)];case"Shape":return[s.tensor1d(M("x",r,t,n).shape,"int32")];case"ShapeN":return M("x",r,t,n).map(h=>s.tensor1d(h.shape));case"Size":return[s.scalar(M("x",r,t,n).size,"int32")];case"Rank":return[s.scalar(M("x",r,t,n).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":let o=M("x",r,t,n),u=M("data",r,t,n),l=M("message",r,t,n),c=M("summarize",r,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let h=0;h<u.length;h++)console.log(Array.prototype.slice.call(u[h].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${r.op} is not implemented`)}},U6e=class{get id(){return this.handle.id}constructor(r,t){this.keyDType=r,this.valueDType=t,this.handle=Pt(0),this.tensorMap=new Map,ns(this.handle)}clearAndClose(){this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Pt(this.size(),"int32")}async import(r,t){this.checkKeyAndValueTensor(r,t);let n=await r.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),Ie(()=>{let s=Bn(t),i=n.length,a=s.length;O.assert(i===a,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${a} elements.`);for(let o=0;o<i;o++){let u=n[o],l=s[o];ns(l),this.tensorMap.set(u,l)}return this.handle})}async find(r,t){this.checkKeyAndValueTensor(r,t);let n=await r.data();return Ie(()=>{let s=[];for(let i=0;i<n.length;i++){let a=n[i],o=this.findWithDefault(a,t);s.push(o)}return Yn(s)})}findWithDefault(r,t){let n=this.tensorMap.get(r);return n??t}checkKeyAndValueTensor(r,t){if(r.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${r.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},W6e=async(r,t,n,s)=>{switch(r.op){case"HashTable":case"HashTableV2":{let i=s.getHashTableHandleByName(r.name);if(i!=null)return[i];{let a=M("keyDType",r,t,n),o=M("valueDType",r,t,n),u=new U6e(a,o);return s.addHashTable(r.name,u),[u.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let i=M("tableHandle",r,t,n,s),a=M("keys",r,t,n),o=M("values",r,t,n);return[await s.getHashTableById(i.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{let i=M("tableHandle",r,t,n,s),a=M("keys",r,t,n),o=M("defaultValue",r,t,n);return[await s.getHashTableById(i.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{let i=M("tableHandle",r,t,n,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}},G6e=(r,t,n,s=Is)=>{switch(r.op){case"ResizeBilinear":{let i=M("images",r,t,n),a=M("size",r,t,n),o=M("alignCorners",r,t,n),u=M("halfPixelCenters",r,t,n);return[s.image.resizeBilinear(i,[a[0],a[1]],o,u)]}case"ResizeNearestNeighbor":{let i=M("images",r,t,n),a=M("size",r,t,n),o=M("alignCorners",r,t,n),u=M("halfPixelCenters",r,t,n);return[s.image.resizeNearestNeighbor(i,[a[0],a[1]],o,u)]}case"CropAndResize":{let i=M("image",r,t,n),a=M("boxes",r,t,n),o=M("boxInd",r,t,n),u=M("cropSize",r,t,n),l=M("method",r,t,n),c=M("extrapolationValue",r,t,n);return[s.image.cropAndResize(i,a,o,u,l,c)]}case"ImageProjectiveTransformV3":{let i=M("images",r,t,n),a=M("transforms",r,t,n),o=M("outputShape",r,t,n),u=M("fillValue",r,t,n),l=M("interpolation",r,t,n),c=M("fillMode",r,t,n);return[s.image.transform(i,a,l.toLowerCase(),c.toLowerCase(),u,o)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}},H6e=(r,t,n,s=Is)=>{switch(r.op){case"Equal":return[s.equal(M("a",r,t,n),M("b",r,t,n))];case"NotEqual":return[s.notEqual(M("a",r,t,n),M("b",r,t,n))];case"Greater":return[s.greater(M("a",r,t,n),M("b",r,t,n))];case"GreaterEqual":return[s.greaterEqual(M("a",r,t,n),M("b",r,t,n))];case"Less":return[s.less(M("a",r,t,n),M("b",r,t,n))];case"LessEqual":return[s.lessEqual(M("a",r,t,n),M("b",r,t,n))];case"LogicalAnd":return[s.logicalAnd(M("a",r,t,n),M("b",r,t,n))];case"LogicalNot":return[s.logicalNot(M("a",r,t,n))];case"LogicalOr":return[s.logicalOr(M("a",r,t,n),M("b",r,t,n))];case"Select":case"SelectV2":return[s.where(M("condition",r,t,n),M("a",r,t,n),M("b",r,t,n))];case"BitwiseAnd":return[s.bitwiseAnd(M("a",r,t,n),M("b",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}},j6e=(r,t,n,s=Is)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(M("a",r,t,n),M("b",r,t,n),M("transposeA",r,t,n),M("transposeB",r,t,n))];case"Einsum":return[s.einsum(M("equation",r,t,n),...M("tensors",r,t,n))];case"Transpose":return[s.transpose(M("x",r,t,n),M("perm",r,t,n))];case"_FusedMatMul":let[i,a]=M("fusedOps",r,t,n),o=i==="biasadd",u=a==="prelu",l=M("numArgs",r,t,n),c=M("leakyreluAlpha",r,t,n);if(o){if(u&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!u&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[h,d]=M("args",r,t,n);return[s.fused.matMul({a:M("a",r,t,n),b:M("b",r,t,n),transposeA:M("transposeA",r,t,n),transposeB:M("transposeB",r,t,n),bias:h,activation:a,preluActivationWeights:d,leakyreluAlpha:c})];case"MatrixBandPart":return[s.linalg.bandPart(M("a",r,t,n),M("numLower",r,t,n),M("numUpper",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}},q6e=(r,t,n,s=Is)=>{switch(r.op){case"EuclideanNorm":return[s.euclideanNorm(M("x",r,t,n),M("axis",r,t,n),M("keepDims",r,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(M("x",r,t,n),M("mean",r,t,n),M("variance",r,t,n),M("offset",r,t,n),M("scale",r,t,n),M("epsilon",r,t,n))];case"FusedBatchNormV3":return[s.batchNorm(M("x",r,t,n),M("mean",r,t,n),M("variance",r,t,n),M("offset",r,t,n),M("scale",r,t,n),M("epsilon",r,t,n))];case"LRN":return[s.localResponseNormalization(M("x",r,t,n),M("radius",r,t,n),M("bias",r,t,n),M("alpha",r,t,n),M("beta",r,t,n))];case"Softmax":return[s.softmax(M("x",r,t,n))];case"LogSoftmax":return[s.logSoftmax(M("x",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}},K6e=(r,t,n,s=Is)=>{switch(r.op){case"RaggedGather":{let{outputNestedSplits:i,outputDenseValues:a}=s.raggedGather(M("paramsNestedSplits",r,t,n),M("paramsDenseValues",r,t,n),M("indices",r,t,n),M("outputRaggedRank",r,t,n));return i.concat(a)}case"RaggedRange":{let{rtNestedSplits:i,rtDenseValues:a}=s.raggedRange(M("starts",r,t,n),M("limits",r,t,n),M("splits",r,t,n));return[i,a]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(M("shape",r,t,n),M("values",r,t,n),M("defaultValue",r,t,n),M("rowPartitionTensors",r,t,n),M("rowPartitionTypes",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}},X6e=(r,t,n,s=Is)=>{switch(r.op){case"Max":{let u=M("axis",r,t,n),l=M("keepDims",r,t,n);return[s.max(M("x",r,t,n),u,l)]}case"Mean":{let u=M("axis",r,t,n),l=M("keepDims",r,t,n);return[s.mean(M("x",r,t,n),u,l)]}case"Min":{let u=M("axis",r,t,n),l=M("keepDims",r,t,n);return[s.min(M("x",r,t,n),u,l)]}case"Sum":{let u=M("axis",r,t,n),l=M("keepDims",r,t,n);return[s.sum(M("x",r,t,n),u,l)]}case"All":{let u=M("axis",r,t,n),l=M("keepDims",r,t,n);return[s.all(M("x",r,t,n),u,l)]}case"Any":{let u=M("axis",r,t,n),l=M("keepDims",r,t,n);return[s.any(M("x",r,t,n),u,l)]}case"ArgMax":{let u=M("axis",r,t,n);return[s.argMax(M("x",r,t,n),u)]}case"ArgMin":{let u=M("axis",r,t,n);return[s.argMin(M("x",r,t,n),u)]}case"Prod":{let u=M("axis",r,t,n),l=M("keepDims",r,t,n);return[s.prod(M("x",r,t,n),u,l)]}case"Cumprod":{let u=M("axis",r,t,n),l=M("exclusive",r,t,n),c=M("reverse",r,t,n);return[s.cumprod(M("x",r,t,n),u,l,c)]}case"Cumsum":{let u=M("axis",r,t,n),l=M("exclusive",r,t,n),c=M("reverse",r,t,n);return[s.cumsum(M("x",r,t,n),u,l,c)]}case"Bincount":let i=M("x",r,t,n),a=M("weights",r,t,n),o=M("size",r,t,n);return[s.bincount(i,a,o)];case"DenseBincount":{let u=M("x",r,t,n),l=M("weights",r,t,n),c=M("size",r,t,n),h=M("binaryOutput",r,t,n);return[s.denseBincount(u,l,c,h)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}},Y6e=(r,t,n,s=Is)=>{switch(r.op){case"ConcatV2":case"Concat":{let i=M("n",r,t,n),a=M("axis",r,t,n),o=M("tensors",r,t,n);return o=o.slice(0,i),[s.concat(o,a)]}case"Gather":{let i=M("x",r,t,n),a=M("indices",r,t,n);return[s.gather(i,s.cast(a,"int32"),0)]}case"GatherV2":{let i=M("axis",r,t,n),a=M("batchDims",r,t,n),o=M("x",r,t,n),u=M("indices",r,t,n);return[s.gather(o,s.cast(u,"int32"),i,a)]}case"Reverse":{let i=M("dims",r,t,n),a=[];for(let u=0;u<i.length;u++)i[u]&&a.push(u);let o=M("x",r,t,n);return[s.reverse(o,a)]}case"ReverseV2":{let i=M("axis",r,t,n),a=M("x",r,t,n);return[s.reverse(a,i)]}case"Slice":{let i=M("begin",r,t,n),a=M("size",r,t,n);return[s.slice(M("x",r,t,n),i,a)]}case"StridedSlice":{let i=M("begin",r,t,n),a=M("end",r,t,n),o=M("strides",r,t,n),u=M("beginMask",r,t,n),l=M("endMask",r,t,n),c=M("ellipsisMask",r,t,n),h=M("newAxisMask",r,t,n),d=M("shrinkAxisMask",r,t,n),p=M("x",r,t,n);return[s.stridedSlice(p,i,a,o,u,l,c,h,d)]}case"Pack":return Ie(()=>{let i=M("axis",r,t,n),a=M("tensors",r,t,n),o=a[0].shape,u=s.squeeze(a[0]).shape,l=a.map(c=>{let h=O.arraysEqual(c.shape,o);if(!h&&!O.arraysEqual(s.squeeze(c).shape,u))throw new Error("the input tensors shape does not match");return h?c:s.reshape(c,o)});return[s.stack(l,i)]});case"Unpack":{let i=M("axis",r,t,n),a=M("tensor",r,t,n);return s.unstack(a,i)}case"Tile":{let i=M("reps",r,t,n);return[s.tile(M("x",r,t,n),i)]}case"Split":case"SplitV":{let i=M("axis",r,t,n),a=M("numOrSizeSplits",r,t,n),o=M("x",r,t,n);return s.split(o,a,i)}case"ScatterNd":{let i=M("indices",r,t,n),a=M("values",r,t,n),o=M("shape",r,t,n);return[s.scatterND(i,a,o)]}case"GatherNd":{let i=M("x",r,t,n),a=M("indices",r,t,n);return[s.gatherND(i,a)]}case"SparseToDense":{let i=M("sparseIndices",r,t,n),a=M("outputShape",r,t,n),o=M("sparseValues",r,t,n),u=M("defaultValue",r,t,n);return[s.sparseToDense(i,o,a,o.dtype===u.dtype?u:s.cast(u,o.dtype))]}case"TensorScatterUpdate":{let i=M("indices",r,t,n),a=M("values",r,t,n),o=M("tensor",r,t,n);return[s.tensorScatterUpdate(o,i,a)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}},Z6e=(r,t,n,s=Is)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:i,outputValues:a,emptyRowIndicator:o,reverseIndexMap:u}=s.sparse.sparseFillEmptyRows(M("indices",r,t,n),M("values",r,t,n),M("denseShape",r,t,n),M("defaultValue",r,t,n));return[i,a,o,u]}case"SparseReshape":{let{outputIndices:i,outputShape:a}=s.sparse.sparseReshape(M("inputIndices",r,t,n),M("inputShape",r,t,n),M("newShape",r,t,n));return[i,a]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(M("data",r,t,n),M("indices",r,t,n),M("segmentIds",r,t,n))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(M("data",r,t,n),M("indices",r,t,n),M("segmentIds",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}},J6e=(r,t,n,s=Is)=>{switch(r.op){case"FFT":return[s.fft(M("x",r,t,n))];case"IFFT":return[s.ifft(M("x",r,t,n))];case"RFFT":return[s.rfft(M("x",r,t,n))];case"IRFFT":return[s.irfft(M("x",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}},Q6e=(r,t,n,s=Is)=>{switch(r.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(M("input",r,t,n),M("pattern",r,t,n),M("rewrite",r,t,n),M("replaceGlobal",r,t,n))];case"StringNGrams":{let{nGrams:i,nGramsSplits:a}=s.string.stringNGrams(M("data",r,t,n),M("dataSplits",r,t,n),M("separator",r,t,n),M("nGramWidths",r,t,n),M("leftPad",r,t,n),M("rightPad",r,t,n),M("padWidth",r,t,n),M("preserveShortSequences",r,t,n));return[i,a]}case"StringSplit":{let{indices:i,values:a,shape:o}=s.string.stringSplit(M("input",r,t,n),M("delimiter",r,t,n),M("skipEmpty",r,t,n));return[i,a,o]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(M("input",r,t,n),M("numBuckets",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}},eWe=(r,t,n,s=Is)=>{switch(r.op){case"Cast":return[s.cast(M("x",r,t,n),M("dtype",r,t,n))];case"ExpandDims":{let i=M("axis",r,t,n);return[s.expandDims(M("x",r,t,n),i)]}case"Squeeze":{let i=M("axis",r,t,n);return[s.squeeze(M("x",r,t,n),i)]}case"Reshape":return[s.reshape(M("x",r,t,n),M("shape",r,t,n))];case"EnsureShape":return[s.ensureShape(M("x",r,t,n),M("shape",r,t,n))];case"MirrorPad":return[s.mirrorPad(M("x",r,t,n),M("padding",r,t,n),M("mode",r,t,n))];case"PadV2":case"Pad":return[s.pad(M("x",r,t,n),M("padding",r,t,n),M("constantValue",r,t,n))];case"SpaceToBatchND":{let i=M("blockShape",r,t,n),a=M("paddings",r,t,n);return[s.spaceToBatchND(M("x",r,t,n),i,a)]}case"BatchToSpaceND":{let i=M("blockShape",r,t,n),a=M("crops",r,t,n);return[s.batchToSpaceND(M("x",r,t,n),i,a)]}case"DepthToSpace":{let i=M("blockSize",r,t,n),a=M("dataFormat",r,t,n).toUpperCase();return[s.depthToSpace(M("x",r,t,n),i,a)]}case"BroadcastTo":return[s.broadcastTo(M("x",r,t,n),M("shape",r,t,n))];case"BroadcastArgs":return[s.broadcastArgs(M("s0",r,t,n),M("s1",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function _V(r,t,n,s,i=Ie){let a=((o,u,l)=>{switch(o.category){case"arithmetic":return i(()=>T6e(o,u,l));case"basic_math":return i(()=>A6e(o,u,l));case"control":return M6e(o,u,l);case"convolution":return i(()=>L6e(o,u,l));case"creation":return i(()=>P6e(o,u,l));case"dynamic":return B6e(o,u,l);case"evaluation":return i(()=>V6e(o,u,l));case"image":return i(()=>G6e(o,u,l));case"graph":return i(()=>z6e(o,u,l));case"logical":return i(()=>H6e(o,u,l));case"matrices":return i(()=>j6e(o,u,l));case"normalization":return i(()=>q6e(o,u,l));case"ragged":return i(()=>K6e(o,u,l));case"reduction":return i(()=>X6e(o,u,l));case"slice_join":return i(()=>Y6e(o,u,l));case"sparse":return i(()=>Z6e(o,u,l));case"spectral":return i(()=>J6e(o,u,l));case"string":return i(()=>Q6e(o,u,l));case"transformation":return i(()=>eWe(o,u,l));case"hash_table":return W6e(o,u,l,s);case"custom":let c=pZ(o.op);if(c&&c.customExecutor)return c.customExecutor(new N6e(o,u,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,t,n);return O.isPromise(a)?a.then(o=>[].concat(o)):[].concat(a)}var EV=class{constructor(r={},t={},n={},s={},i){this.weightMap=r,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=s,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(r,t){return{id:r,frameName:t,iterationId:0}}set currentContext(r){this.contexts!==r&&(this.contexts=r,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let r=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);r.push(this.contextIdforContexts(n))}r.push(""),this._currentContextIds=r}contextIdforContexts(r){return r?r.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(r){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,r)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let r=Object.assign({},this.contexts[this.contexts.length-1]);r.iterationId+=1,r.id=this.lastId,this.contexts.splice(-1,1,r),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(r){return this.weightMap[r]}addTensorArray(r){this.tensorArrayMap[r.id]=r}getTensorArray(r){return this.tensorArrayMap[r]}addTensorList(r){this.tensorListMap[r.id]=r}getTensorList(r){return this.tensorListMap[r]}dispose(r){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(r);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(r)}};function IV(r,t,n,s){let i=new Set,a=[],o=null,u=null,l=new Set,c=new Set(Object.keys(r).map(p=>Hi(p)[0]));s=s||[];let h=new Set(s.map(p=>Hi(p.name)[0])),d=[...t];for(;d.length>0;){let p=d.pop();if((Eh(p)||uWe(p)||lWe(p))&&o==null&&(o=p,u=o.children.map(f=>f.name).filter(f=>i.has(f))),i.add(p.name),n[p.name]==null&&!c.has(p.name)&&!h.has(p.name)){if(p.inputs.length===0){a.push(p.name);continue}p.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),d.push(f))})}}return{inputs:r,outputs:t,usedNodes:i,missingInputs:a,dynamicNode:o,syncInputs:u}}function tWe(r,t){let{usedNodes:n,inputs:s}=t,i=Object.keys(s).map(y=>Hi(y)[0]).map(y=>r.nodes[y]),a=r.initNodes||[],o=y=>n.has(typeof y=="string"?y:y.name);function u(y){return[...new Map(y.map(b=>[b.name,b])).values()]}let l=u([...i,...r.weights,...a]).filter(o),c=u([...l,...Object.values(r.nodes)]).filter(o),h=new Map(c.map(y=>[y.name,y])),d={};for(let y of c){d[y.name]=d[y.name]||0;for(let b of y.children)o(b)||(d[b.name]=Number.POSITIVE_INFINITY),d[b.name]=(d[b.name]||0)+1}let p=Object.entries(d).filter(([,y])=>y===0).map(([y])=>y),f=[...p];for(;p.length>0;){let y=p.pop(),b=h.get(y);for(let x of b.children.filter(o))--d[x.name]===0&&(f.push(x.name),p.push(x.name))}let m=f.map(y=>h.get(y)),g=rWe(m,l);return nWe(g,l),g}function rWe(r,t){let n=new Map(r.map(a=>[a.name,a])),s=t.map(a=>a.name),i=new Set(s);for(;s.length>0;){let a=s.pop(),o=n.get(a);for(let u of o.children)!n.has(u.name)||i.has(u.name)||(i.add(u.name),s.push(u.name))}return r.filter(a=>i.has(a.name))}var M1=class extends Error{constructor(r){super(`NodesExecutionOrderError: ${r}`)}};function nWe(r,t){let n=new Map(r.map((u,l)=>[u.name,l])),s=new Set(t.map(u=>u.name)),i=u=>s.has(typeof u=="string"?u:u.name),a=new Set(r.map(u=>u.name)),o=u=>a.has(typeof u=="string"?u:u.name);for(let u of r){for(let l of u.children.filter(o)){if(!n.has(l.name))throw new M1(`Child ${l.name} of node ${u.name} is unreachable.`);if(n.get(u.name)>n.get(l.name))throw new M1(`Node ${u.name} is scheduled to run after its child ${l.name}.`)}if(!i(u))for(let l of u.inputs){if(!n.has(l.name))throw new M1(`Input ${l.name} of node ${u.name} is unreachable.`);if(n.get(l.name)>n.get(u.name))throw new M1(`Node ${u.name} is scheduled to run before its input ${l.name}.`)}}}function sWe(r){let t=new Map(r.map((u,l)=>[u.name,l])),n=Number.MAX_SAFE_INTEGER,s=r.map((u,l)=>Eh(u)?n:l),i=u=>{let l=s[t.get(u.name)];return l??-1},a=r.map((u,l)=>u.children.map(i).reduce((c,h)=>Math.max(c,h),s[l])),o=new Map;for(let u=0;u<r.length;++u){let l=a[u];if(l===n)continue;let c=r[u],h=r[l];o.has(h.name)||o.set(h.name,[]),o.get(h.name).push(c)}return o}var iWe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),aWe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),oWe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Eh(r){return iWe.has(r.op)}function uWe(r){return aWe.has(r.op)}function lWe(r){return oWe.has(r.op)}var kV=class OZ{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(s=>t[s].map(i=>i.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(s=>{this._functionExecutorMap[s]=new OZ(t.functions[s],this)})}getCompilationKey(t,n){let s=t.map(a=>a.name).sort(),i=n.map(a=>a.name).sort();return s.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(t,n){let s=IV(t,n,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:a,syncInputs:o}=s;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(i.length>0){let c=n.map(d=>d.name),h=Object.keys(t);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${h}]. Missing the following inputs: [${i}]`)}let u=tWe(this.graph,s),l=sWe(u);return{orderedNodes:u,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return ns(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,s])=>[n,this.cloneTensorList(s)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let i=s.map(p=>this.graph.nodes[Hi(p)[0]]),a=n.map(p=>Hi(p)[0]),o=new Set(a),u=a.map(p=>this.graph.nodes[p]);u.length===0&&(u=this._outputs);let l=this.getCompilationKey(i,u),c=this.compiledMap.get(l);c==null&&(c=this.compile(t,u),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=Re().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}let h={},d={};return Ie(()=>{let p=new EV(this.weightMap,h,d,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(b=>{let[x,w]=Hi(b,p),v=[];v[w]=t[b],f[x]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[x]=this.cloneTensorList(v))});let m=this.getFrozenTensorIds(f),{orderedNodes:g,nodeLiveUntilMap:y}=c;for(let b of g){if(f[b.name])continue;let x=_V(b,f,p,this._resourceManager);if(O.isPromise(x))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);f[b.name]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(x)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,f,p,m,o,y.get(b.name))}return this.parent==null&&p.dispose(m),n.map(b=>As(b,f,p))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(s=>t[s]).map(s=>s.map(i=>i.id)));return new Set(n)}checkTensorForDisposal(t,n,s,i,a,o,u){if(!(Eh(n)||o.has(t))){for(let l of s[t])l!=null&&(u[l.id]=(u[l.id]||0)+n.children.length);for(let l of n.inputs){if(Eh(l))continue;let c=xV(l.name,s,i);if(c!=null)for(let h of c){if(!h||h.kept||a.has(h.id))continue;let d=u[h.id];d===1?(h.dispose(),delete u[h.id]):d!=null&&u[h.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,s,i,a,o){function u(l){return Eh(l)||a.has(l.name)}if(!(Eh(t)||o==null))for(let l of o){if(u(l))continue;let c=xV(l.name,n,s);for(let h of c)!h||h.kept||i.has(h.id)||h.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,s=!1,i={},a={}){this.disposeIntermediateTensors(),s||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=Re().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}let o=new EV(this.weightMap,i,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let u=await this.executeWithControlFlow(t,o,n,s),l=n.map(p=>As(p,u,o)),c=l.map(p=>p.id),h=Object.keys(t).map(p=>t[p].id),d=new Set([...c,...h,...this.weightIds]);return Object.values(u).forEach(p=>{p.forEach(f=>{f&&!f.isDisposed&&!d.has(f.id)&&f.dispose()})}),this.parent==null&&o.dispose(d),l}async executeFunctionAsync(t,n,s){let i=t.reduce((a,o,u)=>(a[this.inputs[u].name]=o,a),{});return this._executeAsync(i,this.outputNodes,!0,n,s)}async executeWithControlFlow(t,n,s,i){let a=Object.keys(t),o=a.map(v=>this.graph.nodes[Hi(v)[0]]),u=s.map(v=>Hi(v)[0]),l=new Set(u),c=u.map(v=>this.graph.nodes[v]);c.length===0&&(c=this._outputs);let{usedNodes:h,missingInputs:d,dynamicNode:p,syncInputs:f}=IV(t,c,this.weightMap,this._initNodes),m=[...o,...this.graph.weights,...this._initNodes||[]].map(v=>({node:v,contexts:n.currentContext})),g=Object.assign({},this.weightMap);Object.keys(t).forEach(v=>{let[S,E]=Hi(v),C=[];C[E]=t[v],g[S]=C});let y={},b=this.getFrozenTensorIds(g),x={};for(;m.length>0;){let v=this.processStack(o,m,n,g,x,b,l,y,h);await Promise.all(v)}p==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let w=c.filter(v=>!Eh(v)&&!As(v.name,g,n)).map(v=>v.name);if(w.length>0){let v="";throw p!=null&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${a}]. Consider providing the following inputs: [${d}]. ${v}`)}return g}processStack(t,n,s,i,a,o,u,l,c){let h=[];for(;n.length>0;){let d=n.pop();s.currentContext=d.contexts;let p="";if(d.node.op==="Enter"&&M("isConstant",d.node,i,s)&&([p]=Pu(d.node.name,s)),i[d.node.name]==null){let f=_V(d.node,i,s,this._resourceManager);p||([p]=Pu(d.node.name,s));let m=s.currentContext;O.isPromise(f)?h.push(f.then(g=>(i[p]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(g)),s.currentContext=m,this.checkTensorForDisposal(p,d.node,i,s,o,u,l),this.processChildNodes(d.node,n,s,i,a,c),g))):(i[p]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(f)),this.checkTensorForDisposal(p,d.node,i,s,o,u,l),this.processChildNodes(d.node,n,s,i,a,c))}else this.processChildNodes(d.node,n,s,i,a,c)}return h}processChildNodes(t,n,s,i,a,o){t.children.forEach(u=>{let[l]=Pu(u.name,s);a[l]||!o.has(u.name)||(u.op==="Merge"?u.inputNames.some(c=>!!As(c,i,s))&&(a[l]=!0,n.push({contexts:s.currentContext,node:u})):u.inputNames.every(c=>!!As(c,i,s))&&(a[l]=!0,n.push({contexts:s.currentContext,node:u})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let s=t[n],[i]=Hi(n),a=this.graph.nodes[i];if(a.attrParams.shape&&a.attrParams.shape.value){let o=a.attrParams.shape.value,u=o.length===s.shape.length&&s.shape.every((l,c)=>o[c]===-1||o[c]===l);O.assert(u,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&O.assert(s.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(t){var n,s;let i={};for(let a in t){let o=(s=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||s===void 0?void 0:s[a];o!=null?i[o.name]=t[a]:i[a]=t[a]}return i}checkInputs(t){let n=Object.keys(t).filter(s=>{let[i]=Hi(s);return this.graph.nodes[i]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var s,i;let a=(i=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||i===void 0?void 0:i[n];return a!=null?a.name:n},{})}checkOutputs(t){t.forEach(n=>{let[s]=Hi(n);if(!this.graph.nodes[s])throw new Error(`The output '${n}' is not found in the graph`)})}},cWe=class{constructor(r={},t={}){this.hashTableNameToHandle=r,this.hashTableMap=t}addHashTable(r,t){this.hashTableNameToHandle[r]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(r){return this.hashTableNameToHandle[r]}getHashTableById(r){return this.hashTableMap[r]}dispose(){for(let r in this.hashTableMap)this.hashTableMap[r].clearAndClose(),delete this.hashTableMap[r];for(let r in this.hashTableNameToHandle)this.hashTableNameToHandle[r].dispose(),delete this.hashTableNameToHandle[r]}},hWe="?tfjs-format=file",dWe="model.json",LM=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(r,t={},n=$s){this.modelUrl=r,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new cWe}findIOHandler(){let r=this.modelUrl;if(r.load!=null)this.handler=r;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(r,this.loadOptions);else{let t=this.io.getLoadHandlers(r,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(r,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[r]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=this.handler.load();return O.isPromise(r)?r.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(r)}loadSync(r){let t=this.io.decodeWeights(r.weightData,r.weightSpecs);return this.loadWithWeightMap(r,t)}async loadStreaming(r){if(r.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await Pq(r.getWeightStream(),r.weightSpecs);return this.loadWithWeightMap(r,t)}loadWithWeightMap(r,t){this.artifacts=r;let n=this.artifacts.modelTopology,s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let i=this.artifacts.userDefinedMetadata;i.signature!=null&&(s=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=s,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new kV(vV.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,r.modelInitializer!=null&&r.modelInitializer.node!=null){let i=vV.Instance.transformGraph(r.modelInitializer);this.initializer=new kV(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=r.initializerSignature}return!0}async save(r,t){if(typeof r=="string"){let n=this.io.getSaveHandlers(r);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${r}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${r}'`);r=n[0]}if(r.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return r.save(this.artifacts)}addStructuredOutputNames(r){if(this.structuredOutputKeys){let t=r instanceof ur?[r]:r,n={};return t.forEach((s,i)=>n[this.structuredOutputKeys[i]]=s),n}return r}predict(r,t){let n=this.execute(r,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(r,t){let n=await this.executeAsync(r,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(r){var t;if(!(r instanceof ur)&&!Array.isArray(r)){let i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(let a in i){let o=i[a];o.resourceId!=null&&(r[a]=this.resourceIdToCapturedInput[o.resourceId])}return r}r=Array.isArray(r)?r:[r];let n=Object.keys(this.resourceIdToCapturedInput).length;if(r.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${r.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((i,a)=>{var o,u,l;let c=(l=(u=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||u===void 0?void 0:u[a])===null||l===void 0?void 0:l.resourceId;return c!=null?i[a]=this.resourceIdToCapturedInput[c]:i[a]=r[s++],i},{})}normalizeOutputs(r){return r=r||this.outputNodes,Array.isArray(r)?r:[r]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(r){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let s=0;s<n.length;s++){let i=n[s],a=t[i];this.resourceIdToCapturedInput[a.resourceId]=r[s]}}}execute(r,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),r=this.normalizeInputs(r),t=this.normalizeOutputs(t);let n=this.executor.execute(r,t);return n.length>1?n:n[0]}async executeAsync(r,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),r=this.normalizeInputs(r),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(r,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(r){return Object.keys(r).reduce((t,n)=>(t[n]=[r[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&nr(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function pWe(r,t={},n=$s){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof r=="string"&&(r=mWe(r));let s=new LM(r,t,n);return await s.load(),s}function fWe(r){if(r==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(r instanceof Array){let[s,i]=r;if(!s)throw new Error("modelJSON must be the first element of the array");if(!i||!(i instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");let a=$s.getWeightSpecs(s.weightsManifest),o=$s.getModelArtifactsForJSONSync(s,a,i);t=$s.fromMemorySync(o)}else if("load"in r)t=r;else if("modelTopology"in r&&"weightSpecs"in r&&"weightData"in r)t=$s.fromMemorySync(r);else throw new Error("Unknown model format");let n=new LM(t);return n.load(),n}function mWe(r){return r.endsWith("/")||(r=r+"/"),`${r}${dWe}${hWe}`}var gWe="4.22.0",MZ={};ir(MZ,{CSVDataset:()=>qZ,Dataset:()=>L0,FileDataSource:()=>eJ,TextLineDataset:()=>jZ,URLDataSource:()=>tJ,array:()=>BWe,csv:()=>JWe,func:()=>QWe,generator:()=>e8e,microphone:()=>r8e,version_data:()=>n8e,webcam:()=>t8e,zip:()=>VWe});var yWe=Oc(SC()),bWe=Oc(SC());function xWe(r,t){return X2(r,t)}function X2(r,t,n=new Map,s=new Set){if(r==null)return null;if(typeof Blob=="function"&&r instanceof Blob)return r.slice();if(s.has(r))throw new Error("Circular references are not supported.");if(n.has(r))return n.get(r);let i=t(r);if(i.recurse&&i.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse)if(eg(r)){let a=Array.isArray(r)?[]:{};s.add(r);for(let o in r){let u=r[o],l=X2(u,t,n,s);a[o]=l}return s.delete(r),r.__proto__&&(a.__proto__=r.__proto__),a}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return n.set(r,i.value),i.value}function vWe(r,t=PZ){return LZ(r,t)}function LZ(r,t,n=new Set){let s=r[0];if(n.has(s))throw new Error("Circular references are not supported.");let i=t(r);if(i.recurse&&i.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse)if(eg(s)){let a=Array.isArray(s)?[]:{};n.add(s);for(let o in s){let u=r.map(c=>c[o]),l=LZ(u,t,n);a[o]=l}return n.delete(s),a}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return i.value}function PZ(r){return r===null?null:eg(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}async function BZ(r,t){let n=new Map;X2(r,t,n);for(let s of Array.from(n.keys())){let i=n.get(s);if(O.isPromise(i)){let a=await i;n.set(s,a)}}return X2(r,t,n)}function eg(r){let t=!1;if(Re().get("IS_BROWSER"))t=r instanceof TextDecoder;else{let{StringDecoder:n}=sq();t=r instanceof n}return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof ur)&&!(r instanceof Promise)&&!t)}function wWe(r){return r==null||SWe(r)||Array.isArray(r)||typeof r=="object"&&r instanceof ur||O.isTypedArray(r)}function SWe(r){return r===null||typeof r!="object"&&typeof r!="function"}function CWe(r){return xWe(r,_We)}function _We(r){return r instanceof ur?{value:r.clone(),recurse:!1}:eg(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var VZ=class{constructor(r){if(this.capacity=r,this.begin=0,this.end=0,r==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(r<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(r),this.doubledCapacity=2*r}wrap(r){for(;r<0;)r+=this.doubledCapacity;return r%this.doubledCapacity}get(r){if(r<0)throw new RangeError("Can't get item at a negative index.");return this.data[r%this.capacity]}set(r,t){if(r<0)throw new RangeError("Can't set item at a negative index.");this.data[r%this.capacity]=t}length(){let r=this.end-this.begin;return r<0&&(r=this.doubledCapacity+r),r}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(r){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,r),this.end=this.wrap(this.end+1)}pushAll(r){for(let t of r)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let r=this.get(this.end);return this.set(this.end,void 0),r}unshift(r){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,r)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let r=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),r}shuffleExcise(r){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+r),n=this.get(t);return this.set(t,this.pop()),n}},zZ=class UZ extends VZ{constructor(){super(UZ.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),s=this.length();for(let i=0;i<s;i++)n[i]=this.get(this.wrap(this.begin+i));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}};zZ.INITIAL_CAPACITY=32;function WZ(r){return new kWe(r)}function PM(r){return new NWe(r)}function EWe(r,t){return new GZ(r,t)}function IWe(r,t=Zl.FAIL){return new LWe(r,t)}var Es=class{async toArray(){let r=[],t=await this.next();for(;!t.done;)r.push(t.value),t=await this.next();return r}async toArrayForTest(){let r=this.prefetch(100),t=[],n=await r.next();for(;!n.done;)t.push(n.value),n=await r.next();return t}async resolveFully(){let r=await this.next();for(;!r.done;)r=await this.next()}async resolveWhile(r){let t=await this.next(),n=r(t.value);for(;!t.done&&n;)t=await this.next(),n=r(t.value)}handleErrors(r){return new OWe(this,r)}filter(r){return new $We(this,r)}map(r){return new RWe(this,r)}mapAsync(r){return new NV(this,r)}serialMapAsync(r){return new NV(this,r).serial()}flatmap(r){return new MWe(this,r)}async forEachAsync(r){return this.map(r).resolveFully()}async serialForEach(r){return this.serialMapAsync(r).resolveWhile(t=>t===!0)}rowMajorBatch(r,t=!0){return new FWe(this,r,t)}columnMajorBatch(r,t=!0,n=PZ){return this.rowMajorBatch(r,t).map(s=>vWe(s,n))}concatenate(r,t){return new GZ(WZ([this,r]),t)}take(r){return r<0||r==null?this:new DWe(this,r)}skip(r){return r<0||r==null?this:new AWe(this,r)}prefetch(r){return new HZ(this,r)}shuffle(r,t){return new PWe(this,r,t)}serial(){return new TWe(this)}},kWe=class extends Es{constructor(r){super(),this.items=r,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let r=this.items[this.trav];return this.trav++,{value:CWe(r),done:!1}}},NWe=class extends Es{constructor(r){super(),this.nextFn=r}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(r){throw r.message=`Error thrown while iterating through a dataset: ${r.message}`,r}}},TWe=class extends Es{constructor(r){super(),this.upstream=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},AWe=class extends Es{constructor(r,t){super(),this.upstream=r,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let r=await this.upstream.next();if(r.done)return r;nr(r.value)}return this.upstream.next()}},DWe=class extends Es{constructor(r,t){super(),this.upstream=r,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},FWe=class extends Es{constructor(r,t,n=!0){super(),this.upstream=r,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let r=[];for(;r.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&r.length>0?{value:r,done:!1}:{value:null,done:!0};r.push(t.value)}return{value:r,done:!1}}},$We=class extends Es{constructor(r,t){super(),this.upstream=r,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let r=await this.upstream.next();if(r.done||this.predicate(r.value))return r;nr(r.value)}}},RWe=class extends Es{constructor(r,t){super(),this.upstream=r,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let r=await this.upstream.next();if(r.done)return{value:null,done:!0};let t=No.getTensorsInContainer(r.value),n=this.transform(r.value),s=No.getTensorsInContainer(n);for(let i of t)No.isTensorInList(i,s)||i.dispose();return{value:n,done:!1}}},OWe=class extends Es{constructor(r,t){super(),this.upstream=r,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(r){if(!this.handler(r))return{value:null,done:!0}}}},NV=class extends Es{constructor(r,t){super(),this.upstream=r,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let r=await this.upstream.next();if(r.done)return{value:null,done:!0};let t=No.getTensorsInContainer(r.value),n=await this.transform(r.value),s=No.getTensorsInContainer(n);for(let i of t)No.isTensorInList(i,s)||i.dispose();return{value:n,done:!1}}},BM=class extends Es{constructor(){super(),this.outputQueue=new zZ,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},MWe=class extends BM{constructor(r,t){super(),this.upstream=r,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let r=await this.upstream.next();if(r.done)return!1;let t=No.getTensorsInContainer(r.value),n=this.transform(r.value),s=No.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let i of t)No.isTensorInList(i,s)||i.dispose();return!0}},GZ=class extends Es{constructor(r,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=r}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(r){if(await r,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(r)):t}},Zl;(function(r){r[r.FAIL=0]="FAIL",r[r.SHORTEST=1]="SHORTEST",r[r.LONGEST=2]="LONGEST"})(Zl||(Zl={}));var LWe=class extends Es{constructor(r,t=Zl.FAIL){super(),this.iterators=r,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(r){await r;let t=0,n=0;function s(a){return a instanceof Es?{value:a.next().then(o=>(t++,o.done&&n++,o.value)),recurse:!1}:{value:null,recurse:!0}}let i=await BZ(this.iterators,s);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case Zl.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Zl.SHORTEST:return{value:null,done:!0};case Zl.LONGEST:}return this.count++,{value:i,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},HZ=class extends Es{constructor(r,t){super(),this.upstream=r,this.bufferSize=t,this.buffer=new VZ(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let r=this.upstream.next();this.buffer.push(r)}}next(){return this.refill(),this.buffer.shift()}},PWe=class extends HZ{constructor(r,t,n){super(r,t),this.upstream=r,this.windowSize=t,this.upstreamExhausted=!1,this.random=bWe.alea(n||O.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(r){return Math.floor(this.random()*r)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let r=this.chooseIndex(),t=await this.buffer.shuffleExcise(r);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},L0=class{constructor(){this.size=null}batch(r,t=!0){let n=this;O.assert(r>0,()=>`batchSize needs to be positive, but it is
      ${r}`);let s;return this.size===1/0||this.size==null?s=this.size:t?s=Math.ceil(this.size/r):s=Math.floor(this.size/r),Gi(async()=>(await n.iterator()).columnMajorBatch(r,t,zWe),s)}concatenate(r){let t=this,n;return this.size===1/0||r.size===1/0?n=1/0:this.size!=null&&r.size!=null?n=this.size+r.size:n=null,Gi(async()=>(await t.iterator()).concatenate(await r.iterator()),n)}filter(r){let t=this,n;return this.size===1/0?n=1/0:n=null,Gi(async()=>(await t.iterator()).filter(s=>Ie(()=>r(s))),n)}async forEachAsync(r){return(await this.iterator()).forEachAsync(r)}map(r){let t=this;return Gi(async()=>(await t.iterator()).map(n=>Ie(()=>r(n))),this.size)}mapAsync(r){let t=this;return Gi(async()=>(await t.iterator()).mapAsync(r),this.size)}prefetch(r){if(r==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Gi(async()=>(await t.iterator()).prefetch(r),this.size)}repeat(r){let t=this,n;return this.size!=null&&r>0?n=this.size*r:r===0?n=0:this.size!=null&&(r===void 0||r<0)?n=1/0:n=null,Gi(async()=>{let s=PM(async()=>({value:await t.iterator(),done:!1}));return EWe(s.take(r))},n)}skip(r){let t=this,n;return this.size!=null&&r>=0&&this.size>=r?n=this.size-r:this.size!=null&&(this.size<r||r===void 0||r<0)?n=0:n=null,Gi(async()=>(await t.iterator()).skip(r),n)}shuffle(r,t,n=!0){if(r==null||r<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let s=this,i=yWe.alea(t||O.now().toString());return Gi(async()=>{let a=i.int32();return n&&(a+=i.int32()),(await s.iterator()).shuffle(r,a.toString())},this.size)}take(r){let t=this,n;return this.size!=null&&this.size>r?n=r:this.size!=null&&this.size<=r?n=this.size:n=null,Gi(async()=>(await t.iterator()).take(r),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};L0.MAX_BUFFER_SIZE=1e4;function Gi(r,t=null){return new class extends L0{constructor(){super(...arguments),this.size=t}async iterator(){return r()}}}function BWe(r){return Gi(async()=>WZ(r),r.length)}function VWe(r){if(!eg(r))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(r))for(let n=0;n<r.length;n++)t=t==null?r[n].size:Math.min(t,r[n].size);else if(r instanceof Object)for(let n in r)t=t==null?r[n].size:Math.min(t,r[n].size);return Gi(async()=>{let n=await BZ(r,s=>{if(s instanceof L0)return{value:s.iterator(),recurse:!1};if(eg(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return IWe(n,Zl.SHORTEST)},t)}function zWe(r){if(r===null)return null;let t=r[0];return wWe(t)?{value:UWe(r),recurse:!1}:{value:null,recurse:!0}}function UWe(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof ur?Yn(r):ai(r)}var jZ=class extends L0{constructor(r){super(),this.input=r}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}},L1='"',yy=Symbol("out"),TV=Symbol("field"),P1=Symbol("quote"),pI=Symbol("quoteafterquote"),AV=Symbol("quoteinquote"),qZ=class extends L0{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let r=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!r)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&r&&O.assert(r.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+r.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=r);let t=this.fullColumnNames.reduce((s,i)=>(s[i]=s[i]+1||1,s),{}),n=Object.keys(t).filter(s=>t[s]>1);if(O.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let s of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(s)===-1)throw new Error('The key "'+s+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let r=await(await this.base.iterator()).next();if(r.done)throw new Error("No data was found for CSV parsing.");let t=r.value;return this.parseRow(t,!1)}else return null}constructor(r,t){super(),this.input=r,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new jZ(r),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(O.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let r=await this.base.iterator();return this.hasHeader&&(r=r.skip(1)),r.map(t=>this.makeDataElement(t))}makeDataElement(r){let t=this.parseRow(r),n={},s={};for(let i=0;i<this.fullColumnNames.length;i++){let a=this.fullColumnNames[i],o=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!o)){let u=t[i],l=null;if(u==="")if(o&&o.default!==void 0)l=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${a} is empty in this line: ${r}`);l=void 0}else{let c=Number(u);if(isNaN(c))o&&o.dtype==="bool"?l=this.getBoolean(u):l=u;else if(!o||!o.dtype)l=c;else switch(o.dtype){case"float32":l=c;break;case"int32":l=Math.floor(c);break;case"bool":l=this.getBoolean(u);break;default:l=c}}o&&o.isLabel?s[a]=l:n[a]=l}}return Object.keys(s).length===0?n:{xs:n,ys:s}}getBoolean(r){return r==="1"||r.toLowerCase()==="true"?1:0}parseRow(r,t=!0){let n=[],s=0,i=r.length,a=yy;for(let o=0;o<i;o++)switch(a){case yy:switch(r.charAt(o)){case L1:s=o+1,a=P1;break;case this.delimiter:if(s=o+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),a=yy;break;default:a=TV,s=o;break}break;case TV:switch(r.charAt(o)){case this.delimiter:n.push(r.substring(s,o)),a=yy,s=o+1;break}break;case P1:switch(r.charAt(o)){case L1:a=pI;break}break;case pI:switch(r.charAt(o)){case this.delimiter:n.push(r.substring(s,o-1)),a=yy,s=o+1;break;case L1:a=P1;break;default:a=AV;break}break;case AV:switch(r.charAt(o)){case L1:a=P1;break}break}if(a===pI?n.push(r.substring(s,i-1)):n.push(r.substring(s)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},WWe=class KZ extends Es{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!Re().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new KZ(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,s=await this.getAudioData();if(this.includeSpectrogram){let i=this.flattenQueue(s.freqDataQueue);t=this.getTensorFromAudioDataArray(i,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let i=this.flattenQueue(s.timeDataQueue);n=this.getTensorFromAudioDataArray(i,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],s=0;return new Promise(i=>{let a=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&i({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(a),i({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,s=new Float32Array(t.length*n);return t.forEach((i,a)=>s.set(i,a*n)),s}getTensorFromAudioDataArray(t,n){let s=new Float32Array(O.sizeFromShape(n));return s.set(t,s.length-t.length),ai(s,n)}},GWe=class XZ extends Es{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=qr([0],"int32"),this.webcamConfig.centerCrop){let s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,i=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,a=(1-s)/2,o=(1-i)/2,u=a+s,l=i+o;this.cropBox=ou([o,a,l,u],[1,4])}else this.cropBox=ou([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!Re().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let s=new XZ(t,n);return await s.start(),s}async start(){this.webcamConfig.facingMode&&O.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=Sv.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return Ie(()=>{let n=bs(at(t,"float32"),0),s;s=pa.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let i=s.shape;return Ee(s,i.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},YZ=class{},ZZ=class extends Es{split(r){return new HWe(this,r)}},HWe=class extends ZZ{constructor(r,t){super(),this.upstream=r,this.impl=new jWe(r,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},jWe=class extends BM{constructor(r,t){super(),this.upstream=r,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let r=await this.upstream.next();if(r.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=r.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},qWe=class extends Es{decodeUTF8(){return new KWe(this)}},KWe=class extends ZZ{constructor(r){super(),this.upstream=r,this.impl=new XWe(r)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},XWe=class extends BM{constructor(r){if(super(),this.upstream=r,Re().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=sq();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let r=await this.upstream.next(),t;if(r.done)return!1;t=r.value;let n;return Re().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},JZ=class extends qWe{constructor(r,t={}){super(),this.file=r,this.options=t,O.assert(r instanceof Uint8Array||(Re().get("IS_BROWSER")?r instanceof File||r instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((r,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)r(new Uint8Array(this.file.slice(this.offset,n)));else{let s=new FileReader;s.onload=a=>{let o=s.result;if(o instanceof ArrayBuffer&&(o=new Uint8Array(o)),!(o instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));r(o)},s.onabort=a=>t(new Error("Aborted")),s.onerror=a=>t(new Error(a.type));let i=this.file.slice(this.offset,n);s.readAsArrayBuffer(i)}this.offset=n}),done:!1}}};async function YWe(r,t={},n){let s,i;typeof r=="string"?s=r:(s=r.url,i=ZWe(r));let a=await(0,O.fetch)(s,i);if(a.ok){let o=new Uint8Array(await a.arrayBuffer());return new JZ(o,t)}else throw new Error(a.statusText)}var ZWe=r=>({method:r.method,headers:r.headers,body:r.body,mode:r.mode,credentials:r.credentials,cache:r.cache,redirect:r.redirect,referrer:r.referrer,integrity:r.integrity});function QZ(r){return typeof r=="string"&&r.slice(0,7)==="file://"}var eJ=class extends YZ{constructor(r,t={}){super(),this.input=r,this.options=t}async iterator(){if(QZ(this.input)&&Re().get("IS_NODE")){let r=AR();this.input=r.readFileSync(this.input.slice(7))}return new JZ(this.input,this.options)}},tJ=class extends YZ{constructor(r,t={}){super(),this.url=r,this.fileOptions=t}async iterator(){return QZ(this.url)?new eJ(this.url,this.fileOptions).iterator():YWe(this.url,this.fileOptions)}};function JWe(r,t={}){return new qZ(new tJ(r),t)}function QWe(r){let t=PM(r);return Gi(async()=>t)}function e8e(r){return Gi(async()=>{let t=await r();return PM(()=>t.next())})}async function t8e(r,t){return GWe.create(r,t)}async function r8e(r){return WWe.create(r)}var n8e="4.22.0";function Dt(r,t){Array.isArray(r)||(r=[r]),r.forEach(n=>{n!=null&&O.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var s8e=ku.whereImpl,VM=class rJ extends Rx{nextDataId(){return rJ.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new CC(this,Ma())}write(t,n,s){this.firstUse&&(this.firstUse=!1,Re().get("IS_NODE")&&q.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let i={id:this.nextDataId()};return this.data.set(i,{values:t,dtype:s,refCount:1}),i}makeTensorInfo(t,n,s){let i;if(n==="string"&&s!=null&&s.length>0&&O.isString(s[0])){let a=s.map(o=>O.encodeString(o));i=this.write(a,t,n)}else i=this.write(s,t,n);return{dataId:i,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,s,i,a){this.data.set(t,{values:n,dtype:i,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:s}=this.data.get(t);if(n==="complex64"){let i=this.readSync(s.real.dataId),a=this.readSync(s.imag.dataId);return q.mergeRealAndImagArrays(i,a)}return O.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let s=n.map(i=>O.decodeString(i));return pr(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return pr(t.shape,t.dtype,n)}makeOutput(t,n,s){return Ma().makeTensorFromTensorInfo(this.makeTensorInfo(n,s,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:s}=this.data.get(t);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=O.now();return t(),{kernelMs:O.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Dt([t],"where");let n=this.readSync(t.dataId);return s8e(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};VM.nextDataId=0;var zM={};ir(zM,{addImpl:()=>iJ,bincountImpl:()=>WM,bincountReduceImpl:()=>aJ,bitwiseAndImpl:()=>oJ,castImpl:()=>sJ,ceilImpl:()=>uJ,concatImpl:()=>GM,equalImpl:()=>lJ,expImpl:()=>hJ,expm1Impl:()=>pJ,floorDivImpl:()=>mJ,floorImpl:()=>fJ,gatherNdImpl:()=>gJ,gatherV2Impl:()=>yJ,greaterEqualImpl:()=>xJ,greaterImpl:()=>bJ,lessEqualImpl:()=>wJ,lessImpl:()=>vJ,linSpaceImpl:()=>SJ,logImpl:()=>CJ,maxImpl:()=>_J,maximumImpl:()=>EJ,minimumImpl:()=>IJ,multiplyImpl:()=>HM,negImpl:()=>kJ,notEqualImpl:()=>NJ,prodImpl:()=>TJ,raggedGatherImpl:()=>AJ,raggedRangeImpl:()=>DJ,raggedTensorToTensorImpl:()=>FJ,rangeImpl:()=>qM,rsqrtImpl:()=>$J,scatterImpl:()=>Dh,sigmoidImpl:()=>nGe,simpleAbsImpl:()=>nJ,sliceImpl:()=>Z2,sparseFillEmptyRowsImpl:()=>OJ,sparseReshapeImpl:()=>MJ,sparseSegmentReductionImpl:()=>KM,sqrtImpl:()=>aGe,squaredDifferenceImpl:()=>LJ,staticRegexReplaceImpl:()=>PJ,stridedSliceImpl:()=>BJ,stringNGramsImpl:()=>XM,stringSplitImpl:()=>YM,stringToHashBucketFastImpl:()=>ZM,subImpl:()=>VJ,tileImpl:()=>zJ,topKImpl:()=>WJ,transposeImpl:()=>jM,uniqueImpl:()=>QM});function nJ(r){let t=new Float32Array(r.length);for(let n=0;n<r.length;++n)t[n]=Math.abs(r[n]);return t}var i8e=r=>{let{x:t}=r.inputs,n=r.backend;Dt(t,"abs");let s=new Float32Array(O.sizeFromShape(t.shape)),i=n.data.get(t.dataId).values;return s=nJ(i),n.makeOutput(s,t.shape,t.dtype)},a8e={kernelName:Eg,backendName:"cpu",kernelFunc:i8e};function Hn(r){return(t,n,s,i,a)=>{let o=q.assertAndGetBroadcastShape(t,n),u=o.length,l=O.computeStrides(o),c=O.sizeFromShape(o),h=O.getTypedArrayFromDType(a,c),d=t.length,p=n.length,f=O.computeStrides(t),m=O.computeStrides(n),g=q.getBroadcastDims(t,o),y=q.getBroadcastDims(n,o);if(g.length+y.length===0)for(let b=0;b<h.length;++b)h[b]=r(s[b%s.length],i[b%i.length]);else for(let b=0;b<h.length;++b){let x=O.indexToLoc(b,u,l),w=x.slice(-d);g.forEach(C=>w[C]=0);let v=O.locToIndex(w,d,f),S=x.slice(-p);y.forEach(C=>S[C]=0);let E=O.locToIndex(S,p,m);h[b]=r(s[v],i[E])}return[h,o]}}function Yi(r){let{inputs:t,backend:n}=r,{real:s,imag:i}=t,a=n.data.get(s.dataId).values,o=n.data.get(i.dataId).values,u=n.makeTensorInfo(s.shape,"complex64"),l=n.data.get(u.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",a),imag:n.makeTensorInfo(i.shape,"float32",o)},u}var o8e={kernelName:IC,backendName:"cpu",kernelFunc:Yi};function Y2(r,t,n="float32"){if(n==="complex64"){let i=Y2(r,t,"float32"),a=Y2(r,t,"float32");return Yi({inputs:{real:i,imag:a},backend:r})}let s=O.makeZerosTypedArray(O.sizeFromShape(t),n);return r.makeTensorInfo(t,n,s)}function xu(r){let{inputs:t,backend:n}=r,{x:s}=t;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}var u8e={kernelName:vp,backendName:"cpu",kernelFunc:xu};function Cd(r){let{inputs:t,backend:n}=r,{input:s}=t,i=n.data.get(s.dataId).complexTensorInfos.real,a=n.data.get(i.dataId).values;return n.makeTensorInfo(i.shape,i.dtype,a)}var l8e={kernelName:PC,backendName:"cpu",kernelFunc:Cd};function sJ(r,t,n,s){if(s==="int32"){let i=Int32Array.from(r);return[t,"int32",i]}if(s==="bool"){let i=O.toTypedArray([0],n),[a,o]=Hn((u,l)=>u!==l?1:0)(t,[],r,i,"bool");return[o,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)}function kc(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{dtype:a}=s;if(a==="complex64"){if(i.dtype==="complex64")return xu({inputs:{x:i},backend:n});let h=Y2(n,i.shape,i.dtype),d=kc({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),p=Yi({inputs:{real:d,imag:h},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),p}if(i.dtype==="complex64"){let h=Cd({inputs:{input:i},backend:n}),d=kc({inputs:{x:h},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(h),d}if(!O.hasEncodingLoss(i.dtype,a)){let h=xu({inputs:{x:i},backend:n});return{dataId:h.dataId,shape:h.shape,dtype:a}}let o=n.data.get(i.dataId).values,[u,l,c]=sJ(o,i.shape,i.dtype,a);return n.makeTensorInfo(u,l,c)}var c8e={kernelName:tp,backendName:"cpu",kernelFunc:kc};function cs(r,t,n,s){return n==null?({inputs:i,backend:a})=>{let{a:o,b:u}=i,l=a;Dt([o,u],r);let c=l.data.get(o.dataId).values,h=l.data.get(u.dataId).values,d=o.dtype==="string"?q.fromUint8ToStringArray(c):c,p=o.dtype==="string"?q.fromUint8ToStringArray(h):h,f=s||o.dtype,[m,g]=t(o.shape,u.shape,d,p,f);return l.makeTensorInfo(g,f,m)}:({inputs:i,backend:a})=>{let{a:o,b:u}=i,l=a;if(o.dtype==="complex64"||u.dtype==="complex64"){let c=kc({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(c.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=l.data.get(d.dataId).values,m=l.data.get(p.dataId).values,g=kc({inputs:{x:u},backend:l,attrs:{dtype:"complex64"}}),y=l.data.get(g.dataId),b=y.complexTensorInfos.real,x=y.complexTensorInfos.imag,w=l.data.get(b.dataId).values,v=l.data.get(x.dataId).values,[S,E,C]=n(o.shape,u.shape,f,m,w,v),I=l.makeTensorInfo(C,"float32",S),_=l.makeTensorInfo(C,"float32",E),A=Yi({inputs:{real:I,imag:_},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(I),l.disposeIntermediateTensorInfo(_),A}else{let c=l.data.get(o.dataId).values,h=l.data.get(u.dataId).values,d=s||o.dtype,[p,f]=t(o.shape,u.shape,c,h,d);return l.makeTensorInfo(f,d,p)}}}function UM(r){return(t,n,s,i,a,o)=>{let u=q.assertAndGetBroadcastShape(t,n),l=O.sizeFromShape(u),c=u.length,h=O.computeStrides(u),d=O.getTypedArrayFromDType("float32",l),p=O.getTypedArrayFromDType("float32",l),f=q.getBroadcastDims(t,u),m=q.getBroadcastDims(n,u),g=q.mergeRealAndImagArrays(s,i),y=q.mergeRealAndImagArrays(a,o),b=t.length,x=O.computeStrides(t),w=n.length,v=O.computeStrides(n);if(f.length+m.length===0)for(let S=0;S<d.length;S++){let E=S%g.length,C=S%y.length,I=r(g[E*2],g[E*2+1],y[C*2],y[C*2+1]);d[S]=I.real,p[S]=I.imag}else for(let S=0;S<d.length;S++){let E=O.indexToLoc(S,c,h),C=E.slice(-b);f.forEach(N=>C[N]=0);let I=O.locToIndex(C,b,x),_=E.slice(-w);m.forEach(N=>_[N]=0);let A=O.locToIndex(_,w,v),k=r(g[I*2],g[I*2+1],y[A*2],y[A*2+1]);d[S]=k.real,p[S]=k.imag}return[d,p,u]}}var iJ=Hn((r,t)=>r+t),h8e=UM((r,t,n,s)=>({real:r+n,imag:t+s})),tg=cs(Mc,iJ,h8e),d8e={kernelName:Mc,backendName:"cpu",kernelFunc:tg};function WM(r,t,n,s,i){let a=O.sizeFromShape(s),o=O.makeZerosTypedArray(i,n);for(let u=0;u<r.length;u++){let l=r[u];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(a>0?o[l]+=t[u]:o[l]+=1)}return o}function aJ(r,t,n,s=!1){let i=r.shape[0],a=r.shape[1],o=pr([i,n],t.dtype);for(let u=0;u<i;u++)for(let l=0;l<a;l++){let c=r.get(u,l);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(s?o.set(1,u,c):t.size>0?o.set(o.get(u,c)+t.get(u,l),u,c):o.set(o.get(u,c)+1,u,c))}return o}var oJ=Hn((r,t)=>r&t),p8e=cs($g,oJ),f8e={kernelName:$g,backendName:"cpu",kernelFunc:p8e};function Nu(r){return(t,n,s)=>{let i=O.getArrayFromDType(n,t.length);for(let a=0;a<t.length;++a)i[a]=r(t[a],s);return i}}function Qr(r,t,n){let s=Nu(t);return Hc(r,s,n)}function Hc(r,t,n){return({inputs:s,attrs:i,backend:a})=>{let{x:o}=s;Dt(o,r);let u=a,l=u.data.get(o.dataId).values,c;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=q.fromUint8ToStringArray(l)}else c=l;let h=n||o.dtype,d=t(c,h,i);return u.makeTensorInfo(o.shape,h,d)}}var uJ=Nu(r=>Math.ceil(r)),m8e=Hc(rp,uJ),g8e={kernelName:rp,backendName:"cpu",kernelFunc:m8e};function GM(r,t,n,s){let i=O.getArrayFromDType(n,O.sizeFromShape(t));if(s&&n!=="string"){let a=0;r.forEach(o=>{let u=O.sizeFromShape(o.shape);i.set(o.vals,a),a+=u})}else{let a=0;r.forEach(o=>{let u=n==="string"?q.fromUint8ToStringArray(o.vals):o.vals,l=0;for(let c=0;c<o.shape[0];++c){let h=c*t[1]+a;for(let d=0;d<o.shape[1];++d)i[h+d]=u[l++]}a+=o.shape[1]})}return i}var lJ=Hn((r,t)=>r===t?1:0),cJ=cs(zg,lJ,null,"bool"),y8e={kernelName:zg,backendName:"cpu",kernelFunc:cJ},hJ=Nu(r=>Math.exp(r)),dJ=Hc(fp,hJ,"float32"),b8e={kernelName:fp,backendName:"cpu",kernelFunc:dJ},pJ=Nu(r=>Math.expm1(r)),x8e=Hc(mp,pJ),v8e={kernelName:mp,backendName:"cpu",kernelFunc:x8e},fJ=Nu(r=>Math.floor(r)),w8e=Hc(gp,fJ),S8e={kernelName:gp,backendName:"cpu",kernelFunc:w8e},mJ=Hn((r,t)=>Math.floor(r/t)),C8e=cs(yp,mJ,null,"int32"),_8e={kernelName:yp,backendName:"cpu",kernelFunc:C8e};function gJ(r,t,n,s,i,a,o,u,l){let c=pr([s,a],n);for(let h=0;h<s;h++){let d=[],p=0;for(let f=0;f<i;f++){let m=r[h*i+f];p+=m*o[f],d.push(m)}if(p<0||p>=l/a)throw new Error(`Invalid indices: ${d} does not index into ${u}`);for(let f=0;f<a;f++)c.values[h*a+f]=t.get(...t.indexToLoc(p*a+f))}return c}function yJ(r,t,n){let s=pr(n,r.dtype);for(let i=0;i<s.size;++i){let a=s.indexToLoc(i).slice(),o=a[0],u=a[2],l=t.locToIndex([o,u]);a[2]=t.values[l];let c=r.locToIndex(a);0<=c&&c<r.values.length&&(s.values[i]=r.values[c])}return s}var bJ=Hn((r,t)=>r>t?1:0),E8e=cs(jg,bJ,null,"bool"),I8e={kernelName:jg,backendName:"cpu",kernelFunc:E8e},xJ=Hn((r,t)=>r>=t?1:0),k8e=cs(xp,xJ,null,"bool"),N8e={kernelName:xp,backendName:"cpu",kernelFunc:k8e},vJ=Hn((r,t)=>r<t?1:0),T8e=cs(qg,vJ,null,"bool"),A8e={kernelName:qg,backendName:"cpu",kernelFunc:T8e},wJ=Hn((r,t)=>r<=t?1:0),D8e=cs(Kg,wJ,null,"bool"),F8e={kernelName:Kg,backendName:"cpu",kernelFunc:D8e};function SJ(r,t,n){let s=(t-r)/(n-1),i=O.makeZerosTypedArray(n,"float32");i[0]=r;for(let a=1;a<i.length;a++)i[a]=i[a-1]+s;return i}var CJ=Nu(r=>Math.log(r)),$8e=Hc(Ep,CJ),R8e={kernelName:Ep,backendName:"cpu",kernelFunc:$8e};function _J(r,t,n,s){let i=O.getTypedArrayFromDType(s,O.sizeFromShape(n));for(let a=0;a<i.length;++a){let o=a*t,u=r[o];for(let l=0;l<t;++l){let c=r[o+l];(Number.isNaN(c)||c>u)&&(u=c)}i[a]=u}return i}var EJ=Hn((r,t)=>Math.max(r,t)),O8e=cs(Tp,EJ),M8e={kernelName:Tp,backendName:"cpu",kernelFunc:O8e},IJ=Hn((r,t)=>Math.min(r,t)),L8e=cs($p,IJ),P8e={kernelName:$p,backendName:"cpu",kernelFunc:L8e},HM=Hn((r,t)=>r*t),B8e=UM((r,t,n,s)=>({real:r*n-t*s,imag:r*s+t*n})),G_=cs(Mp,HM,B8e),V8e={kernelName:Mp,backendName:"cpu",kernelFunc:G_};function kJ(r,t,n){let s=O.createScalarValue(-1,n);return HM([],t,s,r,n)}function z8e(r){let{inputs:t,backend:n}=r,{x:s}=t;Dt(s,"neg");let i=n.data.get(s.dataId).values,[a,o]=kJ(i,s.shape,s.dtype);return n.makeTensorInfo(o,s.dtype,a)}var U8e={kernelName:r0,backendName:"cpu",kernelFunc:z8e},NJ=Hn((r,t)=>r!==t?1:0),W8e=cs(n0,NJ,null,"bool"),G8e={kernelName:n0,backendName:"cpu",kernelFunc:W8e};function jM(r,t,n,s,i){let a=t.length,o=O.sizeFromShape(t),u=O.computeStrides(t),l=O.computeStrides(i),c=O.getTypedArrayFromDType(n,O.sizeFromShape(i));for(let h=0;h<o;++h){let d=O.indexToLoc(h,a,u),p=new Array(d.length);for(let m=0;m<p.length;m++)p[m]=d[s[m]];let f=O.locToIndex(p,a,l);c[f]=r[h]}return c}function Ai(r){let{inputs:t,attrs:n,backend:s}=r,{x:i}=t,{perm:a}=n;Dt(i,"transpose");let o=i.shape.length,u=new Array(o);for(let h=0;h<u.length;h++)u[h]=i.shape[a[h]];let l=s.data.get(i.dataId).values,c=jM(l,i.shape,i.dtype,a,u);return{dataId:s.write(c,u,i.dtype),shape:u,dtype:i.dtype}}var H8e={kernelName:el,backendName:"cpu",kernelFunc:Ai};function TJ(r,t,n,s){let[i,a]=q.computeOutAndReduceShapes(r,s),o=va(t,"int32"),u=O.makeZerosTypedArray(O.sizeFromShape(i),o),l=O.sizeFromShape(a);for(let c=0;c<u.length;++c){let h=c*l,d=1;for(let p=0;p<l;++p)d*=n[h+p];u[c]=d}return{outVals:u,outShape:i,outDtype:o}}function j8e(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s;Dt(i,"prod");let u=i.shape.length,l=O.parseAxisParam(a,i.shape),c=q.getAxesPermutation(l,u),h=l,d=i,p=[];c!=null&&(d=Ai({inputs:{x:i},backend:n,attrs:{perm:c}}),p.push(d),h=q.getInnerMostAxes(h.length,u));let f=n.data.get(d.dataId).values,{outVals:m,outShape:g,outDtype:y}=TJ(d.shape,d.dtype,f,h),b=g;return o&&(b=q.expandShapeToKeepDim(g,l)),p.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.makeTensorInfo(b,y,m)}var q8e={kernelName:zp,backendName:"cpu",kernelFunc:j8e};function K8e(r,t,n){r.forEach((s,i)=>{if(s<0||s>=n){let a=O.indexToLoc(i,t.length,O.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${s} is not in [0, ${n})`)}})}function X8e(r,t){for(let n=0;n<r.length;++n){let s=r[n],i=n===r.length-1?t:r[n+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>i)throw new Error("Ragged splits must not point past values");for(let a=1;a<s.length;++a)if(s[a-1]>s[a])throw new Error("Ragged splits must be sorted in ascending order")}}function Y8e(r,t,n,s){let i=[],a=0,o=t.length-1+n.length,u=new Array(o).fill(null).map(()=>[0]);X8e(n,s);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];let h=t[c+1];for(let d=1;d<l+1;++d)u[c].push(d*h)}for(let c=0;c<r.length;++c){let h=r[c],d=r[c]+1;for(let p=0;p<n.length;++p){let f=n[p],m=p+t.length-1;if(m>=0){let g=u[m],y=g[g.length-1]-f[h];for(let b=h;b<d;++b)u[m].push(f[b+1]+y)}h=f[h],d=f[d]}d!==h&&(i.push([h,d]),a+=d-h)}return{outSplits:u,valueSlices:i,numValues:a}}function Z8e(r){let t=[];for(let n=0;n<r.length;++n){let s=r[n].length,i=O.getArrayFromDType("int32",s);t.push(i),r[n].forEach((a,o)=>i[o]=a)}return t}function DV(r,t){let n=r.slice(0,t);for(;n.length<t;)n.push(1);for(let s=t;s<r.length;s++)n[t-1]*=r[s];return n}function J8e(r,t,n,s,i,a){let o=DV(t,2)[1],u=DV(a,2)[1],l=0;for(let c of n)for(let h=c[0];h<c[1];++h){for(let d=0;d<s;++d)i[l*u+d]=r[h*o+d];++l}}function Q8e(r,t,n,s,i){let a=t.slice();a[0]=i;let o=O.getArrayFromDType(n,O.sizeFromShape(a)),u=r.length,l=u===0?0:u/t[0];return J8e(r,t,s,l,o,a),[o,a]}function AJ(r,t,n,s,i,a,o,u){if(r.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(K8e(a,o,l),s.length===0)throw new Error("params.rank must be nonzero");let c=s[0],{outSplits:h,valueSlices:d,numValues:p}=Y8e(a,o,r,c),f=Z8e(h),m=Q8e(n,s,i,d,p);return[f,m[0],m[1]]}var FV=2147483647;function DJ(r,t,n,s,i,a,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");let u=t.length===0,l=i.length===0,c=o.length===0,h=[];u||h.push(t[0]),l||h.push(i[0]),c||h.push(o[0]);for(let y=1;y<h.length;++y)if(h[y]!==h[y-1])throw new Error("starts, limits, and deltas must have the same shape");let d=h.length===0?1:h[0],p=O.getArrayFromDType("int32",d+1);p[0]=0;for(let y=0;y<d;++y){let b=u?r[0]:r[y],x=l?s[0]:s[y],w=c?a[0]:a[y];if(w===0)throw new Error("Requires delta != 0");let v;if(w>0&&x<b||w<0&&x>b)v=0;else if(v=Math.ceil(Math.abs((x-b)/w)),v>FV)throw new Error(`Requires ((limit - start) / delta) <= ${FV}`);p[y+1]=p[y]+v}let f=p[d],m=O.getArrayFromDType(n,f),g=0;for(let y=0;y<d;++y){let b=p[y+1]-p[y],x=u?r[0]:r[y],w=c?a[0]:a[y];for(let v=0;v<b;++v)m[g++]=x,x+=w}return[p,m]}var Oa=q.RowPartitionType,eGe=class IN{constructor(t,n,s,i,a,o,u,l,c,h){this.shape=t,this.shapeShape=n,this.values=s,this.valuesShape=i,this.valuesDType=a,this.defaultValue=o,this.defaultValueShape=u,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=q.getRowPartitionTypesHelper(h),this.raggedRank=q.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Oa.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Oa.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Oa.VALUE_ROWIDS:return IN.getMaxWidthValueRowID(n);case Oa.ROW_SPLITS:return IN.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Oa[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let s=0;for(let i=0;i<n-1;++i){let a=t[i+1]-t[i];a>s&&(s=a)}return s}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let s=0,i=t[0],a=0;for(let o=1;o<n;++o){let u=t[o];u!==i&&(i=u,a=Math.max(o-s,a),s=o)}return Math.max(n-s,a)}tensorShapeFromTensor(t,n,s=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return RV(t,s)}calculateOutputSize(t){let n=this.valuesShape,s=this.defaultValueShape;q.validateDefaultValueShape(s,n);let i=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=q.combineRaggedTensorToTensorShapes(this.raggedRank,i,n);a[0]<0&&(a[0]=t);for(let o=1;o<=this.raggedRank;++o)a[o]<0&&(a[o]=this.getMaxWidth(o));return a}calculateFirstParentOutputIndex(t,n,s){let i=Math.min(t,s),a=[],o=0;for(let u=0;u<i;++u,o+=n)a.push(o);for(let u=i;u<t;++u)a.push(-1);return O.assert(a.length===t,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(t,n,s,i){let a=t.length,o=[];for(let u=0;u<a-1;++u){let l=t[u+1]-t[u],c=Math.min(i,l),h=n[u];h===-1&&(c=0);for(let d=0;d<c;++d)o.push(h),h+=s;for(let d=0;d<l-c;++d)o.push(-1)}if(a>0&&o.length!==t[a-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,n,s,i){let a=t.length,o=[];if(a===0)return[];let u=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let c=n[l];o.push(c);for(let h=1;h<a;++h){let d=t[h];if(d===l)c>=0&&(++u,u<i?c+=s:c=-1);else{if(u=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);c=n[d]}o.push(c)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,n,s,i){let a=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case Oa.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,s,i);case Oa.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,s,i);default:throw new Error(`Unsupported partition type: ${Oa[o]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case Oa.FIRST_DIM_SIZE:return t[0];case Oa.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Oa.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Oa[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let o=s.length-2;o>=0;--o)s[o]=s[o+1]*n[o+1];let i=RV(n,!1),a=O.getArrayFromDType(this.valuesDType,O.sizeFromShape(i));if(s[0]*n[0]>0){let o=this.calculateFirstParentOutputIndex(t,s[0],n[0]);for(let u=1;u<=this.raggedRank;++u)o=this.calculateOutputIndex(u-1,o,s[u],n[u]);this.setOutput(this.raggedRank,o,a,i)}return[i,a]}setOutput(t,n,s,i){if(s.length===0)return;let a=this.values,o=s,u=i.slice();u=u.slice(t+1);let l=O.sizeFromShape(u),c=n.length,h=this.defaultValue;if(h.length!==l&&h.length!==1){let m=this.defaultValueShape;Ie(()=>{let g=Ee(h,m);h=Mh(g,u).dataSync()})}let d=0,p=0,f=0;for(let m=0;m<=c;++m){let g=m<c?n[m]:-1;if(g===f){++f;continue}if(p<f){let y=a.subarray(d*l),b=o.subarray(p*l),x=(f-p)*l;$V(b,y,x)}if(m>=c){let y=s.length;g=Math.floor(y/l)}if(g>f)if(this.defaultValue.length===1)o.subarray(f*l,g*l).fill(this.defaultValue[0]),f=g;else for(;g>f;){let y=o.slice(f*l);$V(y,h,l),++f}g<0?(d=m+1,p=f):(d=m,p=f,f=p+1)}}};function $V(r,t,n){for(let s=0;s<n;s++)r[s]=t[s]}function RV(r,t){let n=[];for(let s of r){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}n.push(s)}return n}function FJ(r,t,n,s,i,a,o,u,l,c){return new eGe(r,t,n,s,i,a,o,u,l,c).compute()}function qM(r,t,n,s){let i=r===t,a=r<t&&n<0,o=t<r&&n>1;if(i||a||o)return O.makeZerosTypedArray(0,s);let u=Math.abs(Math.ceil((t-r)/n)),l=O.makeZerosTypedArray(u,s);t<r&&n===1&&(n=-1),l[0]=r;for(let c=1;c<l.length;c++)l[c]=l[c-1]+n;return l}var $J=Nu(r=>1/Math.sqrt(r)),tGe=Hc(Xp,$J),rGe={kernelName:Xp,backendName:"cpu",kernelFunc:tGe};function Dh(r,t,n,s,i,a,o,u,l,c){let h=[s/i,i],d=r.values,p=t.values;if(s===0)return pr(n,t.dtype);let f=l instanceof Xn?l:pr(h,t.dtype);typeof l=="string"||typeof l=="number"?f.values.fill(l):typeof l=="boolean"&&f.values.fill(+l);for(let m=0;m<a;m++){let g=[],y=0;for(let b=0;b<o;b++){let x=d[m*o+b];g.push(x),y+=x*u[b]}if(y<0||y>=s/i)throw new Error(`Invalid indices: ${g} does not index into ${n}`);for(let b=0;b<i;b++)c?f.values[y*i+b]+=p[m*i+b]:f.values[y*i+b]=t.rank===0?p[0]:p[m*i+b]}return f}var nGe=Nu(r=>1/(1+Math.exp(-r))),RJ=Qr(ef,r=>1/(1+Math.exp(-r))),sGe={kernelName:ef,backendName:"cpu",kernelFunc:RJ};function Z2(r,t,n,s,i){let a=is.isSliceContinous(s,t,n),o=O.sizeFromShape(n),u=O.computeStrides(s);if(a){let d=is.computeFlatOffset(t,u);return i==="string"?r.slice(d,d+o):r.subarray(d,d+o)}let l=i==="string"?q.fromUint8ToStringArray(r):r,c=pr(s,i,l),h=pr(n,i);for(let d=0;d<h.size;++d){let p=h.indexToLoc(d),f=p.map((m,g)=>m+t[g]);h.set(c.get(...f),...p)}return i==="string"?q.fromStringArrayToUint8(h.values):h.values}function _d(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{begin:a,size:o}=s;Dt(i,"slice");let[u,l]=is.parseSliceParams(i,a,o);is.assertParamsValid(i,u,l);let c=n.data.get(i.dataId).values,h=Z2(c,u,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,h)}var iGe={kernelName:g0,backendName:"cpu",kernelFunc:_d};function OJ(r,t,n,s,i,a,o){let u=t[0],l=a[0],c=new Array(l),h=new Array(u),d=t[1];if(l===0){if(u!==0)throw new Error(q.getSparseFillEmptyRowsIndicesDenseShapeMismatch(u));let y=O.getArrayFromDType(n,0),b=O.getArrayFromDType(i,0);return[y,[0,d],b,c,h]}let p=!0,f=0,m=new Array(l).fill(0);for(let y=0;y<u;++y){let b=r[y*d];if(b<0)throw new Error(q.getSparseFillEmptyRowsNegativeIndexErrorMessage(y,b));if(b>=l)throw new Error(q.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(y,b,l));++m[b],p=p&&b>=f,f=b}let g=!0;for(let y=0;y<l;++y){let b=m[y]===0;c[y]=b,g=g&&!b,m[y]=Math.max(m[y],1),y>0&&(m[y]+=m[y-1])}if(g&&p){let y=r,b=s;for(let x=0;x<u;++x)h[x]=x;return[y,[u,d],b,c,h]}else{let y=m[l-1],b=O.getArrayFromDType(n,y*d),x=O.getArrayFromDType(i,y),w=new Array(l).fill(0);for(let v=0;v<u;++v){let S=r[v*d],E=w[S],C=(S===0?0:m[S-1])+E;w[S]++;for(let I=0;I<d;++I)b[C*d+I]=r[v*d+I];x[C]=s[v],h[v]=C}for(let v=0;v<l;++v)if(w[v]===0){let S=v===0?0:m[v-1];b[S*d+0]=v;for(let E=1;E<d;++E)b[S*d+E]=0;x[S]=o}return[b,[y,d],x,c,h]}}function MJ(r,t,n,s,i){let a=O.sizeFromShape(s),o=t[0],u=i.length,l=[],c=1,h=-1;for(let g=0;g<u;++g){let y=i[g];if(y===-1){if(h!==-1)throw new Error(q.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(h,g));h=g,l.push(1)}else{if(y<0)throw new Error(q.getSparseReshapeNegativeOutputDimErrorMessage(g,y));c*=y,l.push(y)}}if(h!==-1){if(c<=0)throw new Error(q.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(a/c);if(c*g!==a)throw new Error(q.getSparseReshapeInputOutputMultipleErrorMessage(s,l));l[h]=g}if(O.sizeFromShape(l)!==a)throw new Error(q.getSparseReshapeInputOutputMismatchErrorMessage(s,l));let d=s.length,p=[];if(d>0){p[d-1]=1;for(let g=d-2;g>=0;--g)p[g]=p[g+1]*s[g+1]}let f=[];if(u>0){f[u-1]=1;for(let g=u-2;g>=0;--g)f[g]=f[g+1]*l[g+1]}let m=O.getArrayFromDType(n,o*u);for(let g=0;g<o;++g){let y=0;for(let b=0;b<d;++b)y+=r[g*d+b]*p[b];for(let b=0;b<u;++b)m[g*u+b]=Math.trunc(y/f[b]),y%=f[b]}return[m,[o,u],l]}function KM(r,t,n,s,i,a=!1,o=0){let u=s.length,l=[t[0],r.length/t[0]],c=l[1],h=u>0?i[u-1]+1:0;if(h<0)throw new Error(q.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=h;let p=d.reduce((x,w)=>x*w,1),f=O.getArrayFromDType(n,p);if(u===0)return h>0&&f.fill(o),[f,d];if(h<=0)throw new Error(q.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,g=1,y=0,b=i[m];for(;;){let x=0;if(g<u){if(x=i[g],b===x){++g;continue}if(b>=x)throw new Error(q.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=h)throw new Error(q.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,h));b>y&&f.fill(o,y*c,b*c);for(let w=m;w<g;++w){let v=s[w];if(v<0||v>=l[0])throw new Error(q.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w,s[w],l[0]));for(let S=0;S<c;S++)f[b*c+S]+=r[v*c+S]}if(a)for(let w=0;w<c;w++)f[b*c+w]/=g-m;if(m=g,++g,y=b+1,b=x,g>u)break}return y<h&&f.fill(o,y*c,h*c),[f,d]}var aGe=Nu(r=>Math.sqrt(r)),oGe=Qr(rf,r=>Math.sqrt(r)),uGe={kernelName:rf,backendName:"cpu",kernelFunc:oGe},LJ=Hn((r,t)=>{let n=r-t;return n*n}),lGe=cs(af,LJ),cGe={kernelName:af,backendName:"cpu",kernelFunc:lGe},PJ=Nu((r,t)=>{let{pattern:n,replaceGlobal:s,rewrite:i}=t;return r.replace(new RegExp(n,s?"g":""),i)}),hGe=Hc(Zx,PJ),dGe={kernelName:Zx,backendName:"cpu",kernelFunc:hGe};function BJ(r,t,n,s){let i=pr(r,t.dtype);for(let a=0;a<i.size;a++){let o=i.indexToLoc(a),u=new Array(o.length);for(let l=0;l<u.length;l++)u[l]=o[l]*n[l]+s[l];i.set(t.get(...u),...o)}return i}var pGe=class{constructor(r,t,n,s,i,a){this.separator=O.encodeString(r),this.nGramWidths=t,this.leftPad=O.encodeString(n),this.rightPad=O.encodeString(s),this.padWidth=i,this.preserveShort=a}getPadWidth(r){return Math.min(this.padWidth<0?r-1:this.padWidth,r-1)}getNumNGrams(r,t){let n=this.getPadWidth(t);return Math.max(0,r+2*n-t+1)}createNGrams(r,t,n,s,i,a){for(let o=0;o<i;++o){let u=this.getPadWidth(a),l=Math.max(0,u-o),c=Math.max(0,u-(i-(o+1))),h=a-(l+c),d=t+(l>0?0:o-u),p=0;p+=l*this.leftPad.length;for(let b=0;b<h;++b)p+=r[d+b].length;p+=c*this.rightPad.length;let f=l+c+h-1;p+=f*this.separator.length,n[s+o]=new Uint8Array(p);let m=n[s+o],g=0,y=b=>b.forEach(x=>m[g++]=x);for(let b=0;b<l;++b)y(this.leftPad),y(this.separator);for(let b=0;b<h-1;++b)y(r[d+b]),y(this.separator);if(h>0){y(r[d+h-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(r,t){let n=r.length,s=t.length;if(s>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<s;++l){let c=t[l]>=u;if(c=c&&t[l]<=n,!c)throw new Error(`Invalid split value ${t[l]}, must be in [${u}, ${n}]`);u=t[l]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}let i=s-1,a=O.getArrayFromDType("int32",s);if(n===0||s===0){let u=new Array(n);for(let l=0;l<=i;++l)a[l]=0;return[u,a]}a[0]=0;for(let u=1;u<=i;++u){let l=t[u]-t[u-1],c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(l,h)}),this.preserveShort&&l>0&&c===0&&(c=1),a[u]=a[u-1]+c}let o=new Array(a[i]);for(let u=0;u<i;++u){let l=t[u],c=a[u];if(this.nGramWidths.forEach(h=>{let d=t[u+1]-t[u],p=this.getNumNGrams(d,h);this.createNGrams(r,l,o,c,p,h),c+=p}),this.preserveShort&&c===a[u]){let h=t[u+1]-t[u];if(h===0)continue;let d=h+2*this.padWidth;this.createNGrams(r,l,o,c,1,d)}}return[o,a]}};function XM(r,t,n,s,i,a,o,u){return new pGe(n,s,i,a,o,u).compute(r,t)}function fGe(r,t,n,s){if(!r.length)return;if(t.length===0){for(let a=0;a<r.length;++a)s.push(r.subarray(a,a+1));return}if(t.length===1){let a=t[0],o=r.indexOf(a);for(;o!==-1;){let u=r.subarray(0,o);(!n||u.length!==0)&&s.push(u),r=r.subarray(o+1),o=r.indexOf(a)}(!n||r.length!==0)&&s.push(r);return}let i=0;for(let a=0;a<r.length+1;a++)if(a===r.length||t.indexOf(r[a])!==-1){let o=r.subarray(i,a);(!n||o.length!==0)&&s.push(o),i=a+1}}function YM(r,t,n){let s=r.length,i=[],a=0,o=0,u=new Array(s);for(let p=0;p<s;++p){let f=i.length;fGe(r[p],t,n,i);let m=i.length-f;u[p]=m,a+=m,o=Math.max(o,m)}let l=O.getArrayFromDType("int32",a*2),c=new Array(a),h=[s,o],d=0;for(let p=0;p<s;++p)for(let f=0;f<u[p];++f)l[d*2]=p,l[d*2+1]=f,c[d]=i[d],++d;return[l,c,h]}function ZM(r,t){let n=O.getArrayFromDType("int32",r.length);for(let s=0;s<r.length;++s)n[s]=O.fingerPrint64(r[s]).modulo(t).getLowBitsUnsigned();return n}var VJ=Hn((r,t)=>r-t),mGe=UM((r,t,n,s)=>({real:r-n,imag:t-s})),JM=cs(of,VJ,mGe),gGe={kernelName:of,backendName:"cpu",kernelFunc:JM};function zJ(r,t){let n=new Array(r.rank);for(let i=0;i<n.length;i++)n[i]=r.shape[i]*t[i];let s=pr(n,r.dtype);for(let i=0;i<s.values.length;++i){let a=s.indexToLoc(i),o=new Array(r.rank);for(let l=0;l<o.length;l++)o[l]=a[l]%r.shape[l];let u=r.locToIndex(o);s.values[i]=r.values[u]}return s}var $y=(r,t)=>{let n=t.value-r.value;return n===0?r.index-t.index:n};function UJ(r,t,n=0,s=r.length-1){for(;s>n;){if(s-n>600){let u=s-n+1,l=t-n+1,c=Math.log(u),h=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*h*(u-h)/u)*Math.sign(l-u/2),p=Math.max(n,Math.floor(t-l*h/u+d)),f=Math.min(s,Math.floor(t+(u-l)*h/u+d));UJ(r,t,p,f)}let i=r[t],a=n,o=s;for(O.swap(r,n,t),$y(r[s],i)>0&&O.swap(r,n,s);a<o;){for(O.swap(r,a,o),a++,o--;$y(r[a],i)<0;)a=a+1;for(;$y(r[o],i)>0;)o=o-1}$y(r[n],i)===0?O.swap(r,n,o):(o=o+1,O.swap(r,o,s)),o<=t&&(n=o+1),t<=o&&(s=o-1)}}function WJ(r,t,n,s,i){let a=t[t.length-1],[o,u]=[r.length/a,a],l=O.getTypedArrayFromDType(n,o*s),c=O.getTypedArrayFromDType("int32",o*s);for(let d=0;d<o;d++){let p=d*u,f=r.subarray(p,p+u),m=new Array(f.length);f.forEach((x,w)=>m[w]={value:x,index:w}),s<m.length&&(UJ(m,s),m=m.slice(0,s)),i&&m.sort($y);let g=d*s,y=l.subarray(g,g+s),b=c.subarray(g,g+s);for(let x=0;x<s;x++)y[x]=m[x].value,b[x]=m[x].index}let h=t.slice();return h[h.length-1]=s,[pr(h,n,l),pr(h,"int32",c)]}function QM(r,t,n,s){let i=O.parseAxisParam(t,n)[0],a=[1,n[0],1];for(let m=0;m<i;m++)a[0]*=n[m];a[1]=n[i];for(let m=i+1;m<n.length;m++)a[2]*=n[m];let o=new Map,u=new Int32Array(n[i]),l=new Xn(a,s,r),c=[],h=a[0]===1&&a[2]===1;for(let m=0;m<n[i];m++){let g;if(h)g=r[m].toString();else{let b=[];for(let x=0;x<a[0];x++)for(let w=0;w<a[2];w++)b.push(l.get(x,m,w));g=b.join(",")}let y=o.get(g);if(y!=null)u[m]=y;else{let b=o.size;o.set(g,b),u[m]=b,c.push(m)}}let d=a.slice();d[1]=o.size;let p=new Xn(d,s);c.forEach((m,g)=>{for(let y=0;y<a[0];y++)for(let b=0;b<a[2];b++)p.set(l.get(y,m,b),y,g,b)});let f=n.slice();return f[i]=d[1],{outputValues:p.values,outputShape:f,indices:u}}var yGe="4.22.0";zC("cpu",()=>new VM,1);var GJ=Qr(dp,r=>r>=0?r:Math.exp(r)-1),bGe={kernelName:dp,backendName:"cpu",kernelFunc:GJ};function HJ(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{alpha:a}=s;Dt([i],"leakyRelu");let o=O.sizeFromShape(i.shape),u=n.data.get(i.dataId).values,l=O.getTypedArrayFromDType("float32",o);for(let c=0;c<u.length;c++)l[c]=u[c]<0?a*u[c]:u[c];return n.makeTensorInfo(i.shape,"float32",l)}var xGe={kernelName:_p,backendName:"cpu",kernelFunc:HJ},vGe=Hn((r,t)=>r<0?t*r:r);function jJ(r){let{inputs:t,backend:n}=r,{x:s,alpha:i}=t;Dt([s,i],"prelu");let a=n.data.get(s.dataId).values,o=n.data.get(i.dataId).values,[u,l]=vGe(s.shape,i.shape,a,o,"float32");return n.makeTensorInfo(l,"float32",u)}var wGe={kernelName:Vp,backendName:"cpu",kernelFunc:jJ},qJ=Qr(Wp,r=>Math.max(0,r)),SGe={kernelName:Wp,backendName:"cpu",kernelFunc:qJ},KJ=Qr(jp,r=>Math.min(Math.max(0,r),6)),CGe={kernelName:jp,backendName:"cpu",kernelFunc:KJ};function J2(r,t,n,s,i){if(n==="linear")return xu({inputs:{x:t},backend:r});if(n==="relu")return qJ({inputs:{x:t},backend:r});if(n==="elu")return GJ({inputs:{x:t},backend:r});if(n==="relu6")return KJ({inputs:{x:t},backend:r});if(n==="prelu")return jJ({inputs:{x:t,alpha:s},backend:r});if(n==="leakyrelu")return HJ({inputs:{x:t},backend:r,attrs:{alpha:i}});if(n==="sigmoid")return RJ({inputs:{x:t},backend:r});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function vn(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{shape:a}=s,o=O.sizeFromShape(i.shape),u=O.inferFromImplicitShape(a,o),l=O.sizeFromShape(u);O.assert(o===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.incRef(i.dataId);let c=n.data.get(i.dataId);if(c.complexTensorInfos!=null){let h=c.complexTensorInfos.real,d=c.complexTensorInfos.imag;h.shape=u,d.shape=u}return{dataId:i.dataId,shape:u,dtype:i.dtype}}var _Ge={kernelName:l0,backendName:"cpu",kernelFunc:vn};function XJ(r){let{inputs:t,backend:n,attrs:s}=r,{a:i,b:a}=t,{transposeA:o,transposeB:u}=s;Dt([i,a],"matMul");let l=i.shape.length,c=a.shape.length,h=o?i.shape[l-2]:i.shape[l-1],d=u?a.shape[c-1]:a.shape[c-2],p=o?i.shape[l-1]:i.shape[l-2],f=u?a.shape[c-2]:a.shape[c-1],m=i.shape.slice(0,-2),g=a.shape.slice(0,-2),y=O.sizeFromShape(m),b=O.sizeFromShape(g),x=k0.assertAndGetBroadcastShape(i.shape.slice(0,-2),a.shape.slice(0,-2)).concat([p,f]);O.assert(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${i.shape} and ${a.shape} and transposeA=${o} and transposeB=${u} must match.`);let w=o?[y,h,p]:[y,p,h],v=u?[b,f,d]:[b,d,f],S=vn({inputs:{x:i},backend:n,attrs:{shape:w}}),E=vn({inputs:{x:a},backend:n,attrs:{shape:v}}),C=o?S.shape[1]:S.shape[2],I=o?S.shape[2]:S.shape[1],_=u?E.shape[1]:E.shape[2],A=Math.max(y,b),k=n.data.get(S.dataId).values,N=n.data.get(E.dataId).values,D=O.computeStrides(S.shape),F=O.computeStrides(E.shape),[P,G,Y]=o?[D[0],1,D[1]]:[D[0],D[1],1],[Z,ee,se]=u?[1,F[1],F[0]]:[F[1],1,F[0]],re=I*_,J=pr([A,I,_],S.dtype),le=J.values,he=n.blockSize;for(let xe=0;xe<A;xe++){let Fe=xe%y,Le=xe%b;for(let Ve=0;Ve<I;Ve+=he){let $e=Math.min(Ve+he,I);for(let Ae=0;Ae<_;Ae+=he){let Te=Math.min(Ae+he,_);for(let Ue=0;Ue<C;Ue+=he){let qe=Math.min(Ue+he,C);for(let Me=Ve;Me<$e;Me++)for(let ie=Ae;ie<Te;ie++){let K=0;for(let pe=Ue;pe<qe;pe++){let _e=k[Fe*P+Me*G+pe*Y],We=N[pe*Z+ie*ee+Le*se];K+=_e*We}le[xe*re+(Me*_+ie)]+=K}}}}}return n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(E),n.makeTensorInfo(x,J.dtype,J.values)}var EGe={kernelName:ep,backendName:"cpu",kernelFunc:XJ};function IGe(r){let{inputs:t,backend:n,attrs:s}=r,{a:i,b:a,bias:o,preluActivationWeights:u}=t,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:d}=s,p,f,m,g=[];p=XJ({inputs:{a:i,b:a},attrs:{transposeA:l,transposeB:c},backend:n}),o&&(f=tg({inputs:{a:p,b:o},backend:n}),g.push(p),p=f),h&&(m=J2(n,p,h,u,d),g.push(p),p=m);for(let y of g)n.disposeIntermediateTensorInfo(y);return p}var kGe={kernelName:cd,backendName:"cpu",kernelFunc:IGe},NGe=Qr(Hd,r=>Math.acos(r)),TGe={kernelName:Hd,backendName:"cpu",kernelFunc:NGe},AGe=Qr(jd,r=>Math.acosh(r)),DGe={kernelName:jd,backendName:"cpu",kernelFunc:AGe};function FGe(r){let{inputs:t,backend:n}=r,s=t;Dt(t,"addN");let i=s.map(u=>n.data.get(u.dataId).values),a=pr(s[0].shape,s[0].dtype),o=a.values;for(let u=0;u<s.length;u++){let l=i[u];for(let c=0;c<o.length;c++)o[c]+=l[c]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}var $Ge={kernelName:qd,backendName:"cpu",kernelFunc:FGe};function RGe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s;Dt(i,"all");let u=O.parseAxisParam(a,i.shape),l=u,c=q.getAxesPermutation(l,i.shape.length),h=i;c!=null&&(h=Ai({inputs:{x:i},backend:n,attrs:{perm:c}}),l=q.getInnerMostAxes(l.length,i.shape.length)),q.assertAxesAreInnerMostDims("all",l,h.shape.length);let[d,p]=q.computeOutAndReduceShapes(h.shape,l),f=O.sizeFromShape(p),m=O.makeZerosTypedArray(O.sizeFromShape(d),h.dtype),g=n.data.get(h.dataId).values;for(let b=0;b<m.length;++b){let x=b*f,w=g[x];for(let v=0;v<f;++v){let S=g[x+v];w=w&&S}m[b]=w}c!=null&&n.disposeIntermediateTensorInfo(h);let y=n.makeTensorInfo(d,h.dtype,m);if(o){let b=q.expandShapeToKeepDim(d,u),x=vn({inputs:{x:y},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(y),x}return y}var OGe={kernelName:Ig,backendName:"cpu",kernelFunc:RGe};function MGe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s;Dt(i,"any");let u=O.parseAxisParam(a,i.shape),l=u,c=q.getAxesPermutation(l,i.shape.length),h=i;c!=null&&(h=Ai({inputs:{x:i},backend:n,attrs:{perm:c}}),l=q.getInnerMostAxes(l.length,i.shape.length)),q.assertAxesAreInnerMostDims("any",l,h.shape.length);let[d,p]=q.computeOutAndReduceShapes(h.shape,l),f=O.sizeFromShape(p),m=O.makeZerosTypedArray(O.sizeFromShape(d),h.dtype),g=n.data.get(h.dataId).values;for(let b=0;b<m.length;++b){let x=b*f,w=g[x];for(let v=0;v<f;++v){let S=g[x+v];w=w||S}m[b]=w}c!=null&&n.disposeIntermediateTensorInfo(h);let y=n.makeTensorInfo(d,h.dtype,m);if(o){let b=q.expandShapeToKeepDim(d,u),x=vn({inputs:{x:y},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(y),x}return y}var LGe={kernelName:kg,backendName:"cpu",kernelFunc:MGe};function PGe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a}=s;Dt(i,"argMax");let o=O.parseAxisParam(a,i.shape),u=q.getAxesPermutation(o,i.shape.length),l=i,c=[];u!=null&&(l=Ai({inputs:{x:i},backend:n,attrs:{perm:u}}),c.push(l),o=q.getInnerMostAxes(o.length,l.shape.length)),o=[o[0]],q.assertAxesAreInnerMostDims("argMax",o,l.shape.length);let[h,d]=q.computeOutAndReduceShapes(l.shape,o),p=O.sizeFromShape(h),f=O.makeZerosTypedArray(p,"int32"),m=O.sizeFromShape(d),g=n.data.get(l.dataId).values;for(let y=0;y<f.length;++y){let b=y*m,x=g[b],w=0;for(let v=0;v<m;++v){let S=g[b+v];S>x&&(x=S,w=v)}f[y]=w}return c.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(h,"int32",f)}var BGe={kernelName:Ng,backendName:"cpu",kernelFunc:PGe};function VGe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a}=s;Dt(i,"argMin");let o=O.parseAxisParam(a,i.shape),u=q.getAxesPermutation(o,i.shape.length),l=i,c=[];u!=null&&(l=Ai({inputs:{x:i},backend:n,attrs:{perm:u}}),c.push(l),o=q.getInnerMostAxes(o.length,l.shape.length)),o=[o[0]],q.assertAxesAreInnerMostDims("argMin",o,l.shape.length);let[h,d]=q.computeOutAndReduceShapes(l.shape,o),p=O.sizeFromShape(h),f=O.makeZerosTypedArray(p,"int32"),m=O.sizeFromShape(d),g=n.data.get(l.dataId).values;for(let y=0;y<f.length;++y){let b=y*m,x=g[b],w=0;for(let v=0;v<m;++v){let S=g[b+v];S<x&&(x=S,w=v)}f[y]=w}return c.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(h,"int32",f)}var zGe={kernelName:Tg,backendName:"cpu",kernelFunc:VGe},UGe=Qr(Kd,r=>Math.asin(r)),WGe={kernelName:Kd,backendName:"cpu",kernelFunc:UGe},GGe=Qr(Xd,r=>Math.asinh(r)),HGe={kernelName:Xd,backendName:"cpu",kernelFunc:GGe},jGe=Qr(Yd,r=>Math.atan(r)),qGe={kernelName:Yd,backendName:"cpu",kernelFunc:jGe},KGe=Hn((r,t)=>Math.atan2(r,t)),XGe=cs(Jd,KGe),YGe={kernelName:Jd,backendName:"cpu",kernelFunc:XGe},ZGe=Qr(Zd,r=>Math.atanh(r)),JGe={kernelName:Zd,backendName:"cpu",kernelFunc:ZGe};function eL(r,t,n,s,i,a){let o=i.strideHeight,u=i.strideWidth,l=i.dilationHeight,c=i.dilationWidth,h=i.effectiveFilterHeight,d=i.effectiveFilterWidth,p=i.padInfo.top,f=i.padInfo.left,m=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=pr(i.outShape,n),y=g.values,b=i.outShape[1]*i.outShape[2]*i.outShape[3],x=i.outShape[2]*i.outShape[3],w=i.outShape[3];for(let v=0;v<i.batchSize;++v){let S=v*b,E=v*s[0];for(let C=0;C<i.inChannels;++C)for(let I=0;I<i.outHeight;++I){let _=I*o-p,A=Math.max(0,_),k=Math.min(i.inHeight,h+_),N=S+I*x;for(let D=0;D<i.outWidth;++D){let F=D*u-f,P=Math.max(0,F),G=Math.min(i.inWidth,d+F),Y=m,Z=0,ee=0;for(let re=A;re<k;re+=l){let J=E+re*s[1];for(let le=P;le<G;le+=c){let he=J+le*s[2],xe=r[he+C];a==="max"&&xe>Y?Y=xe:a==="avg"&&(Z+=xe,ee++)}if(isNaN(Y))break}let se=N+D*w+C;y[se]=a==="avg"?Z/ee:Y}}}return g}function YJ(r,t,n,s,i=!1,a=!1){let o=pr(s.outShape,"int32"),u=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterHeight,p=s.effectiveFilterWidth,f=s.padInfo.top,m=s.padInfo.left,g=pr(t,n,r);for(let y=0;y<s.batchSize;++y)for(let b=0;b<s.inChannels;++b)for(let x=0;x<s.outHeight;++x){let w=x*u-f,v=w;for(;v<0;)v+=c;let S=Math.min(s.inHeight,d+w);for(let E=0;E<s.outWidth;++E){let C=E*l-m,I=C;for(;I<0;)I+=h;let _=Math.min(s.inWidth,p+C),A=Number.NEGATIVE_INFINITY,k=-1;for(let N=v;N<S;N+=c){let D=N-w;for(let F=I;F<_;F+=h){let P=F-C,G=g.get(y,N,F,b);G>A&&(A=G,i?k=a?((y*s.inHeight+N)*s.inWidth+F)*s.inChannels+b:(N*s.inWidth+F)*s.inChannels+b:k=D*p+P)}}o.set(k,y,x,E,b)}}return o}function ZJ(r,t,n,s,i,a){let o=i.strideDepth,u=i.strideHeight,l=i.strideWidth,c=i.dilationDepth,h=i.dilationHeight,d=i.dilationWidth,p=i.effectiveFilterDepth,f=i.effectiveFilterHeight,m=i.effectiveFilterWidth,g=i.padInfo.front,y=i.padInfo.top,b=i.padInfo.left,x=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=pr(i.outShape,n),v=w.values,S=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],E=i.outShape[2]*i.outShape[3]*i.outShape[4],C=i.outShape[3]*i.outShape[4],I=i.outShape[4];for(let _=0;_<i.batchSize;++_){let A=_*S,k=_*s[0];for(let N=0;N<i.inChannels;++N)for(let D=0;D<i.outDepth;++D){let F=D*o-g,P=F;for(;P<0;)P+=c;let G=Math.min(i.inDepth,p+F),Y=A+D*E;for(let Z=0;Z<i.outHeight;++Z){let ee=Z*u-y,se=ee;for(;se<0;)se+=h;let re=Math.min(i.inHeight,f+ee),J=Y+Z*C;for(let le=0;le<i.outWidth;++le){let he=le*l-b,xe=he;for(;xe<0;)xe+=d;let Fe=Math.min(i.inWidth,m+he),Le=J+le*I,Ve=x,$e=0,Ae=0;for(let Ue=P;Ue<G;Ue+=c){let qe=k+Ue*s[1];for(let Me=se;Me<re;Me+=h){let ie=qe+Me*s[2];for(let K=xe;K<Fe;K+=d){let pe=ie+K*s[3],_e=r[pe+N];if(a==="max"&&_e>Ve?Ve=_e:a==="avg"&&($e+=_e,Ae++),isNaN(Ve))break}if(isNaN(Ve))break}if(isNaN(Ve))break}let Te=Le+N;v[Te]=a==="avg"?$e/Math.max(Ae,1):Ve}}}}return w}function QGe(r,t){let n=pr(t.outShape,"int32"),s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,u=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=t.padInfo.front,f=t.padInfo.top,m=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let y=0;y<t.inChannels;++y)for(let b=0;b<t.outDepth;++b){let x=b*s-p,w=x;for(;w<0;)w+=o;let v=Math.min(t.inDepth,c+x);for(let S=0;S<t.outHeight;++S){let E=S*i-f,C=E;for(;C<0;)C+=u;let I=Math.min(t.inHeight,h+E);for(let _=0;_<t.outWidth;++_){let A=_*a-m,k=A;for(;k<0;)k+=l;let N=Math.min(t.inWidth,d+A),D=Number.NEGATIVE_INFINITY,F=-1;for(let P=w;P<v;P+=o){let G=P-x;for(let Y=C;Y<I;Y+=u){let Z=Y-E;for(let ee=k;ee<N;ee+=l){let se=ee-A,re=r.get(g,P,Y,ee,y);re>=D&&(D=re,F=G*h*d+Z*h+se)}}}n.set(F,g,b,S,_,y)}}}return n}function eHe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t;Dt(i,"avgPool");let{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=s,c=1;O.assert(q.eitherStridesOrDilationsAreOne(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);let h=q.computePool2DInfo(i.shape,a,o,c,u,l),d;if(h.filterWidth===1&&h.filterHeight===1&&O.arraysEqual(h.inShape,h.outShape))d=xu({inputs:{x:i},backend:n});else{let p=n.data.get(i.dataId).values,f=O.computeStrides(i.shape),m=eL(p,i.shape,i.dtype,f,h,"avg");d=n.makeTensorInfo(h.outShape,i.dtype,m.values)}return d}var tHe={kernelName:Qd,backendName:"cpu",kernelFunc:eHe};function rHe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l,dataFormat:c}=s;Dt(i,"avgPool3d");let h=q.computePool3DInfo(i.shape,a,o,1,u,l,c),d=n.data.get(i.dataId).values,p=ZJ(d,i.shape,i.dtype,O.computeStrides(i.shape),h,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}var nHe={kernelName:Ag,backendName:"cpu",kernelFunc:rHe};function sHe(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=s;Dt([i,a],"avgPool3DGrad");let h=q.computePool3DInfo(a.shape,o,u,1,l,c),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=h.dilationDepth,x=h.dilationHeight,w=h.dilationWidth,v=h.effectiveFilterDepth,S=h.effectiveFilterHeight,E=h.effectiveFilterWidth,C=v-1-h.padInfo.front,I=E-1-h.padInfo.left,_=S-1-h.padInfo.top,A=pr(a.shape,"float32"),k=1/(m*g*y),N=n.bufferSync(i);for(let D=0;D<h.batchSize;++D)for(let F=0;F<h.inChannels;++F)for(let P=0;P<h.inDepth;++P)for(let G=0;G<h.inHeight;++G)for(let Y=0;Y<h.inWidth;++Y){let Z=P-C,ee=G-_,se=Y-I,re=0;for(let J=0;J<v;J+=b){let le=(Z+J)/d;if(!(le<0||le>=h.outDepth||Math.floor(le)!==le))for(let he=0;he<S;he+=x){let xe=(ee+he)/p;if(!(xe<0||xe>=h.outHeight||Math.floor(xe)!==xe))for(let Fe=0;Fe<E;Fe+=w){let Le=(se+Fe)/f;if(Le<0||Le>=h.outWidth||Math.floor(Le)!==Le)continue;let Ve=N.get(D,le,xe,Le,F);re+=Ve}}}A.set(re*k,D,P,G,Y,F)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}var iHe={kernelName:Lx,backendName:"cpu",kernelFunc:sHe};function aHe(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,o=a;Dt([i,a],"avgPoolGrad");let{filterSize:u,strides:l,pad:c}=s,h=q.computePool2DInfo(o.shape,u,l,1,c),d=h.strideHeight,p=h.strideWidth,f=h.filterHeight,m=h.filterWidth,g=h.dilationHeight,y=h.dilationWidth,b=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,v=b-1-h.padInfo.top,S=pr(o.shape,"float32"),E=1/(f*m),C=n.data.get(i.dataId).values,I=pr(i.shape,"float32",C);for(let _=0;_<h.batchSize;++_)for(let A=0;A<h.inChannels;++A)for(let k=0;k<h.inHeight;++k)for(let N=0;N<h.inWidth;++N){let D=k-v,F=N-w,P=0;for(let G=0;G<b;G+=g){let Y=(D+G)/d;if(!(Y<0||Y>=h.outHeight||Math.floor(Y)!==Y))for(let Z=0;Z<x;Z+=y){let ee=(F+Z)/p;if(ee<0||ee>=h.outWidth||Math.floor(ee)!==ee)continue;let se=I.get(_,Y,ee,A);P+=se}}S.set(P*E,_,k,N,A)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}var oHe={kernelName:Mx,backendName:"cpu",kernelFunc:aHe};function uHe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,scale:a,offset:o,mean:u,variance:l}=t;O.assert(u.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O.assert(o==null||u.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O.assert(a==null||u.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Dt([i,u,l,a,o],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);let h=n.data.get(i.dataId).values,d=n.data.get(u.dataId).values,p=n.data.get(l.dataId).values,f=a?n.data.get(a.dataId).values:new Float32Array([1]),m=o?n.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(h.length),y=m.length,b=f.length,x=p.length,w=d.length,v=0,S=0,E=0,C=0;for(let I=0;I<h.length;++I)g[I]=m[v++]+(h[I]-d[S++])*f[E++]/Math.sqrt(p[C++]+c),v>=y&&(v=0),S>=w&&(S=0),E>=b&&(E=0),C>=x&&(C=0);return n.makeTensorInfo(i.shape,i.dtype,g)}var lHe={kernelName:bp,backendName:"cpu",kernelFunc:uHe};function cHe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{blockShape:a,crops:o}=s;Dt([i],"batchToSpaceND");let u=a.reduce((b,x)=>b*x),l=q.getReshaped(i.shape,a,u),c=q.getPermuted(l.length,a.length),h=q.getReshapedPermuted(i.shape,a,u),d=q.getSliceBeginCoords(o,a.length),p=q.getSliceSize(h,o,a.length),f=vn({inputs:{x:i},backend:n,attrs:{shape:l}}),m=Ai({inputs:{x:f},backend:n,attrs:{perm:c}}),g=vn({inputs:{x:m},backend:n,attrs:{shape:h}}),y=_d({inputs:{x:g},backend:n,attrs:{begin:d,size:p}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}var hHe={kernelName:Dg,backendName:"cpu",kernelFunc:cHe};function dHe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,weights:a}=t,{size:o}=s,u=n.data.get(i.dataId).values,l=n.data.get(a.dataId).values,c=WM(u,l,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,c)}var pHe={kernelName:Fg,backendName:"cpu",kernelFunc:dHe};function fHe(r){let{inputs:t,backend:n}=r,{s0:s,s1:i}=t,a=n.data.get(s.dataId).values,o=n.data.get(i.dataId).values,u=q.assertAndGetBroadcastShape(Array.from(a),Array.from(o));return n.makeTensorInfo([u.length],"int32",Int32Array.from(u))}var mHe={kernelName:Px,backendName:"cpu",kernelFunc:fHe},gHe=Qr(Lc,(r,t)=>{let n=t;return r>n.clipValueMax?n.clipValueMax:r<n.clipValueMin?n.clipValueMin:r}),yHe={kernelName:Lc,backendName:"cpu",kernelFunc:gHe},bHe=r=>{let{x:t}=r.inputs,n=r.backend,s=new Float32Array(O.sizeFromShape(t.shape)),i=n.data.get(t.dataId),a=i.complexTensorInfos.real,o=i.complexTensorInfos.imag,u=n.data.get(a.dataId).values,l=n.data.get(o.dataId).values;for(let c=0;c<u.length;c++){let h=u[c],d=l[c];s[c]=Math.hypot(h,d)}return n.makeOutput(s,t.shape,"float32")},xHe={kernelName:Bx,backendName:"cpu",kernelFunc:bHe};function rg(r){let{inputs:t,backend:n}=r,{input:s}=t,i=n.data.get(s.dataId).complexTensorInfos.imag,a=n.data.get(i.dataId).values;return n.makeTensorInfo(i.shape,i.dtype,a)}var vHe={kernelName:RC,backendName:"cpu",kernelFunc:rg};function ng(r){let{inputs:t,backend:n,attrs:s}=r,{axis:i}=s,a=O.parseAxisParam(i,t[0].shape)[0],o=t.map(g=>g.shape);q.assertParamsConsistent(o,a);let u=q.computeOutShape(t.map(g=>g.shape),a);if(O.sizeFromShape(u)===0)return n.makeTensorInfo(u,t[0].dtype,[]);let l=t.filter(g=>O.sizeFromShape(g.shape)>0);if(l.length===1)return xu({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){let g=l.map(v=>Cd({inputs:{input:v},backend:n})),y=l.map(v=>rg({inputs:{input:v},backend:n})),b=ng({inputs:g,backend:n,attrs:{axis:a}}),x=ng({inputs:y,backend:n,attrs:{axis:a}}),w=Yi({inputs:{real:b,imag:x},backend:n});return g.forEach(v=>n.disposeIntermediateTensorInfo(v)),y.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x),w}let c=l.map(g=>{let y=[-1,O.sizeFromShape(g.shape.slice(a))];return vn({inputs:{x:g},backend:n,attrs:{shape:y}})}),h=c.map(g=>({vals:n.data.get(g.dataId).values,shape:g.shape}));u=q.computeOutShape(c.map(g=>g.shape),1);let d=c[0].shape[0]===1,p=GM(h,u,t[0].dtype,d),f=q.computeOutShape(l.map(g=>g.shape),a),m=n.makeTensorInfo(f,t[0].dtype,p);return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}var wHe={kernelName:Rg,backendName:"cpu",kernelFunc:ng};function JJ(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dataFormat:l,dilations:c,dimRoundingMode:h}=s;Dt([i,a],"conv2d");let d=q.convertConv2DDataFormat(l),p=q.computeConv2DInfo(i.shape,a.shape,o,c,u,h,!1,d),f=p.filterHeight,m=p.filterWidth,g=p.dilationHeight,y=p.dilationWidth,b=p.padInfo.left,x=p.padInfo.top,w=p.dataFormat==="channelsLast",v=new Xn(p.outShape,i.dtype),S=O.computeStrides(i.shape),E=O.computeStrides(a.shape),C=S[0],I=w?S[1]:S[2],_=w?S[2]:1,A=w?1:S[1],k=v.strides[0],N=w?v.strides[1]:v.strides[2],D=w?v.strides[2]:1,F=w?1:v.strides[1],P=n.data.get(i.dataId).values,G=n.data.get(a.dataId).values,Y=v.values;for(let Z=0;Z<p.batchSize;++Z){let ee=Z*C,se=Z*k;for(let re=0;re<p.outHeight;++re){let J=se+re*N,le=re*p.strideHeight-x;for(let he=0;he<f;++he){let xe=le+he*g;if(xe<0||xe>=p.inHeight)continue;let Fe=he*E[0],Le=ee+xe*I;for(let Ve=0;Ve<p.outWidth;++Ve){let $e=J+Ve*D,Ae=Ve*p.strideWidth-b;for(let Te=0;Te<m;++Te){let Ue=Ae+Te*y;if(Ue<0||Ue>=p.inWidth)continue;let qe=Fe+Te*E[1],Me=Le+Ue*_,ie=qe;for(let K=0;K<p.inChannels;++K){let pe=P[Me+K*A];for(let _e=0;_e<p.outChannels;++_e)Y[$e+_e*F]+=pe*G[ie+_e];ie+=p.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,Y)}var SHe={kernelName:np,backendName:"cpu",kernelFunc:JJ};function CHe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,dy:a}=t,{strides:o,pad:u,dataFormat:l,dimRoundingMode:c,filterShape:h}=s;Dt([i,a],"conv2dBackpropFilter");let d=q.convertConv2DDataFormat(l),p=q.computeConv2DInfo(i.shape,h,o,1,u,c,!1,d),{strideHeight:f,strideWidth:m,filterHeight:g,filterWidth:y}=p,b=p.dataFormat==="channelsLast",x=new Xn(p.filterShape,"float32"),w=p.padInfo.left,v=p.padInfo.top,S=n.data.get(i.dataId).values,E=n.data.get(a.dataId).values,C=new Xn(i.shape,i.dtype,S),I=new Xn(a.shape,a.dtype,E);for(let _=0;_<g;++_){let A=Math.max(0,Math.ceil((v-_)/f)),k=Math.min(p.outHeight,(p.inHeight+v-_)/f);for(let N=0;N<y;++N){let D=Math.max(0,Math.ceil((w-N)/m)),F=Math.min(p.outWidth,(p.inWidth+w-N)/m);for(let P=0;P<p.inChannels;++P)for(let G=0;G<p.outChannels;++G){let Y=0;for(let Z=0;Z<p.batchSize;++Z)for(let ee=A;ee<k;++ee){let se=_+ee*f-v;for(let re=D;re<F;++re){let J=N+re*m-w;b?Y+=C.get(Z,se,J,P)*I.get(Z,ee,re,G):Y+=C.get(Z,P,se,J)*I.get(Z,G,ee,re)}}x.set(Y,_,N,P,G)}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var _He={kernelName:kC,backendName:"cpu",kernelFunc:CHe};function EHe(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,filter:a}=t,{inputShape:o,strides:u,pad:l,dataFormat:c,dimRoundingMode:h}=s;Dt([i,a],"conv2dBackpropInput");let d=O.computeStrides(a.shape),p=O.computeStrides(i.shape),f=q.convertConv2DDataFormat(c),m=q.computeConv2DInfo(o,a.shape,u,1,l,h,!1,f),g=new Xn(m.inShape,"float32"),y=g.values,b=n.data.get(i.dataId).values,x=n.data.get(a.dataId).values,[w,v,S]=d,{batchSize:E,filterHeight:C,filterWidth:I,inChannels:_,inHeight:A,inWidth:k,outChannels:N,outHeight:D,outWidth:F,strideHeight:P,strideWidth:G}=m;f=m.dataFormat;let Y=C-1-m.padInfo.top,Z=I-1-m.padInfo.left,ee=f==="channelsLast",se=g.strides[0],re=ee?g.strides[1]:g.strides[2],J=ee?g.strides[2]:1,le=ee?1:g.strides[1],he=p[0],xe=ee?p[1]:p[2],Fe=ee?p[2]:1,Le=ee?1:p[1];for(let Ve=0;Ve<E;++Ve)for(let $e=0;$e<_;++$e)for(let Ae=0;Ae<A;++Ae){let Te=Ae-Y,Ue=Math.max(0,Math.ceil(Te/P)),qe=Math.min(D,(C+Te)/P);for(let Me=0;Me<k;++Me){let ie=Me-Z,K=Math.max(0,Math.ceil(ie/G)),pe=Math.min(F,(I+ie)/G),_e=0;for(let Oe=Ue;Oe<qe;++Oe){let nt=Oe*P-Te;for(let rt=K;rt<pe;++rt){let pt=rt*G-ie,Et=he*Ve+xe*Oe+Fe*rt,ht=w*(C-1-nt)+v*(I-1-pt)+S*$e;for(let Mt=0;Mt<N;++Mt){let it=b[Et+Le*Mt],kt=x[ht+Mt];_e+=it*kt}}}let We=se*Ve+re*Ae+J*Me+le*$e;y[We]=_e}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var IHe={kernelName:sp,backendName:"cpu",kernelFunc:EHe};function kHe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dilations:l}=s;Dt([i,a],"conv3d");let c=q.computeConv3DInfo(i.shape,a.shape,o,l,u),{filterDepth:h,filterHeight:d,filterWidth:p,dilationDepth:f,dilationHeight:m,dilationWidth:g,padInfo:y}=c,b=y.front,x=y.left,w=y.top,v=new Xn(c.outShape,i.dtype),S=n.data.get(i.dataId).values,E=n.data.get(a.dataId).values,C=v.values,I=O.computeStrides(i.shape),_=O.computeStrides(a.shape);for(let A=0;A<c.batchSize;++A){let k=A*I[0],N=A*v.strides[0];for(let D=0;D<c.outDepth;++D){let F=N+D*v.strides[1],P=D*c.strideDepth-b;for(let G=0;G<h;++G){let Y=P+G*f;if(Y<0||Y>=c.inDepth)continue;let Z=G*_[0],ee=k+Y*I[1];for(let se=0;se<c.outHeight;++se){let re=F+se*v.strides[2],J=se*c.strideHeight-w;for(let le=0;le<d;++le){let he=J+le*m;if(he<0||he>=c.inHeight)continue;let xe=Z+le*_[1],Fe=ee+he*I[2];for(let Le=0;Le<c.outWidth;++Le){let Ve=re+Le*c.outChannels,$e=Le*c.strideWidth-x;for(let Ae=0;Ae<p;++Ae){let Te=$e+Ae*g;if(Te<0||Te>=c.inWidth)continue;let Ue=xe+Ae*_[2],qe=Fe+Te*c.inChannels,Me=Ue;for(let ie=0;ie<c.inChannels;++ie){let K=S[qe+ie];for(let pe=0;pe<c.outChannels;++pe)C[Ve+pe]+=K*E[Me+pe];Me+=c.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var NHe={kernelName:ip,backendName:"cpu",kernelFunc:kHe};function THe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,dy:a}=t,{strides:o,pad:u,filterShape:l}=s;Dt([i,a],"conv3dBackpropFilterV2");let c=O.computeStrides(i.shape),h=O.computeStrides(a.shape),d=q.computeConv3DInfo(i.shape,l,o,1,u),p=d.strideDepth,f=d.strideHeight,m=d.strideWidth,g=d.filterDepth,y=d.filterHeight,b=d.filterWidth,x=new Xn(d.filterShape,"float32"),w=x.values,[v,S,E,C]=x.strides,I=n.data.get(a.dataId).values,[_,A,k,N]=h,D=n.data.get(i.dataId).values,[F,P,G,Y]=c,Z=d.padInfo.front,ee=d.padInfo.left,se=d.padInfo.top;for(let re=0;re<g;++re){let J=Math.max(0,Math.ceil((Z-re)/p)),le=Math.min(d.outDepth,(d.inDepth+Z-re)/p),he=re*v;for(let xe=0;xe<y;++xe){let Fe=Math.max(0,Math.ceil((se-xe)/f)),Le=Math.min(d.outHeight,(d.inHeight+se-xe)/f),Ve=xe*S+he;for(let $e=0;$e<b;++$e){let Ae=Math.max(0,Math.ceil((ee-$e)/m)),Te=Math.min(d.outWidth,(d.inWidth+ee-$e)/m),Ue=$e*E+Ve;for(let qe=0;qe<d.inChannels;++qe){let Me=qe*C+Ue;for(let ie=0;ie<d.outChannels;++ie){let K=0;for(let pe=0;pe<d.batchSize;++pe){let _e=pe*F,We=pe*_;for(let Oe=J;Oe<le;++Oe){let nt=(re+Oe*p-Z)*P+_e,rt=Oe*A+We;for(let pt=Fe;pt<Le;++pt){let Et=(xe+pt*f-se)*G+nt,ht=pt*k+rt;for(let Mt=Ae;Mt<Te;++Mt){let it=($e+Mt*m-ee)*Y+Et,kt=Mt*N+ht;K+=D[it+qe]*I[kt+ie]}}}}w[Me+ie]=K}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var AHe={kernelName:Og,backendName:"cpu",kernelFunc:THe};function DHe(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,filter:a}=t,{pad:o,strides:u,inputShape:l}=s;Dt([i],"conv3dBackpropInputV2");let c=O.computeStrides(i.shape),h=O.computeStrides(a.shape),d=q.computeConv3DInfo(l,a.shape,u,1,o),p=new Xn(d.inShape,"float32"),f=p.values,[m,g,y,b]=p.strides,x=n.data.get(i.dataId).values,[w,v,S,E]=c,C=n.data.get(a.dataId).values,[I,_,A,k]=h,{batchSize:N,filterDepth:D,filterHeight:F,filterWidth:P,inChannels:G,inDepth:Y,inHeight:Z,inWidth:ee,outChannels:se,outDepth:re,outHeight:J,outWidth:le,strideDepth:he,strideHeight:xe,strideWidth:Fe}=d,Le=D-1-d.padInfo.front,Ve=F-1-d.padInfo.top,$e=P-1-d.padInfo.left;for(let Ae=0;Ae<N;++Ae)for(let Te=0;Te<G;++Te)for(let Ue=0;Ue<Y;++Ue){let qe=Ue-Le,Me=Math.max(0,Math.ceil(qe/he)),ie=Math.min(re,(D+qe)/he);for(let K=0;K<Z;++K){let pe=K-Ve,_e=Math.max(0,Math.ceil(pe/xe)),We=Math.min(J,(F+pe)/xe);for(let Oe=0;Oe<ee;++Oe){let nt=Oe-$e,rt=Math.max(0,Math.ceil(nt/Fe)),pt=Math.min(le,(P+nt)/Fe),Et=0;for(let ht=Me;ht<ie;++ht){let Mt=ht*he-qe;for(let it=_e;it<We;++it){let kt=it*xe-pe;for(let Lt=rt;Lt<pt;++Lt){let wn=Lt*Fe-nt,Gr=w*Ae+v*ht+S*it+E*Lt,lr=I*(D-1-Mt)+_*(F-1-kt)+A*(P-1-wn)+k*Te;for(let Pr=0;Pr<se;++Pr){let V=x[Gr+Pr],H=C[lr+Pr];Et+=V*H}}}}f[m*Ae+g*Ue+y*K+b*Oe+Te]=Et}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}var FHe={kernelName:Mg,backendName:"cpu",kernelFunc:DHe},$He=Qr(ap,r=>Math.cos(r)),RHe={kernelName:ap,backendName:"cpu",kernelFunc:$He},OHe=Qr(op,r=>Math.cosh(r)),MHe={kernelName:op,backendName:"cpu",kernelFunc:OHe};function LHe(r){let{inputs:t,backend:n,attrs:s}=r,{image:i,boxes:a,boxInd:o}=t,{cropSize:u,method:l,extrapolationValue:c}=s,[h,d,p,f]=i.shape,m=a.shape[0],[g,y]=u,b=pr([m,g,y,f],"float32"),x=n.data.get(a.dataId).values,w=n.data.get(o.dataId).values,v=n.data.get(i.dataId).values,S=O.computeStrides(i.shape),E=O.computeStrides(b.shape);for(let C=0;C<m;C++){let I=C*4,_=x[I],A=x[I+1],k=x[I+2],N=x[I+3],D=w[C];if(D>=h)continue;let F=g>1?(k-_)*(d-1)/(g-1):0,P=y>1?(N-A)*(p-1)/(y-1):0;for(let G=0;G<g;G++){let Y=g>1?_*(d-1)+G*F:.5*(_+k)*(d-1);if(Y<0||Y>d-1){for(let Z=0;Z<y;Z++)for(let ee=0;ee<f;ee++){let se=ee+Z*E[2]+G*E[1]+C*E[0];b.values[se]=c}continue}if(l==="bilinear"){let Z=Math.floor(Y),ee=Math.ceil(Y),se=Y-Z;for(let re=0;re<y;re++){let J=y>1?A*(p-1)+re*P:.5*(A+N)*(p-1);if(J<0||J>p-1){for(let Fe=0;Fe<f;Fe++){let Le=Fe+re*E[2]+G*E[1]+C*E[0];b.values[Le]=c}continue}let le=Math.floor(J),he=Math.ceil(J),xe=J-le;for(let Fe=0;Fe<f;Fe++){let Le=Fe+le*S[2]+Z*S[1]+D*S[0],Ve=v[Le];Le=Fe+he*S[2]+Z*S[1]+D*S[0];let $e=v[Le];Le=Fe+le*S[2]+ee*S[1]+D*S[0];let Ae=v[Le];Le=Fe+he*S[2]+ee*S[1]+D*S[0];let Te=v[Le],Ue=Ve+($e-Ve)*xe,qe=Ae+(Te-Ae)*xe;Le=Fe+re*E[2]+G*E[1]+C*E[0],b.values[Le]=Ue+(qe-Ue)*se}}}else for(let Z=0;Z<y;++Z){let ee=y>1?A*(p-1)+Z*P:.5*(A+N)*(p-1);if(ee<0||ee>p-1){for(let J=0;J<f;J++){let le=J+Z*E[2]+G*E[1]+C*E[0];b.values[le]=c}continue}let se=Math.round(ee),re=Math.round(Y);for(let J=0;J<f;J++){let le=J+se*S[2]+re*S[1]+D*S[0],he=J+Z*E[2]+G*E[1]+C*E[0];b.values[he]=v[le]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var PHe={kernelName:Pg,backendName:"cpu",kernelFunc:LHe};function BHe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,exclusive:o,reverse:u}=s;Dt(i,"cumprod");let l=q.getAxesPermutation([a],i.shape.length),c=i;l!=null&&(c=Ai({inputs:{x:i},backend:n,attrs:{perm:l}}));let h=q.getInnerMostAxes(1,i.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);let d=va(c.dtype,"int32"),p=O.makeOnesTypedArray(O.sizeFromShape(c.shape),d),f=n.data.get(c.dataId).values,m=c.shape[c.shape.length-1],g=u?(b,x)=>b+m-x-1:(b,x)=>b+x;for(let b=0;b<f.length;b+=m)for(let x=0;x<m;x++){let w=g(b,x);if(x===0)p[w]=o?1:f[w];else{let v=g(b,x-1);p[w]=o?f[v]*p[v]:f[w]*p[v]}}let y=n.makeTensorInfo(c.shape,d,p);if(l!=null){let b=q.getUndoAxesPermutation(l),x=Ai({inputs:{x:y},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(c),x}return y}var VHe={kernelName:Lg,backendName:"cpu",kernelFunc:BHe};function zHe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,exclusive:o,reverse:u}=s;Dt(i,"cumsum");let l=q.getAxesPermutation([a],i.shape.length),c=i;l!=null&&(c=Ai({inputs:{x:i},backend:n,attrs:{perm:l}}));let h=q.getInnerMostAxes(1,i.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);let d=va(c.dtype,"int32"),p=O.makeZerosTypedArray(O.sizeFromShape(c.shape),d),f=n.data.get(c.dataId).values,m=c.shape[c.shape.length-1],g=u?(b,x)=>b+m-x-1:(b,x)=>b+x;for(let b=0;b<f.length;b+=m)for(let x=0;x<m;x++){let w=g(b,x);if(x===0)p[w]=o?0:f[w];else{let v=g(b,x-1);p[w]=o?f[v]+p[v]:f[w]+p[v]}}let y=n.makeTensorInfo(c.shape,d,p);if(l!=null){let b=q.getUndoAxesPermutation(l),x=Ai({inputs:{x:y},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(c),x}return y}var UHe={kernelName:up,backendName:"cpu",kernelFunc:zHe};function WHe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,weights:a}=t,{size:o,binaryOutput:u}=s;if(i.shape.length===1){let l=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values,h=WM(l,c,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,h)}else if(i.shape.length===2){let l=n.bufferSync(i),c=n.bufferSync(a),h=aJ(l,c,o,u);return n.makeTensorInfo(h.shape,a.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}var GHe={kernelName:Vx,backendName:"cpu",kernelFunc:WHe};function HHe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{blockSize:a,dataFormat:o}=s;O.assert(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);let u=i.shape[0],l=i.shape[1],c=i.shape[2],h=i.shape[3],d=l*a,p=c*a,f=h/(a*a),m=n.data.get(i.dataId).values,g=new Float32Array(u*d*p*f),y=0;for(let b=0;b<u;++b)for(let x=0;x<d;++x){let w=Math.floor(x/a),v=x%a;for(let S=0;S<p;++S){let E=Math.floor(S/a),C=S%a,I=(v*a+C)*f;for(let _=0;_<f;++_){let A=_+I+h*(E+c*(w+l*b));g[y++]=m[A]}}}return n.makeTensorInfo([u,d,p,f],i.dtype,g)}var jHe={kernelName:Bg,backendName:"cpu",kernelFunc:HHe};function QJ(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dilations:l,dimRoundingMode:c}=s;Dt([i,a],"depthwiseConv2DNative");let h=O.computeStrides(i.shape),d=O.computeStrides(a.shape),p=l;p==null&&(p=[1,1]),O.assert(q.eitherStridesOrDilationsAreOne(o,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`);let f=q.computeConv2DInfo(i.shape,a.shape,o,p,u,c,!0),{filterHeight:m,filterWidth:g,dilationHeight:y,dilationWidth:b,padInfo:x}=f,w=x.left,v=x.top,S=f.outChannels/f.inChannels,E=new Xn(f.outShape,i.dtype),C=n.data.get(i.dataId).values,I=n.data.get(a.dataId).values,_=E.values;for(let A=0;A<f.batchSize;++A){let k=A*h[0],N=A*E.strides[0];for(let D=0;D<f.outHeight;++D){let F=N+D*E.strides[1],P=D*f.strideHeight-v;for(let G=0;G<m;++G){let Y=P+G*y;if(Y<0||Y>=f.inHeight)continue;let Z=G*d[0],ee=k+Y*h[1];for(let se=0;se<f.outWidth;++se){let re=F+se*E.strides[2],J=se*f.strideWidth-w;for(let le=0;le<g;++le){let he=J+le*b;if(he<0||he>=f.inWidth)continue;let xe=Z+le*d[1],Fe=ee+he*f.inChannels,Le=re,Ve=xe;for(let $e=0;$e<f.inChannels;++$e){let Ae=C[Fe+$e];for(let Te=0;Te<S;++Te)_[Le+Te]+=Ae*I[Ve+Te];Le+=S,Ve+=S}}}}}}return n.makeTensorInfo(E.shape,E.dtype,E.values)}var qHe={kernelName:lp,backendName:"cpu",kernelFunc:QJ};function KHe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,dy:a}=t,{strides:o,dilations:u,pad:l,dimRoundingMode:c,filterShape:h}=s;Dt([i,a],"depthwiseConv2dNativeBackpropFilter");let d=q.computeConv2DInfo(i.shape,h,o,u,l,c,!0),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y=new Xn(d.filterShape,"float32"),b=d.padInfo.left,x=d.padInfo.top,w=d.outChannels/d.inChannels,v=n.data.get(i.dataId).values,S=new Xn(i.shape,i.dtype,v),E=n.data.get(a.dataId).values,C=new Xn(a.shape,a.dtype,E);for(let I=0;I<m;++I){let _=Math.max(0,Math.ceil((x-I)/p)),A=Math.min(d.outHeight,(d.inHeight+x-I)/p);for(let k=0;k<g;++k){let N=Math.max(0,Math.ceil((b-k)/f)),D=Math.min(d.outWidth,(d.inWidth+b-k)/f);for(let F=0;F<d.outChannels;++F){let P=Math.trunc(F/w),G=F%w,Y=0;for(let Z=0;Z<d.batchSize;++Z)for(let ee=_;ee<A;++ee){let se=I+ee*p-x;for(let re=N;re<D;++re){let J=k+re*f-b;Y+=S.get(Z,se,J,P)*C.get(Z,ee,re,F)}}y.set(Y,I,k,P,G)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var XHe={kernelName:NC,backendName:"cpu",kernelFunc:KHe};function YHe(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,filter:a}=t,{strides:o,dilations:u,pad:l,dimRoundingMode:c,inputShape:h}=s;Dt([i,a],"depthwiseConv2DNativeBackpropInput");let d=O.computeStrides(i.shape),p=O.computeStrides(a.shape),f=q.computeConv2DInfo(h,a.shape,o,u,l,c,!0),m=new Xn(f.inShape,"float32"),g=m.values,[y,b,x]=m.strides,w=n.data.get(i.dataId).values,[v,S,E]=d,C=n.data.get(a.dataId).values,[I,_,A]=p,{batchSize:k,filterHeight:N,filterWidth:D,inChannels:F,inHeight:P,inWidth:G,outChannels:Y,outHeight:Z,outWidth:ee,strideHeight:se,strideWidth:re}=f,J=N-1-f.padInfo.top,le=D-1-f.padInfo.left,he=Y/F;for(let xe=0;xe<k;++xe)for(let Fe=0;Fe<F;++Fe)for(let Le=0;Le<P;++Le){let Ve=Le-J,$e=Math.max(0,Math.ceil(Ve/se)),Ae=Math.min(Z,(N+Ve)/se);for(let Te=0;Te<G;++Te){let Ue=Te-le,qe=Math.max(0,Math.ceil(Ue/re)),Me=Math.min(ee,(D+Ue)/re),ie=0;for(let K=$e;K<Ae;++K){let pe=K*se-Ve;for(let _e=qe;_e<Me;++_e){let We=_e*re-Ue,Oe=v*xe+S*K+E*_e,nt=I*(N-1-pe)+_*(D-1-We)+A*Fe;for(let rt=0;rt<he;++rt){let pt=Fe*he+rt,Et=w[Oe+pt],ht=C[nt+rt];ie+=Et*ht}}}g[y*xe+b*Le+x*Te+Fe]=ie}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var ZHe={kernelName:TC,backendName:"cpu",kernelFunc:YHe};function JHe(r){let{inputs:t,backend:n}=r,{x:s}=t,i=O.sizeFromShape(s.shape),a=n.data.get(s.dataId).values,o=pr([i,i],s.dtype),u=o.values;for(let c=0;c<a.length;c++)u[c*i+c]=a[c];let l=[...s.shape,...s.shape];return n.makeTensorInfo(l,o.dtype,o.values)}var QHe={kernelName:zx,backendName:"cpu",kernelFunc:JHe},eje={kernelName:cp,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:n})=>{let{x:s,filter:i}=r,{strides:a,pad:o,dilations:u}=n,l=t,c=l.data.get(s.dataId).values,h=s.shape.length,d=l.data.get(i.dataId).values,p=i.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:x,padInfo:w,strideHeight:v,strideWidth:S,filterHeight:E,filterWidth:C,dilationHeight:I,dilationWidth:_,outShape:A}=q.computeDilation2DInfo(s.shape,i.shape,a,o,"NHWC",u),k=O.sizeFromShape(A),N=A.length,D=O.getArrayFromDType(s.dtype,k);for(let F=0;F<f;++F)for(let P=0;P<b;++P){let G=P*v-w.top;for(let Y=0;Y<x;++Y){let Z=Y*S-w.left;for(let ee=0;ee<y;++ee){let se=Number.MIN_SAFE_INTEGER;for(let J=0;J<E;++J){let le=G+J*I;if(le>=0&&le<m)for(let he=0;he<C;++he){let xe=Z+he*_;if(xe>=0&&xe<g){let Fe=O.locToIndex([F,le,xe,ee],h,O.computeStrides(s.shape)),Le=O.locToIndex([J,he,ee],p,O.computeStrides(i.shape)),Ve=c[Fe]+d[Le];Ve>se&&(se=Ve)}}}let re=O.locToIndex([F,P,Y,ee],N,O.computeStrides(A));D[re]=se}}}return{dataId:l.write(O.toTypedArray(D,s.dtype),A,s.dtype),shape:A,dtype:s.dtype}}},tje={kernelName:Wm,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:n})=>{let{x:s,filter:i,dy:a}=r,{strides:o,pad:u,dilations:l}=n,c=t,h=O.toNestedArray(s.shape,c.data.get(s.dataId).values),d=O.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:w,strideWidth:v,filterHeight:S,filterWidth:E,dilationHeight:C,dilationWidth:I,outShape:_}=q.computeDilation2DInfo(s.shape,i.shape,o,u,"NHWC",l);O.assert(a.rank===_.length,()=>`Error in ${Wm}, dy must have the same rank as output ${_.length}, but got ${a.rank}`);let A=O.toNestedArray(_,c.data.get(a.dataId).values),k=O.makeZerosNestedTypedArray(i.shape,i.dtype);for(let N=0;N<p;++N)for(let D=0;D<y;++D){let F=D*w-x.top;for(let P=0;P<b;++P){let G=P*v-x.left;for(let Y=0;Y<g;++Y){let Z=Number.MIN_SAFE_INTEGER,ee=0,se=0;for(let re=0;re<S;++re){let J=F+re*C;if(J>=0&&J<f)for(let le=0;le<E;++le){let he=G+le*I;if(he>=0&&he<m){let xe=h[N][J][he][Y]+d[re][le][Y];xe>Z&&(Z=xe,ee=re,se=le)}}}k[ee][se][Y]+=A[N][D][P][Y]}}}return{dataId:c.write(O.toTypedArray(k,s.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},rje={kernelName:Um,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:n})=>{let{x:s,filter:i,dy:a}=r,{strides:o,pad:u,dilations:l}=n,c=t,h=O.toNestedArray(s.shape,c.data.get(s.dataId).values),d=O.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:w,strideWidth:v,filterHeight:S,filterWidth:E,dilationHeight:C,dilationWidth:I,outShape:_}=q.computeDilation2DInfo(s.shape,i.shape,o,u,"NHWC",l);O.assert(a.rank===_.length,()=>`Error in ${Um}, dy must have the same rank as output ${_.length}, but got ${a.rank}`);let A=O.toNestedArray(_,c.data.get(a.dataId).values),k=O.makeZerosNestedTypedArray(s.shape,s.dtype);for(let N=0;N<p;++N)for(let D=0;D<y;++D){let F=D*w-x.top;for(let P=0;P<b;++P){let G=P*v-x.left;for(let Y=0;Y<g;++Y){let Z=Number.MIN_SAFE_INTEGER,ee=F<0?0:F,se=G<0?0:G;for(let re=0;re<S;++re){let J=F+re*C;if(J>=0&&J<f)for(let le=0;le<E;++le){let he=G+le*I;if(he>=0&&he<m){let xe=h[N][J][he][Y]+d[re][le][Y];xe>Z&&(Z=xe,ee=J,se=he)}}}k[N][ee][se][Y]+=A[N][D][P][Y]}}}return{dataId:c.write(O.toTypedArray(k,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function nje(r){let{inputs:t,backend:n,attrs:s}=r,{image:i}=t,{canvas:a,options:o}=s,{contextOptions:u,imageOptions:l}=o||{},c=(l==null?void 0:l.alpha)||1,h=(u==null?void 0:u.contextType)||"2d";if(h!=="2d")throw new Error(`Context type ${u.contextType} is not supported by the CPU backend.`);let d=a.getContext(h,(u==null?void 0:u.contextAttributes)||{});if(d==null)throw new Error(`Could not get the context with ${h} type.`);let[p,f]=i.shape.slice(0,2),m=i.shape.length===2?1:i.shape[2],g=n.data.get(i.dataId).values,y=i.dtype==="float32"?255:1,b=new Uint8ClampedArray(f*p*4);for(let w=0;w<p*f;++w){let v=[0,0,0,255*c];for(let E=0;E<m;E++){let C=g[w*m+E];if(i.dtype==="float32"){if(C<0||C>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${C}.`)}else if(i.dtype==="int32"&&(C<0||C>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${C}.`);m===1?(v[0]=C*y,v[1]=C*y,v[2]=C*y):v[E]=C*y}let S=w*4;b[S+0]=Math.round(v[0]),b[S+1]=Math.round(v[1]),b[S+2]=Math.round(v[2]),b[S+3]=Math.round(v[3])}a.width=f,a.height=p;let x=new ImageData(b,f,p);return d.putImageData(x,0,0),i}var sje={kernelName:AC,backendName:"cpu",kernelFunc:nje};function Dv(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s;Dt(i,"sum");let u;i.dtype==="bool"?u=kc({inputs:{x:i},backend:n,attrs:{dtype:"int32"}}):u=xu({inputs:{x:i},backend:n});let l=u.shape.length,c=O.parseAxisParam(a,u.shape),h=q.getAxesPermutation(c,l),d=c,p=u;h!=null&&(p=Ai({inputs:{x:u},backend:n,attrs:{perm:h}}),d=q.getInnerMostAxes(d.length,l)),q.assertAxesAreInnerMostDims("sum",d,p.shape.length);let[f,m]=q.computeOutAndReduceShapes(p.shape,d),g=q.upcastType(p.dtype,"int32"),y=Y2(n,f,g),b=O.sizeFromShape(m),x=n.data.get(y.dataId).values,w=n.data.get(p.dataId).values;for(let v=0;v<x.length;++v){let S=v*b,E=0;for(let C=0;C<b;++C)E+=w[S+C];x[v]=E}if(o){let v=q.expandShapeToKeepDim(y.shape,c),S=y;y=vn({inputs:{x:y},backend:n,attrs:{shape:v}}),n.disposeIntermediateTensorInfo(S)}return n.disposeIntermediateTensorInfo(u),h!=null&&n.disposeIntermediateTensorInfo(p),y}var ije={kernelName:nf,backendName:"cpu",kernelFunc:Dv};function aje(r){let{inputs:t,backend:n,attrs:s}=r,{equation:i}=s,a=t,{allDims:o,summedDims:u,idDims:l}=q.decodeEinsumEquation(i,a.length);q.checkEinsumDimSizes(o.length,l,a);let{path:c,steps:h}=q.getEinsumComputePath(u,l),d=h.length,p=null,f=o.length,m=[];for(let g=0;g<d;++g){for(let y of h[g]){let{permutationIndices:b,expandDims:x}=q.getEinsumPermutation(f,l[y]),w;q.isIdentityPermutation(b)?w=a[y]:(w=Ai({inputs:{x:a[y]},backend:n,attrs:{perm:b}}),m.push(w));let v=w.shape.slice();for(let S=0;S<x.length;++S)v.splice(x[S],0,1);O.arraysEqual(w.shape,v)||(w=vn({inputs:{x:w},backend:n,attrs:{shape:v}}),m.push(w)),p===null?p=w:(p=G_({inputs:{a:w,b:p},backend:n}),m.push(p))}g<d-1&&(c[g]>=0&&(p=Dv({inputs:{x:p},backend:n,attrs:{axis:c[g]-(o.length-f),keepDims:!1}}),m.push(p)),f--)}for(let g of m)g!==p&&n.disposeIntermediateTensorInfo(g);return p}var oje={kernelName:DC,backendName:"cpu",kernelFunc:aje};function uje(r){let{inputs:t,backend:n}=r,{dy:s,y:i}=t;Dt([s,i],"eluGrad");let a=new Float32Array(O.sizeFromShape(i.shape)),o=n.data.get(i.dataId).values,u=n.data.get(s.dataId).values;for(let l=0;l<o.length;++l){let c=o[l];c>=0?a[l]=u[l]:a[l]=u[l]*(c+1)}return n.makeTensorInfo(i.shape,"float32",a)}var lje={kernelName:Vg,backendName:"cpu",kernelFunc:uje},cje=q.ERF_P,hje=q.ERF_A1,dje=q.ERF_A2,pje=q.ERF_A3,fje=q.ERF_A4,mje=q.ERF_A5,gje=Qr(pp,r=>{let t=Math.sign(r),n=Math.abs(r),s=1/(1+cje*n);return t*(1-((((mje*s+fje)*s+pje)*s+dje)*s+hje)*s*Math.exp(-n*n))}),yje={kernelName:pp,backendName:"cpu",kernelFunc:gje};function Q2(r){let{inputs:t,backend:n,attrs:s}=r,{input:i}=t,{dim:a}=s,o=i.shape.length,u=i.shape.slice(),l=a;return a<0&&(O.assert(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+a+1),u.splice(l,0,1),vn({inputs:{x:i},backend:n,attrs:{shape:u}})}var bje={kernelName:Ug,backendName:"cpu",kernelFunc:Q2},xje=Hn((r,t)=>r/t),tL=cs(hp,xje),kN={kernelName:hp,backendName:"cpu",kernelFunc:tL};function eQ(r,t,n){let s=r.shape,i=s[0],a=s[1],o=n.data.get(r.dataId),u=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[i,a],h=O.sizeFromShape(c),d=O.getTypedArrayFromDType("float32",h),p=O.getTypedArrayFromDType("float32",h);for(let y=0;y<i;y++){let b=_d({inputs:{x:u},backend:n,attrs:{begin:[y,0],size:[1,a]}}),x=_d({inputs:{x:l},backend:n,attrs:{begin:[y,0],size:[1,a]}}),w=Yi({inputs:{real:b,imag:x},backend:n}),{real:v,imag:S}=vje(w,t,n),E=q.mergeRealAndImagArrays(v,S);for(let C=0;C<a;C++){let I=q.getComplexWithIndex(E,C);d[y*a+C]=I.real,p[y*a+C]=I.imag}n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w)}let f=n.makeTensorInfo(c,"float32",d),m=n.makeTensorInfo(c,"float32",p),g=Yi({inputs:{real:f,imag:m},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}function vje(r,t,n){let s=O.sizeFromShape(r.shape),i=n.data.get(r.dataId),a=n.data.get(i.complexTensorInfos.real.dataId).values,o=n.data.get(i.complexTensorInfos.imag.dataId).values;if(wje(s)){let u=NN(a,o,s,t,n),l=[r.shape[0],r.shape[1]];if(t){let c=n.makeTensorInfo(l,"float32",u.real),h=n.makeTensorInfo(l,"float32",u.imag),d=n.makeTensorInfo([],"float32",O.createScalarValue(s,"float32")),p=xu({inputs:{x:d},backend:n}),f=kN.kernelFunc({inputs:{a:c,b:d},backend:n}),m=kN.kernelFunc({inputs:{a:h,b:p},backend:n}),g=n.data.get(f.dataId).values,y=n.data.get(m.dataId).values;return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),{real:g,imag:y}}return u}else{let u=q.mergeRealAndImagArrays(a,o),l=Sje(u,s,t);return q.splitRealAndImagArrays(l)}}function wje(r){return(r&r-1)===0}function NN(r,t,n,s,i){if(n===1)return{real:r,imag:t};let a=q.mergeRealAndImagArrays(r,t),o=n/2,u=q.complexWithEvenIndex(a),l=u.real,c=u.imag,h=[l.length],d=i.makeTensorInfo(h,"float32",l),p=i.makeTensorInfo(h,"float32",c),f=Yi({inputs:{real:d,imag:p},backend:i}),m=q.complexWithOddIndex(a),g=m.real,y=m.imag,b=[g.length],x=i.makeTensorInfo(b,"float32",g),w=i.makeTensorInfo(b,"float32",y),v=Yi({inputs:{real:x,imag:w},backend:i}),S=NN(l,c,o,s,i),E=S.real,C=S.imag,I=[E.length],_=i.makeTensorInfo(I,"float32",E),A=i.makeTensorInfo(I,"float32",C),k=Yi({inputs:{real:_,imag:A},backend:i}),N=NN(g,y,o,s,i),D=N.real,F=N.imag,P=[D.length],G=i.makeTensorInfo(P,"float32",D),Y=i.makeTensorInfo(P,"float32",F),Z=Yi({inputs:{real:G,imag:Y},backend:i}),ee=q.exponents(n,s),se=[ee.real.length],re=i.makeTensorInfo(se,"float32",ee.real),J=i.makeTensorInfo(se,"float32",ee.imag),le=Yi({inputs:{real:re,imag:J},backend:i}),he=G_({inputs:{a:le,b:Z},backend:i}),xe=tg({inputs:{a:k,b:he},backend:i}),Fe=JM({inputs:{a:k,b:he},backend:i}),Le=Cd({inputs:{input:xe},backend:i}),Ve=Cd({inputs:{input:Fe},backend:i}),$e=rg({inputs:{input:xe},backend:i}),Ae=rg({inputs:{input:Fe},backend:i}),Te=ng({inputs:[Le,Ve],backend:i,attrs:{axis:0}}),Ue=ng({inputs:[$e,Ae],backend:i,attrs:{axis:0}}),qe=i.data.get(Te.dataId).values,Me=i.data.get(Ue.dataId).values;return i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(w),i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(A),i.disposeIntermediateTensorInfo(k),i.disposeIntermediateTensorInfo(G),i.disposeIntermediateTensorInfo(Y),i.disposeIntermediateTensorInfo(Z),i.disposeIntermediateTensorInfo(re),i.disposeIntermediateTensorInfo(J),i.disposeIntermediateTensorInfo(le),i.disposeIntermediateTensorInfo(he),i.disposeIntermediateTensorInfo(xe),i.disposeIntermediateTensorInfo(Fe),i.disposeIntermediateTensorInfo(Le),i.disposeIntermediateTensorInfo($e),i.disposeIntermediateTensorInfo(Ve),i.disposeIntermediateTensorInfo(Ae),i.disposeIntermediateTensorInfo(Te),i.disposeIntermediateTensorInfo(Ue),{real:qe,imag:Me}}function Sje(r,t,n){let s=new Float32Array(t*2);for(let i=0;i<t;i++){let a=0,o=0;for(let u=0;u<t;u++){let l=q.exponent(i*u,t,n),c=q.getComplexWithIndex(r,u);a+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}n&&(a/=t,o/=t),q.assignToTypedArray(s,a,o,i)}return s}function Cje(r){let{inputs:t,backend:n}=r,{input:s}=t,i=O.sizeFromShape(s.shape),a=s.shape[s.shape.length-1],o=i/a,u=vn({inputs:{x:s},backend:n,attrs:{shape:[o,a]}}),l=eQ(u,!1,n),c=vn({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}var _je={kernelName:FC,backendName:"cpu",kernelFunc:Cje};function rL(r){let{backend:t,attrs:n}=r,{shape:s,value:i,dtype:a}=n,o=a||O.inferDtype(i),u=O.getArrayFromDType(o,O.sizeFromShape(s));return Ije(u,i),t.makeTensorInfo(s,o,u)}var Eje={kernelName:Ux,backendName:"cpu",kernelFunc:rL};function Ije(r,t,n){r.fill(t)}var kje={kernelName:Wg,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:n})=>{let{image:s}=r,i=n,a=O.getTypedArrayFromDType(s.dtype,O.sizeFromShape(s.shape)),[o,u,l,c]=s.shape,h=i.data.get(s.dataId).values;for(let d=0;d<o;d++){let p=d*l*u*c;for(let f=0;f<u;f++){let m=f*(l*c);for(let g=0;g<l;g++){let y=g*c;for(let b=0;b<c;b++){let x=Math.round(l-g-1),w=p+m+y+b,v=h[w];if(x>=0&&x<l){let S=x*c,E=p+m+S+b;v=h[E]}a[w]=v}}}}return{dataId:i.write(a,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function Nje(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s,g=JJ({inputs:{x:i,filter:a},backend:n,attrs:{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p}});if(o){let y=g;if(h==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){let b=vn({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});g=tg({inputs:{a:g,b},backend:n}),n.disposeIntermediateTensorInfo(b)}else g=tg({inputs:{a:g,b:o},backend:n});n.disposeIntermediateTensorInfo(y)}if(f){let y=g;if(h==="NCHW"&&f==="prelu"&&u.shape.length===1&&u.shape[0]!==1){let b=vn({inputs:{x:u},backend:n,attrs:{shape:[u.shape[0],1,1]}});g=J2(n,g,f,b,m),n.disposeIntermediateTensorInfo(b)}else g=J2(n,g,f,u,m);n.disposeIntermediateTensorInfo(y)}return g}var Tje={kernelName:hd,backendName:"cpu",kernelFunc:Nje};function Aje(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s,g=QJ({inputs:{x:i,filter:a},backend:n,attrs:{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p}});if(o){let y=g;g=tg({inputs:{a:g,b:o},backend:n}),n.disposeIntermediateTensorInfo(y)}if(f){let y=g;g=J2(n,g,f,u,m),n.disposeIntermediateTensorInfo(y)}return g}var Dje={kernelName:dd,backendName:"cpu",kernelFunc:Aje};function Fje(r){let{inputs:t,backend:n}=r,{params:s,indices:i}=t,a=O.sizeFromShape(s.shape),o=i.shape,u=o[o.length-1],[l,c,h,d]=q.prepareAndValidate(s,i);if(c===0)return n.makeTensorInfo(l,s.dtype,[]);let p=n.data.get(i.dataId).values,f=n.bufferSync(s),m=gJ(p,f,s.dtype,c,u,h,d,s.shape,a);return n.makeTensorInfo(l,s.dtype,m.values)}var $je={kernelName:Hg,backendName:"cpu",kernelFunc:Fje};function Rje(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,indices:a}=t,{axis:o,batchDims:u}=s;Dt([i,a],"gatherV2");let l=O.parseAxisParam(o,i.shape)[0],c=n.data.get(a.dataId).values,h=i.shape[l];for(let v=0;v<c.length;++v){let S=c[v];O.assert(S<=h-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${h-1}]`)}let d=u;u==null&&(d=0);let p=O.sizeFromShape(a.shape),f=q.segment_util.collectGatherOpShapeInfo(i,a,l,d),m=vn({inputs:{x:i},backend:n,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),g=vn({inputs:{x:a},backend:n,attrs:{shape:[f.batchSize,p/f.batchSize]}}),y=[f.batchSize,f.outerSize,p/f.batchSize,f.sliceSize],b=n.bufferSync(g),x=n.bufferSync(m),w=yJ(x,b,y);return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(f.outputShape,w.dtype,w.values)}var Oje={kernelName:Gg,backendName:"cpu",kernelFunc:Rje};function Mje(r){let{inputs:t,backend:n}=r,{input:s}=t,i=O.sizeFromShape(s.shape),a=s.shape[s.shape.length-1],o=i/a,u=vn({inputs:{x:s},backend:n,attrs:{shape:[o,a]}}),l=eQ(u,!0,n),c=vn({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}var Lje={kernelName:$C,backendName:"cpu",kernelFunc:Mje},Pje=Qr(wp,r=>Number.isFinite(r)?1:0,"bool"),Bje={kernelName:wp,backendName:"cpu",kernelFunc:Pje},Vje=Qr(Sp,r=>Math.abs(r)===1/0?1:0,"bool"),zje={kernelName:Sp,backendName:"cpu",kernelFunc:Vje},Uje=Qr(Cp,r=>Number.isNaN(r)?1:0,"bool"),Wje={kernelName:Cp,backendName:"cpu",kernelFunc:Uje};function Gje(r){let{backend:t,attrs:n}=r,{start:s,stop:i,num:a}=n,o=SJ(s,i,a);return t.makeTensorInfo([o.length],"float32",o)}var Hje={kernelName:Xg,backendName:"cpu",kernelFunc:Gje},jje=Qr(Ip,r=>Math.log1p(r)),qje={kernelName:Ip,backendName:"cpu",kernelFunc:jje},Kje=Hn((r,t)=>r&&t),Xje=cs(Yg,Kje,null,"bool"),Yje={kernelName:Yg,backendName:"cpu",kernelFunc:Xje},Zje=Qr(Zg,r=>r?0:1,"bool"),Jje={kernelName:Zg,backendName:"cpu",kernelFunc:Zje},Qje=Hn((r,t)=>r||t),e9e=cs(Jg,Qje,null,"bool"),t9e={kernelName:Jg,backendName:"cpu",kernelFunc:e9e};function r9e(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{depthRadius:a,bias:o,alpha:u,beta:l}=s;Dt(i,"LRN");let c=i.shape[3],h=c-1,d=n.data.get(i.dataId).values,p=O.sizeFromShape(i.shape),f=new Float32Array(p);function m(g){let y=g%c,b=g-y+Math.max(0,y-a),x=g-y+Math.min(y+a,h),w=0;for(;b<=x;b++){let v=d[b];w+=v*v}return w}for(let g=0;g<p;g++){let y=m(g),b=d[g]*Math.pow(o+u*y,-l);f[g]=b}return n.makeTensorInfo(i.shape,i.dtype,f)}var n9e={kernelName:kp,backendName:"cpu",kernelFunc:r9e};function s9e(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,y:a,dy:o}=t,{depthRadius:u,bias:l,alpha:c,beta:h}=s;Dt(o,"LRNGrad");let d=O.sizeFromShape(o.shape),p=o.shape[3],f=n.data.get(o.dataId).values,m=n.data.get(i.dataId).values,g=n.data.get(a.dataId).values,y=new Float32Array(d),b=d;for(let x=0;x<b;x++){let w=x%p,v=x-w+Math.max(0,w-u),S=x-w+Math.min(p,w+u+1),E=0;for(let C=v;C<S;C++)E+=Math.pow(m[C],2);E=c*E+l;for(let C=v;C<S;C++){let I=-2*c*h*m[C]*g[x]/E;x===C&&(I+=Math.pow(E,-h)),I*=f[x],y[C]+=I}}return n.makeTensorInfo(o.shape,i.dtype,y)}var i9e={kernelName:Qg,backendName:"cpu",kernelFunc:s9e};function tQ(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{reductionIndices:a,keepDims:o}=s,u=n,l=i.shape,c=l.length,h=O.parseAxisParam(a,l),d=h,p=q.getAxesPermutation(d,c),f=u.data.get(i.dataId).values;if(p!=null){let v=new Array(c);for(let S=0;S<v.length;S++)v[S]=l[p[S]];f=jM(f,l,i.dtype,p,v),d=q.getInnerMostAxes(d.length,c),l=v}Dt(i,"max"),q.assertAxesAreInnerMostDims("max",d,c);let[m,g]=q.computeOutAndReduceShapes(l,d),y=O.sizeFromShape(g),b=_J(f,y,m,i.dtype),x=u.write(b,m,i.dtype),w=m;return o&&(w=q.expandShapeToKeepDim(m,h)),{dataId:x,shape:w,dtype:i.dtype}}var a9e={kernelName:Np,backendName:"cpu",kernelFunc:tQ};function o9e(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t;Dt(i,"maxPool");let{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=s,c=1;O.assert(q.eitherStridesOrDilationsAreOne(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);let h=q.computePool2DInfo(i.shape,a,o,c,u,l),d;if(h.filterWidth===1&&h.filterHeight===1&&O.arraysEqual(h.inShape,h.outShape))d=xu({inputs:{x:i},backend:n});else{let p=n.data.get(i.dataId).values,f=O.computeStrides(i.shape),m=eL(p,i.shape,i.dtype,f,h,"max");d=n.makeTensorInfo(h.outShape,i.dtype,m.values)}return d}var u9e={kernelName:Ap,backendName:"cpu",kernelFunc:o9e};function l9e(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l,dataFormat:c}=s;Dt(i,"maxPool3d");let h=q.computePool3DInfo(i.shape,a,o,1,u,l,c),d=n.data.get(i.dataId).values,p=ZJ(d,i.shape,i.dtype,O.computeStrides(i.shape),h,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}var c9e={kernelName:e0,backendName:"cpu",kernelFunc:l9e};function h9e(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=s;Dt([i,a],"maxPool3DGrad");let h=q.computePool3DInfo(a.shape,o,u,1,l,c),d=n.bufferSync(a),p=QGe(d,h),f=h.strideDepth,m=h.strideHeight,g=h.strideWidth,y=h.dilationDepth,b=h.dilationHeight,x=h.dilationWidth,w=h.effectiveFilterDepth,v=h.effectiveFilterHeight,S=h.effectiveFilterWidth,E=w-1-h.padInfo.front,C=S-1-h.padInfo.left,I=v-1-h.padInfo.top,_=pr(a.shape,"float32"),A=n.bufferSync(i);for(let k=0;k<h.batchSize;++k)for(let N=0;N<h.inChannels;++N)for(let D=0;D<h.inDepth;++D)for(let F=0;F<h.inHeight;++F)for(let P=0;P<h.inWidth;++P){let G=D-E,Y=F-I,Z=P-C,ee=0;for(let se=0;se<w;se+=y){let re=(G+se)/f;if(!(re<0||re>=h.outDepth||Math.floor(re)!==re))for(let J=0;J<v;J+=b){let le=(Y+J)/m;if(!(le<0||le>=h.outHeight||Math.floor(le)!==le))for(let he=0;he<S;he+=x){let xe=(Z+he)/g;if(xe<0||xe>=h.outWidth||Math.floor(xe)!==xe)continue;let Fe=w*v*S-1-p.get(k,re,le,xe,N),Le=se*v*S+J*S+he,Ve=Fe===Le?1:0;if(Ve===0)continue;let $e=A.get(k,re,le,xe,N);ee+=$e*Ve}}}_.set(ee,k,D,F,P,N)}return n.makeTensorInfo(_.shape,_.dtype,_.values)}var d9e={kernelName:Gx,backendName:"cpu",kernelFunc:h9e};function p9e(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a,output:o}=t,u=a;Dt([a,o],"maxPoolGrad");let{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=q.computePool2DInfo(u.shape,l,c,1,h,d),f=n.data.get(u.dataId).values,m=pr(p.outShape,u.dtype,YJ(f,u.shape,u.dtype,p).values),g=p.strideHeight,y=p.strideWidth,b=p.dilationHeight,x=p.dilationWidth,w=p.effectiveFilterHeight,v=p.effectiveFilterWidth,S=v-1-p.padInfo.left,E=w-1-p.padInfo.top,C=pr(u.shape,"float32"),I=n.data.get(i.dataId).values,_=pr(i.shape,"float32",I);for(let A=0;A<p.batchSize;++A)for(let k=0;k<p.inChannels;++k)for(let N=0;N<p.inHeight;++N)for(let D=0;D<p.inWidth;++D){let F=N-E,P=D-S,G=0;for(let Y=0;Y<w;Y+=b){let Z=(F+Y)/g;if(!(Z<0||Z>=p.outHeight||Math.floor(Z)!==Z))for(let ee=0;ee<v;ee+=x){let se=(P+ee)/y;if(se<0||se>=p.outWidth||Math.floor(se)!==se)continue;let re=w*v-1-m.get(A,Z,se,k),J=Y*v+ee,le=re===J?1:0;if(le===0)continue;let he=_.get(A,Z,se,k);G+=he*le}}C.set(G,A,N,D,k)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}var f9e={kernelName:Wx,backendName:"cpu",kernelFunc:p9e};function m9e(r,t,n,s,i){let a=O.computeStrides(t),o=eL(r,t,n,a,i,"max"),u=YJ(r,t,n,i,!0,s);return[o.values,u.values]}var g9e={kernelName:Hx,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:n})=>{let{x:s}=r,{filterSize:i,strides:a,pad:o,includeBatchInIndex:u}=t,l=n;Dt(s,"MaxPoolWithArgmax");let c=l.data.get(s.dataId).values,h=q.computePool2DInfo(s.shape,i,a,[1,1],o),[d,p]=m9e(c,s.shape,s.dtype,u,h),f=l.write(d,h.outShape,s.dtype),m=l.write(p,h.outShape,s.dtype);return[{dataId:f,shape:h.outShape,dtype:s.dtype},{dataId:m,shape:h.outShape,dtype:"int32"}]}};function y9e(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s,u=O.parseAxisParam(a,i.shape),l=q.computeOutAndReduceShapes(i.shape,u)[1],c=O.sizeFromShape(l),h=[],d=n.makeTensorInfo([],"float32",new Float32Array([c]));h.push(d);let p=kc({inputs:{x:i},backend:n,attrs:{dtype:"float32"}});h.push(p);let f=tL({inputs:{a:p,b:d},backend:n});h.push(f);let m=Dv({inputs:{x:f},backend:n,attrs:{axis:a,keepDims:o}});return h.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}var b9e={kernelName:Dp,backendName:"cpu",kernelFunc:y9e};function x9e(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s;Dt(i,"min");let u=O.parseAxisParam(a,i.shape),l=u,c=q.getAxesPermutation(l,i.shape.length),h=i;c!=null&&(h=Ai({inputs:{x:i},backend:n,attrs:{perm:c}}),l=q.getInnerMostAxes(l.length,i.shape.length)),q.assertAxesAreInnerMostDims("min",l,h.shape.length);let[d,p]=q.computeOutAndReduceShapes(h.shape,l),f=O.sizeFromShape(p),m=O.makeZerosTypedArray(O.sizeFromShape(d),h.dtype),g=n.data.get(h.dataId).values;for(let b=0;b<m.length;++b){let x=b*f,w=g[x];for(let v=0;v<f;++v){let S=g[x+v];(Number.isNaN(S)||S<w)&&(w=S)}m[b]=w}c!=null&&n.disposeIntermediateTensorInfo(h);let y=n.makeTensorInfo(d,h.dtype,m);if(o){let b=q.expandShapeToKeepDim(d,u),x=vn({inputs:{x:y},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(y),x}return y}var v9e={kernelName:Fp,backendName:"cpu",kernelFunc:x9e};function w9e(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{paddings:a,mode:o}=s;Dt(i,"mirrorPad");let u=a.map((x,w)=>x[0]+i.shape[w]+x[1]),l=a.map(x=>x[0]),c=a.map((x,w)=>x[0]+i.shape[w]),h=o==="reflect"?0:1,d=n.data.get(i.dataId).values,p=i.shape.length,f=O.computeStrides(i.shape),m=O.sizeFromShape(u),g=u.length,y=O.computeStrides(u),b=O.getTypedArrayFromDType(i.dtype,m);for(let x=0;x<m;x++){let w=O.indexToLoc(x,g,y);for(let S=0;S<g;S++)w[S]<l[S]?w[S]=l[S]*2-w[S]-h:w[S]>=c[S]&&(w[S]=(c[S]-1)*2-w[S]+h);w=w.map((S,E)=>S-l[E]);let v=O.locToIndex(w,p,f);b[x]=d[v]}return{dataId:n.write(b,u,i.dtype),shape:u,dtype:i.dtype}}var S9e={kernelName:Rp,backendName:"cpu",kernelFunc:w9e},C9e=Hn((r,t)=>{let n=r%t;return r<0&&t<0||r>=0&&t>=0?n:(n+t)%t}),_9e=cs(Op,C9e),E9e={kernelName:Op,backendName:"cpu",kernelFunc:_9e},I9e=Oc(SC());function rQ(r){let{inputs:t,backend:n,attrs:s}=r,{logits:i}=t,{dim:a}=s,o=i.shape.length,u=a;if(u===-1&&(u=o-1),u!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${u}`);let l=O.parseAxisParam([u],i.shape),c=tQ({inputs:{x:i},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),h=q.expandShapeToKeepDim(c.shape,l),d=vn({inputs:{x:c},backend:n,attrs:{shape:h}}),p=JM({inputs:{a:i,b:d},backend:n}),f=dJ({inputs:{x:p},backend:n}),m=Dv({inputs:{x:f},backend:n,attrs:{axis:l,keepDims:!1}}),g=vn({inputs:{x:m},backend:n,attrs:{shape:h}}),y=tL({inputs:{a:f,b:g},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}var k9e={kernelName:sf,backendName:"cpu",kernelFunc:rQ};function N9e(r){let{inputs:t,backend:n,attrs:s}=r,{logits:i}=t,{numSamples:a,seed:o,normalized:u}=s;Dt(i,"multinomial");let l=u?i:rQ({inputs:{logits:i},backend:n,attrs:{dim:-1}}),c=l.shape[0],h=l.shape[1],d=n.data.get(l.dataId).values,p=[c,a],f=O.makeZerosTypedArray(O.sizeFromShape(p),"int32");for(let m=0;m<c;++m){let g=m*h,y=new Float32Array(h-1);y[0]=d[g];for(let w=1;w<y.length;++w)y[w]=y[w-1]+d[g+w];let b=I9e.alea(o.toString()),x=m*a;for(let w=0;w<a;++w){let v=b();f[x+w]=y.length;for(let S=0;S<y.length;S++)if(v<y[S]){f[x+w]=S;break}}}return u||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(p,"int32",f)}var T9e={kernelName:t0,backendName:"cpu",kernelFunc:N9e},A9e=ku.nonMaxSuppressionV3Impl;function D9e(r){let{inputs:t,backend:n,attrs:s}=r,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l}=s;Dt(i,"NonMaxSuppression");let c=n.data.get(i.dataId).values,h=n.data.get(a.dataId).values,{selectedIndices:d}=A9e(c,h,o,u,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var F9e={kernelName:s0,backendName:"cpu",kernelFunc:D9e},$9e=ku.nonMaxSuppressionV4Impl;function R9e(r){let{inputs:t,backend:n,attrs:s}=r,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l,padToMaxOutputSize:c}=s;Dt(i,"NonMaxSuppressionPadded");let h=n.data.get(i.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:p,validOutputs:f}=$9e(h,d,o,u,l,c);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}var O9e={kernelName:i0,backendName:"cpu",kernelFunc:R9e},M9e=ku.nonMaxSuppressionV5Impl;function L9e(r){let{inputs:t,backend:n,attrs:s}=r,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=s;Dt(i,"NonMaxSuppressionWithScore");let h=n.data.get(i.dataId).values,d=n.data.get(a.dataId).values,p=o,f=u,m=l,g=c,{selectedIndices:y,selectedScores:b}=M9e(h,d,p,f,m,g);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var P9e={kernelName:a0,backendName:"cpu",kernelFunc:L9e};function B9e(r){let{inputs:t,backend:n,attrs:s}=r,{indices:i}=t,{dtype:a,depth:o,onValue:u,offValue:l}=s;Dt(i,"oneHot");let c=O.sizeFromShape(i.shape),h=new Float32Array(c*o);h.fill(l);let d=n.data.get(i.dataId).values;for(let p=0;p<c;++p)d[p]>=0&&d[p]<o&&(h[p*o+d[p]]=u);return n.makeTensorInfo([...i.shape,o],a,h)}var V9e={kernelName:Lp,backendName:"cpu",kernelFunc:B9e};function eS(r){let{inputs:t,backend:n}=r,{x:s}=t;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){let i=Cd({inputs:{input:s},backend:n}),a=eS({inputs:{x:i},backend:n}),o=rg({inputs:{input:s},backend:n}),u=eS({inputs:{x:o},backend:n}),l=Yi({inputs:{real:a,imag:u},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}else return rL({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}var z9e={kernelName:E0,backendName:"cpu",kernelFunc:eS};function nQ(r){let{inputs:t,backend:n}=r,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){let i=Cd({inputs:{input:s},backend:n}),a=nQ({inputs:{x:i},backend:n}),o=rg({inputs:{input:s},backend:n}),u=eS({inputs:{x:o},backend:n}),l=Yi({inputs:{real:a,imag:u},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}else return rL({backend:n,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}var U9e={kernelName:o0,backendName:"cpu",kernelFunc:nQ};function sQ(r){let{inputs:t,backend:n,attrs:s}=r,{axis:i}=s;if(t.length===1)return Q2({inputs:{input:t[0]},backend:n,attrs:{dim:i}});let a=t[0].shape,o=t[0].dtype;t.forEach(h=>{O.assertShapesMatch(a,h.shape,"All tensors passed to stack must have matching shapes"),O.assert(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});let u=[],l=t.map(h=>{let d=Q2({inputs:{input:h},backend:n,attrs:{dim:i}});return u.push(d),d}),c=ng({inputs:l,backend:n,attrs:{axis:i}});return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}var W9e={kernelName:u0,backendName:"cpu",kernelFunc:sQ};function G9e(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{paddings:a,constantValue:o}=s;Dt(i,"pad");let u=a.map((b,x)=>b[0]+i.shape[x]+b[1]),l=a.map(b=>b[0]),c=n.data.get(i.dataId).values,h=O.sizeFromShape(i.shape),d=i.shape.length,p=O.computeStrides(i.shape),f=O.sizeFromShape(u),m=u.length,g=O.computeStrides(u),y=O.getTypedArrayFromDType(i.dtype,f);o!==0&&y.fill(o);for(let b=0;b<h;b++){let x=O.indexToLoc(b,d,p).map((v,S)=>v+l[S]),w=O.locToIndex(x,m,g);y[w]=c[b]}return{dataId:n.write(y,u,i.dtype),shape:u,dtype:i.dtype}}var iQ={kernelName:Pp,backendName:"cpu",kernelFunc:G9e},H9e=Hn((r,t)=>Math.pow(r,t)),j9e=cs(Bp,H9e),q9e={kernelName:Bp,backendName:"cpu",kernelFunc:j9e};function K9e(r){let{inputs:t,backend:n,attrs:s}=r,{paramsNestedSplits:i,paramsDenseValues:a,indices:o}=t,{outputRaggedRank:u}=s,l=i.map(b=>n.data.get(b.dataId).values),c=i.map(b=>b.shape),h=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,[p,f,m]=AJ(l,c,h,a.shape,a.dtype,d,o.shape),g=p.map(b=>n.makeTensorInfo([b.length],"int32",b)),y=n.makeTensorInfo(m,a.dtype,f);return g.concat([y])}var X9e={kernelName:OC,backendName:"cpu",kernelFunc:K9e};function Y9e(r){let{inputs:t,backend:n}=r,{starts:s,limits:i,deltas:a}=t,o=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values,l=n.data.get(a.dataId).values,[c,h]=DJ(o,s.shape,s.dtype,u,i.shape,l,a.shape),d=n.makeTensorInfo([c.length],"int32",c),p=n.makeTensorInfo([h.length],s.dtype,h);return[d,p]}var Z9e={kernelName:MC,backendName:"cpu",kernelFunc:Y9e};function J9e(r){let{inputs:t,backend:n,attrs:s}=r,{shape:i,values:a,defaultValue:o,rowPartitionTensors:u}=t,{rowPartitionTypes:l}=s,c=n.data.get(i.dataId).values,h=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,p=u.map(y=>n.data.get(y.dataId).values),f=u.map(y=>y.shape),[m,g]=FJ(c,i.shape,h,a.shape,a.dtype,d,o.shape,p,f,l);return n.makeTensorInfo(m,a.dtype,g)}var Q9e={kernelName:LC,backendName:"cpu",kernelFunc:J9e};function e7e(r){let{backend:t,attrs:n}=r,{start:s,stop:i,dtype:a,step:o}=n,u=qM(s,i,o,a);return t.makeTensorInfo([u.length],a,u)}var t7e={kernelName:jx,backendName:"cpu",kernelFunc:e7e},r7e=Qr(Up,r=>1/r),n7e={kernelName:Up,backendName:"cpu",kernelFunc:r7e};function s7e(r){let{inputs:t,backend:n,attrs:s}=r,{images:i}=t,{alignCorners:a,halfPixelCenters:o,size:u}=s;Dt(i,"resizeBilinear");let l=O.computeStrides(i.shape),[c,h]=u,[d,p,f,m]=i.shape,g=n.data.get(i.dataId).values,y=new Float32Array(O.sizeFromShape([d,c,h,m])),b=[a&&c>1?p-1:p,a&&h>1?f-1:f],x=[a&&c>1?c-1:c,a&&h>1?h-1:h],w=0,v=b[0]/x[0],S=b[1]/x[1];for(let E=0;E<d;E++)for(let C=0;C<c;C++){let I;o?I=v*(C+.5)-.5:I=v*C;let _=Math.max(0,Math.floor(I)),A=I-_,k=Math.min(p-1,Math.ceil(I)),N=E*l[0]+_*l[1],D=E*l[0]+k*l[1];for(let F=0;F<h;F++){let P;o?P=S*(F+.5)-.5:P=S*F;let G=Math.max(0,Math.floor(P)),Y=P-G,Z=Math.min(f-1,Math.ceil(P)),ee=N+G*l[2],se=D+G*l[2],re=N+Z*l[2],J=D+Z*l[2];for(let le=0;le<m;le++){let he=g[ee+le],xe=g[se+le],Fe=g[re+le],Le=g[J+le],Ve=he+(Fe-he)*Y,$e=xe+(Le-xe)*Y,Ae=Ve+($e-Ve)*A;y[w++]=Ae}}}return n.makeTensorInfo([d,c,h,m],"float32",y)}var i7e={kernelName:Hp,backendName:"cpu",kernelFunc:s7e};function a7e(r){let{inputs:t,backend:n,attrs:s}=r,{images:i,dy:a}=t,{alignCorners:o}=s;Dt([a,i],"resizeBilinearGrad");let u=O.computeStrides(i.shape),[l,c,h,d]=i.shape,[,p,f]=a.shape,m=new Float32Array(l*c*h*d),g=[o&&p>1?c-1:c,o&&f>1?h-1:h],y=[o&&p>1?p-1:p,o&&f>1?f-1:f],b=g[0]/y[0],x=g[1]/y[1],w=n.data.get(a.dataId).values,v=0;for(let S=0;S<l;S++){let E=S*u[0];for(let C=0;C<p;C++){let I=C*b,_=Math.floor(I),A=Math.min(Math.ceil(I),c-1),k=E+_*u[1],N=E+A*u[1],D=I-_,F=1-D;for(let P=0;P<f;P++){let G=P*x,Y=Math.floor(G),Z=Math.min(Math.ceil(G),h-1),ee=G-Y,se=1-ee,re=k+Y*u[2],J=k+Z*u[2],le=N+Y*u[2],he=N+Z*u[2],xe=F*se,Fe=F*ee,Le=D*se,Ve=D*ee;for(let $e=0;$e<d;$e++){let Ae=w[v++];m[re+$e]+=Ae*xe,m[J+$e]+=Ae*Fe,m[le+$e]+=Ae*Le,m[he+$e]+=Ae*Ve}}}}return n.makeTensorInfo([l,h,c,d],"float32",m)}var o7e={kernelName:h0,backendName:"cpu",kernelFunc:a7e};function u7e(r){let{inputs:t,backend:n,attrs:s}=r,{images:i}=t,{alignCorners:a,halfPixelCenters:o,size:u}=s;Dt(i,"resizeNearestNeighbor");let l=O.computeStrides(i.shape),[c,h]=u,[d,p,f,m]=i.shape,g=n.data.get(i.dataId).values,y=new Float32Array(d*c*h*m),b=[a&&c>1?p-1:p,a&&h>1?f-1:f],x=[a&&c>1?c-1:c,a&&h>1?h-1:h],w=b[0]/x[0],v=b[1]/x[1],S=0;for(let E=0;E<d;E++){let C=E*l[0];for(let I=0;I<c;I++){let _=o?w*(I+.5):w*I,A=Math.min(p-1,a?Math.round(_):Math.floor(_));o&&(A=Math.max(0,A));let k=C+A*l[1];for(let N=0;N<h;N++){let D=o?v*(N+.5):v*N,F=Math.min(f-1,a?Math.round(D):Math.floor(D));o&&(F=Math.max(0,F));let P=k+F*l[2];for(let G=0;G<m;G++){let Y=g[P+G];y[S++]=Y}}}}return n.makeTensorInfo([d,c,h,m],i.dtype,y)}var l7e={kernelName:Gp,backendName:"cpu",kernelFunc:u7e};function c7e(r){let{inputs:t,backend:n,attrs:s}=r,{images:i,dy:a}=t,{alignCorners:o}=s;Dt([a,i],"resizeNearestNeighborGrad");let u=O.computeStrides(i.shape),l=O.computeStrides(a.shape),[c,h,d,p]=i.shape,[,f,m]=a.shape,g=new Float32Array(c*h*d*p),y=n.data.get(a.dataId).values,b=[o&&f>1?h-1:h,o&&m>1?d-1:d],x=[o&&f>1?f-1:f,o&&m>1?m-1:m],w=b[0]/x[0],v=b[1]/x[1],S=1/w,E=1/v,C=Math.ceil(S)*2+2,I=Math.ceil(E)*2+2;for(let _=0;_<c;_++){let A=_*u[0];for(let k=0;k<h;k++){let N=A+k*u[1],D=Math.floor(k*S),F=Math.floor(D-C/2);for(let P=0;P<d;P++){let G=N+P*u[2],Y=Math.floor(P*E),Z=Math.floor(Y-I/2);for(let ee=0;ee<p;ee++){let se=0;for(let re=0;re<C;re++){let J=re+F;if(J<0||J>=f)continue;let le=A+J*l[1],he=J*w,xe=Math.min(h-1,o?Math.round(he):Math.floor(he));if(k===xe)for(let Fe=0;Fe<I;Fe++){let Le=Fe+Z;if(Le<0||Le>=m)continue;let Ve=le+Le*l[2],$e=Le*v,Ae=Math.min(d-1,o?Math.round($e):Math.floor($e));P===Ae&&(se+=y[Ve+ee])}}g[G+ee]=se}}}}return n.makeTensorInfo(i.shape,i.dtype,g)}var h7e={kernelName:c0,backendName:"cpu",kernelFunc:c7e};function d7e(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{dims:a}=s;Dt(i,"reverse");let o=i.shape.length,u=O.parseAxisParam(a,i.shape);if(o===0)return xu({inputs:{x:i},backend:n});let l=new Xn(i.shape,i.dtype),c=n.bufferSync(i);for(let h=0;h<l.size;h++){let d=l.indexToLoc(h),p=d.slice();u.forEach(f=>p[f]=i.shape[f]-1-p[f]),l.set(c.get(...p),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var p7e={kernelName:qp,backendName:"cpu",kernelFunc:d7e},f7e={kernelName:I0,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:n})=>{let{image:s}=r,{radians:i,fillValue:a,center:o}=t,u=n,l=O.getTypedArrayFromDType(s.dtype,O.sizeFromShape(s.shape)),[c,h,d,p]=s.shape,[f,m]=q.getImageCenter(o,h,d),g=255,y=Math.sin(i),b=Math.cos(i),x=u.data.get(s.dataId).values;for(let w=0;w<c;w++){let v=w*d*h*p;for(let S=0;S<h;S++){let E=S*(d*p);for(let C=0;C<d;C++){let I=C*p;for(let _=0;_<p;_++){let A=[c,S,C,_],k=A[2],N=A[1],D=(k-f)*b-(N-m)*y,F=(k-f)*y+(N-m)*b;D=Math.round(D+f),F=Math.round(F+m);let P=a;if(typeof a!="number"&&(_===3?P=g:P=a[_]),D>=0&&D<d&&F>=0&&F<h){let Y=F*(d*p),Z=D*p,ee=v+Y+Z+_;P=x[ee]}let G=v+E+I+_;l[G]=P}}}}return{dataId:u.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},m7e=Qr(Kp,r=>{let t=Math.floor(r);return r-t<.5?Math.floor(r):r-t>.5?Math.ceil(r):t%2===0?t:t+1}),g7e={kernelName:Kp,backendName:"cpu",kernelFunc:m7e};function y7e(r){let{inputs:t,backend:n,attrs:s}=r,{indices:i,updates:a}=t,{shape:o}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=q.calculateShapes(a,i,o),p=!0,f=n.bufferSync(i),m=n.bufferSync(a),g=Dh(f,m,o,d,c,l,u,h,0,p);return n.makeTensorInfo(o,g.dtype,g.values)}var b7e={kernelName:d0,backendName:"cpu",kernelFunc:y7e};function x7e(r,t){let n=0,s=r.length,i=0;for(;n<s;)i=Math.floor((n+s)/2),r[i]<t?n=i+1:s=i;return s}function v7e(r,t){let n=0,s=r.length,i=0;for(;n<s;)i=Math.floor((n+s)/2),r[i]<=t?n=i+1:s=i;return s}function w7e(r,t,n,s,i,a){let o=O.getArrayFromDType("int32",n*i);for(let u=0;u<n;++u){let l=r.slice(u*s,(u+1)*s),c=u*i;for(let h=0;h<i;++h)o[c+h]=a==="left"?x7e(l,t[h+c]):v7e(l,t[h+c])}return o}function S7e(r){let{inputs:t,backend:n,attrs:s}=r,{sortedSequence:i,values:a}=t,{side:o}=s,u=n.data.get(i.dataId).values,l=n.data.get(a.dataId).values,c=w7e(u,l,i.shape[0],i.shape[1],a.shape[1],o);return n.makeTensorInfo(a.shape,"int32",c)}var C7e={kernelName:f0,backendName:"cpu",kernelFunc:S7e};function _7e(r){let{inputs:t,backend:n}=r,{condition:s,t:i,e:a}=t;Dt([s,i,a],"select");let o=s.shape.length,u=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values,h=va(i.dtype,a.dtype),d=O.makeZerosTypedArray(O.sizeFromShape(i.shape),h),p=0,f=o===0||o>1||i.shape.length===1?1:O.sizeFromShape(i.shape.slice(1));for(let m=0;m<u.length;m++)for(let g=0;g<f;g++)u[m]===1?d[p++]=l[m]:d[p++]=c[m];return n.makeTensorInfo(i.shape,h,d)}var E7e={kernelName:m0,backendName:"cpu",kernelFunc:_7e},I7e=q.SELU_SCALEALPHA,k7e=q.SELU_SCALE,N7e=Qr(Yp,r=>r>=0?k7e*r:I7e*(Math.exp(r)-1)),T7e={kernelName:Yp,backendName:"cpu",kernelFunc:N7e},A7e=Qr(Qp,r=>r<0?-1:r>0?1:0),D7e={kernelName:Qp,backendName:"cpu",kernelFunc:A7e},F7e=Qr(Zp,r=>Math.sin(r)),$7e={kernelName:Zp,backendName:"cpu",kernelFunc:F7e},R7e=Qr(Jp,r=>Math.sinh(r)),O7e={kernelName:Jp,backendName:"cpu",kernelFunc:R7e},M7e=11920928955078125e-23,OV=Math.log(M7e)+2,L7e=Qr(tf,r=>{let t=r>-OV,n=r<OV,s=Math.exp(r),i;return n?i=s:t?i=r:i=Math.log(1+s),i}),P7e={kernelName:tf,backendName:"cpu",kernelFunc:L7e};function B7e(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{blockShape:a,paddings:o}=s;Dt([i],"spaceToBatchND");let u=O.sizeFromShape(a),l=[[0,0]];l.push(...o);for(let y=1+a.length;y<i.shape.length;++y)l.push([0,0]);let c=iQ.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),h=q.getReshaped(c.shape,a,u,!1),d=q.getPermuted(h.length,a.length,!1),p=q.getReshapedPermuted(c.shape,a,u,!1),f=vn({inputs:{x:c},backend:n,attrs:{shape:h}}),m=Ai({inputs:{x:f},backend:n,attrs:{perm:d}}),g=vn({inputs:{x:m},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var V7e={kernelName:y0,backendName:"cpu",kernelFunc:B7e};function z7e(r){let{inputs:t,backend:n}=r,{indices:s,values:i,denseShape:a,defaultValue:o}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);let u=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values,h=n.data.get(o.dataId).values[0],[d,p,f,m,g]=OJ(u,s.shape,s.dtype,l,i.dtype,c,h);return[n.makeTensorInfo(p,s.dtype,d),n.makeTensorInfo([p[0]],i.dtype,f),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(y=>Number(y)))),n.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}var U7e={kernelName:qx,backendName:"cpu",kernelFunc:z7e};function W7e(r){let{inputs:t,backend:n}=r,{inputIndices:s,inputShape:i,newShape:a}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let o=Array.from(n.data.get(i.dataId).values),u=n.data.get(s.dataId).values,l=Array.from(n.data.get(a.dataId).values),[c,h,d]=MJ(u,s.shape,s.dtype,o,l);return[n.makeTensorInfo(h,s.dtype,c),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var G7e={kernelName:x0,backendName:"cpu",kernelFunc:W7e};function H7e(r){let{inputs:t,backend:n}=r,{data:s,indices:i,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(i.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let o=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values,l=n.data.get(a.dataId).values,[c,h]=KM(o,s.shape,s.dtype,u,l,!0);return n.makeTensorInfo(h,s.dtype,c)}var j7e={kernelName:Kx,backendName:"cpu",kernelFunc:H7e};function q7e(r){let{inputs:t,backend:n}=r,{data:s,indices:i,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(i.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let o=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values,l=n.data.get(a.dataId).values,[c,h]=KM(o,s.shape,s.dtype,u,l);return n.makeTensorInfo(h,s.dtype,c)}var K7e={kernelName:Xx,backendName:"cpu",kernelFunc:q7e};function X7e(r){let{inputs:t,backend:n,attrs:s}=r,{sparseIndices:i,sparseValues:a,defaultValue:o}=t,{outputShape:u}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=q.calculateShapes(a,i,u),f=!1,m=n.bufferSync(i),g;switch(a.dtype){case"bool":{let y=n.bufferSync(a),b=!!n.data.get(o.dataId).values[0];g=Dh(m,y,u,p,h,c,l,d,b,f);break}case"float32":{let y=n.bufferSync(a),b=n.data.get(o.dataId).values[0];g=Dh(m,y,u,p,h,c,l,d,b,f);break}case"int32":{let y=n.bufferSync(a),b=n.data.get(o.dataId).values[0];g=Dh(m,y,u,p,h,c,l,d,b,f);break}case"string":{let y=n.bufferSync(a),b=O.decodeString(n.data.get(o.dataId).values[0]);g=Dh(m,y,u,p,h,c,l,d,b,f);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(u,g.dtype,g.values)}var Y7e={kernelName:v0,backendName:"cpu",kernelFunc:X7e};function Z7e(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{numOrSizeSplits:a,axis:o}=s,u=O.parseAxisParam(o,i.shape)[0],l=q.prepareSplitSize(i,a,u),c=new Array(i.shape.length).fill(0),h=i.shape.slice();return l.map(d=>{let p=[...h];p[u]=d;let f=_d({inputs:{x:i},backend:n,attrs:{begin:c,size:p}});return c[u]+=d,f})}var J7e={kernelName:b0,backendName:"cpu",kernelFunc:Z7e},Q7e={kernelName:Yx,backendName:"cpu",kernelFunc:({inputs:r,backend:t})=>{let{x:n}=r,s=t;Dt(n,"square");let i=s.data.get(n.dataId).values,a=new Float32Array(i.length);for(let o=0;o<i.length;++o){let u=i[o];a[o]=u*u}return{dataId:s.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},eqe=Qr(Bc,(r,t)=>{let n=t;return isNaN(r)?NaN:r>0?1:n.alpha}),tqe={kernelName:Bc,backendName:"cpu",kernelFunc:eqe};function rqe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{begin:a,end:o,strides:u,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=s;Dt(i,"stridedSlice");let{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:x,end:w,strides:v}=is.sliceInfo(i.shape,a,o,u,l,c,h,d,p),S;if(g)S=vn({inputs:{x:i},backend:n,attrs:{shape:m}});else if(y||b){O.assert(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);let E=is.computeOutShape(x,w,v),C=_d({inputs:{x:i},backend:n,attrs:{begin:x,size:E}});S=vn({inputs:{x:C},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(C)}else{let E=n.bufferSync(i),C=BJ(f,E,v,x);S=n.makeTensorInfo(m,C.dtype,C.values)}return S}var nqe={kernelName:w0,backendName:"cpu",kernelFunc:rqe};function sqe(r){let{inputs:t,backend:n,attrs:s}=r,{separator:i,nGramWidths:a,leftPad:o,rightPad:u,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:d}=t,p=n.data.get(h.dataId).values,f=n.data.get(d.dataId).values,[m,g]=XM(p,f,i,a,o,u,l,c);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(d.shape,"int32",g)]}var iqe={kernelName:Jx,backendName:"cpu",kernelFunc:sqe};function aqe(r){let{inputs:t,backend:n,attrs:s}=r,{skipEmpty:i}=s,{input:a,delimiter:o}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);let u=n.data.get(a.dataId).values,l=n.data.get(o.dataId).values[0],[c,h,d]=YM(u,l,i),p=h.length;return[n.makeTensorInfo([p,2],"int32",c),n.makeTensorInfo([p],"string",h),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var oqe={kernelName:Qx,backendName:"cpu",kernelFunc:aqe};function uqe(r){let{inputs:t,backend:n,attrs:s}=r,{numBuckets:i}=s,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");let o=n.data.get(a.dataId).values,u=ZM(o,i);return n.makeTensorInfo(a.shape,"int32",u)}var lqe={kernelName:ev,backendName:"cpu",kernelFunc:uqe},cqe=Qr(uf,r=>Math.tan(r)),hqe={kernelName:uf,backendName:"cpu",kernelFunc:cqe},dqe=Qr(lf,r=>Math.tanh(r)),pqe={kernelName:lf,backendName:"cpu",kernelFunc:dqe};function fqe(r){let{inputs:t,backend:n}=r,{tensor:s,indices:i,updates:a}=t,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=q.calculateShapes(a,i,s.shape),d=!1,p=n.bufferSync(i),f=n.bufferSync(a),m=n.bufferSync(s),g=Dh(p,f,s.shape,h,l,u,o,c,m,d);return n.makeTensorInfo(s.shape,g.dtype,g.values)}var mqe={kernelName:p0,backendName:"cpu",kernelFunc:fqe};function gqe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{reps:a}=s;Dt(i,"tile");let o=zJ(n.bufferSync(i),a);return n.makeTensorInfo(o.shape,o.dtype,o.values)}var yqe={kernelName:Pc,backendName:"cpu",kernelFunc:gqe};function bqe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{k:a,sorted:o}=s;Dt(i,"topk");let u=n.data.get(i.dataId).values,[l,c]=WJ(u,i.shape,i.dtype,a,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}var xqe={kernelName:S0,backendName:"cpu",kernelFunc:bqe};function vqe(r){let{inputs:t,attrs:n,backend:s}=r,{image:i,transforms:a}=t,{interpolation:o,fillMode:u,fillValue:l,outputShape:c}=n,[h,d,p,f]=i.shape,[m,g]=c??[d,p],y=[h,m,g,f],b=O.computeStrides(i.shape),x=b[0],w=b[1],v=b[2],S=O.computeStrides(y),E=S[0],C=S[1],I=S[2],_=O.getTypedArrayFromDType(i.dtype,O.sizeFromShape(y));_.fill(l);let A=s.data.get(i.dataId).values,k=s.data.get(a.dataId).values;for(let N=0;N<h;++N){let D=a.shape[0]===1?k:k.subarray(N*8,N*8+8);for(let F=0;F<m;++F)for(let P=0;P<g;++P)for(let G=0;G<f;++G){let Y,Z=D[6]*P+D[7]*F+1;if(Z===0)continue;let ee=(D[0]*P+D[1]*F+D[2])/Z,se=(D[3]*P+D[4]*F+D[5])/Z,re=MV(ee,p,u),J=MV(se,d,u);switch(o){case"nearest":Y=Iqe(A,d,p,x,w,v,N,J,re,G,l);break;case"bilinear":Y=kqe(A,d,p,x,w,v,N,J,re,G,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}let le=N*E+F*C+P*I+G;_[le]=Y}return s.makeTensorInfo(y,i.dtype,_)}return{dataId:s.write(_,y,i.dtype),shape:i.shape,dtype:i.dtype}}var wqe={kernelName:C0,backendName:"cpu",kernelFunc:vqe};function MV(r,t,n){switch(n){case"reflect":return Sqe(r,t);case"wrap":return Cqe(r,t);case"nearest":return Eqe(r,t);case"constant":default:return _qe(r)}}function Sqe(r,t){let n=r;if(n<0)if(t<=1)n=0;else{let s=2*t;n<s&&(n=s*Math.trunc(-n/s)+n),n=n<-t?n+s:-n-1}else if(n>t-1)if(t<=1)n=0;else{let s=2*t;n-=s*Math.trunc(n/s),n>=t&&(n=s-n-1)}return O.clamp(0,n,t-1)}function Cqe(r,t){let n=r;if(n<0)if(t<=1)n=0;else{let s=t-1;n+=t*(Math.trunc(-n/s)+1)}else if(n>t-1)if(t<=1)n=0;else{let s=t-1;n-=t*Math.trunc(n/s)}return O.clamp(0,n,t-1)}function _qe(r,t){return r}function Eqe(r,t){return O.clamp(0,r,t-1)}function Ry(r,t,n,s,i,a,o,u,l,c,h){let d=o*s+u*i+l*a+c;return 0<=u&&u<t&&0<=l&&l<n?r[d]:h}function Iqe(r,t,n,s,i,a,o,u,l,c,h){let d=Math.round(u),p=Math.round(l);return Ry(r,t,n,s,i,a,o,d,p,c,h)}function kqe(r,t,n,s,i,a,o,u,l,c,h){let d=Math.floor(u),p=Math.floor(l),f=d+1,m=p+1,g=(m-l)*Ry(r,t,n,s,i,a,o,d,p,c,h)+(l-p)*Ry(r,t,n,s,i,a,o,d,m,c,h),y=(m-l)*Ry(r,t,n,s,i,a,o,f,p,c,h)+(l-p)*Ry(r,t,n,s,i,a,o,f,m,c,h);return(f-u)*g+(u-d)*y}function Nqe(r){let{inputs:t,attrs:n,backend:s}=r,{axis:i}=n,{x:a}=t;Dt(a,"unique");let o=s.data.get(a.dataId).values,{outputValues:u,outputShape:l,indices:c}=QM(o,i,a.shape,a.dtype);return[s.makeTensorInfo(l,a.dtype,u),s.makeTensorInfo([c.length],"int32",c)]}var Tqe={kernelName:tv,backendName:"cpu",kernelFunc:Nqe};function Aqe(r){let{inputs:t,backend:n,attrs:s}=r,{value:i}=t,{axis:a}=s;a<0&&(a+=i.shape.length);let o=i.shape.length,u=i.shape[a],l=new Array(o-1),c=0;for(let f=0;f<o;f++)f!==a&&(l[c++]=i.shape[f]);let h=new Array(o).fill(0),d=i.shape.slice();d[a]=1;let p=new Array(u);for(let f=0;f<p.length;f++){h[a]=f;let m=_d({inputs:{x:i},backend:n,attrs:{begin:h,size:d}});p[f]=vn({inputs:{x:m},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(m)}return p}var Dqe={kernelName:_0,backendName:"cpu",kernelFunc:Aqe};function Fqe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,segmentIds:a}=t,{numSegments:o}=s;Dt(i,"unsortedSegmentSum");let u=i.shape.length,l=a.shape.length,c=[],h=[],d=u-l,p=a;for(let m=0;m<d;++m){let g=Q2({inputs:{input:p},backend:n,attrs:{dim:m+1}});p=g,h.push(g)}for(let m=0;m<o;++m){let g=O.createScalarValue(m,"int32"),y=n.makeTensorInfo([],"int32",g),b=cJ({inputs:{a:y,b:p},backend:n}),x=kc({inputs:{x:b},backend:n,attrs:{dtype:"float32"}}),w=G_({inputs:{a:x,b:i},backend:n}),v=Dv({inputs:{x:w},backend:n,attrs:{axis:0,keepDims:!1}});c.push(v),h.push(y),h.push(b),h.push(x),h.push(w),h.push(v)}let f=sQ({inputs:c,backend:n,attrs:{axis:0}});return h.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var $qe={kernelName:rv,backendName:"cpu",kernelFunc:Fqe},Rqe=[kGe,a8e,TGe,DGe,d8e,$Ge,OGe,LGe,BGe,zGe,WGe,HGe,qGe,YGe,JGe,tHe,nHe,iHe,oHe,EGe,lHe,hHe,pHe,f8e,mHe,c8e,g8e,yHe,o8e,xHe,wHe,SHe,_He,IHe,NHe,AHe,FHe,RHe,MHe,PHe,VHe,UHe,GHe,jHe,qHe,XHe,ZHe,QHe,eje,tje,rje,sje,oje,bGe,lje,y8e,yje,b8e,bje,v8e,_je,Eje,kje,S8e,_8e,Tje,Dje,$je,Oje,I8e,N8e,u8e,Lje,vHe,Bje,zje,Wje,xGe,A8e,F8e,Hje,R8e,qje,Yje,Jje,t9e,n9e,i9e,a9e,M8e,u9e,c9e,d9e,f9e,g9e,b9e,v9e,P8e,S9e,E9e,T9e,V8e,U8e,F9e,O9e,P9e,G8e,V9e,U9e,W9e,iQ,q9e,wGe,q8e,X9e,Z9e,Q9e,t7e,l8e,kN,n7e,SGe,CGe,_Ge,i7e,o7e,l7e,h7e,p7e,f7e,g7e,rGe,b7e,C7e,E7e,T7e,sGe,D7e,$7e,O7e,iGe,k9e,P7e,V7e,U7e,G7e,j7e,K7e,Y7e,J7e,uGe,Q7e,cGe,dGe,tqe,nqe,iqe,oqe,lqe,gGe,ije,hqe,pqe,mqe,yqe,xqe,wqe,H8e,Tqe,Dqe,$qe,z9e];for(let r of Rqe)nv(r);var aQ={};ir(aQ,{assertNotComplex:()=>B0,bindCanvasToFramebuffer:()=>Hqe,bindColorTextureToFramebuffer:()=>Nw,bindTextureToProgramUniformSampler:()=>SQ,bindTextureUnit:()=>xQ,bindVertexBufferToProgramAttribute:()=>TN,callAndCheck:()=>bt,canBeRepresented:()=>uQ,createFragmentShader:()=>hQ,createFramebuffer:()=>bQ,createProgram:()=>dQ,createStaticIndexBuffer:()=>mQ,createStaticVertexBuffer:()=>fQ,createTexture:()=>gQ,createVertexShader:()=>cQ,getBatchDim:()=>Ed,getExtensionOrThrow:()=>Oy,getFramebufferErrorMessage:()=>CQ,getMaxTexturesInShader:()=>kQ,getNumChannels:()=>Wqe,getProgramUniformLocation:()=>wQ,getProgramUniformLocationOrThrow:()=>vQ,getRowsCols:()=>Id,getShapeAs3D:()=>Ly,getTextureShapeFromLogicalShape:()=>EQ,getWebGLDisjointQueryTimerVersion:()=>NQ,getWebGLErrorMessage:()=>lQ,getWebGLMaxTextureSize:()=>IQ,hasExtension:()=>ma,isCapableOfRenderingToFloatTexture:()=>TQ,isDownloadFloatTextureEnabled:()=>AQ,isReshapeFree:()=>nx,isWebGLFenceEnabled:()=>DQ,isWebGLVersionEnabled:()=>DN,linkProgram:()=>pQ,logShaderSourceAndInfoLog:()=>sL,resetMaxTextureSize:()=>jqe,resetMaxTexturesInShader:()=>qqe,unbindColorTextureFromFramebuffer:()=>AN,unbindTextureUnit:()=>Gqe,validateFramebuffer:()=>My,validateProgram:()=>kw,validateTextureSize:()=>yQ});var Ih={},B1={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function oQ(r,t){Ih[r]=t}function Lo(r,t){if(!(r in Ih)||t!=null){let s=Mqe(r,t);if(s!==null)Ih[r]=s;else return console.log("Could not get context for WebGL version",r),null}let n=Ih[r];return n==null||n.isContextLost()?(delete Ih[r],Lo(r)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Ih[r])}function Oqe(r){if(!Re().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&r===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Mqe(r,t){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??Oqe(r);return n.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Ih[r]},!1),Re().getBool("SOFTWARE_WEBGL_ENABLED")&&(B1.failIfMajorPerformanceCaveat=!1),r===1?n.getContext("webgl",B1)||n.getContext("experimental-webgl",B1):n.getContext("webgl2",B1)}var rx;(function(r){r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH"})(rx||(rx={}));var fa;(function(r){r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD"})(fa||(fa={}));var Ds;(function(r){r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Ds||(Ds={}));function Fv(r,t){return[t,r]}function Lqe(r,t){return r*t}function V1(r){let t=O.sizeFromShape(r),n=Math.ceil(t/4);return O.sizeToSquarishShape(n)}function P0(r,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(r/2))]}function Pqe(r,t){let[n,s]=P0(r,t);return n*s*4}function nL(r,t){let n=r,s,i,a,o,u,l,c,h,d,p;return Re().getNumber("WEBGL_VERSION")===2?(s=n.R32F,i=n.R16F,a=n.RGBA16F,o=n.RGBA32F,u=n.RED,c=4,h=1,d=n.HALF_FLOAT,p=n.FLOAT,l=n.RGBA8):(s=r.RGBA,i=r.RGBA,a=r.RGBA,o=n.RGBA,u=r.RGBA,c=4,h=4,d=t!=null?t.HALF_FLOAT_OES:null,p=r.FLOAT,l=r.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:o,textureFormatFloat:u,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:h,textureTypeHalfFloat:d,textureTypeFloat:p}}function bt(r,t){let n=t();return Re().getBool("DEBUG")&&Bqe(r),n}function Bqe(r){let t=r.getError();if(t!==r.NO_ERROR)throw new Error("WebGL Error: "+lQ(r,t))}var Vqe=596e-10,zqe=65504;function uQ(r){return!!(Re().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||Vqe<Math.abs(r)&&Math.abs(r)<zqe)}function lQ(r,t){switch(t){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Oy(r,t){return Il(r,()=>r.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function cQ(r,t){let n=Il(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(bt(r,()=>r.shaderSource(n,t)),bt(r,()=>r.compileShader(n)),r.getShaderParameter(n,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function hQ(r,t){let n=Il(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(bt(r,()=>r.shaderSource(n,t)),bt(r,()=>r.compileShader(n)),Re().get("ENGINE_COMPILE_ONLY"))return n;if(r.getShaderParameter(n,r.COMPILE_STATUS)===!1)throw sL(t,r.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var Uqe=/ERROR: [0-9]+:([0-9]+):/g;function sL(r,t){let n=Uqe.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(r);return}let s=+n[1],i=r.split(`
`),a=i.length.toString().length+2,o=i.map((d,p)=>O.rightPad((p+1).toString(),a)+d),u=0;for(let d=0;d<o.length;d++)u=Math.max(o[d].length,u);let l=o.slice(0,s-1),c=o.slice(s-1,s),h=o.slice(s);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${O.rightPad(c[0],u)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function dQ(r){return Il(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function pQ(r,t){if(bt(r,()=>r.linkProgram(t)),!Re().get("ENGINE_COMPILE_ONLY")&&r.getProgramParameter(t,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function kw(r,t){if(bt(r,()=>r.validateProgram(t)),r.getProgramParameter(t,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function fQ(r,t){let n=Il(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return bt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),bt(r,()=>r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW)),n}function mQ(r,t){let n=Il(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return bt(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,n)),bt(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW)),n}function Wqe(){return Re().getNumber("WEBGL_VERSION")===2?1:4}function gQ(r){return Il(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function yQ(r,t){let n=Re().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||t<=0){let s=`[${r}x${t}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(r>n||t>n){let s=`[${r}x${t}]`,i=`[${n}x${n}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+i+".")}}function bQ(r){return Il(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function TN(r,t,n,s,i,a,o){let u=r.getAttribLocation(t,n);return u===-1?!1:(bt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,s)),bt(r,()=>r.vertexAttribPointer(u,i,r.FLOAT,!1,a,o)),bt(r,()=>r.enableVertexAttribArray(u)),!0)}function xQ(r,t,n){_Q(r,n),bt(r,()=>r.activeTexture(r.TEXTURE0+n)),bt(r,()=>r.bindTexture(r.TEXTURE_2D,t))}function Gqe(r,t){_Q(r,t),bt(r,()=>r.activeTexture(r.TEXTURE0+t)),bt(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function vQ(r,t,n){return Il(r,()=>r.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function wQ(r,t,n){return r.getUniformLocation(t,n)}function SQ(r,t,n,s){bt(r,()=>xQ(r,t,s)),bt(r,()=>r.uniform1i(n,s))}function Hqe(r){bt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),bt(r,()=>r.viewport(0,0,r.canvas.width,r.canvas.height)),bt(r,()=>r.scissor(0,0,r.canvas.width,r.canvas.height))}function Nw(r,t,n){bt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,n)),bt(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0))}function AN(r,t){bt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),bt(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function My(r){let t=r.checkFramebufferStatus(r.FRAMEBUFFER);if(t!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+CQ(r,t))}function CQ(r,t){switch(t){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Il(r,t,n){let s=bt(r,()=>t());if(s==null)throw new Error(n);return s}function _Q(r,t){let n=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+r.TEXTURE0;if(s<r.TEXTURE0||s>n){let i=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${i}.`)}}function Ed(r,t=2){return O.sizeFromShape(r.slice(0,r.length-t))}function Id(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function Ly(r){let t=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(t=[Ed(r),...Id(r)]),t}function EQ(r,t=!1){let n=Re().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=Re().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&Re().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=n/2),t&&(n=n*2,s=s*2,r=r.map((u,l)=>l>=r.length-2?O.nearestLargerEven(r[l]):r[l]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=O.squeezeShape(r).newShape);let i=O.sizeFromShape(r),a=null;r.length<=1&&i<=n?a=[1,i]:r.length===2&&r[0]<=n&&r[1]<=n?a=r:r.length===3&&r[0]*r[1]<=n&&r[2]<=n?a=[r[0]*r[1],r[2]]:r.length===3&&r[0]<=n&&r[1]*r[2]<=n?a=[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=n&&r[3]<=n?a=[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=n&&r[1]*r[2]*r[3]<=n&&(a=[r[0],r[1]*r[2]*r[3]]);let o=a!=null&&Math.max(...a)>s&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(a==null||o)if(t){let u=Ed(r),l=2,c=2;r.length&&([l,c]=Id(r)),i=u*(l/2)*(c/2),a=O.sizeToSquarishShape(i).map(h=>h*2)}else a=O.sizeToSquarishShape(i);return a}function z1(r){return r%2===0}function nx(r,t){if(r=r.slice(-2),t=t.slice(-2),O.arraysEqual(r,t)||!r.length||!t.length||r[0]===0||r[1]===0||t[0]===0||t[1]===0)return!0;if(r.length!==t.length){let n=r[r.length-1],s=t[t.length-1];if(n===s||z1(n)&&z1(s)&&(r[0]===1||t[0]===1))return!0}return r[1]===t[1]&&z1(r[0])&&z1(t[0])}var Tw,Aw;function IQ(r){if(Tw==null){let t=Lo(r);Tw=t.getParameter(t.MAX_TEXTURE_SIZE)}return Tw}function jqe(){Tw=null}function qqe(){Aw=null}function kQ(r){if(Aw==null){let t=Lo(r);Aw=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Aw)}function NQ(r){if(r===0)return 0;let t,n=Lo(r);return ma(n,"EXT_disjoint_timer_query_webgl2")&&r===2?t=2:ma(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function ma(r,t){return r.getExtension(t)!=null}function DN(r){try{if(Lo(r)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function TQ(r){if(r===0)return!1;let t=Lo(r);if(r===1){if(!ma(t,"OES_texture_float"))return!1}else if(!ma(t,"EXT_color_buffer_float"))return!1;return FN(t)}function AQ(r){if(r===0)return!1;let t=Lo(r);if(r===1){if(!ma(t,"OES_texture_float")||!ma(t,"WEBGL_color_buffer_float"))return!1}else{if(ma(t,"EXT_color_buffer_float"))return FN(t);let n="EXT_color_buffer_half_float";if(ma(t,n)){let s=t.getExtension(n);return Kqe(t,s)}return!1}return FN(t)}function FN(r){let t=nL(r),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n),r.texImage2D(r.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(s),i}function Kqe(r,t){let n=nL(r,t),s=r.createTexture();r.bindTexture(r.TEXTURE_2D,s),r.texImage2D(r.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let i=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,i),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,s,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(s),r.deleteFramebuffer(i),a}function DQ(r){return r!==2?!1:Lo(r).fenceSync!=null}function B0(r,t){Array.isArray(r)||(r=[r]),r.forEach(n=>{n!=null&&O.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Rt=Re();Rt.registerFlag("HAS_WEBGL",()=>Rt.getNumber("WEBGL_VERSION")>0);Rt.registerFlag("WEBGL_VERSION",()=>DN(2)?2:DN(1)?1:0);Rt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Rt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Rt.get("WEBGL_VERSION")===2);Rt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Rt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Rt.registerFlag("WEBGL_PACK",()=>Rt.getBool("HAS_WEBGL"));Rt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_CLIP",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_REDUCE",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_CONV_IM2COL",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>IQ(Rt.getNumber("WEBGL_VERSION")));Rt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>kQ(Rt.getNumber("WEBGL_VERSION")));Rt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=Rt.getNumber("WEBGL_VERSION");return r===0?0:NQ(r)});Rt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Rt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!av.isMobile());Rt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>TQ(Rt.getNumber("WEBGL_VERSION")));Rt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Rt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Rt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Rt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>AQ(Rt.getNumber("WEBGL_VERSION")));Rt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>DQ(Rt.getNumber("WEBGL_VERSION")));Rt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Rt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Rt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(typeof r!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${r}.`);if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});Rt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>av.isMobile()?1:-1,r=>{if(typeof r!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${r}.`);if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});Rt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Rt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Rt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Rt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Rt.registerFlag("WEBGL_EXP_CONV",()=>!1);Rt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Rt.getBool("IS_TEST"));Rt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Rt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Rt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Rt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function mi(){let r,t,n,s,i,a,o,u,l,c;return Re().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",t="in",n="out",s="in",i="texture",a="outputColor",o="out vec4 outputColor;",u=Re().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",t="attribute",n="varying",s="varying",i="texture2D",a="gl_FragColor",o="",u=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:t,varyingVs:n,varyingFs:s,texture2D:i,output:a,defineOutput:o,defineSpecialNaN:u,defineSpecialInf:l,defineRound:c}}function yf(r,t,n="index"){let s=O.computeStrides(t);return s.map((i,a)=>{let o=`int ${r[a]} = ${n} / ${i}`,u=a===s.length-1?`int ${r[a+1]} = ${n} - ${r[a]} * ${i}`:`index -= ${r[a]} * ${i}`;return`${o}; ${u};`}).join("")}function H_(r,t,n="index"){let s=O.computeStrides(t);return s.map((i,a)=>{let o=`int ${r[a]} = ${n} / outShapeStrides[${a}]`,u=a===s.length-1?`int ${r[a+1]} = ${n} - ${r[a]} * outShapeStrides[${a}]`:`index -= ${r[a]} * outShapeStrides[${a}]`;return`${o}; ${u};`}).join("")}function Xqe(r,t){let n=r.length,s=r.map(a=>`${t}[${a}]`),i=new Array(n-1);i[n-2]=s[n-1];for(let a=n-3;a>=0;--a)i[a]=`(${i[a+1]} * ${s[a+1]})`;return i}function Yqe(r,t,n="index"){let s=r.map((a,o)=>o),i=Xqe(s,t);return i.map((a,o)=>{let u=`int ${r[o]} = ${n} / ${i[o]}`,l=o===i.length-1?`int ${r[o+1]} = ${n} - ${r[o]} * ${i[o]}`:`index -= ${r[o]} * ${i[o]}`;return`${u}; ${l};`}).join("")}function iL(r){let t=O.computeStrides(r).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function aL(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var FQ=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:$Q}=q;function Zqe(r,t,n){let s=[];if(r.forEach(p=>{let f=O.sizeFromShape(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),n.enableShapeUniforms){let{uniformShape:m}=oL(n.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(m.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`);break}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});let i=s.join(`
`),a=r.map(p=>Jqe(p,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),o=t.texShape,u=mi(),l=tKe(u),c,h,d=sKe(u);return t.isPacked?(c=Qqe(t.logicalShape,o,n.enableShapeUniforms),h=nKe(u)):(c=eKe(t.logicalShape,o,n.enableShapeUniforms),h=rKe(u)),n.packedInputs&&(d+=uKe),[d,l,h,i,c,a,n.userCode].join(`
`)}function V0(r,t=!1){let n=r.shapeInfo.logicalShape;switch(n.length){case 0:return vKe(r,t);case 1:return SKe(r,t);case 2:return _Ke(r,t);case 3:return IKe(r,t);case 4:return NKe(r,t);case 5:return TKe(r);case 6:return AKe(r);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function RQ(r,t){switch(r.shapeInfo.logicalShape.length){case 0:return xKe(r);case 1:return wKe(r,t);case 2:return CKe(r,t);case 3:return EKe(r,t);default:return kKe(r,t)}}function Jqe(r,t,n=!1,s){let i="";n?i+=RQ(r,s):i+=V0(r,s);let a=r.shapeInfo.logicalShape,o=t.logicalShape;return a.length<=o.length&&(n?i+=DKe(r,t):i+=FKe(r,t)),i}function Qqe(r,t,n){switch(r.length){case 0:return OQ();case 1:return lKe(r,t,n);case 2:return yKe(r,t,n);case 3:return hKe(r,t,n);default:return pKe(r,t,n)}}function eKe(r,t,n){switch(r.length){case 0:return OQ();case 1:return cKe(r,t,n);case 2:return bKe(r,t,n);case 3:return dKe(r,t,n);case 4:return fKe(r,t,n);case 5:return mKe(r,t);case 6:return gKe(r,t);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function tKe(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function rKe(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function nKe(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function sKe(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${iKe}
    ${aKe}
    ${oKe}
  `}var iKe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,aKe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,oKe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,uKe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function OQ(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function lKe(r,t,n){let s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return s[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function cKe(r,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function hKe(r,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(r[2]/2),a=i*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function dKe(r,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${H_(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let s=yf(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function pKe(r,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(r[r.length-1]/2),a=i*Math.ceil(r[r.length-2]/2),o=a,u="",l="b, r, c";for(let c=2;c<r.length-1;c++)o*=r[r.length-c-1],u=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+u,l=`b${c}, `+l;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${u}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${r.length}(${l});
    }
  `}function fKe(r,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${H_(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let s=yf(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function mKe(r,t){let n=yf(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function gKe(r,t){let n=yf(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function yKe(r,t,n){let s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(O.arraysEqual(r,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;let i=Math.ceil(r[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function bKe(r,t,n){return O.arraysEqual(r,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:r[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function bf(r){return`offset${r}`}function xKe(r){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),s=mi();return`
    vec4 ${n}() {
      return ${s.texture2D}(${t}, halfCR);
    }
  `}function vKe(r,t){let n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(r.shapeInfo.isUniform)return`float ${s}() {return ${n};}`;let[i,a]=r.shapeInfo.texShape;if(i===1&&a===1)return`
      float ${s}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=bf(n);if(t)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});
      return sampleTexture(${n}, uv);
    }
  `;let[u,l]=r.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${u}, ${l}, ${o});
      return sampleTexture(${n}, uv);
    }
  `}function wKe(r,t){let n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),i=r.shapeInfo.texShape,a=mi();if(t)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;let o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function SKe(r,t){let n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(r.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${z0(r)}
      }
    `;let i=r.shapeInfo.texShape,a=i[0],o=i[1];if(o===1&&a===1)return`
      float ${s}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let u=bf(n);return o===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${u}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${u}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${u}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${u}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${u});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${a}, ${o}, index + ${u});
      return sampleTexture(${n}, uv);
    }
  `}function CKe(r,t){let n=r.shapeInfo.logicalShape,s=r.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=r.shapeInfo.texShape,o=a[0],u=a[1],l=mi();if(a!=null&&O.arraysEqual(n,a))return t?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${u}.0, ${o}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(t)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;let c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],h=Math.ceil(n[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function _Ke(r,t){let n=r.shapeInfo.logicalShape,s=r.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=r.shapeInfo.texShape;if(a!=null&&O.arraysEqual(n,a)){if(t)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;let p=a[0],f=a[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `}let{newShape:o,keptDims:u}=O.squeezeShape(n),l=o;if(l.length<n.length){let p=U0(r,l),f=["row","col"];return`
      ${V0(p,t)}
      float ${i}(int row, int col) {
        return ${i}(${W0(f,u)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${z0(r)}
      }
    `;let c=a[0],h=a[1],d=bf(s);return h===1?t?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?t?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:t?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${c}, ${h}, index);
    return sampleTexture(${s}, uv);
  }
`}function EKe(r,t){let n=r.shapeInfo.logicalShape,s=r.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=r.shapeInfo.texShape,o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){let p=n.slice(1),f=[1,2],m=U0(r,p),g=["b","row","col"];return`
        ${RQ(m,t)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${W0(g,f)});
        }
      `}let u=mi();if(t)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;let l=o[0],c=o[1],h=Math.ceil(n[2]/2),d=h*Math.ceil(n[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${d}, ${h}, b, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function IKe(r,t){let n=r.shapeInfo.logicalShape,s=r.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n[1]*n[2],o=n[2],{newShape:u,keptDims:l}=O.squeezeShape(n),c=u;if(c.length<n.length){let g=U0(r,c),y=["row","col","depth"];return`
        ${V0(g,t)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${W0(y,l)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${o}, 1)));
        ${z0(r)}
      }
    `;let h=r.shapeInfo.texShape,d=h[0],p=h[1],f=r.shapeInfo.flatOffset;if(p===a&&f==null)return t?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${d}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(p===o&&f==null)return t?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;let m=bf(s);return t?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${o} + depth + ${m};
        vec2 uv = uvFromFlat(${d}, ${p}, index);
        return sampleTexture(${s}, uv);
      }
  `}function kKe(r,t){let n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),i=mi();if(t)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${n}, uv);
    }
  `;let a=r.shapeInfo.logicalShape,o=a.length,u=r.shapeInfo.texShape,l=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],c=l[0],h=l[1],d=Math.ceil(a[o-1]/2),p=d*Math.ceil(a[o-2]/2),f="int b, int row, int col",m=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<o-1;g++)f=`int b${g}, `+f,p*=a[o-g-1],m=`b${g} * ${p} + `+m;return`
    vec4 ${s}(${f}) {
      int index = ${m};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${c});
      return ${i.texture2D}(${n}, uv);
    }
  `}function NKe(r,t){let n=r.shapeInfo.logicalShape,s=r.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n[3],o=n[2]*a,u=n[1]*o,{newShape:l,keptDims:c}=O.squeezeShape(n);if(l.length<n.length){let x=U0(r,l),w=["row","col","depth","depth2"];return`
      ${V0(x,t)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${W0(w,c)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${u}, ${o}, ${a}, 1)));
        ${z0(r)}
      }
    `;let h=r.shapeInfo.flatOffset,d=r.shapeInfo.texShape,p=d[0],f=d[1],m=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,y=`int stride0 = ${s}Shape[1] * stride1;`;if(f===u&&h==null)return t?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${m}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(f===a&&h==null)return t?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;let b=bf(s);return t?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${o} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${p}, ${f}, index + ${b});
      return sampleTexture(${s}, uv);
    }
  `}function TKe(r){let t=r.shapeInfo.logicalShape,n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t[4],a=t[3]*i,o=t[2]*a,u=t[1]*o,{newShape:l,keptDims:c}=O.squeezeShape(t);if(l.length<t.length){let g=U0(r,l),y=["row","col","depth","depth2","depth3"];return`
      ${V0(g)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${W0(y,c)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${o}, ${a}, ${i})) +
          depth3;
        ${z0(r)}
      }
    `;let h=r.shapeInfo.flatOffset,d=r.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=bf(n);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${o} + depth * ${a} +
          depth2 * ${i} + depth3 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function AKe(r){let t=r.shapeInfo.logicalShape,n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:i,keptDims:a}=O.squeezeShape(t);if(i.length<t.length){let y=U0(r,i),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${V0(y)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${W0(b,a)});
      }
    `}let o=t[5],u=t[4]*o,l=t[3]*u,c=t[2]*l,h=t[1]*c;if(r.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${c}, ${l}, ${u})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${z0(r)}
      }
    `;let d=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,f=p[0],m=p[1];if(m===h&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${u}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===o&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;let g=bf(n);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${c} + depth * ${l} +
          depth2 * ${u} + depth3 * ${o} + depth4 + ${g};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `}function z0(r){let t=r.name,n=O.sizeFromShape(r.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function DKe(r,t){let n=r.name,s=n.charAt(0).toUpperCase()+n.slice(1),i="get"+s+"AtOutCoords",a=r.shapeInfo.logicalShape.length,o=t.logicalShape.length,u=$Q(r.shapeInfo.logicalShape,t.logicalShape),l=ln(o),c=o-a,h,d=["x","y","z","w","u","v"];a===0?h="":o<2&&u.length>=1?h="coords = 0;":h=u.map(y=>`coords.${d[y+c]} = 0;`).join(`
`);let p="";o<2&&a>0?p="coords":p=r.shapeInfo.logicalShape.map((y,b)=>`coords.${d[b+c]}`).join(", ");let f="return outputValue;",m=O.sizeFromShape(r.shapeInfo.logicalShape)===1,g=O.sizeFromShape(t.logicalShape)===1;if(a===1&&!m&&!g)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!g)o===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(u.length){let y=a-2,b=a-1;u.indexOf(y)>-1&&u.indexOf(b)>-1?f="return vec4(outputValue.x);":u.indexOf(y)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(b)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${h}
      vec4 outputValue = get${s}(${p});
      ${f}
    }
  `}function FKe(r,t){let n=r.name,s=n.charAt(0).toUpperCase()+n.slice(1),i="get"+s+"AtOutCoords",a=t.texShape,o=r.shapeInfo.texShape,u=r.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!r.shapeInfo.isUniform&&u===l&&r.shapeInfo.flatOffset==null&&O.arraysEqual(o,a))return`
      float ${i}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let c=ln(l),h=$Q(r.shapeInfo.logicalShape,t.logicalShape),d=l-u,p,f=["x","y","z","w","u","v"];u===0?p="":l<2&&h.length>=1?p="coords = 0;":p=h.map(g=>`coords.${f[g+d]} = 0;`).join(`
`);let m="";return l<2&&u>0?m="coords":m=r.shapeInfo.logicalShape.map((g,y)=>`coords.${f[y+d]}`).join(", "),`
    float ${i}() {
      ${c} coords = getOutputCoords();
      ${p}
      return get${s}(${m});
    }
  `}function ln(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function oL(r,t,n){let{newShape:s,keptDims:i}=O.squeezeShape(t),a=t.length,o=r&&a===3&&t[0]===1,u=o?t.slice(1):s,l=!r&&a>1&&!O.arraysEqual(t,n)&&s.length<a||o;return{useSqueezeShape:l,uniformShape:l?u:t,keptDims:i}}function U0(r,t){let n=JSON.parse(JSON.stringify(r));return n.shapeInfo.logicalShape=t,n}function W0(r,t){return t.map(n=>r[n]).join(", ")}function $Ke(r,t,n,s){let i=n.map((h,d)=>{let p={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:h.isUniform?!1:h.texData.isPacked,flatOffset:null};return h.texData!=null&&h.texData.slice!=null&&h.texData.slice.flatOffset>0&&(p.flatOffset=h.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:p}}),a=i.map(h=>h.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},u=Zqe(i,o,t),l=hQ(r.gl,u),c=r.createProgram(l);return Re().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:u,webGLProgram:c,inShapeInfos:a,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(r.buildVao(c),Object.assign({program:t,fragmentShader:l,source:u,webGLProgram:c,inShapeInfos:a,outShapeInfo:o},MQ(r,t,c)))}function MQ(r,t,n){let s=[],i=[],a,o,u,l=null,c=null;c=r.getUniformLocation(n,"NAN",!1),Re().getNumber("WEBGL_VERSION")===1&&(l=r.getUniformLocation(n,"INFINITY",!1));let h=!1;for(let d of t.variableNames){let p={name:d,uniform:r.getUniformLocation(n,d,h),offset:r.getUniformLocation(n,`offset${d}`,h)};t.enableShapeUniforms&&(p.shape=r.getUniformLocation(n,`${d}Shape`,h),p.texShape=r.getUniformLocation(n,`${d}TexShape`,h)),s.push(p)}if(t.enableShapeUniforms&&(a=r.getUniformLocation(n,"outShape",h),u=r.getUniformLocation(n,"outShapeStrides",h),o=r.getUniformLocation(n,"outTexShape",h)),t.customUniforms)for(let d of t.customUniforms)i.push(r.getUniformLocation(n,d.name,h));return{variablesLocations:s,customUniformLocations:i,infLoc:l,nanLoc:c,outShapeLocation:a,outShapeStridesLocation:u,outTexShapeLocation:o}}function LV(r,t){if(r.length!==t.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${t.length} inputs`);r.forEach((n,s)=>{let i=n.logicalShape,a=t[s],o=a.shape;if(!O.arraysEqual(i,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${o} must match`);if(n.isUniform&&a.isUniform)return;let u=n.texShape,l=a.isUniform?null:a.texData.texShape;if(!O.arraysEqual(u,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${u} and ${l} must match`)})}function RKe(r,t,n,s,i){t.program.enableShapeUniforms||(LV(t.inShapeInfos,n),LV([t.outShapeInfo],[s]));let a=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?r.setOutputPackedMatrixTexture(a.texture,o[0],o[1]):r.setOutputMatrixTexture(a.texture,o[0],o[1]),r.setProgram(t.webGLProgram),r.bindVertexArray(t.webGLProgram.vao),Re().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&r.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&r.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let c=n[l],{uniform:h,offset:d,shape:p,texShape:f}=t.variablesLocations[l];if(p){let{uniformShape:m}=oL(t.program.packedInputs,c.shape,c.texData.texShape);switch(m.length){case 1:r.gl.uniform1iv(p,new Int32Array(m));break;case 2:r.gl.uniform2iv(p,new Int32Array(m));break;case 3:r.gl.uniform3iv(p,new Int32Array(m));break;case 4:r.gl.uniform4iv(p,new Int32Array(m));break}}if(f&&r.gl.uniform2i(f,c.texData.texShape[0],c.texData.texShape[1]),h!=null){if(c.isUniform){if(O.sizeFromShape(c.shape)<2)r.gl.uniform1f(h,c.uniformValues[0]);else{let m=c.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),r.gl.uniform1fv(h,m)}continue}c.texData.slice!=null&&d!=null&&r.gl.uniform1i(d,c.texData.slice.flatOffset),r.setInputMatrixTexture(c.texData.texture.texture,h,l)}}let u=t.outShapeLocation;if(u)switch(s.shape.length){case 1:r.gl.uniform1iv(u,new Int32Array(s.shape));break;case 2:r.gl.uniform2iv(u,new Int32Array(s.shape));break;case 3:r.gl.uniform3iv(u,new Int32Array(s.shape));break;case 4:r.gl.uniform4iv(u,new Int32Array(s.shape));break}if(t.outShapeStridesLocation){let l=O.computeStrides(s.shape);switch(s.shape.length){case 2:r.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:r.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:r.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&r.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&i)for(let l=0;l<t.program.customUniforms.length;++l){let c=t.program.customUniforms[l],h=t.customUniformLocations[l],d=i[l];if(c.type==="float")r.gl.uniform1fv(h,d);else if(c.type==="vec2")r.gl.uniform2fv(h,d);else if(c.type==="vec3")r.gl.uniform3fv(h,d);else if(c.type==="vec4")r.gl.uniform4fv(h,d);else if(c.type==="int")r.gl.uniform1iv(h,d);else if(c.type==="ivec2")r.gl.uniform2iv(h,d);else if(c.type==="ivec3")r.gl.uniform3iv(h,d);else if(c.type==="ivec4")r.gl.uniform4iv(h,d);else throw Error(`uniform type ${c.type} is not supported yet.`)}r.executeProgram()}function OKe(r,t,n){let s="";t.concat(n).forEach(o=>{let u=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!o.isUniform){let l=o.texData.texShape,{useSqueezeShape:c,uniformShape:h,keptDims:d}=oL(r.packedInputs,o.shape,l),p="",f="",m="";if(h.length===1&&r.packedInputs){let S=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${S[0]>1}_${S[1]>1}`}else if(h.length===2&&!r.packedInputs)f=`${h[0]>1}_${h[1]>1}`;else if(h.length>2&&!r.packedInputs){let S=O.computeStrides(h);m=`${S[0]===l[1]}_${S[S.length-1]===l[1]}`}let g=o.shape.length,y=h.length===2&&O.arraysEqual(o.shape,l),b=O.sizeFromShape(o.shape)===1,x=q.getBroadcastDims(o.shape,n.shape),w=!r.packedInputs&&g===n.shape.length&&O.arraysEqual(l,n.texData.texShape),v=r.packedInputs||h.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${g}_${w}_${c?d:""}_${h.length}_${b}_${x}_${y}_${p}_${f}_${m}_${v}_${u}`}else{let l=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${l}_${u}`}});let i=r.userCode,a=r.constructor.name;return a+="_"+s+"_"+i+`${Re().getNumber("WEBGL_VERSION")}`,a}function qs(r){return Re().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var MKe=class{constructor(r){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=rx.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=mi();this.outputShape=r,this.enableShapeUniforms=qs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?H_(["r","c","d"],r):yf(["r","c","d"],r)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},LKe=class{constructor(r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=rx.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=mi();this.outputShape=r,this.enableShapeUniforms=qs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?H_(["r","c","d"],r):yf(["r","c","d"],r)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},PKe=class{constructor(r){this.variableNames=["A"],this.outTexUsage=fa.DOWNLOAD;let t=mi();this.outputShape=r,this.userCode=`
      ${FQ}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},BKe=class{constructor(r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=fa.DOWNLOAD;let t=mi();this.outputShape=r,this.userCode=`
      ${FQ}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},VKe={R:0,G:1,B:2,A:3},PV=class{constructor(r,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let s=mi();this.outputShape=r,this.enableShapeUniforms=qs(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let a="";for(let o=0;o<n.length;o++){let u=n[o];a+=`
          if(offset == ${o}) {
            result = values[${VKe[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?aL():iL(r)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${a}
        }
        ${s.output} = vec4(${i}, 0., 0., 0.);
      }
    `}},zKe=class{constructor(r,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=mi();this.outputShape=r,this.enableShapeUniforms=qs(this.outputShape.length);let s="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){let u=a*2+o;s+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${r[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${r[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?aL():iL(r)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${n.output} = ${i};
        }
    `}},LQ={};ir(LQ,{bindVertexProgramAttributeStreams:()=>jQ,createBufferFromOutputTexture:()=>XQ,createFloat16MatrixTexture:()=>UQ,createFloat16PackedMatrixTexture:()=>HQ,createFloat32MatrixTexture:()=>zQ,createIndexBuffer:()=>VQ,createPackedMatrixTexture:()=>GQ,createUnsignedBytesMatrixTexture:()=>WQ,createVertexBuffer:()=>BQ,createVertexShader:()=>PQ,downloadByteEncodedFloatMatrixFromOutputTexture:()=>ZQ,downloadFloat32MatrixFromBuffer:()=>YQ,downloadMatrixFromPackedOutputTexture:()=>QQ,downloadPackedMatrixFromBuffer:()=>JQ,getInternalFormatForFloat16MatrixTexture:()=>lL,getInternalFormatForFloat16PackedMatrixTexture:()=>dL,getInternalFormatForFloat32MatrixTexture:()=>uL,getInternalFormatForPackedMatrixTexture:()=>hL,getInternalFormatForUnsignedBytesMatrixTexture:()=>cL,uploadDenseMatrixToTexture:()=>qQ,uploadPixelDataToTexture:()=>KQ});function PQ(r){let t=mi(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return cQ(r,n)}function BQ(r){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return fQ(r,t)}function VQ(r){let t=new Uint16Array([0,1,2,2,1,3]);return mQ(r,t)}function $v(r,t,n,s,i,a){yQ(t,n);let o=gQ(r),u=r.TEXTURE_2D;return bt(r,()=>r.bindTexture(u,o)),bt(r,()=>r.texParameteri(u,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),bt(r,()=>r.texParameteri(u,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),bt(r,()=>r.texParameteri(u,r.TEXTURE_MIN_FILTER,r.NEAREST)),bt(r,()=>r.texParameteri(u,r.TEXTURE_MAG_FILTER,r.NEAREST)),Re().getNumber("WEBGL_VERSION")===1?bt(r,()=>r.texImage2D(u,0,s,t,n,0,i,a,null)):bt(r,()=>r.texStorage2D(u,1,s,t,n)),bt(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:o,texShape:[n,t]}}function uL(r){return r.internalFormatFloat}function zQ(r,t,n,s){let[i,a]=Fv(t,n);return $v(r,i,a,uL(s),s.textureFormatFloat,r.FLOAT)}function lL(r){return r.internalFormatHalfFloat}function UQ(r,t,n,s){let[i,a]=Fv(t,n);return $v(r,i,a,lL(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function cL(r){return r.downloadTextureFormat}function WQ(r,t,n,s){let[i,a]=Fv(t,n);return $v(r,i,a,cL(s),r.RGBA,r.UNSIGNED_BYTE)}function hL(r){return r.internalFormatPackedFloat}function GQ(r,t,n,s){let[i,a]=P0(t,n);return $v(r,i,a,hL(s),r.RGBA,r.FLOAT)}function dL(r){return r.internalFormatPackedHalfFloat}function HQ(r,t,n,s){let[i,a]=P0(t,n);return $v(r,i,a,dL(s),r.RGBA,s.textureTypeHalfFloat)}function jQ(r,t,n){return bt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),TN(r,t,"clipSpacePos",n,3,20,0)&&TN(r,t,"uv",n,2,20,12)}function qQ(r,t,n,s,i,a){bt(r,()=>r.bindTexture(r.TEXTURE_2D,t));let o,u,l;i instanceof Uint8Array?(o=new Uint8Array(n*s*4),u=r.UNSIGNED_BYTE,l=r.RGBA):(o=new Float32Array(n*s*4),u=r.FLOAT,l=a.internalFormatPackedFloat),o.set(i),Re().getNumber("WEBGL_VERSION")===2?bt(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,n,s,r.RGBA,u,o)):bt(r,()=>r.texImage2D(r.TEXTURE_2D,0,l,n,s,0,r.RGBA,u,o)),bt(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function KQ(r,t,n){bt(r,()=>r.bindTexture(r.TEXTURE_2D,t)),n.data instanceof Uint8Array?Re().getNumber("WEBGL_VERSION")===2?bt(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,n.width,n.height,r.RGBA,r.UNSIGNED_BYTE,n.data)):bt(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,n.width,n.height,0,r.RGBA,r.UNSIGNED_BYTE,n.data)):Re().getNumber("WEBGL_VERSION")===2?bt(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,n)):bt(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,n)),bt(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function XQ(r,t,n,s){let i=r.createBuffer();bt(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,i));let a=4*4*t*n;return bt(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,a,r.STREAM_READ)),bt(r,()=>r.readPixels(0,0,n,t,r.RGBA,r.FLOAT,0)),bt(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),i}function YQ(r,t,n){let s=r,i=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,i),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),i}function ZQ(r,t,n,s){let[i,a]=Fv(t,n),o=4,u=new Uint8Array(Lqe(t*n,o));return bt(r,()=>r.readPixels(0,0,i,a,s.downloadTextureFormat,r.UNSIGNED_BYTE,u)),new Float32Array(u.buffer)}function JQ(r,t,n,s,i,a,o,u){let l=r,c=new Float32Array(Pqe(a,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function QQ(r,t,n){let s=new Float32Array(t*n*4);return bt(r,()=>r.readPixels(0,0,n,t,r.RGBA,r.FLOAT,s)),s}var Dw=class{constructor(r){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=Re().getNumber("WEBGL_VERSION");if(r!=null?(this.gl=r,oQ(t,r)):this.gl=Lo(t),r=this.gl,Re().getNumber("WEBGL_VERSION")===2){let i=r;this.createVertexArray=()=>bt(i,()=>i.createVertexArray()),this.bindVertexArray=a=>bt(i,()=>i.bindVertexArray(a)),this.deleteVertexArray=a=>bt(i,()=>i.deleteVertexArray(a)),this.getVertexArray=()=>bt(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(r!=null){let i=r.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>bt(r,()=>i.createVertexArrayOES()),this.bindVertexArray=a=>bt(r,()=>i.bindVertexArrayOES(a)),this.deleteVertexArray=a=>bt(r,()=>i.deleteVertexArrayOES(a)),this.getVertexArray=()=>bt(r,()=>r.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Re().getNumber("WEBGL_VERSION")===1){let i="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Oy(this.gl,i),ma(this.gl,a))this.textureHalfFloatExtension=Oy(this.gl,a);else if(Re().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),ma(this.gl,s))this.colorBufferHalfFloatExtension=Oy(this.gl,s);else if(Re().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",ma(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(ma(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=BQ(this.gl),this.indexBuffer=VQ(this.gl),this.framebuffer=bQ(this.gl),this.textureConfig=nL(this.gl,this.textureHalfFloatExtension)}get debug(){return Re().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let r=this.gl;bt(r,()=>r.finish()),bt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),bt(r,()=>r.deleteFramebuffer(this.framebuffer)),bt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,null)),bt(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,null)),bt(r,()=>r.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(r,t){return this.throwIfDisposed(),zQ(this.gl,r,t,this.textureConfig)}createFloat16MatrixTexture(r,t){return this.throwIfDisposed(),UQ(this.gl,r,t,this.textureConfig)}createUnsignedBytesMatrixTexture(r,t){return this.throwIfDisposed(),WQ(this.gl,r,t,this.textureConfig)}uploadPixelDataToTexture(r,t){this.throwIfDisposed(),KQ(this.gl,r,t)}uploadDenseMatrixToTexture(r,t,n,s){this.throwIfDisposed(),qQ(this.gl,r,t,n,s,this.textureConfig)}createFloat16PackedMatrixTexture(r,t){return this.throwIfDisposed(),HQ(this.gl,r,t,this.textureConfig)}createPackedMatrixTexture(r,t){return this.throwIfDisposed(),GQ(this.gl,r,t,this.textureConfig)}deleteMatrixTexture(r){this.throwIfDisposed(),this.outputTexture===r&&(AN(this.gl,this.framebuffer),this.outputTexture=null),bt(this.gl,()=>this.gl.deleteTexture(r))}downloadByteEncodedFloatMatrixFromOutputTexture(r,t,n){return this.downloadMatrixDriver(r,()=>ZQ(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(r,t,n,s,i,a){return JQ(this.gl,r,t,n,s,i,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(r,t){return YQ(this.gl,r,t)}createBufferFromTexture(r,t,n){this.bindTextureToFrameBuffer(r);let s=XQ(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){let r=this.createFence(this.gl);return this.pollFence(r)}createFence(r){let t,n;if(Re().getBool("WEBGL_FENCE_API_ENABLED")){let s=r,i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);r.flush(),n=()=>{let a=s.clientWaitSync(i,0,0);return a===s.ALREADY_SIGNALED||a===s.CONDITION_SATISFIED},t=i}else Re().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Re().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(r,t,n){return this.downloadMatrixDriver(r,()=>QQ(this.gl,t,n))}createProgram(r){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=PQ(t));let n=dQ(t);bt(t,()=>t.attachShader(n,this.vertexShader)),bt(t,()=>t.attachShader(n,r)),pQ(t,n);let s=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&kw(t,s),s}buildVao(r){this.setProgram(r),this.bindVertexArray(r.vao);let t=this.gl;bt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),jQ(t,r,this.vertexBuffer)}deleteProgram(r){this.throwIfDisposed(),r===this.program&&(this.program=null),r!=null&&(bt(this.gl,()=>this.gl.deleteProgram(r)),this.deleteVertexArray(r.vao))}setProgram(r){this.throwIfDisposed(),this.program=r,this.program!=null&&this.debug&&kw(this.gl,this.program),bt(this.gl,()=>this.gl.useProgram(r))}getUniformLocation(r,t,n=!0){return this.throwIfDisposed(),n?vQ(this.gl,r,t):wQ(this.gl,r,t)}getAttributeLocation(r,t){return this.throwIfDisposed(),bt(this.gl,()=>this.gl.getAttribLocation(r,t))}getUniformLocationNoThrow(r,t){return this.throwIfDisposed(),this.gl.getUniformLocation(r,t)}setInputMatrixTexture(r,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),SQ(this.gl,r,t,n)}setOutputMatrixTexture(r,t,n){this.setOutputMatrixTextureDriver(r,n,t)}setOutputPackedMatrixTexture(r,t,n){this.throwIfDisposed();let[s,i]=P0(t,n);this.setOutputMatrixTextureDriver(r,s,i)}setOutputMatrixWriteRegion(r,t,n,s){this.setOutputMatrixWriteRegionDriver(n,r,s,t)}setOutputPackedMatrixWriteRegion(r,t,n,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&kw(this.gl,this.program),My(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let r=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}bt(r,()=>r.drawElements(r.TRIANGLES,6,r.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),bt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Oy(this.gl,Re().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Re().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=n.createQuery();return n.beginQuery(s.TIME_ELAPSED_EXT,i),i}let r=this.getQueryTimerExtensionWebGL1(),t=r.createQueryEXT();return r.beginQueryEXT(r.TIME_ELAPSED_EXT,t),t}endQuery(){if(Re().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let r=this.getQueryTimerExtensionWebGL1();r.endQueryEXT(r.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(r){return await O.repeatedTry(()=>this.disposed||this.isQueryAvailable(r,Re().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(r,Re().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(r,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(r,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(r,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(r,t){if(t===0)return!0;if(t===2){let n=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=n.getQueryParameter(r,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),s=n.getQueryObjectEXT(r,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(r){return new Promise(t=>{this.addItemToPoll(()=>r.isFencePassed(),()=>t())})}pollItems(){let r=UKe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=r;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(r+1)}addItemToPoll(r,t){if(this.itemsToPoll.push({isDoneFn:r,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Re().platform&&(n=Re().platform.setTimeoutCustom.bind(Re().platform)),O.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(r){this.throwIfDisposed(),Nw(this.gl,r,this.framebuffer),this.debug&&My(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Nw(this.gl,this.outputTexture,this.framebuffer),this.debug&&My(this.gl)):AN(this.gl,this.framebuffer)}downloadMatrixDriver(r,t){this.bindTextureToFrameBuffer(r);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(r,t,n){this.throwIfDisposed();let s=this.gl;Nw(s,r,this.framebuffer),this.debug&&My(s),this.outputTexture=r,bt(s,()=>s.viewport(0,0,t,n)),bt(s,()=>s.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(r,t,n,s){this.throwIfDisposed(),bt(this.gl,()=>this.gl.scissor(r,t,n,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function UKe(r){let t=0;for(;t<r.length&&r[t]();++t);return t-1}var{addImpl:WKe,bincountImpl:eee,bincountReduceImpl:GKe,bitwiseAndImpl:HKe,castImpl:jKe,ceilImpl:qKe,concatImpl:KKe,equalImpl:XKe,expImpl:YKe,expm1Impl:ZKe,floorImpl:JKe,gatherNdImpl:QKe,gatherV2Impl:eXe,greaterImpl:tXe,greaterEqualImpl:rXe,lessImpl:nXe,lessEqualImpl:sXe,linSpaceImpl:iXe,logImpl:aXe,maxImpl:oXe,maximumImpl:uXe,minimumImpl:lXe,multiplyImpl:cXe,negImpl:hXe,notEqualImpl:dXe,prodImpl:pXe,raggedGatherImpl:fXe,raggedRangeImpl:mXe,raggedTensorToTensorImpl:gXe,rangeImpl:yXe,rsqrtImpl:bXe,scatterImpl:xXe,sigmoidImpl:vXe,simpleAbsImpl:tee,sliceImpl:wXe,sparseFillEmptyRowsImpl:SXe,sparseReshapeImpl:CXe,sparseSegmentReductionImpl:ree,sqrtImpl:_Xe,staticRegexReplaceImpl:EXe,stridedSliceImpl:IXe,stringNGramsImpl:kXe,stringSplitImpl:NXe,stringToHashBucketFastImpl:TXe,subImpl:AXe,tileImpl:DXe,topKImpl:FXe,transposeImpl:pL,uniqueImpl:$Xe}=zM;function nee(r,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${r}.${n}`)}function si(r,t){return t===1?[r]:nee(r,t)}function RXe(r,t){if(r===1)return"rc";let n="";for(let s=0;s<r;s++)n+=t[s],s<r-1&&(n+=",");return n}var OXe=class{constructor(r){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=r,this.rank=r.length,this.enableShapeUniforms=qs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=si("rc",this.rank),n=ln(this.rank),s=this.getOutOfBoundsCondition(t),i=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(r){let t=[];for(let n=0;n<=1;n++)for(let s=0;s<=1;s++){let i=`${n===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)i=`${r[r.length-1-a]},`+i;t.push(i)}return t}getOutOfBoundsCondition(r){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${r[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(r){if(this.rank===1)return"";let t=r.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${s};
    `}getOutput(r){let t=this.getSourceCoordsArr(r);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},see=class{constructor(r,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=r,this.enableShapeUniforms=qs(this.outputShape.length);let n="";for(let s=0;s<4;s++){let i="thisRC = rc;";s%2===1&&(i+="thisRC.z += 1;"),s>1&&(i+="thisRC.y += 1;"),n+=`
        ${i}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${MXe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?aL():iL(r)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":r[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":r[2]};

        ${n}

        setOutput(result);
      }
    `}};function MXe(r,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Yqe(["r","c","d"],"inputShape"):yf(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var LXe=class{constructor(r){this.gpgpu=r,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(r,t,n){let s=VV(t,n),i=zV(r,s,n);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);let a=BV(r,s,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let u=this.freeTextures[i].pop();return this.usedTextures[i].push(u),u}let o;return s===Ds.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(r[0],r[1]):s===Ds.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(r[0],r[1]):s===Ds.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(r[0],r[1]):s===Ds.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(r[0],r[1]):s===Ds.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(r[0],r[1])),this.usedTextures[i].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(r,t,n,s){if(this.freeTextures==null)return;let i=VV(n,s),a=zV(t,i,s);a in this.freeTextures||(this.freeTextures[a]=[]);let o=BV(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,s),u=Re().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(r.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(r),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;let l=this.usedTextures[a],c=l&&l.indexOf(r);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let r=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${r})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let r in this.freeTextures)this.freeTextures[r].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let r in this.usedTextures)this.usedTextures[r].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function PXe(r,t){let n=r;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===r.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function BV(r,t,n,s,i){let a=BXe(t,s),o;if(i){let[l,c]=P0(r[0],r[1]);o=l*c}else{let[l,c]=Fv(r[0],r[1]);o=l*c}let u=PXe(n,a);return o*u}function BXe(r,t){switch(r){case Ds.PACKED_2X2_FLOAT32:return hL(t);case Ds.PACKED_2X2_FLOAT16:return dL(t);case Ds.UNPACKED_FLOAT32:return uL(t);case Ds.UNPACKED_FLOAT16:return lL(t);case Ds.PACKED_4X1_UNSIGNED_BYTE:return cL(t);default:throw new Error(`Unknown physical texture type ${r}`)}}function VXe(r){return Re().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?Ds.PACKED_2X2_FLOAT32:Ds.UNPACKED_FLOAT32:r?Ds.PACKED_2X2_FLOAT16:Ds.UNPACKED_FLOAT16}function VV(r,t){if(r===fa.UPLOAD)return Ds.PACKED_2X2_FLOAT32;if(r===fa.RENDER||r==null)return VXe(t);if(r===fa.DOWNLOAD||r===fa.PIXELS)return Ds.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function zV(r,t,n){return`${r[0]}_${r[1]}_${t}_${n}`}var nu=class{constructor(r,t){this.variableNames=["A"],this.outputShape=r,this.enableShapeUniforms=qs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},oo="if (isnan(x)) return x;",zXe="return x;",UV="return abs(x);",UXe="return (x >= 0.0) ? x : (exp(x) - 1.0);",WXe=oo+`
  return (x < 0.0) ? 0.0 : x;
`,GXe=oo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Pl="return x;",HXe="return 1.0 / (1.0 + exp(-1.0 * x));",jXe="return x;",qXe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,KXe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,XXe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,YXe="return 1.0 / (1.0 + exp(-1.0 * x));",Jl=class{constructor(r,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=qs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},ZXe=class{constructor(r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=r,this.enableShapeUniforms=qs(this.outputShape.length);let t=r.length,n=si("rc",t),s=ln(t),i=RXe(t,n),a=n.slice(-2),o=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}},JXe=ku.whereImpl,QXe=1e-7,eYe=1e-4,fI={};function tYe(r){return r in fI||(fI[r]={}),fI[r]}var rYe=Re().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),nYe=600;function sYe(){return Re().global.screen==null?1024:Re().global.screen.height*Re().global.screen.width*window.devicePixelRatio*nYe/1024/1024}var fL=class iee extends Rx{nextDataId(){return iee.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Re().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof Dw)n=t;else{let s=Lo(Re().getNumber("WEBGL_VERSION"),t);n=new Dw(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let s=Lo(Re().getNumber("WEBGL_VERSION"));n=new Dw(s),this.binaryCache=tYe(Re().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new LXe(this.gpgpu),this.numMBBeforeWarning=sYe(),this.texData=new CC(this,Ma())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,s,i,a,o){let u=this.makeTensorInfo(n,s),l=this.texData.get(u.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[i,a]},l.texShape=[i,a];let c=Ly(n),h=new PV(c,!1,o),d=this.runWebGLProgram(h,[u],s,[[i,a]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(u),d.dataId}write(t,n,s){if((Re().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Re().getBool("DEBUG"))&&this.checkNumericalProblems(t),s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let i={id:this.nextDataId()};return this.texData.set(i,{shape:n,dtype:s,values:t,usage:fa.UPLOAD,refCount:1}),i}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,s,i,a){if(Re().getBool("DEBUG")&&this.checkNumericalProblems(n),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:s,dtype:i,values:n,usage:fa.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:s,dtype:i,complexTensorInfos:a,slice:o,shape:u,isPacked:l}=n;if(o!=null){let p;l?p=new Jl(u,Pl):p=new nu(u,Pl);let f=this.runWebGLProgram(p,[{dataId:t,shape:u,dtype:i}],i),m=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),m}if(s!=null)return this.convertAndCacheOnCPU(t);if(i==="string")return s;let c=this.activeTimers!=null,h;c&&(h=O.now());let d;if(i==="complex64"){let p=this.readSync(a.real.dataId),f=this.readSync(a.imag.dataId);d=q.mergeRealAndImagArrays(p,f)}else d=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=O.now()-h),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){let m=this.pendingRead.get(t);return new Promise(g=>m.push(g))}let n=this.texData.get(t),{values:s,shape:i,slice:a,dtype:o,complexTensorInfos:u,isPacked:l}=n;if(a!=null){let m;l?m=new Jl(i,Pl):m=new nu(i,Pl);let g=this.runWebGLProgram(m,[{dataId:t,shape:i,dtype:o}],o),y=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(s!=null)return this.convertAndCacheOnCPU(t);if(Re().getBool("DEBUG")&&!Re().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Re().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,h;if(o!=="complex64"&&Re().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(t);let m=this.texData.get(h.dataId);c=this.gpgpu.createBufferFromTexture(m.texture.texture,...V1(i))}this.pendingRead.set(t,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(o==="complex64"){let m=await Promise.all([this.read(u.real.dataId),this.read(u.imag.dataId)]),g=m[0],y=m[1];d=q.mergeRealAndImagArrays(g,y)}else if(c==null)d=this.getValuesFromTexture(t);else{let m=O.sizeFromShape(i);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,m)}if(h!=null&&this.disposeIntermediateTensorInfo(h),c!=null){let m=this.gpgpu.gl;bt(m,()=>m.deleteBuffer(c))}let p=this.convertAndCacheOnCPU(t,d),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(m=>m(p)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Ma().removeDataId(t,this),this.pendingDeletes--),p}readToGPU(t,n={}){let s=this.texData.get(t),{values:i,shape:a,slice:o,dtype:u,isPacked:l,texture:c}=s;if(u==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let f;l?f=new Jl(a,Pl):f=new nu(a,Pl);let m=this.runWebGLProgram(f,[{dataId:t,shape:a,dtype:u}],u),g=this.readToGPU(m,n);return this.disposeIntermediateTensorInfo(m),g}if(c==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let h=this.decode(t,n.customTexShape),d=Ma().makeTensorFromTensorInfo(h),p=this.texData.get(h.dataId);return Object.assign({tensorRef:d},p.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let s=n.map(i=>O.decodeString(i));return pr(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return pr(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let s=t[n];if(!uQ(s))throw Re().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:s,isPacked:i}=this.texData.get(t),a=O.sizeFromShape(n);if(Re().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let p=this.decode(t),f=this.texData.get(p.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...V1(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(p),m}let o=Re().getBool("WEBGL_PACK")&&i===!0,u=o?Ly(n):n,l=o?new BKe(u):new PKe(u),c=this.runWebGLProgram(l,[{shape:u,dtype:s,dataId:t}],"float32"),h=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return Re().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let n=this.activeTimers,s=[],i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,t();let a=O.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=O.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,i&&(this.programTimersStack=null);let u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Re().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(a);u.kernelMs=O.sum(l),u.getExtraProfileInfo=()=>l.map((c,h)=>({name:o[h],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Re().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:O.now(),endMs:null}}endTimer(t){return Re().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=O.now(),t)}async getQueryTime(t){if(Re().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:s}=this.texData.get(t);return s!=null&&(this.disposeData(s.real.dataId,n),this.disposeData(s.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:s,texShape:i,usage:a,isPacked:o,slice:u}=this.texData.get(t),l=u&&u.origDataId||t,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(n,i,a,o)));let h=this.texData.get(t);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=rYe){return Re().getBool("WEBGL_CPU_FORWARD")&&t.every(s=>this.texData.get(s.dataId).texture==null&&O.sizeFromShape(s.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){q.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return JXe(t.shape,n)}packedUnaryOp(t,n,s){let i=new Jl(t.shape,n),a=this.compileAndRun(i,[t],s);return Ma().makeTensorFromTensorInfo(a)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let i=tee(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,i)}if(Re().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,UV,t.dtype);let n=new nu(t.shape,UV),s=this.compileAndRun(n,[t]);return Ma().makeTensorFromTensorInfo(s)}makeTensorInfo(t,n,s){let i;if(n==="string"&&s!=null&&s.length>0&&O.isString(s[0])){let a=s.map(o=>O.encodeString(o));i=this.write(a,t,n)}else i=this.write(s,t,n);return this.texData.get(i).usage=null,{dataId:i,shape:t,dtype:n}}makeOutput(t,n,s){return Ma().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,s),this)}unpackTensor(t){let n=new ZXe(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new OXe(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let s=[Ed(t.shape),...Id(t.shape)],i={dtype:t.dtype,shape:s,dataId:t.dataId},a=[Ed(n),...Id(n)],o=new see(a,s),u=!0,l=[s],c=this.runWebGLProgram(o,[i],t.dtype,l,u);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(t,n){let s=this.texData.get(t),{isPacked:i,shape:a,dtype:o}=s;if(n!=null){let p=O.sizeFromShape(a),f=n[0]*n[1]*4;O.assert(p<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let u=Ly(a),l;i?l=new LKe(u):l=new MKe(u);let c=!0,h=[n??V1(u)],d=this.runWebGLProgram(l,[{shape:u,dtype:o,dataId:t}],o,h,c,n);return{dtype:o,shape:a,dataId:d.dataId}}runWebGLProgram(t,n,s,i,a=!1,o){let u=this.makeTensorInfo(t.outputShape,s),l=this.texData.get(u.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===rx.DENSE){let b=o??V1(t.outputShape);l.texShape=b.map(x=>x*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),O.sizeFromShape(u.shape)===0)return l.values=O.getTypedArrayFromDType(u.dtype,0),u;let c=[],h=n.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(b.dataId);if(x.texture==null){if(!t.packedInputs&&O.sizeFromShape(b.shape)<=Re().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:x.values};t.packedInputs&&(x.isPacked=!0,x.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!x.isPacked!=!!t.packedInputs)b=x.isPacked?this.unpackTensor(b):this.packTensor(b),c.push(b),x=this.texData.get(b.dataId);else if(x.isPacked&&!nx(x.shape,b.shape)){let w=b,v=b.shape;b.shape=x.shape,b=this.packedReshape(b,v),c.push(b),x=this.texData.get(b.dataId),w.shape=v}return{shape:b.shape,texData:x,isUniform:!1}});this.uploadToGPU(u.dataId);let d={shape:u.shape,texData:l,isUniform:!1},p=OKe(t,h,d),f=this.getAndSaveBinary(p,()=>$Ke(this.gpgpu,t,h,d)),m=this.activeTimers!=null,g;m&&(g=this.startTimer()),Re().get("ENGINE_COMPILE_ONLY")||RKe(this.gpgpu,f,h,d,i),c.forEach(b=>this.disposeIntermediateTensorInfo(b)),m&&(g=this.endTimer(g),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(g)}));let y=Re().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){let b=O.now();b-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!Re().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&a===!1){let b=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),b}return u}compileAndRun(t,n,s,i,a=!1){return s=s||n[0].dtype,this.runWebGLProgram(t,n,s,i,a)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Re().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Ie(()=>{if(!Re().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=Re().getBool("DEBUG");Re().set("DEBUG",!1);let n=this.abs(Pt(1e-8)).dataSync()[0];if(Re().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?QXe:eYe}uploadToGPU(t){let n=this.texData.get(t),{shape:s,dtype:i,values:a,texture:o,usage:u,isPacked:l}=n;if(o!=null)return;let c=this.activeTimers!=null,h;c&&(h=O.now());let d=n.texShape;if(d==null&&(d=EQ(s,l),n.texShape=d),a!=null){let p=Ly(s),f,m=d[1],g=d[0],y=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(l||!y)&&([m,g]=P0(d[0],d[1])),l?f=new zKe(p,y):f=new PV(p,y);let b=y?[g,m]:d,x=this.makeTensorInfo(b,i),w=this.texData.get(x.dataId);y?w.usage=fa.PIXELS:w.usage=fa.UPLOAD,w.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),m,g,a);let v=[[g,m]],S=this.runWebGLProgram(f,[x],i,v,!0),E=this.texData.get(S.dataId);n.texShape=E.texShape,n.isPacked=E.isPacked,n.usage=E.usage,Re().get("ENGINE_COMPILE_ONLY")?this.disposeData(S.dataId):(n.texture=E.texture,n.values=null,this.texData.delete(S.dataId)),this.disposeIntermediateTensorInfo(x),c&&(this.uploadWaitMs+=O.now()-h)}else{let p=this.acquireTexture(d,u,i,l);n.texture=p}}convertAndCacheOnCPU(t,n){let s=this.texData.get(t),{dtype:i}=s;return n!=null&&(s.values=iYe(n,i)),s.values}acquireTexture(t,n,s,i){if(this.numBytesInGPU+=this.computeBytes(t,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,i)}computeBytes(t,n){return t[0]*t[1]*O.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let s=new Promise(i=>{try{this.checkCompletion_(n),i(!0)}catch(a){throw a}});t.push(s)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await nO(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(sL(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:s,infLoc:i,nanLoc:a,outShapeLocation:o,outShapeStridesLocation:u,outTexShapeLocation:l}=MQ(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=s,t.infLoc=i,t.nanLoc=a,t.outShapeLocation=o,t.outShapeStridesLocation=u,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,s){t.channels=t.channels||"RGBA";let{texture:i,height:a,width:o,channels:u}=t,l=Ma().backend;if(!l.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let c=l.writeTexture(i,n,s,a,o,u);return Ma().makeTensorFromDataId(c,n,s,l)}};fL.nextDataId=0;function iYe(r,t){if(t==="float32"||t==="complex64")return r;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let s=0;s<n.length;++s)n[s]=Math.round(r[s]);return n}else throw new Error(`Unknown dtype ${t}`)}var aYe="4.22.0";function aee(){Re().set("WEBGL_FORCE_F16_TEXTURES",!0)}av.isBrowser()&&zC("webgl",()=>new fL,2);var oYe={forceHalfFloat:aee},mL=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,kd=class{constructor(r,t,n){this.variableNames=["A","B"],this.outputShape=q.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=qs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${r}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},xf=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,G0=class{constructor(r,t,n,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=q.assertAndGetBroadcastShape(t,n);let i=this.outputShape.length;this.enableShapeUniforms=qs(i);let a="";if(s)if(i===0||O.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${ln(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let o=si("coords",i);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${o[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${o[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${o[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${o[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${r}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function ia(r){let{inputs:t,backend:n}=r,{x:s}=t;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}var uYe={kernelName:vp,backendName:"webgl",kernelFunc:ia};function jc(r){let{inputs:t,backend:n}=r,{real:s,imag:i}=t,a=n.makeTensorInfo(s.shape,"complex64"),o=n.texData.get(a.dataId),u=ia({inputs:{x:s},backend:n}),l=ia({inputs:{x:i},backend:n});return o.complexTensorInfos={real:u,imag:l},a}var lYe={kernelName:IC,backendName:"webgl",kernelFunc:jc},oee="return (a < 0.) ? b * a : a;",uee=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function cYe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{alpha:a}=s,o=n.makeTensorInfo([],"float32",O.createScalarValue(a,"float32")),u=Re().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new G0(uee,i.shape,o.shape):new kd(oee,i.shape,o.shape),l=n.runWebGLProgram(u,[i,o],"float32");return n.disposeIntermediateTensorInfo(o),l}var hYe={kernelName:_p,backendName:"webgl",kernelFunc:cYe},lee="return (a < 0.) ? b * a : a;",cee=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function dYe(r){let{inputs:t,backend:n}=r,{x:s,alpha:i}=t,a=Re().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new G0(cee,s.shape,i.shape):new kd(lee,s.shape,i.shape);return n.runWebGLProgram(a,[s,i],"float32")}var pYe={kernelName:Vp,backendName:"webgl",kernelFunc:dYe},H0="if (isnan(x)) return x;";function Rr({opSnippet:r,packedOpSnippet:t,cpuKernelImpl:n,dtype:s}){return({inputs:i,backend:a})=>{let{x:o}=i,u=a,l=s||o.dtype;if(u.shouldExecuteOnCPU([o])&&n!=null){let d=u.texData.get(o.dataId),p=n(d.values,l);return u.makeTensorInfo(o.shape,l,p)}let c=Re().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,h;return c?h=new Jl(o.shape,t):h=new nu(o.shape,r),u.runWebGLProgram(h,[o],l)}}function Os({opSnippet:r,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:i,dtype:a}){return({inputs:o,backend:u})=>{let{a:l,b:c}=o,h=u;if(s&&l.dtype==="complex64"){let m=h.texData.get(l.dataId),g=h.texData.get(c.dataId),[y,b]=[[m.complexTensorInfos.real,g.complexTensorInfos.real],[m.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(w=>{let[v,S]=w,E={dataId:v.dataId,dtype:v.dtype,shape:l.shape},C={dataId:S.dataId,dtype:S.dtype,shape:c.shape},I=new kd(r,l.shape,c.shape);return h.runWebGLProgram(I,[E,C],va(v.dtype,S.dtype))}),x=jc({inputs:{real:y,imag:b},backend:h});return h.disposeIntermediateTensorInfo(y),h.disposeIntermediateTensorInfo(b),x}let d=a||va(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||h.shouldExecuteOnCPU([l,c]))&&i!=null){let m=h.texData.get(l.dataId).values,g=h.texData.get(c.dataId).values,y=l.dtype==="string"?q.fromUint8ToStringArray(m):m,b=l.dtype==="string"?q.fromUint8ToStringArray(g):g,[x,w]=i(l.shape,c.shape,y,b,d),v=h.makeTensorInfo(w,d),S=h.texData.get(v.dataId);return S.values=x,v}let p=Re().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,f;return p?f=new G0(t,l.shape,c.shape,n):f=new kd(r,l.shape,c.shape),h.runWebGLProgram(f,[l,c],d)}}function sx(r,t=!1){if(r==="linear")return t?jXe:zXe;if(r==="relu")return t?KXe:WXe;if(r==="elu")return t?qXe:UXe;if(r==="relu6")return t?XXe:GXe;if(r==="prelu")return t?cee:lee;if(r==="leakyrelu")return t?uee:oee;if(r==="sigmoid")return t?YXe:HXe;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var hee=class{constructor(r,t,n,s=!1,i=!1,a=!1,o=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=qs(this.outputShape.length);let c=s?r[1]:r[2],h=Math.ceil(c/2),d=s?"i * 2, rc.y":"rc.y, i * 2",p=i?"rc.z, i * 2":"i * 2, rc.z",f=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",y="";o&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:g=`vec4 activation(vec4 x) {
          ${o}
        }`,y="result = activation(result);");let b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let x="rc.x",w="rc.x";r[0]<t[0]?x=`imod(rc.x, ${r[0]})`:t[0]<r[0]&&(w=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x};
        int batchB = ${w};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}},WV={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},GV=class{constructor(r,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=q.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${r}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},HV="return a * b;";function gL(r){let{inputs:t,backend:n}=r,{a:s,b:i}=t,a=q.upcastType(s.dtype,i.dtype);if(s.dtype==="complex64"){let u=n.texData.get(s.dataId),l=n.texData.get(i.dataId),c=new GV(WV.REAL,s.shape,i.shape),h=new GV(WV.IMAG,s.shape,i.shape),d=[{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],p=n.runWebGLProgram(c,d,"float32"),f=n.runWebGLProgram(h,d,"float32"),m=jc({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}if(n.shouldExecuteOnCPU([s,i])){let u=n.texData.get(s.dataId),l=n.texData.get(i.dataId),[c,h]=cXe(s.shape,i.shape,u.values,l.values,a),d=n.makeTensorInfo(h,a),p=n.texData.get(d.dataId);return p.values=c,d}let o;return Re().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new G0(HV,s.shape,i.shape):o=new kd(HV,s.shape,i.shape),n.runWebGLProgram(o,[s,i],a)}var fYe={kernelName:Mp,backendName:"webgl",kernelFunc:gL};function mYe(r,t,n){let s=[Ed(r.shape),...Id(r.shape)],i={dtype:r.dtype,shape:s,dataId:r.dataId},a=[Ed(t),...Id(t)],o=new see(a,s),u=!0,l=[s],c=n.runWebGLProgram(o,[i],r.dtype,l,u);return{dataId:c.dataId,shape:t,dtype:c.dtype}}function gt(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{shape:a}=s,o=n,u=O.sizeFromShape(i.shape),l=O.inferFromImplicitShape(a,u),c=O.sizeFromShape(l);O.assert(u===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${i.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`);let h=o.texData.get(i.dataId);return h.isPacked&&!nx(i.shape,l)&&!(h.texture!==null&&nx(h.shape,l))?mYe(i,l,o):(o.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}var gYe={kernelName:l0,backendName:"webgl",kernelFunc:gt},jV=class{constructor(r,t){this.variableNames=["x"];let{windowSize:n,batchSize:s,inSize:i,outSize:a}=r;this.outputShape=[s,a];let o=Math.floor(n/4)*4,u=n%4,l="sumValue += dot(values, ones);";if(t!=null){let h=1/t;l=`sumValue += dot(values * ${O.isInt(h)?h.toPrecision(2):h}, ones);`}let c="";i%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${o};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},yYe=class{constructor(r,t){this.variableNames=["x"];let{windowSize:n,batchSize:s,inSize:i,outSize:a}=r;this.outputShape=[s,a];let o="0.0",u="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",u="min"):t==="max"&&(o="-1.0 / 1e-20",u="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let c=Math.floor(n/4)*4,h=n%4,d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(o="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(o="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";i%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function bYe(r){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:r[1],s=q.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return t}function vf(r,t,n,s){let i=bYe(r.shape),a=r;for(let o=0;o<i.length;o++){let{inSize:u,windowSize:l,outSize:c}=i[o],h,d;n==="mean"?h=o===0?new jV({windowSize:l,inSize:u,batchSize:r.shape[0],outSize:c},u):new jV({windowSize:l,inSize:u,batchSize:r.shape[0],outSize:c}):h=new yYe({windowSize:l,inSize:u,batchSize:r.shape[0],outSize:c},n),d=a,a=s.runWebGLProgram(h,[a],t),d.dataId!==r.dataId&&s.disposeIntermediateTensorInfo(d)}return a}var xYe=class{constructor(r,t){this.variableNames=["A"];let n=new Array(r.length);for(let a=0;a<n.length;a++)n[a]=r[t[a]];this.outputShape=n,this.rank=n.length;let s=ln(this.rank),i=vYe(t);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}};function vYe(r){let t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let i=0;i<r.length;i++)s[r[i]]=n[i];return s.join()}var wYe=class{constructor(r,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(r.length);for(let c=0;c<n.length;c++)n[c]=r[t[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let s=ln(this.rank),i=nee("rc",this.rank),a=new Array(this.rank);for(let c=0;c<t.length;c++)a[t[c]]=i[c];let o=`vec2(${a.slice(-2).join()})`,u=`++${i[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function j_(r,t,n){let s=Re().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wYe(r.shape,t):new xYe(r.shape,t);return n.runWebGLProgram(s,[r],r.dtype)}function SYe(r,t,n,s){let i=t,a=r.shape.length,o=O.parseAxisParam(i,r.shape),u=o,l=q.getAxesPermutation(u,a),c=l!=null,h=r;c&&(h=j_(r,l,s),u=q.getInnerMostAxes(u.length,a)),q.assertAxesAreInnerMostDims("sum",u,a);let[d,p]=q.computeOutAndReduceShapes(h.shape,u),f=d;n&&(f=q.expandShapeToKeepDim(d,o));let m=O.sizeFromShape(p),g=O.sizeFromShape(r.shape)/m,y=gt({inputs:{x:h},attrs:{shape:[g,m]},backend:s}),b=VC(r.dtype),x=vf(y,b,"sum",s),w=gt({inputs:{x},attrs:{shape:f},backend:s});return s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(x),c&&s.disposeIntermediateTensorInfo(h),w}function q_(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s;return SYe(i,a,o,n)}var CYe={kernelName:nf,backendName:"webgl",kernelFunc:q_};function li(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{perm:a}=s,o=n,u=i.shape.length,l=new Array(u);for(let h=0;h<l.length;h++)l[h]=i.shape[a[h]];let c;if(o.shouldExecuteOnCPU([i])){let h=o.texData.get(i.dataId).values,d=pL(h,i.shape,i.dtype,a,l);c=o.makeTensorInfo(l,i.dtype);let p=o.texData.get(c.dataId);p.values=d}else c=j_(i,a,o);return c}var _Ye={kernelName:el,backendName:"webgl",kernelFunc:li},dee=1e3;function tS({a:r,b:t,transposeA:n,transposeB:s,backend:i,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:l=null}){let c=r.shape.length,h=t.shape.length,d=n?r.shape[c-2]:r.shape[c-1],p=s?t.shape[h-1]:t.shape[h-2],f=n?r.shape[c-1]:r.shape[c-2],m=s?t.shape[h-2]:t.shape[h-1],g=r.shape.slice(0,-2),y=t.shape.slice(0,-2),b=O.sizeFromShape(g),x=O.sizeFromShape(y),w=k0.assertAndGetBroadcastShape(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);O.assert(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${n} and transposeB=${s} must match.`);let v=n?[b,d,f]:[b,f,d],S=s?[x,m,p]:[x,p,m],E=gt({inputs:{x:r},backend:i,attrs:{shape:v}}),C=gt({inputs:{x:t},backend:i,attrs:{shape:S}}),I=[E,C],_=Math.max(b,x),A=n?E.shape[1]:E.shape[2],k=a!=null,N=o!=null,D=l==="leakyrelu",F=l!=null?sx(l,!0):null,P=k||N||D||F!=null,G;if((f===1||m===1)&&A>dee&&P===!1){let Z=E,ee=C;n&&(Z=li({inputs:{x:E},backend:i,attrs:{perm:[0,2,1]}}),I.push(Z)),s&&(ee=li({inputs:{x:C},backend:i,attrs:{perm:[0,2,1]}}),I.push(ee));let se=m!==1,re=m===1,J=Z;se&&(J=gt({inputs:{x:Z},backend:i,attrs:{shape:[_,A,1]}}),I.push(J));let le=m===1?2:1,he=ee;re&&(he=gt({inputs:{x:ee},backend:i,attrs:{shape:[_,1,A]}}),I.push(he));let xe=gL({inputs:{a:J,b:he},backend:i});G=q_({inputs:{x:xe},backend:i,attrs:{axis:le,keepDims:!0}}),I.push(xe)}else{let Z=va(r.dtype,t.dtype),ee=new hee(v,S,[_,f,m],n,s,k,F,N,D),se=[E,C];if(a!=null&&se.push(a),N&&se.push(o),D){let re=i.makeTensorInfo([],"float32",O.createScalarValue(u,"float32"));se.push(re),I.push(re)}G=i.runWebGLProgram(ee,se,Z)}let Y=gt({inputs:{x:G},backend:i,attrs:{shape:w}});I.push(G);for(let Z of I)i.disposeIntermediateTensorInfo(Z);return Y}function EYe(r){let{inputs:t,backend:n,attrs:s}=r,{a:i,b:a,bias:o,preluActivationWeights:u}=t,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:d}=s;return tS({a:i,b:a,transposeA:l,transposeB:c,backend:n,bias:o,preluActivationWeights:u,leakyreluAlpha:d,activation:h})}var IYe={kernelName:cd,backendName:"webgl",kernelFunc:EYe},qV="return abs(x);";function kYe(r){let{inputs:t,backend:n}=r,{x:s}=t;if(n.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){let a=n.texData.get(s.dataId),o=tee(a.values);return n.makeTensorInfo(s.shape,s.dtype,o)}let i;return Re().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Jl(s.shape,qV):i=new nu(s.shape,qV),n.runWebGLProgram(i,[s],s.dtype)}var NYe={kernelName:Eg,backendName:"webgl",kernelFunc:kYe},TYe=oo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,AYe=Rr({opSnippet:TYe}),DYe={kernelName:Hd,backendName:"webgl",kernelFunc:AYe},FYe=oo+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,$Ye=Rr({opSnippet:FYe}),RYe={kernelName:jd,backendName:"webgl",kernelFunc:$Ye},KV="return a + b;",OYe=Os({opSnippet:KV,packedOpSnippet:KV,supportsComplex:!0,cpuKernelImpl:WKe}),MYe={kernelName:Mc,backendName:"webgl",kernelFunc:OYe},LYe=class{constructor(r,t){this.outputShape=[],this.outputShape=r,this.variableNames=t.map((i,a)=>`T${a}`);let n=[];this.variableNames.forEach(i=>{n.push(`float v${i} = get${i}AtOutCoords();`)});let s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}},PYe=class{constructor(r,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.variableNames=t.map((i,a)=>`T${a}`);let n=[];this.variableNames.forEach(i=>{n.push(`vec4 v${i} = get${i}AtOutCoords();`)});let s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}};function Fw(r){let{inputs:t,backend:n}=r,s=t;if(s.length===1)return ia({inputs:{x:s[0]},backend:n});if(s.length>Re().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(s.length/2),l=Fw({inputs:s.slice(0,u),backend:n}),c=Fw({inputs:s.slice(u),backend:n});return Fw({inputs:[l,c],backend:n})}let i=s.map(u=>u.dtype).reduce((u,l)=>va(u,l)),a=s.map(u=>u.shape),o=Re().getBool("WEBGL_PACK")?new PYe(s[0].shape,a):new LYe(s[0].shape,a);return n.runWebGLProgram(o,s,i)}var BYe={kernelName:qd,backendName:"webgl",kernelFunc:Fw};function VYe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s,u=i.shape.length,l=O.parseAxisParam(a,i.shape),c=l,h=q.getAxesPermutation(c,u),d=i;h!=null&&(d=li({inputs:{x:i},backend:n,attrs:{perm:h}}),c=q.getInnerMostAxes(c.length,u)),q.assertAxesAreInnerMostDims("all",c,u);let[p,f]=q.computeOutAndReduceShapes(d.shape,c),m=O.sizeFromShape(f),g=gt({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=vf(g,g.dtype,"all",n),b;if(o){let x=q.expandShapeToKeepDim(p,l);b=gt({inputs:{x:y},backend:n,attrs:{shape:x}})}else b=gt({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),h!=null&&n.disposeIntermediateTensorInfo(d),b}var zYe={kernelName:Ig,backendName:"webgl",kernelFunc:VYe};function UYe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s,u=i.shape.length,l=O.parseAxisParam(a,i.shape),c=l,h=q.getAxesPermutation(c,u),d=i;h!=null&&(d=li({inputs:{x:i},backend:n,attrs:{perm:h}}),c=q.getInnerMostAxes(c.length,u)),q.assertAxesAreInnerMostDims("any",c,u);let[p,f]=q.computeOutAndReduceShapes(d.shape,c),m=O.sizeFromShape(f),g=gt({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=vf(g,g.dtype,"any",n),b;if(o){let x=q.expandShapeToKeepDim(p,l);b=gt({inputs:{x:y},backend:n,attrs:{shape:x}})}else b=gt({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),h!=null&&n.disposeIntermediateTensorInfo(d),b}var WYe={kernelName:kg,backendName:"webgl",kernelFunc:UYe},GYe=class{constructor(r,t,n){this.variableNames=["A"];let{windowSize:s,batchSize:i,outSize:a}=r;n||this.variableNames.push("bestIndicesA"),this.outputShape=[i,a];let o=t==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},HYe=class{constructor(r,t,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,O.assert(r.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let i=r[r.length-1],a=Math.ceil(i/t);this.outputShape=r.slice(0,-1),a>1&&this.outputShape.push(a),s||this.variableNames.push("bestIndicesA");let o=this.outputShape,u=o.length,l=ln(u),c=si("coords",u),h,d;if(a===1){d=u+1;let C=ln(d);h=`
        ${C} sourceLocR = ${C}(${c.join()}, 0);
        ++${c[u-1]};
        ${C} sourceLocG = ${C}(${c.join()}, 0);
        ++${c[u-2]};
        ${C} sourceLocA = ${C}(${c.join()}, 0);
        --${c[u-1]};
        ${C} sourceLocB = ${C}(${c.join()}, 0);
        --${c[u-2]};`}else d=u,h=`
        ${l} sourceLocR = coords;
        ++${c[u-1]};
        ${l} sourceLocG = coords;
        ++${c[u-2]};
        ${l} sourceLocA = coords;
        --${c[u-1]};
        ${l} sourceLocB = coords;
        --${c[u-2]};`;let p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],m=p.map(C=>"int "+C),g=si("sourceLocR",d-1).concat("inIdx.r"),y=si("sourceLocG",d-1).concat("inIdx.g"),b=si("sourceLocB",d-1).concat("inIdx.b"),x=si("sourceLocA",d-1).concat("inIdx.a"),w=n==="max"?"greaterThan":"lessThan",v=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${x.join()})));`,S=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,E=s?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${E}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u-1]} < ${o[u-1]-1};
        bool hasNextRow = ${c[u-2]} < ${o[u-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${S};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${S};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function pee(r,t,n,s=null){let i=t.shape[0],a=t.shape[1];s!=null&&(i=s.shape[0],a=s.shape[1]);let o=q.computeOptimalWindowSize(a),u={windowSize:o,inSize:a,batchSize:i,outSize:Math.ceil(a/o)},l=new GYe(u,n,s==null),c=[t];s!=null&&c.push(s);let h=r.runWebGLProgram(l,c,"int32");if(h.shape[1]===1)return h;let d=pee(r,t,n,h);return r.disposeIntermediateTensorInfo(h),d}function fee(r,t,n,s=null){let i=s!=null?s.shape:t.shape,a=i[i.length-1],o=q.computeOptimalWindowSize(a),u=new HYe(i,o,n,s==null),l=s==null?[t]:[t,s],c=r.runWebGLProgram(u,l,"int32");if(c.shape.length===t.shape.length){let h=fee(r,t,n,c);return r.disposeIntermediateTensorInfo(c),h}return c}function mee(r,t,n,s){let i=[n];if(q.assertAxesAreInnerMostDims("arg"+s.charAt(0).toUpperCase()+s.slice(1),i,t.shape.length),!Re().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let a=[],o=r.texData.get(t.dataId),u=o!==null&&o.isPacked,l=t;u&&(l=r.unpackTensor(t),a.push(l));let[c,h]=q.computeOutAndReduceShapes(l.shape,i),d=O.sizeFromShape(h),p=gt({inputs:{x:l},backend:r,attrs:{shape:[-1,d]}});a.push(p);let f=pee(r,p,s);a.push(f);let m=gt({inputs:{x:f},backend:r,attrs:{shape:c}});return a.forEach(g=>r.disposeIntermediateTensorInfo(g)),m}return fee(r,t,s)}function jYe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a}=s,o=O.parseAxisParam(a,i.shape),u=q.getAxesPermutation(o,i.shape.length),l=i,c=[];u!=null&&(l=li({inputs:{x:i},backend:n,attrs:{perm:u}}),c.push(l),o=q.getInnerMostAxes(o.length,l.shape.length)),q.assertAxesAreInnerMostDims("argMax",[o[0]],l.shape.length);let h=mee(n,l,o[0],"max");return c.forEach(d=>n.disposeIntermediateTensorInfo(d)),h}var qYe={kernelName:Ng,backendName:"webgl",kernelFunc:jYe};function KYe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a}=s,o=O.parseAxisParam(a,i.shape),u=q.getAxesPermutation(o,i.shape.length),l=i,c=[];u!=null&&(l=li({inputs:{x:i},backend:n,attrs:{perm:u}}),c.push(l),o=q.getInnerMostAxes(o.length,l.shape.length)),q.assertAxesAreInnerMostDims("argMin",[o[0]],l.shape.length);let h=mee(n,l,o[0],"min");return c.forEach(d=>n.disposeIntermediateTensorInfo(d)),h}var XYe={kernelName:Tg,backendName:"webgl",kernelFunc:KYe},YYe=oo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,ZYe=Rr({opSnippet:YYe}),JYe={kernelName:Kd,backendName:"webgl",kernelFunc:ZYe},QYe=oo+"return log(x + sqrt(x * x + 1.0));",eZe=Rr({opSnippet:QYe}),tZe={kernelName:Xd,backendName:"webgl",kernelFunc:eZe},rZe=oo+`
  return atan(x);
`,nZe=Rr({opSnippet:rZe}),sZe={kernelName:Yd,backendName:"webgl",kernelFunc:nZe},iZe=mL+`
  return atan(a, b);
`,aZe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xf+`
  return result;
`,oZe=Os({opSnippet:iZe,packedOpSnippet:aZe}),uZe={kernelName:Jd,backendName:"webgl",kernelFunc:oZe},lZe=oo+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,cZe=Rr({opSnippet:lZe}),hZe={kernelName:Zd,backendName:"webgl",kernelFunc:cZe},ix=class{constructor(r,t,n,s=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=r.filterWidth,o=r.strideHeight,u=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left;this.outputShape=r.outShape;let m=t==="avg",g=`((batch  * ${r.inHeight} + xR) * ${r.inWidth} + xC) * ${r.inChannels} + d`,y=`(xR * ${r.inWidth} + xC) * ${r.inChannels} + d`,b="0.0";if(m||(b="-1.0 / 1e-20"),n){let C=">=";this.userCode=`
        const ivec2 strides = ivec2(${o}, ${u});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${r.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${r.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${C} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?i?g:y:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let x="max",w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / max(count, 1.0)");let v=Math.floor(a/4)*4,S=a%4,E=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${u});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${r.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${r.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${E}
          }

          int xC = xCCorner + ${v};
          if (${S===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${S===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${S===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${E}
          }
        }
        setOutput(${w});
      }
    `}},yL=class{constructor(r,t,n,s=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=r.filterWidth,o=r.strideDepth,u=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,h=r.dilationHeight,d=r.dilationWidth,p=r.effectiveFilterDepth,f=r.effectiveFilterHeight,m=r.effectiveFilterWidth,g=r.padInfo.front,y=r.padInfo.top,b=r.padInfo.left;this.outputShape=r.outShape;let x=t==="avg",w="0.0";if(x||(w="-1.0 / 1e-20"),n){let _=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${r.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${r.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${r.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${_} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?i?`(((batch * ${r.inDepth} + xD) * ${r.inHeight} + xR) * ${r.inWidth} + xC) * ${r.inChannels} + ch`:`((xD * ${r.inHeight} + xR) * ${r.inWidth} + xC) * ${r.inChannels} + ch`:`wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",S=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(S="avgValue / max(count, 1.0)");let E=Math.floor(a/4)*4,C=a%4,I=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${r.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${r.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${r.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${E}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${I}
            }

            int xC = xCCorner + ${E};
            if (${C===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${I}
            } else if (${C===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${I}
            } else if (${C===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${I}
            }
          }
        }
        setOutput(${S});
      }
    `}};function dZe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t;B0(i,"avgPool");let{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=s,c=1;O.assert(q.eitherStridesOrDilationsAreOne(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);let h=q.computePool2DInfo(i.shape,a,o,c,u,l);if(h.filterWidth===1&&h.filterHeight===1&&O.arraysEqual(h.inShape,h.outShape))return ia({inputs:{x:i},backend:n});let d=new ix(h,"avg",!1);return n.runWebGLProgram(d,[i],"float32")}var pZe={kernelName:Qd,backendName:"webgl",kernelFunc:dZe};function fZe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l,dataFormat:c}=s,h=[1,1,1],d=q.computePool3DInfo(i.shape,a,o,h,u,l,c),p=new yL(d,"avg",!1);return n.runWebGLProgram(p,[i],"float32")}var mZe={kernelName:Ag,backendName:"webgl",kernelFunc:fZe},gZe=class{constructor(r){this.variableNames=["dy"],this.outputShape=r.inShape;let t=r.filterHeight,n=r.filterWidth,s=r.strideHeight,i=r.strideWidth,a=r.dilationHeight,o=r.dilationWidth,u=r.effectiveFilterHeight,l=r.effectiveFilterWidth,c=u-1-r.padInfo.top,h=l-1-r.padInfo.left,d=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${r.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},yZe=class{constructor(r){this.variableNames=["dy"],this.outputShape=r.inShape;let t=r.filterDepth,n=r.filterHeight,s=r.filterWidth,i=r.strideDepth,a=r.strideHeight,o=r.strideWidth,u=r.dilationDepth,l=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterDepth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,f=h-1-r.padInfo.front,m=d-1-r.padInfo.top,g=p-1-r.padInfo.left,y=1/(t*n*s);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${r.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${r.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function bZe(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,o=a,{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=s,d=[1,1,1],p=q.computePool3DInfo(o.shape,u,l,d,c,h),f=new yZe(p);return n.runWebGLProgram(f,[i],o.dtype)}var xZe={kernelName:Lx,backendName:"webgl",kernelFunc:bZe};function vZe(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,o=a;B0([i,a],"avgPoolGrad");let{filterSize:u,strides:l,pad:c}=s,h=q.computePool2DInfo(o.shape,u,l,1,c),d=new gZe(h);return n.runWebGLProgram(d,[i],o.dtype)}var wZe={kernelName:Mx,backendName:"webgl",kernelFunc:vZe};function SZe(r){let{inputs:t,backend:n,attrs:s}=r,{a:i,b:a}=t,{transposeA:o,transposeB:u}=s;return tS({a:i,b:a,transposeA:o,transposeB:u,backend:n})}var CZe={kernelName:ep,backendName:"webgl",kernelFunc:SZe},_Ze=class{constructor(r,t,n,s,i,a){this.outputShape=[],this.variableNames=["x","mean","variance"],q.assertAndGetBroadcastShape(r,t),q.assertAndGetBroadcastShape(r,n);let o="0.0";s!=null&&(q.assertAndGetBroadcastShape(r,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="1.0";i!=null&&(q.assertAndGetBroadcastShape(r,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=r,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},EZe=class{constructor(r,t,n,s,i,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],q.assertAndGetBroadcastShape(r,t),q.assertAndGetBroadcastShape(r,n);let o="vec4(0.0)";s!=null&&(q.assertAndGetBroadcastShape(r,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="vec4(1.0)";i!=null&&(q.assertAndGetBroadcastShape(r,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=r,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}},IZe=({inputs:r,backend:t,attrs:n})=>{let{x:s,mean:i,variance:a,offset:o,scale:u}=r;O.assert(i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O.assert(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O.assert(u==null||i.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let c=[s,i,a],h=null;o!=null&&(h=o.shape,c.push(o));let d=null;u!=null&&(d=u.shape,c.push(u));let p=Re().getBool("WEBGL_PACK_NORMALIZATION")?new EZe(s.shape,i.shape,a.shape,h,d,l):new _Ze(s.shape,i.shape,a.shape,h,d,l);return t.runWebGLProgram(p,c,c[0].dtype)},kZe={kernelName:bp,backendName:"webgl",kernelFunc:IZe},NZe=class{constructor(r){this.variableNames=["source"],this.outputShape=r,this.rank=r.length;let t=ln(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=TZe(this.rank),s,i=r.map((a,o)=>`sourceLoc.${$N[o]} = start[${o}] + coords.${$N[o]};`);s=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${n}));
      }
    `}},$N=["x","y","z","w","u","v"];function TZe(r){if(r===1)return"sourceLoc";if(r<=6)return $N.slice(0,r).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var AZe=class{constructor(r){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.rank=r.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=ln(this.rank),n=si("coords",this.rank),s=si("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,a=`getChannel(getSource(${s.join()}), ${i})`,o=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${r[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${a};
        --${s[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${r[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${r[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${a};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${r.map((c,h)=>`start[${h}]`).join()});`:r.map((c,h)=>`${s[h]} = ${n[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${o}
        ${u}
        setOutput(result);
      }
    `}};function DZe(r,t,n,s){let i=s.texData.get(r.dataId),a=s.makeTensorInfo(n,r.dtype),o=s.texData.get(a.dataId);Object.assign(o,i),o.refCount=1,o.shape=n,o.dtype=r.dtype;let u=is.computeFlatOffset(t,O.computeStrides(r.shape));i.slice&&(u+=i.slice.flatOffset),o.slice={flatOffset:u,origDataId:i.slice&&i.slice.origDataId||r.dataId};let l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),a}function j0(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{begin:a,size:o}=s,[u,l]=is.parseSliceParams(i,a,o);if(is.assertParamsValid(i,u,l),O.sizeFromShape(l)===0)return n.makeTensorInfo(l,i.dtype,[]);if(n.shouldExecuteOnCPU([i])||i.dtype==="string"){let d=n.texData.get(i.dataId),p=wXe(d.values,u,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,p)}let{isPacked:c}=n.texData.get(i.dataId),h=is.isSliceContinous(i.shape,u,l);if(c||!h){let d=Re().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new AZe(l):new NZe(l),p=[u];return n.runWebGLProgram(d,[i],i.dtype,p)}return n.uploadToGPU(i.dataId),DZe(i,u,l,n)}var FZe={kernelName:g0,backendName:"webgl",kernelFunc:j0},$Ze=r=>{let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{blockShape:a,crops:o}=s;O.assert(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let u=a.reduce((x,w)=>x*w),l=q.getReshaped(i.shape,a,u),c=q.getPermuted(l.length,a.length),h=q.getReshapedPermuted(i.shape,a,u),d=q.getSliceBeginCoords(o,a.length),p=q.getSliceSize(h,o,a.length),f=[],m=gt({inputs:{x:i},backend:n,attrs:{shape:l}}),g=li({inputs:{x:m},backend:n,attrs:{perm:c}}),y=gt({inputs:{x:g},backend:n,attrs:{shape:h}}),b=j0({inputs:{x:y},backend:n,attrs:{begin:d,size:p}});return f.push(m),f.push(g),f.push(y),f.forEach(x=>n.disposeIntermediateTensorInfo(x)),b},RZe={kernelName:Dg,backendName:"webgl",kernelFunc:$Ze};function OZe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,weights:a}=t,{size:o}=s,u=n.readSync(i.dataId),l=n.readSync(a.dataId),c=eee(u,l,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,c)}var MZe={kernelName:Fg,backendName:"webgl",kernelFunc:OZe},LZe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,PZe=`
  return float(int(a.r) & int(b.r));
`;function BZe(r){let{inputs:t,backend:n}=r,{a:s,b:i}=t,a=Re().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Re().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([s,i])||o===1){let l=n.texData.get(s.dataId).values,c=n.texData.get(i.dataId).values,[h,d]=HKe(s.shape,i.shape,l,c,s.dtype),p=n.makeTensorInfo(d,s.dtype),f=n.texData.get(p.dataId);return f.values=h,p}let u;return a?u=new G0(LZe,s.shape,i.shape,!1):u=new kd(PZe,s.shape,i.shape),n.runWebGLProgram(u,[s,i],s.dtype)}var VZe={kernelName:$g,backendName:"webgl",kernelFunc:BZe};function zZe(r){let{inputs:t,backend:n}=r,{s0:s,s1:i}=t,a=n.readSync(s.dataId),o=n.readSync(i.dataId),u=q.assertAndGetBroadcastShape(Array.from(a),Array.from(o));return n.makeTensorInfo([u.length],"int32",Int32Array.from(u))}var UZe={kernelName:Px,backendName:"webgl",kernelFunc:zZe},WZe="return float(a != b);",gee=Os({opSnippet:WZe,cpuKernelImpl:dXe,dtype:"bool"}),GZe={kernelName:n0,backendName:"webgl",kernelFunc:gee};function Rv(r){let{inputs:t,backend:n}=r,{input:s}=t,i=n.texData.get(s.dataId);return ia({inputs:{x:i.complexTensorInfos.real},backend:n})}var HZe={kernelName:PC,backendName:"webgl",kernelFunc:Rv},jZe="return float(int(x));";function qZe(r,t){let n=new nu(r.shape,jZe),s=t.runWebGLProgram(n,[r],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function RN(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{dtype:a}=s;if(a==="complex64"){if(i.dtype==="complex64")return ia({inputs:{x:i},backend:n});let o=On(i.shape),u=RN({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),l=jc({inputs:{real:u,imag:o},backend:n});return o.dispose(),n.disposeIntermediateTensorInfo(u),l}if(i.dtype==="complex64"){let o=Rv({inputs:{input:i},backend:n}),u=RN({inputs:{x:o},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(o),u}if(!O.hasEncodingLoss(i.dtype,a)){let o=ia({inputs:{x:i},backend:n});return{dataId:o.dataId,shape:o.shape,dtype:a}}if(n.shouldExecuteOnCPU([i])){let o=n.texData.get(i.dataId).values,[u,l,c]=jKe(o,i.shape,i.dtype,a);return n.makeTensorInfo(u,l,c)}if(a==="int32")return qZe(i,n);if(a==="bool"){let o=n.makeTensorInfo([],"bool",O.getTypedArrayFromDType("bool",1)),u=gee({inputs:{a:i,b:o},backend:n});return n.disposeIntermediateTensorInfo(o),u}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`)}var KZe={kernelName:tp,backendName:"webgl",kernelFunc:RN},XV="return ceil(x);",XZe=Rr({opSnippet:XV,packedOpSnippet:XV,cpuKernelImpl:qKe}),YZe={kernelName:rp,backendName:"webgl",kernelFunc:XZe},ZZe=class{constructor(r){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=r,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},JZe=class{constructor(r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=r,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function QZe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{clipValueMin:a,clipValueMax:o}=s,u;Re().getBool("WEBGL_PACK_CLIP")?u=new JZe(i.shape):u=new ZZe(i.shape);let l=[[a],[o]];return n.runWebGLProgram(u,[i],i.dtype,l)}var eJe={kernelName:Lc,backendName:"webgl",kernelFunc:QZe},tJe=class{constructor(r){this.variableNames=["real","imag"],this.outputShape=r,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function YV(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}function rJe(r){let{inputs:t,backend:n}=r,{x:s}=t,i=n.texData.get(s.dataId),a=new tJe(s.shape),o=[YV(s,i.complexTensorInfos.real),YV(s,i.complexTensorInfos.imag)];return n.runWebGLProgram(a,o,o[0].dtype)}var nJe={kernelName:Bx,backendName:"webgl",kernelFunc:rJe},sJe=class{constructor(r){this.outputShape=[],this.outputShape=q.computeOutShape(r,1),this.variableNames=r.map((a,o)=>`T${o}`);let t=new Array(r.length-1);t[0]=r[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+r[a][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){let o=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${o}));`)}let s=t.length,i=t[t.length-1];n.push(`else setOutput(getT${s}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},iJe=class{constructor(r,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=q.computeOutShape(r,t);let n=this.outputShape,s=n.length,i=ln(s),a=si("coords",s),o=["x","y","z","w","u","v"].slice(0,s);this.variableNames=r.map((m,g)=>`T${g}`);let u=new Array(r.length-1);u[0]=r[0][t];for(let m=1;m<u.length;m++)u[m]=u[m-1]+r[m][t];let l=o[t],c=o.slice(-2),h=o.join(),d=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;for(let m=1;m<u.length;m++){let g=u[m-1];d+=`
        if (${l} < ${u[m]}  && ${l} >= ${u[m-1]}) {
          return getChannel(
            getT${m}(${U1(o,l,g)}),
            vec2(${U1(c,l,g)}));
        }`}let p=u.length,f=u[u.length-1];d+=`
        return getChannel(
          getT${p}(${U1(o,l,f)}),
          vec2(${U1(c,l,f)}));`,this.userCode=`
      float getValue(${o.map(m=>"int "+m)}) {
        ${d}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[s-1]} = ${a[s-1]} + 1;
        if (${a[s-1]} < ${n[s-1]}) {
          result.g = getValue(${a});
        }

        ${a[s-2]} = ${a[s-2]} + 1;
        if (${a[s-2]} < ${n[s-2]}) {
          result.a = getValue(${a});
        }

        ${a[s-1]} = ${a[s-1]} - 1;
        if (${a[s-2]} < ${n[s-2]} &&
            ${a[s-1]} < ${n[s-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function U1(r,t,n){let s=r.indexOf(t);return r.map((i,a)=>a===s?`${i} - ${n}`:i).join()}function K_(r){let{inputs:t,backend:n}=r,{input:s}=t,i=n.texData.get(s.dataId);return ia({inputs:{x:i.complexTensorInfos.imag},backend:n})}var aJe={kernelName:RC,backendName:"webgl",kernelFunc:K_};function Py(r,t,n){let s=r[0].dtype;if(s==="complex64"){let f=r.map(x=>Rv({inputs:{input:x},backend:n})),m=r.map(x=>K_({inputs:{input:x},backend:n})),g=Py(f,t,n),y=Py(m,t,n),b=jc({inputs:{real:g,imag:y},backend:n});return f.forEach(x=>n.disposeIntermediateTensorInfo(x)),m.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),b}let i=n.shouldExecuteOnCPU(r);if(s==="string"&&(i=!0),i){let f=r.map(v=>{let S=[-1,O.sizeFromShape(v.shape.slice(t))];return gt({inputs:{x:v},backend:n,attrs:{shape:S}})}),m=f.map(v=>({vals:n.readSync(v.dataId),shape:v.shape})),g=q.computeOutShape(f.map(v=>v.shape),1),y=f[0].shape[0]===1,b=KKe(m,g,s,y),x=q.computeOutShape(r.map(v=>v.shape),t),w=n.makeTensorInfo(x,s,b);return f.forEach(v=>n.disposeIntermediateTensorInfo(v)),w}let a=r.filter(f=>O.sizeFromShape(f.shape)>0),o=Re().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){let f=o?new nu(r[0].shape,Pl):new Jl(r[0].shape,Pl);return n.runWebGLProgram(f,r,s)}let u=Re().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>u){let f=[];for(let g=0;g<a.length;g+=u){let y=a.slice(g,g+u);f.push(Py(y,t,n))}let m=Py(f,t,n);for(let g of f)n.disposeIntermediateTensorInfo(g);return m}if(o){let f=new iJe(a.map(m=>m.shape),t);return n.runWebGLProgram(f,a,s)}let{tensors2D:l,outShape:c}=oJe(a,t,n),h=new sJe(l.map(f=>f.shape)),d=n.runWebGLProgram(h,l,s);l.forEach(f=>n.disposeIntermediateTensorInfo(f));let p=gt({inputs:{x:d},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(d),p}function oJe(r,t,n){let s=q.computeOutShape(r.map(i=>i.shape),t);return{tensors2D:r.map(i=>gt({inputs:{x:i},attrs:{shape:[-1,O.sizeFromShape(i.shape.slice(t))]},backend:n})),outShape:s}}function yee(r){let{inputs:t,backend:n,attrs:s}=r,{axis:i}=s,a=O.parseAxisParam(i,t[0].shape)[0],o=t.map(c=>c.shape);q.assertParamsConsistent(o,a);let u=q.computeOutShape(t.map(c=>c.shape),a);if(O.sizeFromShape(u)===0)return n.makeTensorInfo(u,t[0].dtype,[]);let l=t.filter(c=>O.sizeFromShape(c.shape)>0);return l.length===1?ia({inputs:{x:l[0]},backend:n}):Py(l,a,n)}var uJe={kernelName:Rg,backendName:"webgl",kernelFunc:yee},bee=class{constructor(r,t=!1,n=null,s=!1,i=!1){this.variableNames=["x","W"],this.outputShape=r.outShape;let a=r.padInfo.top,o=r.padInfo.left,u=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,h=r.dilationWidth,d=r.filterHeight,p=r.filterWidth,f=Math.floor(r.inChannels/4)*4,m=r.inChannels%4,g=r.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,x=g?3:1,w="",v="";n&&(s?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:i?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:w=`
          float activation(float x) {
            ${n}
          }
        `,v="result = activation(result);");let S=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${r.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${r.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${S}
        ${v}
        setOutput(result);
      }
    `}},lJe=class{constructor(r){this.variableNames=["x","W"],this.outputShape=r.outShape;let t=r.padInfo.front,n=r.padInfo.top,s=r.padInfo.left,i=r.strideDepth,a=r.strideHeight,o=r.strideWidth,u=r.dilationDepth,l=r.dilationHeight,c=r.dilationWidth,h=r.filterDepth,d=r.filterHeight,p=r.filterWidth,f=Math.floor(r.inChannels/4)*4,m=r.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${a}, ${o});
      const ivec3 pads = ivec3(${t}, ${n}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${r.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${r.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${r.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},xee=class{constructor(r,t=!1,n=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=r.outShape,this.enableShapeUniforms=qs(this.outputShape.length);let a=r.padInfo.left,o=r.strideWidth,u=r.dilationWidth,l=r.filterHeight,c=r.filterWidth,h=c,d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)d+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${r.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)d+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(h+1)/2;g++){let y=g*2;if(d+=`
           xC = xCCorner + ${y*u};
           `,o===1){if(y<c&&(a%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,u===1&&y>0?d+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){let b=a%2===0?O.nearestLargerEven(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,u>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:d+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?d+=`
                     xC${y+1} = xTexelC${y};
                     `:d+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(a%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(d+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(d+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${r.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(d+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${r.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",f="";n&&(s?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:i?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:p=`vec4 activation(vec4 x) {
           ${n}
         }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${f}
         setOutput(result);
       }
     `}},cJe=class{constructor(r,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=r,this.enableShapeUniforms=qs(this.outputShape.length);let{dataFormat:n}=t,s=mi(),i=n==="channelsLast",a=i?1:2,o=i?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${r[2]} && pos < ${r[1]}) {`,l="";for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)l+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${s.output} = result;
      }
    `}};function rS(r,t){let n=r.length;return n>=3?t?[...r.slice(0,-3),r[n-3]*r[n-2],r[n-1]]:[...r.slice(0,-3),r[n-3],r[n-2]*r[n-1]]:!t&&n===1&&r[0]>1?[r[0],1]:null}function vee({x:r,filter:t,convInfo:n,backend:s,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){let l=r.shape,c=s.texData.get(r.dataId),h=n.inChannels,d=l[0]*l[1]*l[2],p=n.outChannels,f=n.dataFormat==="channelsLast",m=!1,g=!1,y,b=[];if(a!=null){let x=rS(a.shape,f);x!=null&&(a=gt({inputs:{x:a},backend:s,attrs:{shape:x}}),b.push(a))}if(i!=null){let x=rS(i.shape,f);x!=null&&(i=gt({inputs:{x:i},backend:s,attrs:{shape:x}}),b.push(i))}if(!((d===1||p===1)&&h>dee)&&c.isPacked&&f&&c.texture!=null&&l[2]%2!==0&&O.arraysEqual(c.shape.slice(-3),l.slice(-3))){let x=l[0]*l[1]*(l[2]+1),w={dataId:r.dataId,shape:[1,x,n.inChannels],dtype:r.dtype},v=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,O.assert(nx(c.shape,w.shape),()=>`packed reshape ${c.shape} to ${w.shape} isn't free`);let S=gt({inputs:{x:t},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});b.push(S);let E=tS({a:w,b:S,backend:s,transposeA:m,transposeB:g,bias:i,activation:u,preluActivationWeights:a,leakyreluAlpha:o}),C=s.texData.get(E.dataId);O.assert(C.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=v,C.shape=n.outShape,y=ia({inputs:{x:E},backend:s}),y.shape=n.outShape,b.push(E)}else{let x=n.outHeight*n.outWidth,w=gt({inputs:{x:r},backend:s,attrs:{shape:f?[n.batchSize,x,n.inChannels]:[n.batchSize,n.inChannels,x]}}),v=gt({inputs:{x:t},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}}),S=tS({a:f?w:v,b:f?v:w,transposeA:!f,transposeB:g,backend:s,bias:i,activation:u,preluActivationWeights:a,leakyreluAlpha:o});y=gt({inputs:{x:S},backend:s,attrs:{shape:n.outShape}}),b.push(w),b.push(v),b.push(S)}for(let x of b)s.disposeIntermediateTensorInfo(x);return y}function wee({x:r,filter:t,convInfo:n,backend:s,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){let{filterWidth:l,filterHeight:c,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=n,m=f==="channelsLast",g=l*c*h,y=p*d,b=[n.batchSize,g,y],x=!0,w=!1,v=[];if(a!=null){let Z=rS(a.shape,m);Z!=null&&(a=gt({inputs:{x:a},backend:s,attrs:{shape:Z}}),v.push(a))}if(i!=null){let Z=rS(i.shape,m);Z!=null&&(i=gt({inputs:{x:i},backend:s,attrs:{shape:Z}}),v.push(i))}let S=gt({inputs:{x:t},backend:s,attrs:{shape:[1,g,O.sizeFromShape(t.shape)/g]}});v.push(S);let E=new cJe(b,n),C=[r.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],I=s.runWebGLProgram(E,[r],"float32",C),_=gt({inputs:{x:I},backend:s,attrs:{shape:b}});v.push(I),v.push(_);let A=i!=null,k=a!=null,N=u==="leakyrelu",D=u?sx(u,!0):null,F=new hee(m?_.shape:S.shape,m?S.shape:_.shape,m?[n.batchSize,y,n.outChannels]:[n.batchSize,n.outChannels,y],x,w,A,D,k,N),P=m?[_,S]:[S,_];if(i&&P.push(i),k&&P.push(a),N){let Z=s.makeTensorInfo([],"float32",O.createScalarValue(o,"float32"));P.push(Z),v.push(Z)}let G=s.runWebGLProgram(F,P,"float32"),Y=gt({inputs:{x:G},backend:s,attrs:{shape:n.outShape}});v.push(G);for(let Z of v)s.disposeIntermediateTensorInfo(Z);return Y}function hJe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dataFormat:l,dilations:c,dimRoundingMode:h}=s,d=q.convertConv2DDataFormat(l),p=q.computeConv2DInfo(i.shape,a.shape,o,c,u,h,!1,d),f;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))f=vee({x:i,filter:a,convInfo:p,backend:n});else if(p.strideWidth<=2&&d==="channelsLast"&&Re().getBool("WEBGL_EXP_CONV")){let g=new xee(p),y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];f=n.runWebGLProgram(g,[i,a],"float32",y)}else if(Re().getBool("WEBGL_CONV_IM2COL"))f=wee({x:i,filter:a,convInfo:p,backend:n});else{let g=new bee(p);f=n.runWebGLProgram(g,[i,a],"float32")}let m=gt({inputs:{x:f},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(f),m}var dJe={kernelName:np,backendName:"webgl",kernelFunc:hJe},pJe=class{constructor(r){this.variableNames=["x","dy"],this.outputShape=r.filterShape;let t=r.strideHeight,n=r.strideWidth,s=r.padInfo.top,i=r.padInfo.left,a=r.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${r.batchSize}; b++) {
          for (int yR = 0; yR < ${r.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${r.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${r.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${i};

              if (xC < 0 || xC >= ${r.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},fJe=class{constructor(r){this.variableNames=["dy","W"],this.outputShape=r.inShape;let t=r.filterHeight,n=r.filterWidth,s=r.strideHeight,i=r.strideWidth,a=r.dataFormat==="channelsLast",o=t-1-r.padInfo.top,u=n-1-r.padInfo.left,l=a?1:2,c=a?2:3,h=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${r.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${r.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},mJe=class{constructor(r){this.variableNames=["x","dy"],this.outputShape=r.filterShape;let t=r.strideDepth,n=r.strideHeight,s=r.strideWidth,i=r.padInfo.front,a=r.padInfo.top,o=r.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${r.batchSize}; b++) {
          for (int yF = 0; yF < ${r.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${r.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${r.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${r.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${r.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${o};

                if (xC < 0 || xC >= ${r.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},gJe=class{constructor(r){this.variableNames=["dy","W"],this.outputShape=r.inShape;let t=r.filterDepth,n=r.filterHeight,s=r.filterWidth,i=r.strideDepth,a=r.strideHeight,o=r.strideWidth,u=t-1-r.padInfo.front,l=n-1-r.padInfo.top,c=s-1-r.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${r.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${r.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${r.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function yJe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,dy:a}=t,{strides:o,pad:u,dataFormat:l,dimRoundingMode:c,filterShape:h}=s,d=q.convertConv2DDataFormat(l),p=q.computeConv2DInfo(i.shape,h,o,1,u,c,!1,d),f=new pJe(p);return n.runWebGLProgram(f,[i,a],"float32")}var bJe={kernelName:kC,backendName:"webgl",kernelFunc:yJe},xJe=class{constructor(r){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=r.inShape,this.enableShapeUniforms=qs(this.outputShape.length);let t=r.filterHeight,n=r.filterWidth,s=t-1-r.padInfo.top,i=n-1-r.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${r.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${r.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${r.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${r.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${r.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${r.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function vJe(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,filter:a}=t,{inputShape:o,strides:u,pad:l,dataFormat:c,dimRoundingMode:h}=s,d=q.convertConv2DDataFormat(c),p=q.computeConv2DInfo(o,a.shape,u,1,l,h,!1,d);if(Re().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){let f=[[p.strideHeight,p.strideWidth]],m=new xJe(p);return n.runWebGLProgram(m,[i,a],"float32",f)}else{let f=new fJe(p);return n.runWebGLProgram(f,[i,a],"float32")}}var wJe={kernelName:sp,backendName:"webgl",kernelFunc:vJe};function SJe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dilations:l}=s,c=q.computeConv3DInfo(i.shape,a.shape,o,l,u),h=new lJe(c);return n.runWebGLProgram(h,[i,a],"float32")}var CJe={kernelName:ip,backendName:"webgl",kernelFunc:SJe};function _Je(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,dy:a}=t,{strides:o,pad:u,filterShape:l}=s,c=q.computeConv3DInfo(i.shape,l,o,1,u),h=new mJe(c);return n.runWebGLProgram(h,[i,a],"float32")}var EJe={kernelName:Og,backendName:"webgl",kernelFunc:_Je};function IJe(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,filter:a}=t,{pad:o,strides:u,inputShape:l}=s,c=q.computeConv3DInfo(l,a.shape,u,1,o),h=new gJe(c);return n.runWebGLProgram(h,[i,a],"float32")}var kJe={kernelName:Mg,backendName:"webgl",kernelFunc:IJe},NJe=H0+`
  return cos(x);
`,TJe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${xf}
  return result;
`,AJe=Rr({opSnippet:NJe,packedOpSnippet:TJe}),DJe={kernelName:ap,backendName:"webgl",kernelFunc:AJe},FJe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,$Je=Rr({opSnippet:FJe}),RJe={kernelName:op,backendName:"webgl",kernelFunc:$Je},OJe=class{constructor(r,t,n,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[a,o,u,l]=r,[c]=t,[h,d]=n;this.outputShape=[c,h,d,l];let p=s==="bilinear"?1:0,[f,m]=[`${o-1}.0`,`${u-1}.0`],[g,y,b]=h>1?[`${(o-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[x,w,v]=d>1?[`${(u-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},MJe=r=>{let{inputs:t,backend:n,attrs:s}=r,{image:i,boxes:a,boxInd:o}=t,{cropSize:u,method:l,extrapolationValue:c}=s,h=new OJe(i.shape,a.shape,u,l,c);return n.runWebGLProgram(h,[i,a,o],"float32")},LJe={kernelName:Pg,backendName:"webgl",kernelFunc:MJe},ax;(function(r){r.Prod="*",r.Sum="+"})(ax||(ax={}));var ZV=class{constructor(r,t,n,s){this.op=r,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let i=this.outputShape.length,a=this.op===ax.Prod?"1.0":"0.0",o=n?a:`getX(${JV(i,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1],l="",c="";n?(l=s?`end != ${u-1}`:"end != 0",c=s?"end + 1":"end - 1"):(l=s?`end + pow2 < ${u}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ln(i)} coords = getOutputCoords();
        int end = ${QV(i,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${c};
          ${QV(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${JV(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function JV(r,t,n){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${r} is not yet supported`)}function QV(r,t,n){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${r} is not yet supported`)}function See(r,t,n,s,i,a){let o=t.shape.length,u=q.getAxesPermutation([s],o),l=t;u!=null&&(l=li({inputs:{x:t},backend:n,attrs:{perm:u}}));let c=q.getInnerMostAxes(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);let h=l.shape[c],d=ia({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(h))-1;p++){let f=new ZV(r,l.shape,!1,a),m=[[p]],g=d;d=n.runWebGLProgram(f,[d],d.dtype,m),n.disposeIntermediateTensorInfo(g)}if(i){let p=new ZV(r,l.shape,i,a),f=d;d=n.runWebGLProgram(p,[d],d.dtype),n.disposeIntermediateTensorInfo(f)}if(u!=null){let p=q.getUndoAxesPermutation(u),f=li({inputs:{x:d},backend:n,attrs:{perm:p}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),f}return d}function PJe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,exclusive:o,reverse:u}=s;return See(ax.Prod,i,n,a,o,u)}var BJe={kernelName:Lg,backendName:"webgl",kernelFunc:PJe};function VJe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,exclusive:o,reverse:u}=s;return See(ax.Sum,i,n,a,o,u)}var zJe={kernelName:up,backendName:"webgl",kernelFunc:VJe};function UJe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,weights:a}=t,{size:o,binaryOutput:u}=s;if(i.shape.length===1){let l=n.readSync(i.dataId),c=n.readSync(a.dataId),h=eee(l,c,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,h)}else if(i.shape.length===2){let l=n.bufferSync(i),c=n.bufferSync(a),h=GKe(l,c,o,u);return n.makeTensorInfo(h.shape,a.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}var WJe={kernelName:Vx,backendName:"webgl",kernelFunc:UJe},GJe=class{constructor(r,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=r,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function HJe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{blockSize:a,dataFormat:o}=s,u=i.shape[0],l=o==="NHWC"?i.shape[1]:i.shape[2],c=o==="NHWC"?i.shape[2]:i.shape[3],h=o==="NHWC"?i.shape[3]:i.shape[1],d=l*a,p=c*a,f=h/(a*a),m=o==="NHWC"?[u,d,p,f]:[u,f,d,p],g=new GJe(m,a,o);return n.runWebGLProgram(g,[i],i.dtype)}var jJe={kernelName:Bg,backendName:"webgl",kernelFunc:HJe},Cee=class{constructor(r,t=!1,n=null,s=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=r.outShape,this.enableShapeUniforms=qs(this.outputShape.length);let a=r.filterHeight,o=r.filterWidth,u=r.outChannels/r.inChannels,l="",c="";n&&(s?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:i?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");let h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `}},_ee=class{constructor(r,t=!1,n=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=r.outShape,this.enableShapeUniforms=qs(this.outputShape.length);let a=r.outChannels/r.inChannels,o=r.padInfo.left,u=r.strideWidth,l=r.dilationWidth,c=r.filterHeight,h=r.filterWidth,d=h,p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<h;y++)p+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;p+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<h;y++)p+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(d+1)/2;y++){let b=y*2;if(p+=`
          xC = xCCorner + ${b*l};
          `,u===1){if(b<h&&(o%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,l===1&&b>0?p+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<h)){let x=o%2===0?O.nearestLargerEven(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,l>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:p+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):x===1?p+=`
                    xC${b+1} = xTexelC${b};
                    `:p+=`
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<h&&(o%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<h&&(p+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<h&&(p+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<h&&(p+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",m="";n&&(s?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:i?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:f=`vec4 activation(vec4 x) {
          ${n}
        }`,m="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}};function qJe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dilations:l,dimRoundingMode:c}=s,h=l;h==null&&(h=[1,1]),O.assert(q.eitherStridesOrDilationsAreOne(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);let d=q.computeConv2DInfo(i.shape,a.shape,o,h,u,c,!0),p;Re().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?p=new _ee(d):p=new Cee(d);let f=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(p,[i,a],"float32",f)}var KJe={kernelName:lp,backendName:"webgl",kernelFunc:qJe},XJe=class{constructor(r){this.variableNames=["x","dy"],this.outputShape=r.filterShape;let t=r.strideHeight,n=r.strideWidth,s=r.padInfo.top,i=r.padInfo.left,a=r.outChannels/r.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${r.batchSize}; b++) {
          for (int yR = 0; yR < ${r.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${r.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${r.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${i};

              if (xC < 0 || xC >= ${r.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},YJe=class{constructor(r){this.variableNames=["dy","W"],this.outputShape=r.inShape;let t=r.filterHeight,n=r.filterWidth,s=r.strideHeight,i=r.strideWidth,a=t-1-r.padInfo.top,o=n-1-r.padInfo.left,u=r.outChannels/r.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${r.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function ZJe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,dy:a}=t,{strides:o,dilations:u,pad:l,dimRoundingMode:c,filterShape:h}=s,d=q.computeConv2DInfo(i.shape,h,o,u,l,c,!0),p=new XJe(d);return n.runWebGLProgram(p,[i,a],"float32")}var JJe={kernelName:NC,backendName:"webgl",kernelFunc:ZJe};function QJe(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,filter:a}=t,{strides:o,dilations:u,pad:l,dimRoundingMode:c,inputShape:h}=s,d=q.computeConv2DInfo(h,a.shape,o,u,l,c,!0),p=new YJe(d);return n.runWebGLProgram(p,[i,a],"float32")}var eQe={kernelName:TC,backendName:"webgl",kernelFunc:QJe},tQe=class{constructor(r){this.variableNames=["X"],this.outputShape=[r,r],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function rQe(r){let{inputs:t,backend:n}=r,{x:s}=t,i=[...s.shape,...s.shape],a=O.sizeFromShape(s.shape),o=gt({inputs:{x:s},backend:n,attrs:{shape:[a]}}),u=new tQe(a),l=n.runWebGLProgram(u,[o],o.dtype),c=gt({inputs:{x:l},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}var nQe={kernelName:zx,backendName:"webgl",kernelFunc:rQe},sQe=class{constructor(r){this.variableNames=["x","W"],this.outputShape=r.outShape;let{inHeight:t,inWidth:n,padInfo:s,strideHeight:i,strideWidth:a,filterHeight:o,filterWidth:u,dilationHeight:l,dilationWidth:c}=r,{top:h,left:d}=s;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${a});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function iQe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dilations:l}=s,c=q.computeDilation2DInfo(i.shape,a.shape,o,u,"NHWC",l),h,d=new sQe(c);h=n.runWebGLProgram(d,[i,a],"float32");let p=gt({inputs:{x:h},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(h),p}var aQe={kernelName:cp,backendName:"webgl",kernelFunc:iQe};function oQe(r){let{inputs:t,backend:n,attrs:s}=r,{equation:i}=s,a=t,{allDims:o,summedDims:u,idDims:l}=q.decodeEinsumEquation(i,a.length);q.checkEinsumDimSizes(o.length,l,a);let{path:c,steps:h}=q.getEinsumComputePath(u,l),d=h.length,p=null,f=o.length,m=[];for(let g=0;g<d;++g){for(let y of h[g]){let{permutationIndices:b,expandDims:x}=q.getEinsumPermutation(f,l[y]),w;q.isIdentityPermutation(b)?w=a[y]:(w=li({inputs:{x:a[y]},backend:n,attrs:{perm:b}}),m.push(w));let v=w.shape.slice();for(let S=0;S<x.length;++S)v.splice(x[S],0,1);O.arraysEqual(w.shape,v)||(w=gt({inputs:{x:w},backend:n,attrs:{shape:v}}),m.push(w)),p===null?p=w:(p=gL({inputs:{a:w,b:p},backend:n}),m.push(p))}g<d-1&&(c[g]>=0&&(p=q_({inputs:{x:p},backend:n,attrs:{axis:c[g]-(o.length-f),keepDims:!1}}),m.push(p)),f--)}for(let g of m)g!==p&&n.disposeIntermediateTensorInfo(g);return p}var uQe={kernelName:DC,backendName:"webgl",kernelFunc:oQe},lQe="return (x >= 0.0) ? x : (exp(x) - 1.0);",cQe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,hQe=Rr({opSnippet:lQe,packedOpSnippet:cQe}),dQe={kernelName:dp,backendName:"webgl",kernelFunc:hQe},pQe="return (b >= 0.0) ? a : a * (b + 1.0);",fQe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,mQe=r=>{let{inputs:t,backend:n}=r,{dy:s,y:i}=t,a=Re().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new G0(fQe,s.shape,i.shape):new kd(pQe,s.shape,i.shape);return n.runWebGLProgram(a,[s,i],s.dtype)},gQe={kernelName:Vg,backendName:"webgl",kernelFunc:mQe},yQe=`
  return vec4(equal(a, b));
`,bQe="return float(a == b);",xQe=Os({opSnippet:bQe,packedOpSnippet:yQe,dtype:"bool",cpuKernelImpl:XKe}),vQe={kernelName:zg,backendName:"webgl",kernelFunc:xQe},wQe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${q.ERF_P};
  float a1 = ${q.ERF_A1};
  float a2 = ${q.ERF_A2};
  float a3 = ${q.ERF_A3};
  float a4 = ${q.ERF_A4};
  float a5 = ${q.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,SQe=Rr({opSnippet:wQe}),CQe={kernelName:pp,backendName:"webgl",kernelFunc:SQe},_Qe=H0+`
  return exp(x);
`,EQe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Eee=Rr({opSnippet:_Qe,packedOpSnippet:EQe,cpuKernelImpl:YKe,dtype:"float32"}),IQe={kernelName:fp,backendName:"webgl",kernelFunc:Eee};function ON(r){let{inputs:t,attrs:n,backend:s}=r,{dim:i}=n,{input:a}=t,o=a.shape.length,u=a.shape.slice(),l=i;return i<0&&(O.assert(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),u.splice(l,0,1),gt({inputs:{x:a},backend:s,attrs:{shape:u}})}var kQe={kernelName:Ug,backendName:"webgl",kernelFunc:ON},ez="return exp(x) - 1.0;",NQe=Rr({opSnippet:ez,packedOpSnippet:ez,cpuKernelImpl:ZKe}),TQe={kernelName:mp,backendName:"webgl",kernelFunc:NQe},tz=class{constructor(r,t,n){this.variableNames=["real","imag"];let s=t[1];this.outputShape=t;let i=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${s}.0`:"1.0",o;if(r==="real")o="return real * expR - imag * expI;";else if(r==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${r}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function Iee(r,t,n){let s=n.texData.get(r.dataId),i=O.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],o=i/a,u=gt({inputs:{x:r},backend:n,attrs:{shape:[o,a]}}),l=u.shape,c=new tz("real",l,t),h=new tz("imag",l,t),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],p=n.runWebGLProgram(c,d,"float32"),f=n.runWebGLProgram(h,d,"float32"),m=jc({inputs:{real:p,imag:f},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f);let g=gt({inputs:{x:m},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(m),g}function AQe(r){let{inputs:t,backend:n}=r,{input:s}=t;return Iee(s,!1,n)}var DQe={kernelName:FC,backendName:"webgl",kernelFunc:AQe},FQe=class{constructor(r,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=r,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Ov(r){let{backend:t,attrs:n}=r,{shape:s,value:i}=n,{dtype:a}=n;if(a=a||O.inferDtype(i),a==="string"){let o=O.getArrayFromDType(a,O.sizeFromShape(s));return o.fill(i),t.makeTensorInfo(s,a,o)}else{let o=new FQe(s,i),u=[[i]];return t.runWebGLProgram(o,[],a,u)}}var $Qe={kernelName:Ux,backendName:"webgl",kernelFunc:Ov},RQe=class{constructor(r){this.variableNames=["Image"],this.outputShape=[];let t=r[2];this.outputShape=r,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},OQe={kernelName:Wg,backendName:"webgl",kernelFunc:({inputs:r,backend:t})=>{let{image:n}=r,s=t,i=new RQe(n.shape);return s.runWebGLProgram(i,[n],n.dtype)}},rz="return floor(x);",MQe=Rr({opSnippet:rz,packedOpSnippet:rz,cpuKernelImpl:JKe}),LQe={kernelName:gp,backendName:"webgl",kernelFunc:MQe},PQe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,BQe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,VQe=Os({opSnippet:PQe,packedOpSnippet:BQe,dtype:"int32"}),zQe={kernelName:yp,backendName:"webgl",kernelFunc:VQe},UQe=class{constructor(r){this.variableNames=["A"];let t=mi(),[n,s]=r;this.outputShape=r,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},WQe=class{constructor(r){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=mi(),[n,s]=r;this.outputShape=r,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},GQe={kernelName:R2,backendName:"webgl",kernelFunc:HQe},Bf,mI=Re().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function HQe(r){let{inputs:t,backend:n,attrs:s}=r,{pixels:i}=t,{numChannels:a}=s,o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,u=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,c]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],h=[c,l],d=[c,l,a];if(u||o){let g=Re().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Bf==null||g!==mI)&&(mI=g,Bf=document.createElement("canvas").getContext("2d",{willReadFrequently:mI})),Bf.canvas.width=l,Bf.canvas.height=c,Bf.drawImage(i,0,0,l,c),i=Bf.canvas}let p=n.makeTensorInfo(h,"int32");n.texData.get(p.dataId).usage=fa.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),i);let f=Re().getBool("WEBGL_PACK")?new WQe(d):new UQe(d),m=n.runWebGLProgram(f,[p],"int32");return n.disposeData(p.dataId),m}function jQe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s,g=q.convertConv2DDataFormat(h),y=q.computeConv2DInfo(i.shape,a.shape,l,d,c,p,!1,g),b,x=[],w=o!=null,v=u!=null,S=f==="leakyrelu",E=()=>{let I=[i,a],_=(A,k)=>{if(k==="NCHW"&&A.shape.length===1&&A.shape[0]!==1){let N=gt({inputs:{x:A},backend:n,attrs:{shape:[A.shape[0],1,1]}});return x.push(N),N}return A};if(w&&I.push(_(o,h)),v&&I.push(_(u,h)),S){let A=n.makeTensorInfo([],"float32",O.createScalarValue(m,"float32"));I.push(A),x.push(A)}return I};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))b=vee({x:i,filter:a,convInfo:y,backend:n,bias:o,activation:f,preluActivationWeights:u,leakyreluAlpha:m});else if(y.strideWidth<=2&&g==="channelsLast"&&Re().getBool("WEBGL_EXP_CONV")){let I=f?sx(f,!0):null,_=new xee(y,w,I,v,S),A=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],k=E();b=n.runWebGLProgram(_,k,"float32",A)}else if(Re().getBool("WEBGL_CONV_IM2COL"))b=wee({x:i,filter:a,convInfo:y,backend:n,bias:o,activation:f,preluActivationWeights:u,leakyreluAlpha:m});else{let I=f?sx(f,!1):null,_=new bee(y,w,I,v,S),A=E();b=n.runWebGLProgram(_,A,"float32")}let C=gt({inputs:{x:b},backend:n,attrs:{shape:y.outShape}});return x.push(b),x.forEach(I=>n.disposeIntermediateTensorInfo(I)),C}var qQe={kernelName:hd,backendName:"webgl",kernelFunc:jQe};function KQe(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,m=[],g=h;g==null&&(g=[1,1]),O.assert(q.eitherStridesOrDilationsAreOne(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);let y=q.computeConv2DInfo(i.shape,a.shape,l,g,c,d,!0),b=Re().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,x=p?sx(p,b):null,w=[i,a],v=o!=null,S=u!=null,E=p==="leakyrelu";if(v&&w.push(o),S&&w.push(u),E){let A=n.makeTensorInfo([],"float32",O.createScalarValue(f,"float32"));w.push(A),m.push(A)}let C;b?C=new _ee(y,v,x,S,E):C=new Cee(y,v,x,S,E);let I=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],_=n.runWebGLProgram(C,w,"float32",I);return m.forEach(A=>n.disposeIntermediateTensorInfo(A)),_}var XQe={kernelName:dd,backendName:"webgl",kernelFunc:KQe},YQe=class{constructor(r,t,n,s){this.sliceDim=r,this.strides=t,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=n;let i=ln(n.length),a=`
    int index;`;for(let o=0;o<this.sliceDim;o++)a+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function ZQe(r){let{inputs:t,backend:n}=r,{params:s,indices:i}=t,a=i.shape,o=a[a.length-1],u=O.sizeFromShape(s.shape),[l,c,h,d]=q.prepareAndValidate(s,i),p=gt({inputs:{x:i},backend:n,attrs:{shape:[c,o]}}),f=gt({inputs:{x:s},backend:n,attrs:{shape:[O.sizeFromShape(s.shape)/h,h]}});if(n.shouldExecuteOnCPU([s,i])||s.dtype==="string"){let b=n.readSync(i.dataId),x=n.bufferSync(s),w=QKe(b,x,s.dtype,c,o,h,d,s.shape,u);return n.makeTensorInfo(l,s.dtype,w.values)}let m=new YQe(o,d,[c,h],s.shape),g=n.runWebGLProgram(m,[f,p],f.dtype),y=gt({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),y}var JQe={kernelName:Hg,backendName:"webgl",kernelFunc:ZQe},QQe=class{constructor(r,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=ln(this.rank),s=eet(r);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${r[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}};function eet(r,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<r.length;i++)i===2?s.push("index"):s.push(`${n[i]}`);return s.join()}function kee(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,indices:a}=t,{axis:o,batchDims:u}=s,l=O.parseAxisParam(o,i.shape)[0];if(Re().get("DEBUG")){let x=n.readSync(a.dataId),w=i.shape[l];for(let v=0;v<x.length;++v){let S=x[v];O.assert(S<=w-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${w-1}]`)}}let c=q.segment_util.collectGatherOpShapeInfo(i,a,l,u),h=O.sizeFromShape(a.shape),d=[],p=gt({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=gt({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,h/c.batchSize]}});d.push(p),d.push(f);let m=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([i,a])||i.dtype==="string"){let x=n.bufferSync(f),w=n.bufferSync(p),v=eXe(w,x,m);return d.forEach(S=>n.disposeIntermediateTensorInfo(S)),n.makeTensorInfo(c.outputShape,v.dtype,v.values)}let g=new QQe(p.shape,m),y=n.runWebGLProgram(g,[p,f],p.dtype);d.push(y);let b=gt({inputs:{x:y},backend:n,attrs:{shape:c.outputShape}});return d.forEach(x=>n.disposeIntermediateTensorInfo(x)),b}var tet={kernelName:Gg,backendName:"webgl",kernelFunc:kee},ret="return float(a > b);",net=`
  return vec4(greaterThan(a, b));
`,set=Os({opSnippet:ret,packedOpSnippet:net,cpuKernelImpl:tXe,dtype:"bool"}),iet={kernelName:jg,backendName:"webgl",kernelFunc:set},aet="return float(a >= b);",oet=`
  return vec4(greaterThanEqual(a, b));
`,uet=Os({opSnippet:aet,packedOpSnippet:oet,dtype:"bool",cpuKernelImpl:rXe}),cet={kernelName:xp,backendName:"webgl",kernelFunc:uet};function het(r){let{inputs:t,backend:n}=r,{input:s}=t;return Iee(s,!0,n)}var det={kernelName:$C,backendName:"webgl",kernelFunc:het},pet="return float(!isnan(x) && !isinf(x));",fet=Rr({opSnippet:pet,dtype:"bool"}),met={kernelName:wp,backendName:"webgl",kernelFunc:fet},get="return float(isinf(x));",yet=Rr({opSnippet:get,dtype:"bool"}),bet={kernelName:Sp,backendName:"webgl",kernelFunc:yet},xet="return float(isnan(x));",vet=Rr({opSnippet:xet,dtype:"bool"}),wet={kernelName:Cp,backendName:"webgl",kernelFunc:vet},Cet="return float(a < b);",_et=`
  return vec4(lessThan(a, b));
`,Eet=Os({opSnippet:Cet,packedOpSnippet:_et,cpuKernelImpl:nXe,dtype:"bool"}),Iet={kernelName:qg,backendName:"webgl",kernelFunc:Eet},ket="return float(a <= b);",Net=`
  return vec4(lessThanEqual(a, b));
`,Tet=Os({opSnippet:ket,packedOpSnippet:Net,cpuKernelImpl:sXe,dtype:"bool"}),Aet={kernelName:Kg,backendName:"webgl",kernelFunc:Tet};function Det(r){let{backend:t,attrs:n}=r,{start:s,stop:i,num:a}=n,o=iXe(s,i,a);return t.makeTensorInfo([o.length],"float32",o)}var Fet={kernelName:Xg,backendName:"webgl",kernelFunc:Det},$et=H0+`
  return x < 0.0 ? 0./0. : log(x);
`,Ret=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Oet=Rr({opSnippet:$et,packedOpSnippet:Ret,cpuKernelImpl:aXe}),Met={kernelName:Ep,backendName:"webgl",kernelFunc:Oet},Let=H0+`
  return log(1.0 + x);
`,Pet=Rr({opSnippet:Let}),Bet={kernelName:Ip,backendName:"webgl",kernelFunc:Pet},Vet="return float(a >= 1.0 && b >= 1.0);",zet=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Uet=Os({opSnippet:Vet,packedOpSnippet:zet,dtype:"bool"}),Wet={kernelName:Yg,backendName:"webgl",kernelFunc:Uet},Get="return float(!(x >= 1.0));",Het=Rr({opSnippet:Get}),jet={kernelName:Zg,backendName:"webgl",kernelFunc:Het},qet="return float(a >= 1.0 || b >= 1.0);",Ket=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Xet=Os({opSnippet:qet,packedOpSnippet:Ket,dtype:"bool"}),Yet={kernelName:Jg,backendName:"webgl",kernelFunc:Xet},Zet=class{constructor(r,t,n,s,i){this.variableNames=["x"],this.outputShape=[];let a=t,o=r[3]-1;this.outputShape=r;let u,l=`float(${n}) + float(${s}) * sum`;i===.5?u=`inversesqrt(${l})`:i===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}},Jet=class{constructor(r,t,n,s,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=t,o=r[3]-1;this.outputShape=r;let u,l=`float(${n}) + float(${s}) * sum`;i===.5?u=`inversesqrt(${l})`:i===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}},Qet=r=>{let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{depthRadius:a,bias:o,alpha:u,beta:l}=s,c=Re().getBool("WEBGL_PACK_NORMALIZATION")?new Jet(i.shape,a,o,u,l):new Zet(i.shape,a,o,u,l);return n.runWebGLProgram(c,[i],i.dtype)},ett={kernelName:kp,backendName:"webgl",kernelFunc:Qet},ttt=class{constructor(r,t,n,s,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=r,this.depth=r[3],this.depthRadius=t,this.bias=n,this.alpha=s,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},rtt=r=>{let{inputs:t,backend:n,attrs:s}=r,{x:i,y:a,dy:o}=t,{depthRadius:u,bias:l,alpha:c,beta:h}=s,d=new ttt(i.shape,u,l,c,h);return n.runWebGLProgram(d,[i,a,o],i.dtype)},ntt={kernelName:Qg,backendName:"webgl",kernelFunc:rtt};function stt(r,t,n,s){let i=O.sizeFromShape(t),a=O.sizeFromShape(r.shape)/i,o=gt({inputs:{x:r},attrs:{shape:[a,i]},backend:s}),u=vf(o,r.dtype,"max",s),l=gt({inputs:{x:u},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(u),l}function Nee(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{reductionIndices:a,keepDims:o}=s,u=i.shape.length,l=O.parseAxisParam(a,i.shape),c=l,h=q.getAxesPermutation(c,u),d=h!=null,p=n.shouldExecuteOnCPU([i]),f=i;if(d){if(p){let x=n.texData.get(f.dataId).values,w=new Array(u);for(let E=0;E<w.length;E++)w[E]=i.shape[h[E]];let v=pL(x,i.shape,i.dtype,h,w);f=n.makeTensorInfo(w,i.dtype);let S=n.texData.get(f.dataId);S.values=v}else f=j_(i,h,n);c=q.getInnerMostAxes(c.length,u)}q.assertAxesAreInnerMostDims("max",c,u);let[m,g]=q.computeOutAndReduceShapes(f.shape,c),y=m;o&&(y=q.expandShapeToKeepDim(m,l));let b;if(p){let x=n.texData.get(f.dataId).values,w=oXe(x,O.sizeFromShape(g),y,i.dtype);b=n.makeTensorInfo(y,i.dtype);let v=n.texData.get(b.dataId);v.values=w}else b=stt(f,g,y,n);return d&&n.disposeIntermediateTensorInfo(f),b}var itt={kernelName:Np,backendName:"webgl",kernelFunc:Nee},att=mL+`
  return max(a, b);
`,ott=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xf+`
  return result;
`,utt=Os({opSnippet:att,packedOpSnippet:ott,cpuKernelImpl:uXe}),ltt={kernelName:Tp,backendName:"webgl",kernelFunc:utt};function ctt(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t;B0(i,"maxPool");let{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=s,c=1;O.assert(q.eitherStridesOrDilationsAreOne(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);let h=q.computePool2DInfo(i.shape,a,o,c,u,l);if(h.filterWidth===1&&h.filterHeight===1&&O.arraysEqual(h.inShape,h.outShape))return ia({inputs:{x:i},backend:n});let d=new ix(h,"max",!1);return n.runWebGLProgram(d,[i],i.dtype)}var htt={kernelName:Ap,backendName:"webgl",kernelFunc:ctt};function dtt(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{filterSize:a,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=s,h=[1,1,1],d=q.computePool3DInfo(i.shape,a,o,h,u,c,l),p=new yL(d,"max",!1);return n.runWebGLProgram(p,[i],i.dtype)}var ptt={kernelName:e0,backendName:"webgl",kernelFunc:dtt},ftt=class{constructor(r){this.variableNames=["dy","maxPos"],this.outputShape=r.inShape;let t=r.strideHeight,n=r.strideWidth,s=r.dilationHeight,i=r.effectiveFilterHeight,a=r.effectiveFilterWidth,o=i-1-r.padInfo.top,u=a-1-r.padInfo.left,l=i*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${r.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},mtt=class{constructor(r){this.variableNames=["dy","maxPos"],this.outputShape=r.inShape;let t=r.strideDepth,n=r.strideHeight,s=r.strideWidth,i=r.dilationDepth,a=r.dilationHeight,o=r.dilationWidth,u=r.effectiveFilterDepth,l=r.effectiveFilterHeight,c=r.effectiveFilterWidth,h=u-1-r.padInfo.front,d=l-1-r.padInfo.top,p=c-1-r.padInfo.left,f=u*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${r.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${r.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function gtt(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,o=a,{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=s,d=[1,1,1],p=q.computePool3DInfo(o.shape,u,l,d,c,h),f=new yL(p,"max",!0),m=n.runWebGLProgram(f,[o],o.dtype),g=new mtt(p),y=n.runWebGLProgram(g,[i,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}var ytt={kernelName:Gx,backendName:"webgl",kernelFunc:gtt};function btt(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a,output:o}=t,u=a;B0([a,o],"maxPoolGrad");let{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=q.computePool2DInfo(u.shape,l,c,1,h,d),f=!0,m=new ix(p,"max",f),g=n.runWebGLProgram(m,[u],u.dtype),y=new ftt(p),b=n.runWebGLProgram(y,[i,g],u.dtype);return n.disposeIntermediateTensorInfo(g),b}var xtt={kernelName:Wx,backendName:"webgl",kernelFunc:btt};function vtt(r,t,n,s){let i=new ix(n,"max",!1),a=s.runWebGLProgram(i,[r],"float32");i=new ix(n,"max",!0,!0,t);let o=s.runWebGLProgram(i,[r],"float32");return[a,o]}var wtt={kernelName:Hx,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:n})=>{let{x:s}=r,{filterSize:i,strides:a,pad:o,includeBatchInIndex:u}=t,l=n;O.assert(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);let c=[1,1];O.assert(q.eitherStridesOrDilationsAreOne(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let h=q.computePool2DInfo(s.shape,i,a,c,o),[d,p]=vtt(s,u,h,l);return[d,p]}};function Stt(r,t,n,s){let i=O.sizeFromShape(t),a=O.sizeFromShape(r.shape)/i,o=gt({inputs:{x:r},attrs:{shape:[a,i]},backend:s}),u=vf(o,"float32","mean",s),l=gt({inputs:{x:u},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(u),l}var Ctt={kernelName:Dp,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:n})=>{let{x:s}=r,{keepDims:i,axis:a}=t,o=n,u=s.shape.length,l=O.parseAxisParam(a,s.shape),c=l,h=q.getAxesPermutation(c,u),d=h!=null,p=o.shouldExecuteOnCPU([s]),f=[],m=s;if(d){if(p){let w=o.texData.get(m.dataId).values,v=new Array(u);for(let C=0;C<v.length;C++)v[C]=s.shape[h[C]];let S=pL(w,s.shape,s.dtype,h,v);m=o.makeTensorInfo(v,s.dtype);let E=o.texData.get(m.dataId);E.values=S}else m=j_(s,h,o);f.push(m),c=q.getInnerMostAxes(c.length,u)}q.assertAxesAreInnerMostDims("sum",c,u);let[g,y]=q.computeOutAndReduceShapes(m.shape,c),b=g;i&&(b=q.expandShapeToKeepDim(g,l));let x=Stt(m,y,b,o);for(let w of f)o.disposeIntermediateTensorInfo(w);return x}};function _tt(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s,u=i.shape.length,l=O.parseAxisParam(a,i.shape),c=l,h=q.getAxesPermutation(c,u),d=i;h!=null&&(d=li({inputs:{x:i},backend:n,attrs:{perm:h}}),c=q.getInnerMostAxes(c.length,i.shape.length)),q.assertAxesAreInnerMostDims("min",c,u);let[p,f]=q.computeOutAndReduceShapes(d.shape,c),m=O.sizeFromShape(f),g=gt({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=vf(g,g.dtype,"min",n),b;if(o){let x=q.expandShapeToKeepDim(p,l);b=gt({inputs:{x:y},backend:n,attrs:{shape:x}})}else b=gt({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),h!=null&&n.disposeIntermediateTensorInfo(d),b}var Ett={kernelName:Fp,backendName:"webgl",kernelFunc:_tt},Itt=mL+`
  return min(a, b);
`,ktt=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xf+`
  return result;
`,Ntt=Os({opSnippet:Itt,packedOpSnippet:ktt,cpuKernelImpl:lXe}),Ttt={kernelName:$p,backendName:"webgl",kernelFunc:Ntt},Att=class{constructor(r,t,n){this.variableNames=["x"],this.outputShape=t.map((c,h)=>c[0]+r[h]+c[1]);let s=r.length,i=ln(s),a=t.map(c=>c[0]).join(","),o=t.map((c,h)=>c[0]+r[h]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),l=n==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}},Dtt=class{constructor(r,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,m)=>f[0]+r[m]+f[1]);let s=r.length,i=ln(s),a=t.map(f=>f[0]).join(","),o=t.map((f,m)=>f[0]+r[m]).join(","),u=si("rc",s),l=si("source",s),c=`${u[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${l.slice(-2).join()})`,d=n==="reflect"?0:1,p="";if(s===1){let f=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${h});
        ${u[s-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${h});
        }
      `}else{let f=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${h});
        ${u[s-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${h});
        }
        rc = outputLoc;
        ${u[s-2]} += 1;
        if(${u[s-2]} < ${this.outputShape[s-2]}) {
          ${f}
          result[2] = getChannel(getX(${l.join()}), ${h});
          ${u[s-1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${l.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}},Ftt=({inputs:r,backend:t,attrs:n})=>{let{x:s}=r,{paddings:i,mode:a}=n,o=Re().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Dtt(s.shape,i,a):new Att(s.shape,i,a);return t.runWebGLProgram(o,[s],s.dtype)},$tt={kernelName:Rp,backendName:"webgl",kernelFunc:Ftt},Rtt=`if (b == 0.0) return NAN;
  return mod(a, b);`,Ott=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+xf+`
  return result;
`,Mtt=Os({opSnippet:Rtt,packedOpSnippet:Ott}),Ltt={kernelName:Op,backendName:"webgl",kernelFunc:Mtt},Ptt=class{constructor(r,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[r,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},Btt=`
if (a == b) {
  return 1.0;
};
return a / b;`,Vtt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Tee=Os({opSnippet:Btt,packedOpSnippet:Vtt,checkOutOfBounds:!0}),ztt={kernelName:hp,backendName:"webgl",kernelFunc:Tee},nz="return a - b;",Aee=Os({opSnippet:nz,packedOpSnippet:nz,supportsComplex:!0,cpuKernelImpl:AXe}),Utt={kernelName:of,backendName:"webgl",kernelFunc:Aee};function Dee(r){let{inputs:t,backend:n,attrs:s}=r,{logits:i}=t,{dim:a}=s,o=O.parseAxisParam([a],i.shape),u=Nee({inputs:{x:i},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=q.expandShapeToKeepDim(u.shape,o),c=gt({inputs:{x:u},backend:n,attrs:{shape:l}}),h=Aee({inputs:{a:i,b:c},backend:n}),d=Eee({inputs:{x:h},backend:n}),p=q_({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),f=gt({inputs:{x:p},backend:n,attrs:{shape:l}}),m=Tee({inputs:{a:d,b:f},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}var Wtt={kernelName:sf,backendName:"webgl",kernelFunc:Dee};function Gtt(r){let{inputs:t,backend:n,attrs:s}=r,{logits:i}=t,{numSamples:a,seed:o,normalized:u}=s,l=u?i:Dee({inputs:{logits:i},backend:n,attrs:{dim:i.shape.length-1}}),c=l.shape[0],h=l.shape[1],d=new Ptt(c,h,a),p=[[o]],f=n.runWebGLProgram(d,[l],"int32",p);return u||n.disposeIntermediateTensorInfo(l),f}var Htt={kernelName:t0,backendName:"webgl",kernelFunc:Gtt},jtt=oo+`
  return -x;
`,qtt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Ktt(r){let{inputs:t,backend:n}=r,{x:s}=t;if(n.shouldExecuteOnCPU([s])){let a=n.texData.get(s.dataId),[o,u]=hXe(a.values,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,o)}let i;return Re().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Jl(s.shape,qtt):i=new nu(s.shape,jtt),n.runWebGLProgram(i,[s],s.dtype)}var Xtt={kernelName:r0,backendName:"webgl",kernelFunc:Ktt},Ytt=ku.nonMaxSuppressionV3Impl;function Ztt(r){q.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:s}=r,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l}=s,c=n.readSync(i.dataId),h=n.readSync(a.dataId),{selectedIndices:d}=Ytt(c,h,o,u,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var Jtt={kernelName:s0,backendName:"webgl",kernelFunc:Ztt},Qtt=ku.nonMaxSuppressionV4Impl;function ert(r){q.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:s}=r,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l,padToMaxOutputSize:c}=s,h=n.readSync(i.dataId),d=n.readSync(a.dataId),{selectedIndices:p,validOutputs:f}=Qtt(h,d,o,u,l,c);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}var trt={kernelName:i0,backendName:"webgl",kernelFunc:ert},rrt=ku.nonMaxSuppressionV5Impl;function nrt(r){q.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:s}=r,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=s,h=n.readSync(i.dataId),d=n.readSync(a.dataId),p=o,f=u,m=l,g=c,{selectedIndices:y,selectedScores:b}=rrt(h,d,p,f,m,g);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var srt={kernelName:a0,backendName:"webgl",kernelFunc:nrt},irt=class{constructor(r,t,n,s){this.variableNames=["indices"],this.outputShape=[r,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${n}),
                      float(index == coords.y)));
      }
    `}},art=r=>{let{inputs:t,backend:n,attrs:s}=r,{indices:i}=t,{dtype:a,depth:o,onValue:u,offValue:l}=s,c=O.sizeFromShape(i.shape),h=new irt(c,o,u,l),d=gt({inputs:{x:i},backend:n,attrs:{shape:[c]}}),p=n.runWebGLProgram(h,[d],a);n.disposeIntermediateTensorInfo(d);let f=[...i.shape,o],m=gt({inputs:{x:p},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(p),m},ort={kernelName:Lp,backendName:"webgl",kernelFunc:art};function nS(r){let{inputs:t,backend:n}=r,{x:s}=t;if(s.dtype==="complex64"){let i=Rv({inputs:{input:s},backend:n}),a=nS({inputs:{x:i},backend:n}),o=K_({inputs:{input:s},backend:n}),u=nS({inputs:{x:o},backend:n}),l=jc({inputs:{real:a,imag:u},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}else return Ov({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:n})}var urt={kernelName:E0,backendName:"webgl",kernelFunc:nS};function Fee(r){let{inputs:t,backend:n}=r,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){let i=Rv({inputs:{input:s},backend:n}),a=Fee({inputs:{x:i},backend:n}),o=K_({inputs:{input:s},backend:n}),u=nS({inputs:{x:o},backend:n}),l=jc({inputs:{real:a,imag:u},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}else return Ov({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:n})}var lrt={kernelName:o0,backendName:"webgl",kernelFunc:Fee};function crt(r){let{inputs:t,backend:n,attrs:s}=r,{axis:i}=s;if(t.length===1)return ON({inputs:{input:t[0]},backend:n,attrs:{dim:i}});let a=t[0].shape,o=t[0].dtype;t.forEach(h=>{O.assertShapesMatch(a,h.shape,"All tensors passed to stack must have matching shapes"),O.assert(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});let u=[],l=t.map(h=>{let d=ON({inputs:{input:h},backend:n,attrs:{dim:i}});return u.push(d),d}),c=yee({inputs:l,backend:n,attrs:{axis:i}});return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}var hrt={kernelName:u0,backendName:"webgl",kernelFunc:crt},drt=class{constructor(r,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,c)=>l[0]+r[c]+l[1]);let s=r.length,i=ln(s),a=t.map(l=>l[0]).join(","),o=t.map((l,c)=>l[0]+r[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}},prt=class{constructor(r,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,g)=>m[0]+r[g]+m[1]);let s=r.length,i=ln(s),a=t.map(m=>m[0]).join(","),o=t.map((m,g)=>m[0]+r[g]).join(","),u=si("rc",s),l=si("source",s),c=`${u[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${i} rc = outputLoc;`,`${u[s-1]} += 1;
       if(${c}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${u[s-2]} += 1;
       if(${u[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${u[s-1]} += 1;
         if(${c}) {`],p=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",f="";for(let m=0,g=s===1?2:4;m<g;m++)f+=`
        ${d[m]}
        if (${p}) {
          result[${m}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${m}] = getChannel(getX(${l.join()}), ${h});
        }
      `;f+=s===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}},$ee=r=>{let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{paddings:a,constantValue:o}=s;if(O.sizeFromShape(i.shape)===0){let c=a.map((h,d)=>h[0]+i.shape[d]+h[1]);return Ov({backend:n,attrs:{shape:c,value:o,dtype:i.dtype}})}let u=Re().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new prt(i.shape,a,o):new drt(i.shape,a,o),l=[[o]];return n.runWebGLProgram(u,[i],i.dtype,l)},frt={kernelName:Pp,backendName:"webgl",kernelFunc:$ee},mrt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,grt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+xf+`
  return result;
`,yrt=Os({opSnippet:mrt,packedOpSnippet:grt}),brt={kernelName:Bp,backendName:"webgl",kernelFunc:yrt};function xrt(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,keepDims:o}=s,u=i.shape.length,l=[],c=O.parseAxisParam(a,i.shape),h=c,d=q.getAxesPermutation(h,u),p=i;d!=null&&(p=li({inputs:{x:i},backend:n,attrs:{perm:d}}),h=q.getInnerMostAxes(h.length,u),l.push(p)),q.assertAxesAreInnerMostDims("prod",h,u);let f;if(n.shouldExecuteOnCPU([p])){let m=n.texData.get(p.dataId).values,{outVals:g,outShape:y,outDtype:b}=pXe(p.shape,p.dtype,m,h);f=n.makeTensorInfo(y,b,g)}else{let[m,g]=q.computeOutAndReduceShapes(p.shape,h),y=O.sizeFromShape(g),b=gt({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),x=VC(i.dtype),w=vf(b,x,"prod",n);f=gt({inputs:{x:w},backend:n,attrs:{shape:m}}),l.push(b),l.push(w)}if(o){l.push(f);let m=q.expandShapeToKeepDim(f.shape,c);f=gt({inputs:{x:f},backend:n,attrs:{shape:m}})}return l.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var vrt={kernelName:zp,backendName:"webgl",kernelFunc:xrt};function wrt(r){let{inputs:t,backend:n,attrs:s}=r,{paramsNestedSplits:i,paramsDenseValues:a,indices:o}=t,{outputRaggedRank:u}=s,l=i.map(b=>n.readSync(b.dataId)),c=i.map(b=>b.shape),h=n.readSync(a.dataId),d=n.readSync(o.dataId),[p,f,m]=fXe(l,c,h,a.shape,a.dtype,d,o.shape,u),g=p.map(b=>n.makeTensorInfo([b.length],"int32",b)),y=n.makeTensorInfo(m,a.dtype,f);return g.concat([y])}var Srt={kernelName:OC,backendName:"webgl",kernelFunc:wrt};function Crt(r){let{inputs:t,backend:n}=r,{starts:s,limits:i,deltas:a}=t,o=n.readSync(s.dataId),u=n.readSync(i.dataId),l=n.readSync(a.dataId),[c,h]=mXe(o,s.shape,s.dtype,u,i.shape,l,a.shape),d=n.makeTensorInfo([c.length],"int32",c),p=n.makeTensorInfo([h.length],s.dtype,h);return[d,p]}var _rt={kernelName:MC,backendName:"webgl",kernelFunc:Crt};function Ert(r){let{inputs:t,backend:n,attrs:s}=r,{shape:i,values:a,defaultValue:o,rowPartitionTensors:u}=t,{rowPartitionTypes:l}=s,c=n.readSync(i.dataId),h=n.readSync(a.dataId),d=n.readSync(o.dataId),p=u.map(y=>n.readSync(y.dataId)),f=u.map(y=>y.shape),[m,g]=gXe(c,i.shape,h,a.shape,a.dtype,d,o.shape,p,f,l);return n.makeTensorInfo(m,a.dtype,g)}var Irt={kernelName:LC,backendName:"webgl",kernelFunc:Ert},Ree=r=>{let{backend:t,attrs:n}=r,{start:s,stop:i,step:a,dtype:o}=n,u=yXe(s,i,a,o);return t.makeTensorInfo([u.length],o,u)},krt={kernelName:jx,backendName:"webgl",kernelFunc:Ree},Nrt="return 1.0 / x;",Trt=Rr({opSnippet:Nrt}),Art={kernelName:Up,backendName:"webgl",kernelFunc:Trt},Drt=oo+`
  return (x < 0.0) ? 0.0 : x;
`,Frt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,$rt=Rr({opSnippet:Drt,packedOpSnippet:Frt}),Rrt={kernelName:Wp,backendName:"webgl",kernelFunc:$rt},Ort=oo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Mrt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Lrt=Rr({opSnippet:Ort,packedOpSnippet:Mrt}),Prt={kernelName:jp,backendName:"webgl",kernelFunc:Lrt},Brt=class{constructor(r,t,n,s,i){this.variableNames=["A"],this.outputShape=[];let[a,o,u,l]=r;this.outputShape=[a,t,n,l];let c=[s&&t>1?o-1:o,s&&n>1?u-1:u],h=[s&&t>1?t-1:t,s&&n>1?n-1:n],d;i?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},Vrt=class{constructor(r,t,n,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,o,u,l]=r;this.outputShape=[a,t,n,l];let c=[s&&t>1?o-1:o,s&&n>1?u-1:u],h=[s&&t>1?t-1:t,s&&n>1?n-1:n],d;i?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function zrt(r){let{inputs:t,backend:n,attrs:s}=r,{images:i}=t,{alignCorners:a,halfPixelCenters:o,size:u}=s,[l,c]=u,h=Re().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Vrt(i.shape,l,c,a,o):new Brt(i.shape,l,c,a,o);return n.runWebGLProgram(h,[i],"float32")}var Urt={kernelName:Hp,backendName:"webgl",kernelFunc:zrt},Wrt=class{constructor(r,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,s,i]=t,[,a,o]=r,u=[n&&a>1?s-1:s,n&&o>1?i-1:i],l=[n&&a>1?a-1:a,n&&o>1?o-1:o],c=u[0]/l[0],h=u[1]/l[1],d=1/c,p=1/h,f=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Grt(r){let{inputs:t,backend:n,attrs:s}=r,{images:i,dy:a}=t,{alignCorners:o}=s,u=new Wrt(a.shape,i.shape,o);return n.runWebGLProgram(u,[a],a.dtype)}var Hrt={kernelName:h0,backendName:"webgl",kernelFunc:Grt},jrt=class{constructor(r,t,n,s,i){this.variableNames=["A"],this.outputShape=[];let[a,o,u,l]=r;this.outputShape=[a,t,n,l];let c=[s&&t>1?o-1:o,s&&n>1?u-1:u],h=[s&&t>1?t-1:t,s&&n>1?n-1:n],d=s?"0.5":"0.0",p;i?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},qrt=class{constructor(r,t,n,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,o,u,l]=r;this.outputShape=[a,t,n,l];let c=[s&&t>1?o-1:o,s&&n>1?u-1:u],h=[s&&t>1?t-1:t,s&&n>1?n-1:n],d=s?"0.5":"0.0",p;i?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Krt(r){let{inputs:t,backend:n,attrs:s}=r,{images:i}=t,{alignCorners:a,halfPixelCenters:o,size:u}=s,[l,c]=u,h=Re().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qrt(i.shape,l,c,a,o):new jrt(i.shape,l,c,a,o);return n.runWebGLProgram(h,[i],i.dtype)}var Xrt={kernelName:Gp,backendName:"webgl",kernelFunc:Krt},Yrt=class{constructor(r,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,s,i]=t,[,a,o]=r,u=[n&&a>1?s-1:s,n&&o>1?i-1:i],l=[n&&a>1?a-1:a,n&&o>1?o-1:o],c=u[0]/l[0],h=u[1]/l[1],d=1/c,p=1/h,f=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Zrt(r){let{inputs:t,backend:n,attrs:s}=r,{images:i,dy:a}=t,{alignCorners:o}=s,u=new Yrt(a.shape,i.shape,o);return n.runWebGLProgram(u,[a],a.dtype)}var Jrt={kernelName:c0,backendName:"webgl",kernelFunc:Zrt},Qrt=class{constructor(r,t){this.variableNames=["x"];let n=r.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=r,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${r[0]} - coord - 1));
        }
      `;return}let s=o=>t.indexOf(o)!==-1&&r[o]!==1?`${r[o]} - coords[${o}] - 1`:`coords[${o}]`,i=r.map((o,u)=>s(u)).join(","),a=ln(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}},ent=class{constructor(r,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=r.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=r;let s=si("rc",n),i=`${s[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${s[n-2]} + 1 < ${this.outputShape[n-2]}`,o=ln(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${r[0]} - rc - 1),
            ${r[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${r[0]} - (rc  + 1) - 1),
                ${r[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(s.slice())};
          if(${i}){
            result.g = ${l(s.slice())};
          }
          if(${a}) {
            result.b = ${c(s.slice())};
            if(${i}) {
              result.a = ${h(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return d(f)}function l(f){return f[n-1]="("+f[n-1]+" + 1)",d(f)}function c(f){return f[n-2]="("+f[n-2]+" + 1)",d(f)}function h(f){return f[n-1]="("+f[n-1]+" + 1)",f[n-2]="("+f[n-2]+" + 1)",d(f)}function d(f){let m=r.map((b,x)=>p(x,f)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function p(f,m){return t.indexOf(f)!==-1&&r[f]!==1?`${r[f]} - ${m[f]} - 1`:`${m[f]}`}}};function tnt(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{dims:a}=s,o=i.shape.length,u=O.parseAxisParam(a,i.shape);if(o===0)return ia({inputs:{x:i},backend:n});let l=Re().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ent(i.shape,u):new Qrt(i.shape,u);return n.runWebGLProgram(l,[i],i.dtype)}var rnt={kernelName:qp,backendName:"webgl",kernelFunc:tnt},nnt=class{constructor(r,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=r[1],s=r[2];this.outputShape=r;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},snt={kernelName:I0,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:n})=>{let{image:s}=r,{radians:i,fillValue:a,center:o}=t,u=n,l=new nnt(s.shape,a),[c,h]=q.getImageCenter(o,s.shape[1],s.shape[2]),d=[[c,h,Math.sin(i),Math.cos(i)]];return u.runWebGLProgram(l,[s],s.dtype,d)}},int=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,ant=Rr({opSnippet:int}),ont={kernelName:Kp,backendName:"webgl",kernelFunc:ant},unt="return inversesqrt(x);",lnt=Rr({opSnippet:unt,cpuKernelImpl:bXe}),cnt={kernelName:Xp,backendName:"webgl",kernelFunc:lnt},bL=class{constructor(r,t,n,s,i,a,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;let l=ln(i.length),c=ln(a.length),h="";n===1?h="i":n===2&&(h="i, j");let d=`getIndices(${h})`,p="";s===1?p="i":s===2&&(p="i, coords[1]");let f=`getUpdates(${p})`,m="";u&&(m="coords[0], coords[1]");let g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${r}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}},hnt=class{constructor(r,t,n,s,i,a,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;let l=ln(i.length),c=ln(a.length),h="";n===1?h="i":n===2&&(h="i, j");let d=`getIndices(${h})`,p="";s===1?p="i":s===2&&(p="i, coords[1]");let f=`getUpdates(${p})`,m="";u&&(m="coords[0], coords[1]");let g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${r}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}};function dnt(r){let{inputs:t,backend:n,attrs:s}=r,{indices:i,updates:a}=t,{shape:o}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=q.calculateShapes(a,i,o),p=[d/c,c];if(d===0)return n.makeTensorInfo(o,i.dtype);let f=gt({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=gt({inputs:{x:a},backend:n,attrs:{shape:[l,c]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0])),y;Re().getBool("WEBGL_PACK")?y=new hnt(l,u,f.shape.length,m.shape.length,h,p):y=new bL(l,u,f.shape.length,m.shape.length,h,p);let b=n.runWebGLProgram(y,[m,f,g],m.dtype),x=gt({inputs:{x:b},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),x}var pnt={kernelName:d0,backendName:"webgl",kernelFunc:dnt},fnt=class{constructor(r,t,n,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[r,n];let i="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,o=Re().getNumber("WEBGL_VERSION")===2?i:a,u=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function mnt(r){let{inputs:t,backend:n,attrs:s}=r,{sortedSequence:i,values:a}=t,{side:o}=s,u=new fnt(i.shape[0],i.shape[1],a.shape[1],o),l=[[i.shape[1]]];return n.runWebGLProgram(u,[i,a],"int32",l)}var gnt={kernelName:f0,backendName:"webgl",kernelFunc:mnt},ynt=class{constructor(r,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let s,i;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)i="resRC",s="resRC";else{let o=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let c=0;c<t.length;c++)l.push(`${o[c]}`),c<r&&u.push(`${o[c]}`);s=u.join(),i=l.join()}let a=ln(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}};function bnt(r){let{inputs:t,backend:n}=r,{condition:s,t:i,e:a}=t,o=new ynt(s.shape.length,i.shape,i.shape.length);return n.runWebGLProgram(o,[s,i,a],va(i.dtype,a.dtype))}var xnt={kernelName:m0,backendName:"webgl",kernelFunc:bnt},vnt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${q.SELU_SCALEALPHA};
  float scale = ${q.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,wnt=Rr({opSnippet:vnt}),Snt={kernelName:Yp,backendName:"webgl",kernelFunc:wnt},Cnt=H0+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,_nt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ent=Rr({opSnippet:Cnt,packedOpSnippet:_nt,cpuKernelImpl:vXe}),Int={kernelName:ef,backendName:"webgl",kernelFunc:Ent},knt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Nnt=Rr({opSnippet:knt}),Tnt={kernelName:Qp,backendName:"webgl",kernelFunc:Nnt},Ant=H0+`
  return sin(x);
`,Dnt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${xf}
  return result;
`,Fnt=Rr({opSnippet:Ant,packedOpSnippet:Dnt}),$nt={kernelName:Zp,backendName:"webgl",kernelFunc:Fnt},Rnt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Ont=Rr({opSnippet:Rnt}),Mnt={kernelName:Jp,backendName:"webgl",kernelFunc:Ont},Lnt=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Pnt=Rr({opSnippet:Lnt}),Bnt={kernelName:tf,backendName:"webgl",kernelFunc:Pnt},Vnt=r=>{let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{blockShape:a,paddings:o}=s;O.assert(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let u=a.reduce((b,x)=>b*x),l=[[0,0]];l.push(...o);for(let b=1+a.length;b<i.shape.length;++b)l.push([0,0]);let c=[],h=$ee({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),d=q.getReshaped(h.shape,a,u,!1),p=q.getPermuted(d.length,a.length,!1),f=q.getReshapedPermuted(h.shape,a,u,!1),m=gt({inputs:{x:h},backend:n,attrs:{shape:d}}),g=li({inputs:{x:m},backend:n,attrs:{perm:p}}),y=gt({inputs:{x:g},backend:n,attrs:{shape:f}});return c.push(h),c.push(m),c.push(g),c.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},znt={kernelName:y0,backendName:"webgl",kernelFunc:Vnt};function Unt(r){let{inputs:t,backend:n}=r,{indices:s,values:i,denseShape:a,defaultValue:o}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);let u=n.readSync(s.dataId),l=n.readSync(i.dataId),c=n.readSync(a.dataId),h=n.readSync(o.dataId)[0],[d,p,f,m,g]=SXe(u,s.shape,s.dtype,l,i.dtype,c,h);return[n.makeTensorInfo(p,s.dtype,d),n.makeTensorInfo([p[0]],i.dtype,f),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(y=>Number(y)))),n.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}var Wnt={kernelName:qx,backendName:"webgl",kernelFunc:Unt};function Gnt(r){let{inputs:t,backend:n}=r,{inputIndices:s,inputShape:i,newShape:a}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let o=Array.from(n.readSync(i.dataId)),u=n.readSync(s.dataId),l=Array.from(n.readSync(a.dataId)),[c,h,d]=CXe(u,s.shape,s.dtype,o,l);return[n.makeTensorInfo(h,s.dtype,c),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var Hnt={kernelName:x0,backendName:"webgl",kernelFunc:Gnt};function jnt(r){let{inputs:t,backend:n}=r,{data:s,indices:i,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);let o=n.readSync(s.dataId),u=n.readSync(i.dataId),l=n.readSync(a.dataId),[c,h]=ree(o,s.shape,s.dtype,u,l,!0);return n.makeTensorInfo(h,s.dtype,c)}var qnt={kernelName:Kx,backendName:"webgl",kernelFunc:jnt};function Knt(r){let{inputs:t,backend:n}=r,{data:s,indices:i,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);let o=n.readSync(s.dataId),u=n.readSync(i.dataId),l=n.readSync(a.dataId),[c,h]=ree(o,s.shape,s.dtype,u,l);return n.makeTensorInfo(h,s.dtype,c)}var Xnt={kernelName:Xx,backendName:"webgl",kernelFunc:Knt};function Ynt(r){let{inputs:t,backend:n,attrs:s}=r,{sparseIndices:i,sparseValues:a,defaultValue:o}=t,{outputShape:u}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=q.calculateShapes(a,i,u),f=!1;if(a.dtype==="string"){let b=n.bufferSync(i),x=n.bufferSync(a),w=O.decodeString(n.readSync(o.dataId)[0]),v=xXe(b,x,u,p,h,c,l,d,w,f);return n.makeTensorInfo(u,v.dtype,v.values)}let m=new bL(c,l,i.shape.length,a.shape.length,d,[p,1],f),g=n.runWebGLProgram(m,[a,i,o],a.dtype),y=gt({inputs:{x:g},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(g),y}var Znt={kernelName:v0,backendName:"webgl",kernelFunc:Ynt};function Jnt(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{numOrSizeSplits:a,axis:o}=s,u=O.parseAxisParam(o,i.shape)[0],l=q.prepareSplitSize(i,a,u),c=i.shape.length,h=new Array(c).fill(0),d=i.shape.slice();return l.map(p=>{let f=[...d];f[u]=p;let m=j0({inputs:{x:i},backend:n,attrs:{begin:h,size:f}});return h[u]+=p,m})}var Qnt={kernelName:b0,backendName:"webgl",kernelFunc:Jnt},sz="return sqrt(x);",est=Rr({opSnippet:sz,packedOpSnippet:sz,cpuKernelImpl:_Xe}),tst={kernelName:rf,backendName:"webgl",kernelFunc:est},rst="return x * x;",nst=Rr({opSnippet:rst}),sst={kernelName:Yx,backendName:"webgl",kernelFunc:nst},iz="return (a - b) * (a - b);",ist=Os({opSnippet:iz,packedOpSnippet:iz}),ast={kernelName:af,backendName:"webgl",kernelFunc:ist};function ost(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");let a=n.readSync(i.dataId),o=q.fromUint8ToStringArray(a),u=EXe(o,"string",s);return n.makeTensorInfo(i.shape,"string",u)}var ust={kernelName:Zx,backendName:"webgl",kernelFunc:ost};function lst({inputs:r,attrs:t,backend:n}){let{x:s}=r,i=oo+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new nu(s.shape,i);return n.runWebGLProgram(a,[s],s.dtype)}var cst={kernelName:Bc,backendName:"webgl",kernelFunc:lst},hst=class{constructor(r,t,n){this.variableNames=["x"],this.outputShape=n;let s=n.length,i=ln(n.length),a=ln(n.length),o="";if(s===1)o="coords * strides + begin";else{let u=0;o=n.map((l,c)=>(u++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${u-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${r});
      ${i} strides = ${i}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}};function dst(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{begin:a,end:o,strides:u,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=s,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:x,end:w,strides:v}=is.sliceInfo(i.shape,a,o,u,l,c,h,d,p),S;if(g)S=gt({inputs:{x:i},backend:n,attrs:{shape:m}});else if(y||b){O.assert(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);let C=is.computeOutShape(x,w,v),I=j0({inputs:{x:i},backend:n,attrs:{begin:x,size:C}});S=gt({inputs:{x:I},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(I)}else if(n.shouldExecuteOnCPU([i])){let C=n.readSync(i.dataId),I=pr(i.shape,i.dtype,C),_=IXe(f,I,v,x);S=n.makeTensorInfo(m,i.dtype,_.values)}else{let C=new hst(x,v,f);S=n.runWebGLProgram(C,[i],i.dtype)}let E=gt({inputs:{x:S},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(S),E}var pst={kernelName:w0,backendName:"webgl",kernelFunc:dst};function fst(r){let{inputs:t,backend:n,attrs:s}=r,{separator:i,nGramWidths:a,leftPad:o,rightPad:u,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:d}=t,p=n.readSync(h.dataId),f=n.readSync(d.dataId),[m,g]=kXe(p,f,i,a,o,u,l,c);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(d.shape,"int32",g)]}var mst={kernelName:Jx,backendName:"webgl",kernelFunc:fst};function gst(r){let{inputs:t,backend:n,attrs:s}=r,{skipEmpty:i}=s,{input:a,delimiter:o}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);let u=n.readSync(a.dataId),l=n.readSync(o.dataId)[0],[c,h,d]=NXe(u,l,i),p=h.length;return[n.makeTensorInfo([p,2],"int32",c),n.makeTensorInfo([p],"string",h),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var yst={kernelName:Qx,backendName:"webgl",kernelFunc:gst};function bst(r){let{inputs:t,backend:n,attrs:s}=r,{numBuckets:i}=s,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");let o=n.readSync(a.dataId),u=TXe(o,i);return n.makeTensorInfo(a.shape,"int32",u)}var xst={kernelName:ev,backendName:"webgl",kernelFunc:bst},vst="return tan(x);",wst=Rr({opSnippet:vst}),Sst={kernelName:uf,backendName:"webgl",kernelFunc:wst},Cst=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,_st=Rr({opSnippet:Cst}),Est={kernelName:lf,backendName:"webgl",kernelFunc:_st};function Ist(r){let{inputs:t,backend:n,attrs:s}=r,{tensor:i,indices:a,updates:o}=t,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=q.calculateShapes(o,a,i.shape),p=[d/c,c];if(d===0)return n.makeTensorInfo(i.shape,a.dtype);let f=gt({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=gt({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),g=gt({inputs:{x:i},backend:n,attrs:{shape:p}}),y=new bL(l,u,f.shape.length,m.shape.length,h,p,!1,!0),b=n.runWebGLProgram(y,[m,f,g],g.dtype),x=gt({inputs:{x:b},backend:n,attrs:{shape:i.shape}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),x}var kst={kernelName:p0,backendName:"webgl",kernelFunc:Ist},Nst=class{constructor(r,t){this.variableNames=["A"];let n=new Array(r.length);for(let a=0;a<n.length;a++)n[a]=r[a]*t[a];this.outputShape=n,this.rank=n.length;let s=ln(this.rank),i=Tst(r);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}};function Tst(r){let t=r.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${r[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let i=0;i<r.length;i++)s.push(`imod(${n[i]}, ${r[i]})`);return s.join()}function Oee(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{reps:a}=s;if(i.dtype==="string"||i.shape.length>5){let u=n.readSync(i.dataId),l=i.dtype==="string"?u.map(d=>O.decodeString(d)):u,c=pr(i.shape,i.dtype,l),h=DXe(c,a);return n.makeTensorInfo(h.shape,h.dtype,h.values)}let o=new Nst(i.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}var Ast={kernelName:Pc,backendName:"webgl",kernelFunc:Oee},Dst=class{constructor(r){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=r,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Fst=class{constructor(r){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=r,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function oh(r,t){t!==null&&r.disposeIntermediateTensorInfo(t)}function az(r){let t=1;for(;t<r;)t*=2;return t}function $st(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{k:a,sorted:o}=s,u=Re().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Re().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,h=c[c.length-1];if(n.shouldExecuteOnCPU([i])||h<u||a>l){let _=n.readSync(i.dataId),[A,k]=FXe(_,c,i.dtype,a,o);return[n.makeTensorInfo(A.shape,A.dtype,A.values),n.makeTensorInfo(k.shape,k.dtype,k.values)]}if(a===0)return c[c.length-1]=0,[n.makeTensorInfo(c,i.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(h===1)return[i,Ov({attrs:{shape:c,dtype:"int32",value:0},backend:n})];let d=n.texData.get(i.dataId),p=d!==null&&d.isPacked,f=p?n.unpackTensor(i):i,m=O.sizeFromShape(c)/h,g=gt({inputs:{x:f},attrs:{shape:[m,h]},backend:n});p&&oh(n,f);let y=az(a),b=az(h),x=null,w=()=>x===null?[g,g]:[g,x],v=(_,A,k)=>{let N=w(),D=new Dst(k),F=[[h],[x===null?1:0],[Number.NEGATIVE_INFINITY],[_],[A]],P=x;x=n.runWebGLProgram(D,N,"int32",F),oh(n,P)};for(let _=1;_<y;_*=2){let A=_*2;for(let k=_;k>=1;k/=2)v(A,k,[m,b])}for(let _=b;_>y;_/=2){let A=w(),k=new Fst([m,_/2]),N=[[h],[x===null?1:0],[y]],D=x;x=n.runWebGLProgram(k,A,"int32",N),oh(n,D);let F=y/2,P=F*2;for(let G=F;G>=1;G/=2)v(P,G,x.shape)}let S=x;x=j0({inputs:{x},backend:n,attrs:{begin:0,size:[m,a]}}),oh(n,S);let E=kee({inputs:{x:g,indices:x},backend:n,attrs:{axis:1,batchDims:1}});oh(n,g);let C=c.slice(0,-1);C.push(a),S=x,x=gt({inputs:{x},attrs:{shape:C},backend:n}),oh(n,S);let I=E;return E=gt({inputs:{x:E},attrs:{shape:C},backend:n}),oh(n,I),[E,x]}var Rst={kernelName:S0,backendName:"webgl",kernelFunc:$st},Ost=class{constructor(r,t,n,s,i,a){this.variableNames=["Image","Transforms"],this.outputShape=a;let o=n==="nearest"?1:2,u;switch(s){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${r} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${r}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function Mst(r){let{inputs:t,backend:n,attrs:s}=r,{image:i,transforms:a}=t,{interpolation:o,fillMode:u,fillValue:l,outputShape:c}=s,[h,d,p,f]=i.shape,[m,g]=c??[d,p],y=[h,m,g,f],b=new Ost(d,p,o,u,l,y);return n.runWebGLProgram(b,[i,a],"float32")}var Lst={kernelName:C0,backendName:"webgl",kernelFunc:Mst};function Pst(r){let{inputs:t,attrs:n,backend:s}=r,{axis:i}=n,{x:a}=t;B0(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let o=s.readSync(a.dataId),{outputValues:u,outputShape:l,indices:c}=$Xe(o,i,a.shape,a.dtype);return[s.makeTensorInfo(l,a.dtype,u),s.makeTensorInfo([c.length],"int32",c)]}var Bst={kernelName:tv,backendName:"webgl",kernelFunc:Pst};function Vst(r){let{inputs:t,backend:n,attrs:s}=r,{value:i}=t,{axis:a}=s;a<0&&(a+=i.shape.length);let o=i,u=o.shape.length,l=i.shape[a],c=new Array(u-1),h=0;for(let g=0;g<u;g++)g!==a&&(c[h++]=o.shape[g]);let d=[],p=new Array(u).fill(0),f=o.shape.slice();f[a]=1;let m=new Array(l);for(let g=0;g<m.length;g++){p[a]=g;let y=j0({inputs:{x:o},backend:n,attrs:{begin:p,size:f}}),b=gt({inputs:{x:y},backend:n,attrs:{shape:c}});m[g]=b,d.push(y)}return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}var zst={kernelName:_0,backendName:"webgl",kernelFunc:Vst},Ust=class{constructor(r,t){this.variableNames=["x","segmentIds"];let n=r.windowSize,s=r.batchSize,i=r.inSize,a=r.numSegments,o=a*Math.ceil(i/n);this.outputShape=[s,o];let u="0.0",l="sumValue",c=Math.floor(n/4)*4,h=n%4,d=`
        sumValue += dot(values, segFilter);
    `,p="";i%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let f="";i%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function Wst(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,segmentIds:a}=t,{numSegments:o}=s,u=i.shape.length,l=[],c=0,h=q.getAxesPermutation([c],u),d=i;h!=null&&(d=li({inputs:{x:i},backend:n,attrs:{perm:h}}),l.push(d),c=q.getInnerMostAxes(1,u)[0]);let p=q.segment_util.computeOutShape(d.shape,c,o),f=O.sizeFromShape([d.shape[c]]),m=gt({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}});l.push(m);let g=VC(i.dtype),y=(v,S,E,C,I)=>{let _=v.shape[0],A=v.shape[1],k=q.segment_util.segOpComputeOptimalWindowSize(A,I),N={windowSize:k,inSize:A,batchSize:_,numSegments:I},D=new Ust(N,S),F=n.compileAndRun(D,[v,E],C);if(l.push(F),F.shape[1]===I)return F;let P=Ree({backend:n,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),G=Oee({inputs:{x:P},backend:n,attrs:{reps:[A/k]}});return l.push(P),l.push(G),y(F,S,G,C,I)},b=y(m,"unsortedSegmentSum",a,g,o),x=gt({inputs:{x:b},backend:n,attrs:{shape:p}}),w=x;if(h!=null){l.push(x);let v=q.getUndoAxesPermutation(h);w=li({inputs:{x:w},backend:n,attrs:{perm:v}})}return l.forEach(v=>n.disposeIntermediateTensorInfo(v)),w}var Gst={kernelName:rv,backendName:"webgl",kernelFunc:Wst},Hst=[IYe,NYe,DYe,RYe,MYe,BYe,zYe,WYe,qYe,XYe,JYe,tZe,sZe,uZe,hZe,pZe,mZe,xZe,wZe,CZe,kZe,RZe,MZe,VZe,UZe,KZe,YZe,eJe,lYe,nJe,uJe,dJe,bJe,wJe,CJe,EJe,kJe,DJe,RJe,LJe,BJe,zJe,WJe,jJe,KJe,JJe,eQe,nQe,aQe,uQe,dQe,gQe,vQe,CQe,IQe,kQe,TQe,DQe,$Qe,OQe,LQe,zQe,GQe,qQe,XQe,JQe,tet,iet,cet,uYe,det,aJe,met,bet,wet,hYe,Iet,Aet,Fet,Met,Bet,Wet,jet,Yet,ett,ntt,itt,ltt,htt,ptt,ytt,xtt,wtt,Ctt,Ett,Ttt,$tt,Ltt,Htt,fYe,Xtt,Jtt,trt,srt,GZe,ort,lrt,hrt,frt,brt,pYe,vrt,Srt,_rt,Irt,krt,HZe,ztt,Art,Rrt,Prt,gYe,Urt,Hrt,Xrt,Jrt,rnt,snt,ont,cnt,pnt,gnt,xnt,Snt,Int,Tnt,$nt,Mnt,FZe,Wtt,Bnt,znt,Wnt,Hnt,qnt,Xnt,Znt,Qnt,tst,sst,ast,ust,cst,pst,mst,yst,xst,Utt,CYe,Sst,Est,kst,Ast,Rst,Lst,_Ye,Bst,zst,Gst,urt];for(let r of Hst)nv(r);var Lr;(function(r){r[r.float32=0]="float32",r[r.int32=1]="int32",r[r.bool=2]="bool",r[r.string=3]="string",r[r.complex64=4]="complex64"})(Lr||(Lr={}));var ox;(function(r){r[r.linear=0]="linear",r[r.relu=1]="relu",r[r.relu6=2]="relu6",r[r.prelu=3]="prelu",r[r.leakyrelu=4]="leakyrelu",r[r.sigmoid=5]="sigmoid",r[r.elu=6]="elu"})(ox||(ox={}));var Mee;function jst(r){Mee=r.wasm.cwrap(cd,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function qst(r){let{inputs:t,backend:n,attrs:s}=r,{a:i,b:a,bias:o,preluActivationWeights:u}=t;if(i.dtype!=="float32"||a.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:d}=s,p=n.dataIdMap.get(i.dataId).id,f=n.dataIdMap.get(a.dataId).id,m=0;if(o!=null){let I=n.dataIdMap.get(o.dataId);if(I.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${I.shape.length}.`);m=I.id}let g=u==null?0:n.dataIdMap.get(u.dataId).id,y=ox[h];if(y==null)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);let b=l?i.shape[2]:i.shape[1],x=c?a.shape[1]:a.shape[2],w=k0.assertAndGetBroadcastShape(i.shape.slice(0,-2),a.shape.slice(0,-2)),v=n.makeOutput([...w,b,x],i.dtype),S=n.dataIdMap.get(v.dataId).id,E=new Uint8Array(new Int32Array(i.shape).buffer),C=new Uint8Array(new Int32Array(a.shape).buffer);return Mee(p,E,i.shape.length,f,C,a.shape.length,l,c,y,m,g,d||0,S),v}var Kst={kernelName:cd,backendName:"wasm",setupFunc:jst,kernelFunc:qst};function Nr(r,t){let n;function s(a){n=a.wasm.cwrap(r,null,["number","number","number"])}function i(a){let{backend:o,inputs:{x:u}}=a,l=o.dataIdMap.get(u.dataId).id,c=o.makeOutput(u.shape,t||u.dtype),h=o.dataIdMap.get(c.dataId).id;return O.sizeFromShape(c.shape)===0||n(l,Lr[u.dtype],h),c}return{kernelName:r,backendName:"wasm",setupFunc:s,kernelFunc:i}}var Xst=Nr(Eg),Yst=Nr(Hd),Zst=Nr(jd);function Qn(r,t,n){let s;function i(o){s=o.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function a(o){let{backend:u,inputs:l}=o,{a:c,b:h}=l,d=u.dataIdMap.get(c.dataId).id,p=u.dataIdMap.get(h.dataId).id,f=n??c.dtype,m=q.assertAndGetBroadcastShape(c.shape,h.shape),g=u.makeOutput(m,f);if(O.sizeFromShape(m)===0)return g;let y=new Uint8Array(new Int32Array(c.shape).buffer),b=new Uint8Array(new Int32Array(h.shape).buffer),x=u.dataIdMap.get(g.dataId).id;return s(d,y,c.shape.length,p,b,h.shape.length,Lr[c.dtype],x),g}return{kernelName:r,backendName:"wasm",setupFunc:i,kernelFunc:a}}var Jst=Qn(Mc),Lee;function Qst(r){Lee=r.wasm.cwrap(qd,null,["array","number","number","number"])}function eit(r){let{inputs:t,backend:n}=r,s=n.makeOutput(t[0].shape,t[0].dtype);if(O.sizeFromShape(s.shape)===0)return s;let i=t.map(u=>n.dataIdMap.get(u.dataId).id),a=new Uint8Array(new Int32Array(i).buffer),o=n.dataIdMap.get(s.dataId).id;return Lee(a,i.length,Lr[s.dtype],o),s}var tit={kernelName:qd,backendName:"wasm",setupFunc:Qst,kernelFunc:eit};function X_(r){let{inputs:{x:t},backend:n}=r;if(t.dtype==="string")return ai(n.readSync(t.dataId),t.shape,t.dtype);let s=n.makeOutput(t.shape,t.dtype),i=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(s).set(i),s}var rit={kernelName:vp,backendName:"wasm",kernelFunc:X_},Pee;function nit(r){Pee=r.wasm.cwrap(el,null,["number","array","number","number","number","array","number"])}function Nc(r){let{inputs:t,backend:n,attrs:s}=r,[i,a]=iit(t.x.shape,s.perm),o=!0;for(let m=0;m<a.length;m++)a[m]!==m&&(o=!1);let u=sit(t.x.shape,s.perm),l={dataId:t.x.dataId,shape:i,dtype:t.x.dtype};if(o){let m=X_({inputs:t,backend:n});return m.shape=u,m}let c=n.makeOutput(u,l.dtype),h=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(c.dataId).id,p=new Uint8Array(new Int32Array(a).buffer),f=new Uint8Array(new Int32Array(l.shape).buffer);return Pee(h,f,l.shape.length,Lr[l.dtype],d,p,a.length),c}function sit(r,t){let n=new Array(r.length);for(let s=0;s<n.length;s++)n[s]=r[t[s]];return n}function iit(r,t){let n=[],s=[];for(let i=0;i<r.length;++i)r[i]!==1&&n.push(r[i]),r[t[i]]!==1&&s.push(t[i]);for(let i=0;i<s.length;++i){let a=-1;for(let o=0;o<s.length;++o)s[o]>=i&&(a===-1||s[a]>s[o])&&(a=o);s[a]=i}return[n,s]}var ait={kernelName:el,backendName:"wasm",kernelFunc:Nc,setupFunc:nit};function qc(r,t,n){let s=r.shape,i=r.shape.length,a=O.parseAxisParam(t,s),o=a,u=q.getAxesPermutation(o,i),l=null,c=!1;if(u!=null){let h=new Array(i);for(let p=0;p<h.length;p++)h[p]=s[u[p]];o=q.getInnerMostAxes(o.length,i),l=Nc({inputs:{x:r},attrs:{perm:u},backend:n});let d=n.dataIdMap.get(r.dataId).id;n.dataIdMap.get(l.dataId).id!==d&&(c=!0)}return{transposed:l,originalAxes:a,axes:o,inputWasTransposed:c}}var Bee;function oit(r){Bee=r.wasm.cwrap(Ig,null,["number, number, number"])}function uit(r){let{backend:t,inputs:n,attrs:s}=r,{axis:i,keepDims:a}=s,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,l=o,{transposed:c,axes:h,originalAxes:d,inputWasTransposed:p}=qc(o,i,t);if(p){let x=t.dataIdMap.get(c.dataId).id;l=c,u=x}let f=l.shape.length;q.assertAxesAreInnerMostDims("all",h,f);let[m,g]=q.computeOutAndReduceShapes(l.shape,h),y=O.sizeFromShape(g),b=t.makeOutput(m,o.dtype);if(O.sizeFromShape(l.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;Bee(u,y,x)}if(p&&t.disposeData(c.dataId),a){let x=q.expandShapeToKeepDim(b.shape,d);b.shape=x}return b}var lit={kernelName:Ig,backendName:"wasm",setupFunc:oit,kernelFunc:uit},Vee;function cit(r){Vee=r.wasm.cwrap(kg,null,["number, number, number"])}function hit(r){let{backend:t,inputs:n,attrs:s}=r,{axis:i,keepDims:a}=s,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,l=o,{transposed:c,axes:h,originalAxes:d,inputWasTransposed:p}=qc(o,i,t);if(p){let x=t.dataIdMap.get(c.dataId).id;l=c,u=x}let f=l.shape.length;q.assertAxesAreInnerMostDims("any",h,f);let[m,g]=q.computeOutAndReduceShapes(l.shape,h),y=O.sizeFromShape(g),b=t.makeOutput(m,o.dtype);if(O.sizeFromShape(l.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;Vee(u,y,x)}if(p&&t.disposeData(c.dataId),a){let x=q.expandShapeToKeepDim(b.shape,d);b.shape=x}return b}var dit={kernelName:kg,backendName:"wasm",setupFunc:cit,kernelFunc:hit};function zee(r){let t;function n(i){t=i.wasm.cwrap(r,null,["number","number","number","number","number"])}function s(i){let{backend:a,inputs:o,attrs:u}=i,{axis:l}=u,{x:c}=o,h=a.dataIdMap.get(c.dataId).id,d=h,p=c,{transposed:f,axes:m,inputWasTransposed:g}=qc(c,l,a);if(g){let S=a.dataIdMap.get(f.dataId).id;S!==h&&(p=f,d=S)}let y=p.shape.slice(0,-1),b=a.makeOutput(y,"int32"),x=a.dataIdMap.get(b.dataId).id,w=O.sizeFromShape(b.shape),v=p.shape[m[0]];return t(d,Lr[p.dtype],w,v,x),g&&a.disposeData(f.dataId),b}return{kernelName:r,backendName:"wasm",setupFunc:n,kernelFunc:s}}var pit=zee(Ng),fit=zee(Tg),mit=Nr(Kd),git=Nr(Xd),yit=Nr(Yd),bit=Qn(Jd),xit=Nr(Zd),Uee;function vit(r){Uee=r.wasm.cwrap(Qd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function wit(r){let{inputs:t,attrs:n,backend:s}=r,i=t.x,a=s.dataIdMap.get(i.dataId).id,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=n,h=q.computePool2DInfo(i.shape,o,u,1,l,c),d=h.filterHeight,p=h.filterWidth,f=h.padInfo.top,m=h.padInfo.right,g=h.padInfo.bottom,y=h.padInfo.left,b=h.strideHeight,x=h.strideWidth,w=h.inChannels;if(h.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);if(h.dilationWidth!==1||h.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${h.dilationHeight}, ${h.dilationWidth}].`);let v=s.makeOutput(h.outShape,"float32"),S=s.dataIdMap.get(v.dataId).id;return Uee(a,i.shape[0],i.shape[1],i.shape[2],d,p,f,m,g,y,b,x,w,S),v}var Sit={kernelName:Qd,backendName:"wasm",setupFunc:vit,kernelFunc:wit},Wee;function Cit(r){Wee=r.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function _it(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l,dataFormat:c}=s,h=q.computePool3DInfo(i.shape,a,o,1,u,l,c),d=n.makeOutput(h.outShape,i.dtype);return Wee(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,h.batchSize,h.inChannels,h.inDepth,h.inHeight,h.inWidth,h.outDepth,h.outHeight,h.outWidth,h.strideDepth,h.strideHeight,h.strideWidth,h.dilationDepth,h.dilationHeight,h.dilationWidth,h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth,h.padInfo.front,h.padInfo.top,h.padInfo.left),d}var Eit={kernelName:Ag,backendName:"wasm",setupFunc:Cit,kernelFunc:_it},Gee;function Iit(r){Gee=r.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function kit(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=s,h=q.computePool3DInfo(a.shape,o,u,1,l,c),d=n.makeOutput(a.shape,a.dtype);return Gee(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,h.batchSize,h.inChannels,h.inDepth,h.inHeight,h.inWidth,h.outDepth,h.outHeight,h.outWidth,h.strideDepth,h.strideHeight,h.strideWidth,h.dilationDepth,h.dilationHeight,h.dilationWidth,h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth,h.padInfo.front,h.padInfo.top,h.padInfo.left,h.filterDepth,h.filterHeight,h.filterWidth),d}var Nit={kernelName:Lx,backendName:"wasm",setupFunc:Iit,kernelFunc:kit},Hee;function Tit(r){Hee=r.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ait(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,{filterSize:o,strides:u,pad:l}=s,c=q.computePool2DInfo(a.shape,o,u,1,l),h=n.makeOutput(a.shape,a.dtype);return Hee(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left,c.filterHeight,c.filterWidth),h}var Dit={kernelName:Mx,backendName:"wasm",setupFunc:Tit,kernelFunc:Ait};function Ei(r){let{inputs:t,attrs:n}=r,{x:s}=t,{shape:i}=n,a=O.sizeFromShape(s.shape),o=O.inferFromImplicitShape(i,a);return O.assert(a===O.sizeFromShape(o),()=>`new shape: ${o}, old shape: ${s.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(s.dataId),{dataId:s.dataId,shape:o,dtype:s.dtype}}var Fit={kernelName:l0,backendName:"wasm",kernelFunc:Ei},jee;function $it(r){jee=r.wasm.cwrap(ep,null,["number","array","number","number","array","number","number","number","number"])}function Rit(r){let{inputs:t,backend:n,attrs:s}=r,{a:i,b:a}=t,{transposeA:o,transposeB:u}=s;if(i.dtype!=="float32"||a.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=i.shape.length,c=a.shape.length,h=o?i.shape[l-2]:i.shape[l-1],d=u?a.shape[c-1]:a.shape[c-2],p=o?i.shape[l-1]:i.shape[l-2],f=u?a.shape[c-2]:a.shape[c-1],m=i.shape.slice(0,-2),g=a.shape.slice(0,-2),y=O.sizeFromShape(m),b=O.sizeFromShape(g),x=k0.assertAndGetBroadcastShape(i.shape.slice(0,-2),a.shape.slice(0,-2)).concat([p,f]);O.assert(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${i.shape} and ${a.shape} and transposeA=${o} and transposeB=${u} must match.`);let w=o?[y,h,p]:[y,p,h],v=u?[b,f,d]:[b,d,f],S=Ei({inputs:{x:i},backend:n,attrs:{shape:w}}),E=Ei({inputs:{x:a},backend:n,attrs:{shape:v}}),C=n.dataIdMap.get(S.dataId).id,I=n.dataIdMap.get(E.dataId).id,_=o?S.shape[2]:S.shape[1],A=u?E.shape[1]:E.shape[2],k=Math.max(y,b),N=n.makeOutput([k,_,A],S.dtype),D=n.dataIdMap.get(N.dataId).id,F=new Uint8Array(new Int32Array(S.shape).buffer),P=new Uint8Array(new Int32Array(E.shape).buffer);return jee(C,F,S.shape.length,I,P,E.shape.length,o,u,D),n.disposeData(S.dataId),n.disposeData(E.dataId),N.shape=x,N}var Oit={kernelName:ep,backendName:"wasm",setupFunc:$it,kernelFunc:Rit};function Nd(r){let{inputs:{x:t},attrs:{begin:n,size:s},backend:i}=r,[a,o]=is.parseSliceParams(t,n,s),u=is.isSliceContinous(t.shape,a,o),l=i.readSync(t.dataId),c=i.makeOutput(o,t.dtype),h=O.computeStrides(t.shape),d=i.dataIdMap.get(c.dataId);if(u){let m=is.computeFlatOffset(a,h);return t.dtype==="string"?d.stringBytes=l.slice(m,m+O.sizeFromShape(o)):i.typedArrayFromHeap(c).set(l.subarray(m,m+O.sizeFromShape(o))),c}if(t.dtype==="string"){let m=Z2(l,a,o,t.shape,t.dtype);return d.stringBytes=m,c}let p=i.typedArrayFromHeap(c),f=t.shape.length;if(f===2)Mit(l,h[0],p,a,o);else if(f===3)Lit(l,h[0],h[1],p,a,o);else if(f===4)Pit(l,h[0],h[1],h[2],p,a,o);else{let m=Z2(l,a,o,t.shape,t.dtype);p.set(m)}return c}function Mit(r,t,n,s,i){let a=0,o=s[0],u=s[1],l=o+i[0];for(let c=o;c<l;c++){let h=c*t+u;n.set(r.subarray(h,h+i[1]),a),a+=i[1]}}function Lit(r,t,n,s,i,a){let o=0,u=i[0],l=i[1],c=i[2],h=u+a[0],d=l+a[1];for(let p=u;p<h;p++)for(let f=l;f<d;f++){let m=p*t+f*n+c;s.set(r.subarray(m,m+a[2]),o),o+=a[2]}}function Pit(r,t,n,s,i,a,o){let u=0,l=a[0],c=a[1],h=a[2],d=l+o[0],p=c+o[1],f=h+o[2],m=a[3];for(let g=l;g<d;g++)for(let y=c;y<p;y++)for(let b=h;b<f;b++){let x=g*t+y*n+b*s+m;i.set(r.subarray(x,x+o[3]),u),u+=o[3]}}var Bit={kernelName:g0,backendName:"wasm",kernelFunc:Nd};function Vit(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{blockShape:a,crops:o}=s,u=a.reduce((b,x)=>b*x),l=q.getReshaped(i.shape,a,u),c=q.getPermuted(l.length,a.length),h=q.getReshapedPermuted(i.shape,a,u),d=q.getSliceBeginCoords(o,a.length),p=q.getSliceSize(h,o,a.length),f=Ei({inputs:{x:i},backend:n,attrs:{shape:l}}),m=Nc({inputs:{x:f},backend:n,attrs:{perm:c}}),g=Ei({inputs:{x:m},backend:n,attrs:{shape:h}}),y=Nd({inputs:{x:g},backend:n,attrs:{begin:d,size:p}});return n.disposeData(f.dataId),n.disposeData(m.dataId),n.disposeData(g.dataId),y}var zit={kernelName:Dg,backendName:"wasm",kernelFunc:Vit},qee;function Uit(r){qee=r.wasm.cwrap(Fg,null,["number","number","boolean","number","number","number"])}function Wit(r){let{backend:t,inputs:n,attrs:s}=r,{x:i,weights:a}=n,{size:o}=s,u=a.shape.reduce((d,p)=>d*p,1)!==0,l=i.shape.length===1?[o]:[i.shape[0],o],c=t.makeOutput(l,a.dtype);function h(d){return t.dataIdMap.get(d.dataId).id}return qee(h(i),o,u,h(a),Lr[a.dtype],h(c)),c}var Git={kernelName:Fg,backendName:"wasm",setupFunc:Uit,kernelFunc:Wit},Hit=Qn($g);function jit(r){let{inputs:t,backend:n}=r,{s0:s,s1:i}=t,a=n.typedArrayFromHeap(s),o=n.typedArrayFromHeap(i),u=q.assertAndGetBroadcastShape(Array.from(a),Array.from(o));return n.makeOutput([u.length],"int32",void 0,new Int32Array(u))}var qit={kernelName:Px,backendName:"wasm",kernelFunc:jit};function Kc(r){let{inputs:{x:t},attrs:{dtype:n},backend:s}=r,i=s.makeOutput(t.shape,n),a=s.typedArrayFromHeap(t);return s.typedArrayFromHeap(i).set(a),i}var Kit={kernelName:tp,backendName:"wasm",kernelFunc:Kc},Xit=Nr(rp),Kee;function Yit(r){Kee=r.wasm.cwrap(Lc,null,["number","number","number","number"])}function Zit(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{clipValueMin:a,clipValueMax:o}=s,u=n.dataIdMap.get(i.dataId).id,l=n.makeOutput(i.shape,i.dtype),c=n.dataIdMap.get(l.dataId).id;return Kee(u,a,o,c),l}var Jit={kernelName:Lc,backendName:"wasm",setupFunc:Yit,kernelFunc:Zit};function Xee(r){let{inputs:t,backend:n}=r,s=O.parseAxisParam(r.attrs.axis,t[0].shape)[0],i=t.map(f=>f.shape);q.assertParamsConsistent(i,s);let a=q.computeOutShape(t.map(f=>f.shape),s),o=t.filter(f=>O.sizeFromShape(f.shape)>0);if(o.length===1)return X_({inputs:{x:o[0]},backend:n});let u=n.makeOutput(a,t[0].dtype);if(O.sizeFromShape(a)===0)return u;if(o[0].dtype==="string"){let f=o.map(w=>{let v=[-1,O.sizeFromShape(w.shape.slice(s))];return Ei({inputs:{x:w},backend:n,attrs:{shape:v}})}),m=f.map(w=>({vals:n.readSync(w.dataId),shape:w.shape}));a=q.computeOutShape(f.map(w=>w.shape),1);let g=f[0].shape[0]===1,y=GM(m,a,t[0].dtype,g),b=q.computeOutShape(o.map(w=>w.shape),s);u.shape=b;let x=n.dataIdMap.get(u.dataId);return x.stringBytes=q.fromStringArrayToUint8(y),f.forEach(w=>n.disposeData(w.dataId)),u}let l=O.sizeFromShape(o[0].shape.slice(0,s)),c=0,h=o.map(f=>{let m=O.sizeFromShape(f.shape.slice(s));return c+=m,m}),d=o.map(f=>n.typedArrayFromHeap(f)),p=n.typedArrayFromHeap(u);for(let f=0;f<l;f++){let m=f*c;for(let g=0;g<d.length;g++){let y=h[g],b=f*y,x=d[g].subarray(b,b+y);p.set(x,m),m+=y}}return u}var Qit={kernelName:Rg,backendName:"wasm",kernelFunc:Xee},Yee;function eat(r){Yee=r.wasm.cwrap(np,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function tat(r){let{inputs:t,attrs:n,backend:s}=r,{x:i,filter:a}=t,o=s.dataIdMap.get(i.dataId).id,u=s.dataIdMap.get(a.dataId).id,{strides:l,dilations:c,pad:h,dimRoundingMode:d,dataFormat:p}=n,f=q.convertConv2DDataFormat(p),m=q.computeConv2DInfo(i.shape,a.shape,l,c,h,d,!1,f),g=m.filterHeight,y=m.filterWidth,b=m.padInfo.top,x=m.padInfo.right,w=m.padInfo.bottom,v=m.padInfo.left,S=m.dilationHeight,E=m.dilationWidth,C=m.strideHeight,I=m.strideWidth,_=m.inChannels,A=m.outChannels,k=m.padInfo.type==="SAME"?1:0;if(m.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${m.dataFormat}'. Please use 'channelsLast'.`);let N=s.makeOutput(m.outShape,"float32"),D=s.dataIdMap.get(N.dataId).id;return Yee(o,i.shape[0],i.shape[1],i.shape[2],u,g,y,b,x,w,v,k,S,E,C,I,_,A,D),N}var rat={kernelName:np,backendName:"wasm",setupFunc:eat,kernelFunc:tat},Zee;function nat(r){Zee=r.wasm.cwrap(sp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function sat(r){let{backend:t,inputs:n,attrs:s}=r,{dy:i,filter:a}=n,{strides:o,pad:u,dataFormat:l,dimRoundingMode:c,inputShape:h}=s,d=1,p=q.convertConv2DDataFormat(l),f=q.computeConv2DInfo(h,a.shape,o,d,u,c,!1,p),{batchSize:m,filterHeight:g,filterWidth:y,inChannels:b,inHeight:x,inWidth:w,outChannels:v,outHeight:S,outWidth:E,strideHeight:C,strideWidth:I}=f,_=g-1-f.padInfo.top,A=y-1-f.padInfo.left,k=f.dataFormat==="channelsLast",N=O.computeStrides(f.inShape),D=O.computeStrides(i.shape),[F,P,G]=O.computeStrides(a.shape),Y=N[0],Z=k?N[1]:N[2],ee=k?N[2]:1,se=k?1:N[1],re=D[0],J=k?D[1]:D[2],le=k?D[2]:1,he=k?1:D[1],xe=t.makeOutput(f.inShape,"float32"),Fe=t.dataIdMap.get(xe.dataId).id,Le=t.dataIdMap.get(i.dataId).id,Ve=t.dataIdMap.get(a.dataId).id;return Zee(Le,Ve,m,g,y,x,w,b,S,E,v,C,I,_,A,F,P,G,Y,Z,ee,se,re,J,le,he,Fe),xe}var iat={kernelName:sp,backendName:"wasm",setupFunc:nat,kernelFunc:sat},Jee;function aat(r){Jee=r.wasm.cwrap(ip,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function oat(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dilations:l}=s;if(i.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${i.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let c=q.computeConv3DInfo(i.shape,a.shape,o,l,u),h=n.makeOutput(c.outShape,i.dtype);return Jee(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),h}var uat={kernelName:ip,backendName:"wasm",setupFunc:aat,kernelFunc:oat},Qee;function lat(r){Qee=r.wasm.cwrap(Og,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function cat(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,dy:a}=t,{strides:o,pad:u,filterShape:l}=s;if(i.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${i.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let c=q.computeConv3DInfo(i.shape,l,o,1,u),h=n.makeOutput(c.filterShape,a.dtype);return Qee(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),h}var hat={kernelName:Og,backendName:"wasm",setupFunc:lat,kernelFunc:cat},ete;function dat(r){ete=r.wasm.cwrap(Mg,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function pat(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,filter:a}=t,{pad:o,strides:u,inputShape:l}=s;if(i.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${i.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let c=q.computeConv3DInfo(l,a.shape,u,1,o),h=n.makeOutput(c.inShape,i.dtype);return ete(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),h}var fat={kernelName:Mg,backendName:"wasm",setupFunc:dat,kernelFunc:pat},mat=Nr(ap),gat=Nr(op),MN;(function(r){r[r.bilinear=0]="bilinear",r[r.nearest=1]="nearest"})(MN||(MN={}));var tte;function yat(r){tte=r.wasm.cwrap(Pg,null,["number","number","number","number","array","number","number","number","number","number"])}function bat(r){let{backend:t,inputs:n,attrs:s}=r,{method:i,extrapolationValue:a,cropSize:o}=s,{image:u,boxes:l,boxInd:c}=n,h=l.shape[0],[d,p]=o,f=[h,d,p,u.shape[3]],m=t.dataIdMap.get(u.dataId),g;u.dtype!=="float32"&&(g=Kc({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));let y=m.id,b=t.dataIdMap.get(l.dataId).id,x=t.dataIdMap.get(c.dataId).id,w=t.makeOutput(f,"float32"),v=t.dataIdMap.get(w.dataId).id,S=new Uint8Array(new Int32Array(u.shape).buffer);return tte(y,b,x,h,S,d,p,MN[i],a,v),g!=null&&t.disposeData(g.dataId),w}var xat={kernelName:Pg,backendName:"wasm",setupFunc:yat,kernelFunc:bat},rte;function vat(r){rte=r.wasm.cwrap(Lg,null,["number","number","number","number","number","number"])}function wat(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,exclusive:o,reverse:u}=s,l=i.shape.length;O.assert(i.dtype==="float32"||i.dtype==="int32",()=>`cumprod does not support ${i.dtype} tensors in the WASM backend`);let c=q.getAxesPermutation([a],l),h=i;c!==null&&(h=Nc({inputs:{x:i},attrs:{perm:c},backend:n}));let d=q.getInnerMostAxes(1,l)[0];q.assertAxesAreInnerMostDims("cumprod",[d],l);let p=n.makeOutput(h.shape,h.dtype),f=h.shape[d],m=n.dataIdMap.get(h.dataId).id,g=n.dataIdMap.get(p.dataId).id;rte(m,o?1:0,u?1:0,f,g,Lr[i.dtype]);let y=p;if(c!==null){let b=q.getUndoAxesPermutation(c);y=Nc({inputs:{x:p},attrs:{perm:b},backend:n}),n.disposeData(h.dataId),n.disposeData(p.dataId)}return y}var Sat={kernelName:Lg,backendName:"wasm",setupFunc:vat,kernelFunc:wat},nte;function Cat(r){nte=r.wasm.cwrap(up,null,["number","number","number","number","number","number"])}function _at(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{axis:a,exclusive:o,reverse:u}=s,l=i.shape.length;O.assert(i.dtype==="float32"||i.dtype==="int32",()=>`cumsum does not support ${i.dtype} tensors in the WASM backend`);let c=q.getAxesPermutation([a],l),h=i;c!==null&&(h=Nc({inputs:{x:i},attrs:{perm:c},backend:n}));let d=q.getInnerMostAxes(1,l)[0];q.assertAxesAreInnerMostDims("cumsum",[d],l);let p=n.makeOutput(h.shape,h.dtype),f=h.shape[d],m=n.dataIdMap.get(h.dataId).id,g=n.dataIdMap.get(p.dataId).id;nte(m,o?1:0,u?1:0,f,g,Lr[i.dtype]);let y=p;if(c!==null){let b=q.getUndoAxesPermutation(c);y=Nc({inputs:{x:p},attrs:{perm:b},backend:n}),n.disposeData(h.dataId),n.disposeData(p.dataId)}return y}var Eat={kernelName:up,backendName:"wasm",setupFunc:Cat,kernelFunc:_at},ste;function Iat(r){ste=r.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function kat(r){let{backend:t,inputs:n,attrs:s}=r,{x:i,weights:a}=n,{size:o,binaryOutput:u}=s,l=a.shape.reduce((p,f)=>p*f,1)!==0,c=i.shape.length===1?[o]:[i.shape[0],o],h=t.makeOutput(c,a.dtype);function d(p){return t.dataIdMap.get(p.dataId).id}return ste(d(i),new Uint8Array(new Int32Array(i.shape).buffer),i.shape.length,o,l,d(a),Lr[a.dtype],u,d(h)),h}var Nat={kernelName:Vx,backendName:"wasm",setupFunc:Iat,kernelFunc:kat},ite;function Tat(r){ite=r.wasm.cwrap(Bg,null,["number","number","number","array","number","array","array","number","number"])}function Aat(r){let{backend:t,inputs:n,attrs:s}=r,{x:i}=n,{blockSize:a,dataFormat:o}=s,u=i.shape[0],l=o==="NHWC"?i.shape[1]:i.shape[2],c=o==="NHWC"?i.shape[2]:i.shape[3],h=o==="NHWC"?i.shape[3]:i.shape[1],d=l*a,p=c*a,f=h/(a*a),m=o==="NHWC"?[u,d,p,f]:[u,f,d,p],g=t.makeOutput(m,"float32"),y=t.dataIdMap.get(i.dataId).id,b=new Uint8Array(new Int32Array(O.computeStrides(i.shape)).buffer),x=new Uint8Array(new Int32Array(m).buffer),w=new Uint8Array(new Int32Array(O.computeStrides(m)).buffer),v=t.dataIdMap.get(g.dataId).id;return ite(y,a,o==="NHWC"?1:0,b,i.shape.length-1,x,w,m.length,v),g}var Dat={kernelName:Bg,backendName:"wasm",setupFunc:Tat,kernelFunc:Aat},ate;function Fat(r){ate=r.wasm.cwrap(lp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function $at(r){let{inputs:t,attrs:n,backend:s}=r,{x:i,filter:a}=t,o=s.dataIdMap.get(i.dataId).id,u=s.dataIdMap.get(a.dataId).id,{strides:l,dilations:c,pad:h,dimRoundingMode:d}=n,p=c??[1,1],f=q.computeConv2DInfo(i.shape,a.shape,l,p,h,d,!0),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,x=f.padInfo.bottom,w=f.padInfo.left,v=f.dilationHeight,S=f.dilationWidth,E=f.strideHeight,C=f.strideWidth,I=f.inChannels,_=f.outChannels,A=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let k=s.makeOutput(f.outShape,"float32"),N=s.dataIdMap.get(k.dataId).id;return ate(o,i.shape[0],i.shape[1],i.shape[2],u,m,g,y,b,x,w,A,v,S,E,C,I,_,N),k}var Rat={kernelName:lp,backendName:"wasm",setupFunc:Fat,kernelFunc:$at},ote;function Oat(r){ote=r.wasm.cwrap("Diag",null,["number","number","number","number"])}function Mat(r){let{inputs:t,backend:n}=r,{x:s}=t,i=O.sizeFromShape(s.shape),a=n.makeOutput([...s.shape,...s.shape],s.dtype);return ote(n.dataIdMap.get(s.dataId).id,Lr[s.dtype],i,n.dataIdMap.get(a.dataId).id),a}var Lat={kernelName:zx,backendName:"wasm",setupFunc:Oat,kernelFunc:Mat},ute;function Pat(r){ute=r.wasm.cwrap(cp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Bat(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a}=t,{strides:o,pad:u,dilations:l}=s;if(i.dtype!==a.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${i.dtype} and ${a.dtype}`);let c=q.computeDilation2DInfo(i.shape,a.shape,o,u,"NHWC",l),h=n.makeOutput(c.outShape,i.dtype);return ute(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,Lr[i.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),h}var Vat={kernelName:cp,backendName:"wasm",setupFunc:Pat,kernelFunc:Bat},lte;function zat(r){lte=r.wasm.cwrap(Wm,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Uat(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a,dy:o}=t,{strides:u,pad:l,dilations:c}=s;if(i.dtype!==a.dtype||i.dtype!==o.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${i.dtype}, ${a.dtype}, and ${o.dtype}`);let h=q.computeDilation2DInfo(i.shape,a.shape,u,l,"NHWC",c),d=n.makeOutput(a.shape,a.dtype);return lte(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,n.dataIdMap.get(d.dataId).id,Lr[i.dtype],h.batchSize,h.inChannels,h.inHeight,h.inWidth,h.outHeight,h.outWidth,h.strideHeight,h.strideWidth,h.dilationHeight,h.dilationWidth,h.filterHeight,h.filterWidth,h.padInfo.top,h.padInfo.left),d}var Wat={kernelName:Wm,backendName:"wasm",setupFunc:zat,kernelFunc:Uat},cte;function Gat(r){cte=r.wasm.cwrap(Um,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Hat(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,filter:a,dy:o}=t,{strides:u,pad:l,dilations:c}=s;if(i.dtype!==a.dtype||i.dtype!==o.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${i.dtype}, ${a.dtype}, and ${o.dtype}`);let h=q.computeDilation2DInfo(i.shape,a.shape,u,l,"NHWC",c),d=n.makeOutput(i.shape,i.dtype);return cte(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,n.dataIdMap.get(d.dataId).id,Lr[i.dtype],h.batchSize,h.inChannels,h.inHeight,h.inWidth,h.outHeight,h.outWidth,h.strideHeight,h.strideWidth,h.dilationHeight,h.dilationWidth,h.filterHeight,h.filterWidth,h.padInfo.top,h.padInfo.left),d}var jat={kernelName:Um,backendName:"wasm",setupFunc:Gat,kernelFunc:Hat},qat=Nr(dp),hte;function Kat(r){hte=r.wasm.cwrap(Vg,null,["number","number","number"])}function Xat(r){let{inputs:t,backend:n}=r,{dy:s,y:i}=t,a=n.makeOutput(i.shape,"float32"),o=u=>n.dataIdMap.get(u.dataId).id;return hte(o(i),o(s),o(a)),a}var Yat={kernelName:Vg,backendName:"wasm",setupFunc:Kat,kernelFunc:Xat},Zat=!1,Jat=Qn(zg,Zat,"bool"),Qat=Nr(pp),eot=Nr(fp,"float32");function LN(r){let{inputs:t,attrs:n,backend:s}=r,{input:i}=t,{dim:a}=n,o=i.shape.length,u=i.shape.slice(),l=a;return a<0&&(O.assert(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+a+1),u.splice(l,0,1),Ei({inputs:{x:i},backend:s,attrs:{shape:u}})}var tot={kernelName:Ug,backendName:"wasm",kernelFunc:LN},rot=Nr(mp,"float32");function dte(r){let{attrs:{shape:t,value:n},backend:s}=r,{attrs:{dtype:i}}=r;i=i||O.inferDtype(n);let a=s.makeOutput(t,i);return s.typedArrayFromHeap(a).fill(n),a}var not={kernelName:Ux,backendName:"wasm",kernelFunc:dte},pte;function sot(r){pte=r.wasm.cwrap(Wg,null,["number","number","number","number","number","number"])}function iot(r){let{inputs:t,backend:n}=r,{image:s}=t,i=n.makeOutput(s.shape,s.dtype),a=n.dataIdMap.get(s.dataId).id,o=n.dataIdMap.get(i.dataId).id,[u,l,c,h]=s.shape;return pte(a,u,l,c,h,o),i}var aot={kernelName:Wg,backendName:"wasm",kernelFunc:iot,setupFunc:sot},oot=Nr(gp),uot=Qn(yp),fte;function lot(r){fte=r.wasm.cwrap(bp,null,["number","number","number","number","number","number","number"])}function cot(r){let{backend:t,inputs:n,attrs:s}=r,{varianceEpsilon:i}=s,{x:a,mean:o,variance:u,offset:l,scale:c}=n,h=t.dataIdMap.get(a.dataId).id,d=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(u.dataId).id,f=l!=null?t.dataIdMap.get(l.dataId).id:0,m=c!=null?t.dataIdMap.get(c.dataId).id:0,g=t.makeOutput(a.shape,a.dtype);if(O.sizeFromShape(a.shape)===0)return g;let y=t.dataIdMap.get(g.dataId).id;return fte(h,d,p,f,m,i,y),g}var hot={kernelName:bp,backendName:"wasm",setupFunc:lot,kernelFunc:cot},mte;function dot(r){mte=r.wasm.cwrap(hd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function pot(r){let{inputs:t,attrs:n,backend:s}=r,{x:i,filter:a,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dilations:h,dataFormat:d,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=n,g=q.computeConv2DInfo(i.shape,a.shape,l,h,c,p),y=ox[f];if(y==null)throw new Error(`${f} activation not yet supported for FusedConv2D in the wasm backend.`);let b=s.dataIdMap.get(i.dataId).id,x=s.dataIdMap.get(a.dataId).id,w=g.outChannels,v=0;if(o!=null){let le=s.dataIdMap.get(o.dataId);if(le.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${le.shape.length}.`);if(le.shape[0]!==w)throw new Error(`FusedConv2D bias shape (${le.shape}) does not match the number of output channels (${w})`);v=le.id}let S=g.filterHeight,E=g.filterWidth,C=g.padInfo.top,I=g.padInfo.right,_=g.padInfo.bottom,A=g.padInfo.left,k=g.dilationHeight,N=g.dilationWidth,D=g.strideHeight,F=g.strideWidth,P=g.inChannels,G=g.padInfo.type==="SAME"?1:0,Y=g.batchSize,Z=g.inHeight,ee=g.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let se=s.makeOutput(g.outShape,"float32"),re=s.dataIdMap.get(se.dataId).id,J=u==null?0:s.dataIdMap.get(u.dataId).id;return mte(b,Y,Z,ee,x,S,E,v,C,I,_,A,G,k,N,D,F,P,w,y,J,m||0,re),se}var fot={kernelName:hd,backendName:"wasm",setupFunc:dot,kernelFunc:pot},gte;function mot(r){gte=r.wasm.cwrap(dd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function got(r){let{inputs:t,attrs:n,backend:s}=r,{x:i,filter:a,bias:o,preluActivationWeights:u}=t,{strides:l,pad:c,dilations:h,dataFormat:d,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=n,g=q.computeConv2DInfo(i.shape,a.shape,l,h,c,p,!0),y=ox[f];if(y==null)throw new Error(`${f} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let b=s.dataIdMap.get(i.dataId).id,x=s.dataIdMap.get(a.dataId).id,w=g.outChannels,v=0;if(o!=null){let le=s.dataIdMap.get(o.dataId);if(le.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${le.shape.length}.`);if(le.shape[0]!==w)throw new Error(`FusedDepthwiseConv2D bias shape (${le.shape}) does not match the number of output channels (${w})`);v=le.id}let S=g.filterHeight,E=g.filterWidth,C=g.padInfo.top,I=g.padInfo.right,_=g.padInfo.bottom,A=g.padInfo.left,k=g.dilationHeight,N=g.dilationWidth,D=g.strideHeight,F=g.strideWidth,P=g.inChannels,G=g.padInfo.type==="SAME"?1:0,Y=g.batchSize,Z=g.inHeight,ee=g.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let se=s.makeOutput(g.outShape,"float32"),re=s.dataIdMap.get(se.dataId).id,J=u==null?0:s.dataIdMap.get(u.dataId).id;return gte(b,Y,Z,ee,x,S,E,v,C,I,_,A,G,k,N,D,F,P,w,y,J,m||0,re),se}var yot={kernelName:dd,backendName:"wasm",setupFunc:mot,kernelFunc:got},yte;function bot(r){yte=r.wasm.cwrap(Hg,null,["number","number","number","number","number","number","array","number"])}function xot(r){let{backend:t,inputs:n}=r,{params:s,indices:i}=n,[a,o,u,l]=rO.prepareAndValidate(s,i),c=t.makeOutput(a,s.dtype);if(o===0)return c;let h=i.shape,d=h[h.length-1],p=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=new Uint8Array(new Int32Array(l).buffer),g=t.dataIdMap.get(c.dataId).id;return yte(p,Lr[s.dtype],f,o,d,u,m,g),c}var vot={kernelName:Hg,backendName:"wasm",setupFunc:bot,kernelFunc:xot},bte;function wot(r){bte=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function Sot(r){let{backend:t,inputs:n,attrs:s}=r,{x:i,indices:a}=n,{axis:o,batchDims:u}=s,l=O.parseAxisParam(o,i.shape)[0],c=t.readSync(a.dataId),h=i.shape[l];for(let C=0;C<c.length;++C){let I=c[C];O.assert(I<=h-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${h-1}]`)}let d=q.segment_util.collectGatherOpShapeInfo(i,a,l,u),p=Ei({inputs:{x:i},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),f=O.sizeFromShape(a.shape),m=Ei({inputs:{x:a},attrs:{shape:[d.batchSize,f/d.batchSize]},backend:t}),g=[d.batchSize,d.outerSize,f/d.batchSize,d.sliceSize],y=t.makeOutput(g,i.dtype);if(O.sizeFromShape(i.shape)===0)return y;let b=p.shape.length-1,x=t.dataIdMap.get(p.dataId).id,w=t.dataIdMap.get(m.dataId).id,v=t.dataIdMap.get(y.dataId).id,S=new Uint8Array(new Int32Array(O.computeStrides(p.shape)).buffer),E=new Uint8Array(new Int32Array(O.computeStrides(g)).buffer);return bte(x,Lr[i.dtype],S,b,w,d.batchSize,E,v),t.disposeData(p.dataId),t.disposeData(m.dataId),y.shape=d.outputShape,y}var Cot={kernelName:Gg,backendName:"wasm",setupFunc:wot,kernelFunc:Sot},_ot=!1,Eot=Qn(jg,_ot,"bool"),Iot=!1,kot=Qn(xp,Iot,"bool"),Not=Nr(wp,"bool"),Tot=Nr(Sp,"bool"),Aot=Nr(Cp,"bool"),xte;function Dot(r){xte=r.wasm.cwrap(_p,null,["number","number","number","number"])}function Fot(r){let{inputs:{x:t},attrs:{alpha:n},backend:s}=r,i=s.dataIdMap.get(t.dataId).id,a=s.makeOutput(t.shape,"float32");if(O.sizeFromShape(t.shape)!==0){let o=s.dataIdMap.get(a.dataId).id;xte(i,Lr[t.dtype],n,o)}return a}var $ot={kernelName:_p,backendName:"wasm",setupFunc:Dot,kernelFunc:Fot},Rot=!1,Oot=Qn(qg,Rot,"bool"),Mot=!1,Lot=Qn(Kg,Mot,"bool"),vte;function Pot(r){vte=r.wasm.cwrap(Xg,null,["number","number","number","number"])}function Bot(r){let{attrs:t,backend:n}=r,{start:s,stop:i,num:a}=t,o=Math.floor(a),u=n.makeOutput([o],"float32");return vte(n.dataIdMap.get(u.dataId).id,s,i,o),u}var Vot={kernelName:Xg,backendName:"wasm",setupFunc:Pot,kernelFunc:Bot},zot=Nr(Ep),Uot=Nr(Ip),Wot=!1,Got=Qn(Yg,Wot,"bool"),Hot=Nr(Zg),jot=!1,qot=Qn(Jg,jot,"bool"),Kot=!1,Xot=Qn(xq,Kot,"bool"),wte;function Yot(r){wte=r.wasm.cwrap(kp,null,["number","number","number","number","number","number","number"])}function Zot(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{depthRadius:a,bias:o,alpha:u,beta:l}=s;if(i.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let c=n.makeOutput(i.shape,i.dtype);return wte(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,i.shape[3],a,o,u,l),c}var Jot={kernelName:kp,backendName:"wasm",setupFunc:Yot,kernelFunc:Zot},Ste;function Qot(r){Ste=r.wasm.cwrap(Qg,null,["number","number","number","number","number","number","number","number","number"])}function eut(r){let{inputs:t,backend:n,attrs:s}=r,{x:i,y:a,dy:o}=t,{depthRadius:u,bias:l,alpha:c,beta:h}=s;if(i.dtype!=="float32"||a.dtype!=="float32"||o.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let d=n.makeOutput(i.shape,i.dtype);return Ste(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,n.dataIdMap.get(d.dataId).id,o.shape[3],u,l,c,h),d}var tut={kernelName:Qg,backendName:"wasm",setupFunc:Qot,kernelFunc:eut},Cte;function rut(r){Cte=r.wasm.cwrap(Np,null,["number","number","number","number"])}function nut(r){let{backend:t,inputs:n,attrs:s}=r,{reductionIndices:i,keepDims:a}=s,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,l=o,{transposed:c,axes:h,originalAxes:d,inputWasTransposed:p}=qc(o,i,t);if(p){let x=t.dataIdMap.get(c.dataId).id;l=c,u=x}let f=l.shape.length;q.assertAxesAreInnerMostDims("max",h,f);let[m,g]=q.computeOutAndReduceShapes(l.shape,h),y=O.sizeFromShape(g),b=t.makeOutput(m,o.dtype);if(O.sizeFromShape(l.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;Cte(u,Lr[o.dtype],y,x)}if(p&&t.disposeData(c.dataId),a){let x=q.expandShapeToKeepDim(b.shape,d);b.shape=x}return b}var sut={kernelName:Np,backendName:"wasm",setupFunc:rut,kernelFunc:nut},iut=Qn(Tp),_te;function aut(r){_te=r.wasm.cwrap(Ap,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function out(r){let{inputs:t,attrs:n,backend:s}=r,i=t.x,a=s.dataIdMap.get(i.dataId).id;O.assert(i.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${i.dtype}.`);let{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=n,h=q.computePool2DInfo(i.shape,o,u,1,l,c),d=h.filterHeight,p=h.filterWidth,f=h.padInfo.top,m=h.padInfo.right,g=h.padInfo.bottom,y=h.padInfo.left,b=h.dilationHeight,x=h.dilationWidth,w=h.strideHeight,v=h.strideWidth,S=h.inChannels,E=h.outChannels;if(h.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let C=s.makeOutput(h.outShape,"float32"),I=s.dataIdMap.get(C.dataId).id;return _te(a,i.shape[0],i.shape[1],i.shape[2],d,p,f,m,g,y,b,x,w,v,S,E,I),C}var uut={kernelName:Ap,backendName:"wasm",setupFunc:aut,kernelFunc:out},Ete;function lut(r){Ete=r.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function cut(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l,dataFormat:c}=s,h=q.computePool3DInfo(i.shape,a,o,1,u,l,c),d=n.makeOutput(h.outShape,i.dtype);return Ete(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,h.batchSize,h.inChannels,h.inDepth,h.inHeight,h.inWidth,h.outDepth,h.outHeight,h.outWidth,h.strideDepth,h.strideHeight,h.strideWidth,h.dilationDepth,h.dilationHeight,h.dilationWidth,h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth,h.padInfo.front,h.padInfo.top,h.padInfo.left),d}var hut={kernelName:e0,backendName:"wasm",setupFunc:lut,kernelFunc:cut},Ite;function dut(r){Ite=r.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function put(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=s,h=q.computePool3DInfo(a.shape,o,u,1,l,c),d=n.makeOutput(a.shape,a.dtype);return Ite(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,h.batchSize,h.inChannels,h.inDepth,h.inHeight,h.inWidth,h.outDepth,h.outHeight,h.outWidth,h.strideDepth,h.strideHeight,h.strideWidth,h.dilationDepth,h.dilationHeight,h.dilationWidth,h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth,h.padInfo.front,h.padInfo.top,h.padInfo.left),d}var fut={kernelName:Gx,backendName:"wasm",setupFunc:dut,kernelFunc:put},kte;function mut(r){kte=r.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function gut(r){let{inputs:t,backend:n,attrs:s}=r,{dy:i,input:a}=t,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=s,h=q.computePool2DInfo(a.shape,o,u,1,l,c),d=n.makeOutput(a.shape,a.dtype);return kte(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,h.batchSize,h.inChannels,h.inHeight,h.inWidth,h.outHeight,h.outWidth,h.strideHeight,h.strideWidth,h.dilationHeight,h.dilationWidth,h.effectiveFilterHeight,h.effectiveFilterWidth,h.padInfo.top,h.padInfo.left),d}var yut={kernelName:Wx,backendName:"wasm",setupFunc:mut,kernelFunc:gut},Nte;function but(r){Nte=r.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function xut(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{filterSize:a,strides:o,pad:u,includeBatchInIndex:l}=s;O.assert(i.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.shape.length}.`);let c=[1,1];O.assert(q.eitherStridesOrDilationsAreOne(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);let h=q.computePool2DInfo(i.shape,a,o,[1,1],u),d=n.makeOutput(h.outShape,i.dtype),p=n.makeOutput(h.outShape,"int32");return Nte(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(p.dataId).id,Lr[i.dtype],l,h.batchSize,h.inChannels,h.inHeight,h.inWidth,h.outHeight,h.outWidth,h.strideHeight,h.strideWidth,h.dilationHeight,h.dilationWidth,h.effectiveFilterHeight,h.effectiveFilterWidth,h.padInfo.top,h.padInfo.left),[d,p]}var vut={kernelName:Hx,backendName:"wasm",setupFunc:but,kernelFunc:xut},Tte;function wut(r){Tte=r.wasm.cwrap(Dp,null,["number, number, number"])}function Sut(r){let{backend:t,inputs:n,attrs:s}=r,{axis:i,keepDims:a}=s,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,l=u,c=o,{transposed:h,axes:d,originalAxes:p,inputWasTransposed:f}=qc(o,i,t),m=d;if(f){let v=t.dataIdMap.get(h.dataId).id;v!==u&&(c=h,l=v,m=q.getInnerMostAxes(m.length,c.shape.length))}q.assertAxesAreInnerMostDims("mean",m,c.shape.length);let[g,y]=q.computeOutAndReduceShapes(c.shape,m),b=O.sizeFromShape(y),x=c;c.dtype!=="float32"&&(x=Kc({backend:t,inputs:{x:c},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(x.dataId).id);let w=t.makeOutput(g,"float32");if(O.sizeFromShape(c.shape)!==0){let v=t.dataIdMap.get(w.dataId).id;Tte(l,b,v)}if(f&&t.disposeData(h.dataId),a){let v=q.expandShapeToKeepDim(w.shape,p);w.shape=v}return c.dtype!=="float32"&&t.disposeData(x.dataId),w}var Cut={kernelName:Dp,backendName:"wasm",setupFunc:wut,kernelFunc:Sut},Ate;function _ut(r){Ate=r.wasm.cwrap(Fp,null,["number","number","number","number"])}function Eut(r){let{backend:t,inputs:n,attrs:s}=r,{axis:i,keepDims:a}=s,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,l=u,c=o,{transposed:h,axes:d,originalAxes:p,inputWasTransposed:f}=qc(o,i,t);if(f){let w=t.dataIdMap.get(h.dataId).id;w!==u&&(c=h,l=w)}let m=c.shape.length;q.assertAxesAreInnerMostDims("min",d,m);let[g,y]=q.computeOutAndReduceShapes(c.shape,d),b=O.sizeFromShape(y),x=t.makeOutput(g,c.dtype);if(O.sizeFromShape(c.shape)!==0){let w=t.dataIdMap.get(x.dataId).id;Ate(l,Lr[o.dtype],b,w)}if(f&&t.disposeData(h.dataId),a){let w=q.expandShapeToKeepDim(x.shape,p);x.shape=w}return x}var Iut={kernelName:Fp,backendName:"wasm",setupFunc:_ut,kernelFunc:Eut},kut=Qn($p),PN;(function(r){r[r.reflect=0]="reflect",r[r.symmetric=1]="symmetric"})(PN||(PN={}));var Dte;function Nut(r){Dte=r.wasm.cwrap(Rp,null,["number","array","number","number","array","array","number","number"])}function Tut(r){let{inputs:{x:t},backend:n,attrs:{paddings:s,mode:i}}=r,a=s.map((m,g)=>m[0]+t.shape[g]+m[1]),o=n.dataIdMap.get(t.dataId).id,u=n.makeOutput(a,t.dtype),l=n.dataIdMap.get(u.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),h=s.map(m=>m[0]),d=s.map(m=>m[1]),p=new Uint8Array(new Int32Array(h).buffer),f=new Uint8Array(new Int32Array(d).buffer);return Dte(o,c,t.shape.length,Lr[t.dtype],p,f,PN[i],l),u}var Aut={kernelName:Rp,backendName:"wasm",kernelFunc:Tut,setupFunc:Nut},Fte;function Dut(r){Fte=r.wasm.cwrap(sf,null,["number","number","number","number"])}function $te(r){let{backend:t,inputs:{logits:n},attrs:{dim:s}}=r,i=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),o=t.dataIdMap.get(a.dataId).id,u=n.shape[s],l=O.sizeFromShape(n.shape)/u;return O.sizeFromShape(a.shape)===0||Fte(i,o,u,l),a}var Fut={kernelName:sf,backendName:"wasm",setupFunc:Dut,kernelFunc:$te},Rte;function $ut(r){Rte=r.wasm.cwrap(t0,null,["number","number","number","number","number","number"])}function Rut(r){let{inputs:t,backend:n,attrs:s}=r,{logits:i}=t,{numSamples:a,seed:o,normalized:u}=s;if(i.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${i.dtype}`);let l=u?i:$te({inputs:{logits:i},backend:n,attrs:{dim:i.shape.length-1}}),[c,h]=l.shape,d=n.makeOutput([c,a],"int32");return Rte(n.dataIdMap.get(l.dataId).id,c,h,a,o,n.dataIdMap.get(d.dataId).id),u||n.disposeData(l.dataId),d}var Out={kernelName:t0,backendName:"wasm",setupFunc:$ut,kernelFunc:Rut},Mut=Qn(Op),Lut=Qn(Mp),Put=Nr(r0);function xL(r,t){let n=new Int32Array(r.wasm.HEAPU8.buffer,t,4),s=n[0],i=n[1],a=n[2],o=n[3];return r.wasm._free(t),{pSelectedIndices:s,selectedSize:i,pSelectedScores:a,pValidOutputs:o}}var Ote;function But(r){Ote=r.wasm.cwrap(s0,"number",["number","number","number","number","number"])}function Vut(r){let{backend:t,inputs:n,attrs:s}=r,{iouThreshold:i,maxOutputSize:a,scoreThreshold:o}=s,{boxes:u,scores:l}=n,c=t.dataIdMap.get(u.dataId).id,h=t.dataIdMap.get(l.dataId).id,d=Ote(c,h,a,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=xL(t,d);return t.wasm._free(m),t.wasm._free(g),t.makeOutput([f],"int32",p)}var zut={kernelName:s0,backendName:"wasm",setupFunc:But,kernelFunc:Vut},Mte;function Uut(r){Mte=r.wasm.cwrap(i0,"number",["number","number","number","number","number","bool"])}function Wut(r){let{backend:t,inputs:n,attrs:s}=r,{iouThreshold:i,maxOutputSize:a,scoreThreshold:o,padToMaxOutputSize:u}=s,{boxes:l,scores:c}=n,h=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(c.dataId).id,p=Mte(h,d,a,i,o,u),{pSelectedIndices:f,selectedSize:m,pSelectedScores:g,pValidOutputs:y}=xL(t,p);t.wasm._free(g);let b=t.makeOutput([m],"int32",f),x=t.makeOutput([],"int32",y);return[b,x]}var Gut={kernelName:i0,backendName:"wasm",setupFunc:Uut,kernelFunc:Wut},Lte;function Hut(r){Lte=r.wasm.cwrap(a0,"number",["number","number","number","number","number","number"])}function jut(r){let{backend:t,inputs:n,attrs:s}=r,{iouThreshold:i,maxOutputSize:a,scoreThreshold:o,softNmsSigma:u}=s,{boxes:l,scores:c}=n,h=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(c.dataId).id,p=Lte(h,d,a,i,o,u),{pSelectedIndices:f,selectedSize:m,pSelectedScores:g,pValidOutputs:y}=xL(t,p);t.wasm._free(y);let b=t.makeOutput([m],"int32",f),x=t.makeOutput([m],"float32",g);return[b,x]}var qut={kernelName:a0,backendName:"wasm",setupFunc:Hut,kernelFunc:jut},Kut=!1,Xut=Qn(n0,Kut,"bool"),Pte;function Yut(r){Pte=r.wasm.cwrap(Lp,null,["number","number","number","number","number"])}function Zut(r){let{inputs:t,backend:n,attrs:s}=r,{indices:i}=t,{dtype:a,depth:o,onValue:u,offValue:l}=s,c=n.makeOutput([...i.shape,o],a),h=n.dataIdMap.get(c.dataId).id,d=n.dataIdMap.get(i.dataId).id;return Pte(d,o,u,l,h),c}var Jut={kernelName:Lp,backendName:"wasm",setupFunc:Yut,kernelFunc:Zut};function Qut(r){let{inputs:{x:t},backend:n}=r,s=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(s).fill(1),s}var elt={kernelName:o0,backendName:"wasm",kernelFunc:Qut};function tlt(r){let{inputs:t,backend:n,attrs:s}=r,{axis:i}=s;if(t.length===1)return LN({inputs:{input:t[0]},backend:n,attrs:{dim:i}});let a=t[0].shape,o=t[0].dtype;t.forEach(h=>{O.assertShapesMatch(a,h.shape,"All tensors passed to stack must have matching shapes"),O.assert(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});let u=[],l=t.map(h=>{let d=LN({inputs:{input:h},backend:n,attrs:{dim:i}});return u.push(d),d}),c=Xee({inputs:l,backend:n,attrs:{axis:i}});return u.forEach(h=>n.disposeData(h.dataId)),c}var rlt={kernelName:u0,backendName:"wasm",kernelFunc:tlt},Bte;function nlt(r){Bte=r.wasm.cwrap(Pp,null,["number","array","number","number","array","array","number","number"])}function slt(r){let{inputs:{x:t},backend:n,attrs:{paddings:s,constantValue:i}}=r,a=s.map((m,g)=>m[0]+t.shape[g]+m[1]);if(O.sizeFromShape(t.shape)===0)return dte({backend:n,attrs:{shape:a,value:i,dtype:t.dtype}});let o=n.dataIdMap.get(t.dataId).id,u=n.makeOutput(a,t.dtype),l=n.dataIdMap.get(u.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),h=s.map(m=>m[0]),d=s.map(m=>m[1]),p=new Uint8Array(new Int32Array(h).buffer),f=new Uint8Array(new Int32Array(d).buffer);return Bte(o,c,t.shape.length,Lr[t.dtype],p,f,i,l),u}var Vte={kernelName:Pp,backendName:"wasm",kernelFunc:slt,setupFunc:nlt},ilt=Qn(Bp),zte;function alt(r){zte=r.wasm.cwrap(Vp,null,["number","number","number"])}function olt(r){let{inputs:t,backend:n}=r,{x:s,alpha:i}=t,a=n.dataIdMap.get(s.dataId).id,o=n.dataIdMap.get(i.dataId).id,u=a,l=s,c=l;l.dtype!=="float32"&&(c=Kc({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),u=n.dataIdMap.get(c.dataId).id);let h=n.makeOutput(s.shape,"float32"),d=n.dataIdMap.get(h.dataId).id;return zte(u,o,d),l.dtype!=="float32"&&n.disposeData(c.dataId),h}var ult={kernelName:Vp,backendName:"wasm",setupFunc:alt,kernelFunc:olt},Ute;function llt(r){Ute=r.wasm.cwrap(zp,null,["number","number","number","number"])}function clt(r){let{backend:t,inputs:n,attrs:s}=r,{axis:i,keepDims:a}=s,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,l=u,c=o,{transposed:h,axes:d,originalAxes:p,inputWasTransposed:f}=qc(o,i,t),m=d;if(f){let w=t.dataIdMap.get(h.dataId).id;w!==u&&(c=h,l=w,m=q.getInnerMostAxes(m.length,c.shape.length))}q.assertAxesAreInnerMostDims("prod",m,c.shape.length);let[g,y]=q.computeOutAndReduceShapes(c.shape,m),b=O.sizeFromShape(y),x=t.makeOutput(g,c.dtype);if(O.sizeFromShape(c.shape)!==0){let w=t.dataIdMap.get(x.dataId).id;Ute(l,b,Lr[x.dtype],w)}if(f&&t.disposeData(h.dataId),a){let w=q.expandShapeToKeepDim(x.shape,p);x.shape=w}return x}var hlt={kernelName:zp,backendName:"wasm",setupFunc:llt,kernelFunc:clt},dlt=r=>{let{backend:t,attrs:n}=r,{start:s,stop:i,step:a,dtype:o}=n,u=qM(s,i,a,o),l=t.makeOutput([u.length],o);return t.typedArrayFromHeap(l).set(u),l},plt={kernelName:jx,backendName:"wasm",kernelFunc:dlt},flt=Qn(hp),mlt=Nr(Up),glt=Nr(Wp),ylt=Nr(jp),Wte;function blt(r){Wte=r.wasm.cwrap(Hp,null,["number","number","number","number","number","number","number","number","number","number"])}function xlt(r){let{backend:t,inputs:n,attrs:s}=r,{images:i}=n,{alignCorners:a,halfPixelCenters:o,size:u}=s,[l,c]=u,[h,d,p,f]=i.shape,m=[h,l,c,f],g=t.dataIdMap.get(i.dataId),y;g.dtype!=="float32"&&(y=Kc({backend:t,inputs:{x:i},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(y.dataId));let b=g.id,x=t.makeOutput(m,"float32");if(O.sizeFromShape(i.shape)===0)return x;let w=t.dataIdMap.get(x.dataId).id;return Wte(b,h,d,p,f,l,c,a?1:0,o?1:0,w),y!=null&&t.disposeData(y.dataId),x}var vlt={kernelName:Hp,backendName:"wasm",setupFunc:blt,kernelFunc:xlt},Gte;function wlt(r){Gte=r.wasm.cwrap(h0,null,["number","number","number","array","array","boolean"])}function Slt(r){let{inputs:t,backend:n,attrs:s}=r,{images:i,dy:a}=t,{alignCorners:o}=s,u=n.makeOutput(i.shape,"float32"),l=n.dataIdMap.get(i.dataId),c;return l.dtype!=="float32"&&(c=Kc({backend:n,inputs:{x:i},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(c.dataId)),Gte(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,new Uint8Array(new Int32Array(i.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),o),c!=null&&n.disposeData(c.dataId),u}var Clt={kernelName:h0,backendName:"wasm",setupFunc:wlt,kernelFunc:Slt},Hte;function _lt(r){Hte=r.wasm.cwrap(Gp,null,["number","number","number","number","number","number","number","number","number","number"])}function Elt(r){let{backend:t,inputs:n,attrs:s}=r,{images:i}=n,{alignCorners:a,halfPixelCenters:o,size:u}=s,[l,c]=u,[h,d,p,f]=i.shape,m=[h,l,c,f],g=t.makeOutput(m,"float32");if(O.sizeFromShape(i.shape)===0)return g;let y=t.dataIdMap.get(i.dataId),b;y.dtype!=="float32"&&(b=Kc({backend:t,inputs:{x:i},attrs:{dtype:"float32"}}),y=t.dataIdMap.get(b.dataId));let x=y.id,w=t.dataIdMap.get(g.dataId).id;return Hte(x,h,d,p,f,l,c,a?1:0,o?1:0,w),b!=null&&t.disposeData(b.dataId),g}var Ilt={kernelName:Gp,backendName:"wasm",setupFunc:_lt,kernelFunc:Elt},jte;function klt(r){jte=r.wasm.cwrap(c0,null,["number","number","number","array","array","boolean"])}function Nlt(r){let{inputs:t,backend:n,attrs:s}=r,{images:i,dy:a}=t,{alignCorners:o}=s,u=n.makeOutput(i.shape,"float32"),l=n.dataIdMap.get(i.dataId),c;return l.dtype!=="float32"&&(c=Kc({backend:n,inputs:{x:i},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(c.dataId)),jte(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,new Uint8Array(new Int32Array(i.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),o),c!=null&&n.disposeData(c.dataId),u}var Tlt={kernelName:c0,backendName:"wasm",setupFunc:klt,kernelFunc:Nlt},qte;function Alt(r){qte=r.wasm.cwrap(qp,null,["number","array","number","array","number","number"])}function Dlt(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{dims:a}=s,o=O.parseAxisParam(a,i.shape);if(i.shape.length===0)return X_({inputs:{x:i},backend:n});let u=n.makeOutput(i.shape,i.dtype),l=n.dataIdMap.get(i.dataId).id,c=n.dataIdMap.get(u.dataId).id,h=new Uint8Array(new Int32Array(o).buffer),d=new Uint8Array(new Int32Array(i.shape).buffer);qte(l,h,o.length,d,i.shape.length,c);let p=Ei({inputs:{x:u},attrs:{shape:i.shape},backend:n});return n.disposeData(u.dataId),p}var Flt={kernelName:qp,backendName:"wasm",kernelFunc:Dlt,setupFunc:Alt},Kte;function $lt(r){Kte=r.wasm.cwrap(I0,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Rlt(r){let{inputs:t,backend:n,attrs:s}=r,{image:i}=t,{radians:a,fillValue:o,center:u}=s,l=n.makeOutput(i.shape,i.dtype),c=n.dataIdMap.get(i.dataId).id,h=n.dataIdMap.get(l.dataId).id,[d,p,f,m]=i.shape,[g,y]=q.getImageCenter(u,p,f),b=o===0,x=255,w=typeof o=="number"?[o,o,o,b?0:x]:[...o,x],v=new Uint8Array(new Int32Array(w).buffer);return Kte(c,d,p,f,m,a,g,y,v,w.length,h),l}var Olt={kernelName:I0,backendName:"wasm",kernelFunc:Rlt,setupFunc:$lt},Mlt=Nr(Kp),Llt=Nr(Xp),Xte;function Plt(r){Xte=r.wasm.cwrap(d0,null,["number","number","number","number","number","number","array","number","number"])}function Blt(r){let{backend:t,inputs:n,attrs:s}=r,{indices:i,updates:a}=n,{shape:o}=s,u=t.makeOutput(o,a.dtype);if(O.sizeFromShape(o)===0)return u;let{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=h_.calculateShapes(a,i,o),f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),y=t.dataIdMap.get(u.dataId).id;return Xte(f,m,Lr[a.dtype],l,c,h,g,p,y),u}var Vlt={kernelName:d0,backendName:"wasm",setupFunc:Plt,kernelFunc:Blt},Yte;function zlt(r){Yte=r.wasm.cwrap(f0,null,["number","number","number","number","number","number","bool","number"])}function Ult(r){let{inputs:t,backend:n,attrs:s}=r,{sortedSequence:i,values:a}=t,{side:o}=s;if(i.dtype!==a.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${i.dtype} and ${a.dtype}`);let u=n.makeOutput(a.shape,"int32");function l(c){return n.dataIdMap.get(c.dataId).id}return Yte(l(i),l(a),i.shape[0],i.shape[1],a.shape[1],Lr[i.dtype],o==="left",l(u)),u}var Wlt={kernelName:f0,backendName:"wasm",setupFunc:zlt,kernelFunc:Ult},Zte;function Glt(r){Zte=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function Hlt(r){let{inputs:t,backend:n}=r,{condition:s,t:i,e:a}=t,o=n.dataIdMap.get(s.dataId).id,u=n.dataIdMap.get(i.dataId).id,l=n.dataIdMap.get(a.dataId).id,c=n.makeOutput(i.shape,i.dtype),h=n.dataIdMap.get(c.dataId).id,d=s.shape.length,p=i.shape.length,f=d===0||d>1||p===1?1:O.sizeFromShape(i.shape.slice(1));return Zte(o,u,l,f,h),c}var jlt={kernelName:m0,backendName:"wasm",kernelFunc:Hlt,setupFunc:Glt},qlt=Nr(Yp),Jte;function Klt(r){Jte=r.wasm.cwrap(ef,null,["number","number"])}function Xlt(r){let{backend:t,inputs:{x:n}}=r,s=t.dataIdMap.get(n.dataId).id,i=t.makeOutput(n.shape,n.dtype),a=t.dataIdMap.get(i.dataId).id;return O.sizeFromShape(i.shape)===0||Jte(s,a),i}var Ylt={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Klt,kernelFunc:Xlt},Zlt=Nr(Qp),Jlt=Nr(Zp),Qlt=Nr(Jp),ect=Nr(tf);function tct(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,{blockShape:a,paddings:o}=s,u=O.sizeFromShape(a),l=[[0,0]];l.push(...o);for(let y=1+a.length;y<i.shape.length;++y)l.push([0,0]);let c=Vte.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),h=q.getReshaped(c.shape,a,u,!1),d=q.getPermuted(h.length,a.length,!1),p=q.getReshapedPermuted(c.shape,a,u,!1),f=Ei({inputs:{x:c},backend:n,attrs:{shape:h}}),m=Nc({inputs:{x:f},backend:n,attrs:{perm:d}}),g=Ei({inputs:{x:m},backend:n,attrs:{shape:p}});return n.disposeData(c.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}var rct={kernelName:y0,backendName:"wasm",kernelFunc:tct},Qte;function nct(r){Qte=r.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function sct(r){let{backend:t,inputs:n}=r,{indices:s,values:i,denseShape:a,defaultValue:o}=n,u=s.shape[0],l=s.shape[1],c=t.readSync(a.dataId)[0],h=[u+c,l],d=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id,f=t.dataIdMap.get(o.dataId).id,m=t.makeOutput(h,s.dtype),g=t.dataIdMap.get(m.dataId).id,y=t.makeOutput(h.slice(0,1),i.dtype),b=t.dataIdMap.get(y.dataId).id,x=t.makeOutput([c],"bool"),w=t.dataIdMap.get(x.dataId).id,v=t.makeOutput([u],s.dtype),S=t.dataIdMap.get(v.dataId).id,E=t.makeOutput([4],"int32"),C=t.dataIdMap.get(E.dataId).id,I=Qte(d,p,Lr[i.dtype],u,c,l,f,g,b,w,S,C),_=t.readSync(E.dataId),A;switch(_[0]){case 1:{A=q.getSparseFillEmptyRowsIndicesDenseShapeMismatch(_[1]);break}case 2:{A=q.getSparseFillEmptyRowsNegativeIndexErrorMessage(_[1],_[2]);break}case 3:A=q.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(_[1],_[2],_[3]);break;default:A=""}if(t.disposeData(E.dataId),A)throw t.disposeData(m.dataId),t.disposeData(y.dataId),t.disposeData(x.dataId),t.disposeData(v.dataId),new Error(A);let k=m,N=y;return I!==h[0]&&(k=Nd({inputs:{x:m},attrs:{begin:0,size:[I,l]},backend:t}),N=Nd({inputs:{x:y},attrs:{begin:0,size:I},backend:t}),t.disposeData(m.dataId),t.disposeData(y.dataId)),[k,N,x,v]}var ict={kernelName:qx,backendName:"wasm",setupFunc:nct,kernelFunc:sct},ere;function act(r){ere=r.wasm.cwrap(x0,null,["number","number","number","number","number","number","number"])}function oct(r){let{backend:t,inputs:n}=r,{inputIndices:s,inputShape:i,newShape:a}=n;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let o=t.dataIdMap.get(s.dataId).id,u=t.dataIdMap.get(i.dataId).id,l=t.dataIdMap.get(a.dataId).id,c=s.shape[0],h=O.sizeFromShape(a.shape),d=t.makeOutput([c,h],s.dtype),p=t.dataIdMap.get(d.dataId).id,f=t.makeOutput([h],a.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput([3],"int32"),y=t.dataIdMap.get(g.dataId).id;ere(o,u,l,c,p,m,y);let b=t.readSync(g.dataId),x;switch(b[0]){case 0:{x=q.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break}case 1:{x=q.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break}case 2:x=q.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let w=Array.from(t.readSync(i.dataId)),v=Array.from(t.readSync(f.dataId));x=q.getSparseReshapeInputOutputMultipleErrorMessage(w,v);break}case 4:{let w=Array.from(t.readSync(i.dataId)),v=Array.from(t.readSync(f.dataId));x=q.getSparseReshapeInputOutputMismatchErrorMessage(w,v);break}default:x=""}if(t.disposeData(g.dataId),x)throw t.disposeData(d.dataId),t.disposeData(f.dataId),new Error(x);return[d,f]}var uct={kernelName:x0,backendName:"wasm",setupFunc:act,kernelFunc:oct},tre;function rre(r){tre=r.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function nre(r,t){let{backend:n,inputs:s}=r,{data:i,indices:a,segmentIds:o}=s,u=a.shape[0],l=n.readSync(o.dataId,u-1,u)[0],c=u>0?l+1:0;if(c<0)throw new Error(q.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=i.shape.slice();h[0]=c;let d=n.dataIdMap.get(i.dataId).id,p=n.dataIdMap.get(a.dataId).id,f=n.dataIdMap.get(o.dataId).id,m=n.makeOutput(h,i.dtype),g=n.dataIdMap.get(m.dataId).id,y=n.makeOutput([4],"int32"),b=n.dataIdMap.get(y.dataId).id;tre(d,Lr[i.dtype],i.shape[0],p,f,g,b,t,0);let x=n.readSync(y.dataId),w;switch(x[0]){case 0:{w=q.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{w=q.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:w=q.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x[1],x[2]);break;case 3:w=q.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x[1],x[2],x[3]);break;default:w=""}if(n.disposeData(y.dataId),w)throw n.disposeData(m.dataId),new Error(w);return m}function lct(r){return nre(r,!0)}var cct={kernelName:Kx,backendName:"wasm",setupFunc:rre,kernelFunc:lct};function hct(r){return nre(r,!1)}var dct={kernelName:Xx,backendName:"wasm",setupFunc:rre,kernelFunc:hct},sre;function pct(r){sre=r.wasm.cwrap(v0,null,["number","number","number","number","number","number","number","number","array","number","number"])}function fct(r){let{backend:t,inputs:n,attrs:s}=r,{sparseIndices:i,sparseValues:a,defaultValue:o}=n,{outputShape:u}=s,l=t.makeOutput(u,o.dtype);if(O.sizeFromShape(u)===0)return l;let{sliceRank:c,numUpdates:h,sliceSize:d,strides:p,outputSize:f}=q.calculateShapes(a,i,u),m=t.dataIdMap.get(i.dataId).id,g=t.dataIdMap.get(a.dataId).id,y=t.dataIdMap.get(o.dataId).id,b=new Uint8Array(new Int32Array(p).buffer),x=t.dataIdMap.get(l.dataId).id;return sre(m,g,a.shape.length,y,Lr[o.dtype],c,h,d,b,f,x),l}var mct={kernelName:v0,backendName:"wasm",setupFunc:pct,kernelFunc:fct};function gct(r){let{inputs:t,attrs:n,backend:s}=r,{x:i}=t,{numOrSizeSplits:a,axis:o}=n,u=O.parseAxisParam(o,i.shape)[0],l=q.prepareSplitSize(i,a,u),c=new Array(i.shape.length).fill(0),h=i.shape.slice();return l.map(d=>{let p=[...h];p[u]=d;let f=Nd({inputs:{x:i},attrs:{begin:c,size:p},backend:s});return c[u]+=d,f})}var yct={kernelName:b0,backendName:"wasm",kernelFunc:gct},bct=Nr(rf),xct=Nr(Yx),vct=Qn(af),ire;function wct(r){ire=r.wasm.cwrap(Bc,null,["number","number","number","number"])}function Sct(r){let{backend:t,inputs:n,attrs:s}=r,{alpha:i}=s,{x:a}=n,o=t.dataIdMap.get(a.dataId).id,u=t.makeOutput(a.shape,a.dtype),l=t.dataIdMap.get(u.dataId).id;return ire(o,i,Lr[a.dtype],l),u}var Cct={kernelName:Bc,backendName:"wasm",setupFunc:wct,kernelFunc:Sct},are;function _ct(r){are=r.wasm.cwrap(w0,null,["number","array","number","array","array","array","array","array","number","number"])}function Ect(r){let{backend:t,inputs:n,attrs:s}=r,{x:i}=n,{begin:a,end:o,strides:u,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=s,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:x,end:w,strides:v}=is.sliceInfo(i.shape,a,o,u,l,c,h,d,p),S;if(g)S=Ei({inputs:{x:i},backend:t,attrs:{shape:m}});else if(y||b){O.assert(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);let E=is.computeOutShape(x,w,v),C=Nd({inputs:{x:i},backend:t,attrs:{begin:x,size:E}});S=Ei({inputs:{x:C},backend:t,attrs:{shape:m}}),t.disposeData(C.dataId)}else{let E=t.makeOutput(f,"float32"),C=t.dataIdMap.get(i.dataId).id,I=new Uint8Array(new Int32Array(O.computeStrides(i.shape)).buffer),_=new Uint8Array(new Int32Array(x).buffer),A=new Uint8Array(new Int32Array(w).buffer),k=new Uint8Array(new Int32Array(v).buffer),N=new Uint8Array(new Int32Array(f).buffer),D=new Uint8Array(new Int32Array(O.computeStrides(f)).buffer),F=t.dataIdMap.get(E.dataId).id;are(C,I,i.shape.length,_,A,k,N,D,f.length,F),S=Ei({inputs:{x:E},backend:t,attrs:{shape:m}}),t.disposeData(E.dataId)}return S}var Ict={kernelName:w0,backendName:"wasm",setupFunc:_ct,kernelFunc:Ect};function kct(r){let{backend:t,inputs:n,attrs:s}=r,{data:i,dataSplits:a}=n,{separator:o,nGramWidths:u,leftPad:l,rightPad:c,padWidth:h,preserveShortSequences:d}=s,p=t.readSync(i.dataId),f=t.readSync(a.dataId),[m,g]=XM(p,f,o,u,l,c,h,d),y=t.makeOutput([m.length],"string"),b=t.dataIdMap.get(y.dataId);b.stringBytes=m;let x=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(x).set(g),[y,x]}var Nct={kernelName:Jx,backendName:"wasm",kernelFunc:kct};function Tct(r){let{backend:t,inputs:n,attrs:s}=r,{input:i,delimiter:a}=n,{skipEmpty:o}=s,u=t.readSync(i.dataId),l=t.readSync(a.dataId),[c,h,d]=YM(u,l[0],o),p=h.length,f=t.makeOutput([p,2],"int32");t.typedArrayFromHeap(f).set(c);let m=t.makeOutput([p],"string"),g=t.dataIdMap.get(m.dataId);g.stringBytes=h;let y=t.makeOutput([2],"int32");return t.typedArrayFromHeap(y).set(d),[f,m,y]}var Act={kernelName:Qx,backendName:"wasm",kernelFunc:Tct};function Dct(r){let{backend:t,inputs:n,attrs:s}=r,{input:i}=n,{numBuckets:a}=s,o=t.readSync(i.dataId),u=ZM(o,a),l=t.makeOutput(i.shape,"int32");return t.typedArrayFromHeap(l).set(u),l}var Fct={kernelName:ev,backendName:"wasm",kernelFunc:Dct},$ct=Qn(of),ore;function Rct(r){ore=r.wasm.cwrap(nf,null,["number","number","number","number"])}function Oct(r){let{backend:t,inputs:n,attrs:s}=r,{axis:i,keepDims:a}=s,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,l=u,c=o,{transposed:h,axes:d,originalAxes:p,inputWasTransposed:f}=qc(o,i,t),m=d;if(f){let w=t.dataIdMap.get(h.dataId).id;w!==u&&(c=h,l=w,m=q.getInnerMostAxes(m.length,c.shape.length))}q.assertAxesAreInnerMostDims("sum",m,c.shape.length);let[g,y]=q.computeOutAndReduceShapes(c.shape,m),b=O.sizeFromShape(y),x=t.makeOutput(g,c.dtype);if(O.sizeFromShape(c.shape)!==0){let w=t.dataIdMap.get(x.dataId).id;ore(l,b,Lr[x.dtype],w)}if(f&&t.disposeData(h.dataId),a){let w=q.expandShapeToKeepDim(x.shape,p);x.shape=w}return x}var Mct={kernelName:nf,backendName:"wasm",setupFunc:Rct,kernelFunc:Oct},Lct=Nr(uf),Pct=Nr(lf),ure;function Bct(r){ure=r.wasm.cwrap(p0,null,["number","number","number","number","number","number","array","number","number","number"])}function Vct(r){let{backend:t,inputs:n,attrs:s}=r,{tensor:i,indices:a,updates:o}=n,u=t.makeOutput(i.shape,i.dtype);if(O.sizeFromShape(i.shape)===0)return u;let{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=h_.calculateShapes(o,a,i.shape),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(o.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(d).buffer),b=t.dataIdMap.get(u.dataId).id;return ure(f,m,Lr[o.dtype],l,c,h,y,p,b,g),u}var zct={kernelName:p0,backendName:"wasm",setupFunc:Bct,kernelFunc:Vct},lre;function Uct(r){lre=r.wasm.cwrap(Pc,null,["number","array","number","array","number","number"])}function Wct(r){let{inputs:t,backend:n,attrs:s}=r,{x:i}=t,a=n.dataIdMap.get(i.dataId).id,{reps:o}=s,u=new Array(i.shape.length);for(let p=0;p<u.length;p++)u[p]=i.shape[p]*o[p];let l=new Uint8Array(new Int32Array(i.shape).buffer),c=new Uint8Array(new Int32Array(u).buffer),h=n.makeOutput(u,i.dtype),d=n.dataIdMap.get(h.dataId).id;return lre(a,l,i.shape.length,c,u.length,Lr[h.dtype],d),h}var Gct={kernelName:Pc,backendName:"wasm",setupFunc:Uct,kernelFunc:Wct},cre;function Hct(r){cre=r.wasm.cwrap(S0,null,["number","array","number","number","number","bool","number","number"])}var jct=({inputs:r,backend:t,attrs:n})=>{let{x:s}=r,{k:i,sorted:a}=n,o=t.dataIdMap.get(s.dataId).id,u=new Uint8Array(new Int32Array(s.shape).buffer),l=s.shape.slice();l[l.length-1]=i;let c=t.makeOutput(l,s.dtype),h=t.dataIdMap.get(c.dataId).id,d=t.makeOutput(l,"int32"),p=t.dataIdMap.get(d.dataId).id;return cre(o,u,s.shape.length,Lr[s.dtype],i,a,h,p),[c,d]},qct={kernelName:S0,backendName:"wasm",setupFunc:Hct,kernelFunc:jct},hre;function Kct(r){hre=r.wasm.cwrap(C0,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function Xct(r){let{backend:t,inputs:n,attrs:s}=r,{image:i,transforms:a}=n,{interpolation:o,fillMode:u,fillValue:l,outputShape:c}=s,[h,d,p,f]=i.shape,[m,g]=c??[d,p],y=[h,m,g,f],b=new Uint8Array(new Int32Array(O.computeStrides(i.shape)).buffer),x=new Uint8Array(new Int32Array(O.computeStrides(y)).buffer),w=t.makeOutput(y,i.dtype),v=t.dataIdMap.get(w.dataId).id,S=t.dataIdMap.get(i.dataId).id,E=t.dataIdMap.get(a.dataId).id,C=o==="nearest"?1:2,I;switch(u){case"constant":I=1;break;case"reflect":I=2;break;case"wrap":I=3;break;case"nearest":I=4;break;default:I=1;break}return hre(S,E,a.shape[0]>1,h,m,g,f,p,d,b,i.shape.length-1,x,y.length-1,C,I,l,v),w}var Yct={kernelName:C0,backendName:"wasm",setupFunc:Kct,kernelFunc:Xct};function Zct(r){let{inputs:t,attrs:n,backend:s}=r,{axis:i}=n,{x:a}=t,{outputValues:o,outputShape:u,indices:l}=QM(s.readSync(a.dataId),i,a.shape,a.dtype);return[s.makeOutput(u,a.dtype,void 0,o),s.makeOutput([l.length],"int32",void 0,l)]}var Jct={kernelName:tv,backendName:"wasm",kernelFunc:Zct};function Qct(r){let{inputs:t,backend:n,attrs:s}=r,{value:i}=t,{axis:a}=s;a<0&&(a+=i.shape.length);let o=i.shape[a],u=i.shape.length,l=new Array(u-1),c=0;for(let f=0;f<u;f++)f!==a&&(l[c++]=i.shape[f]);let h=new Array(o),d=new Array(u).fill(0),p=i.shape.slice();p[a]=1;for(let f=0;f<h.length;f++)d[a]=f,h[f]=Nd({inputs:{x:i},attrs:{begin:d,size:p},backend:n});return h.map(({dataId:f,dtype:m})=>({dataId:f,dtype:m,shape:l}))}var eht={kernelName:_0,backendName:"wasm",kernelFunc:Qct};function tht(r){let{inputs:{x:t},backend:n}=r,s=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(s).fill(0),s}var rht={kernelName:E0,backendName:"wasm",kernelFunc:tht},nht=[Kst,Xst,Yst,Zst,Jst,tit,lit,dit,pit,fit,mit,git,yit,bit,xit,Sit,Dit,Eit,Nit,Oit,zit,Git,Hit,qit,Kit,Xit,Jit,Qit,rat,iat,uat,hat,fat,mat,gat,xat,Sat,Eat,Nat,Dat,Rat,Lat,Vat,Wat,jat,qat,Yat,Jat,Qat,eot,tot,rot,not,aot,oot,uot,hot,fot,yot,vot,Cot,Eot,kot,rit,Not,Tot,Aot,$ot,Oot,Lot,Vot,Uot,zot,Got,Hot,qot,Xot,Jot,tut,sut,iut,uut,hut,fut,yut,vut,Cut,Iut,kut,Aut,Out,Mut,Lut,Put,zut,Gut,qut,Xut,Jut,elt,rlt,Vte,ilt,ult,hlt,plt,flt,mlt,glt,ylt,Fit,vlt,Clt,Ilt,Tlt,Flt,Olt,Mlt,Llt,Vlt,Wlt,jlt,qlt,Ylt,Zlt,Jlt,Qlt,Bit,Fut,ect,rct,ict,uct,cct,dct,mct,yct,bct,xct,vct,Cct,Ict,Nct,Act,Fct,$ct,Mct,Lct,Pct,zct,Gct,qct,Yct,ait,Jct,eht,rht];for(let r of nht)nv(r);var BN=Re();BN.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});BN.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(BN.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var oz=Oc(MAe()),sht=Oc(LAe()),uz=Oc(PAe()),lz=oz.default||oz,iht=uz.default||uz,dre=class extends Rx{constructor(r){super(),this.wasm=r,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(pre),VN=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new CC(this,Ma())}write(r,t,n){let s={id:this.dataIdNextNumber++};return this.move(s,r,t,n,1),s}numDataIds(){return this.dataIdMap.numDataIds()}async time(r){let t=O.now();return r(),{kernelMs:O.now()-t}}move(r,t,n,s,i){let a=this.dataIdNextNumber++;if(s==="string"){let c=t;this.dataIdMap.set(r,{id:a,stringBytes:c,shape:n,dtype:s,memoryOffset:null,refCount:i});return}let o=O.sizeFromShape(n),u=o*O.bytesPerElement(s),l=this.wasm._malloc(u)>>>0;this.dataIdMap.set(r,{id:a,memoryOffset:l,shape:n,dtype:s,refCount:i}),this.wasm.tfjs.registerTensor(a,o,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),l)}async read(r){return this.readSync(r)}readSync(r,t,n){let{memoryOffset:s,dtype:i,shape:a,stringBytes:o}=this.dataIdMap.get(r);if(i==="string")return(t==null||t===0)&&(n==null||n>=o.length)?o:o.slice(t,n);t=t||0,n=n||O.sizeFromShape(a);let u=O.bytesPerElement(i),l=this.wasm.HEAPU8.slice(s+t*u,s+n*u);return uht(l.buffer,i)}disposeData(r,t=!1){if(this.dataIdMap.has(r)){let n=this.dataIdMap.get(r);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(r)}return!0}refCount(r){return this.dataIdMap.has(r)?this.dataIdMap.get(r).refCount:0}incRef(r){let t=this.dataIdMap.get(r);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(r){return this.dataIdMap.get(r).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(r,t,n,s){let i;if(n==null)i=this.write(s??null,r,t);else{let a=this.dataIdNextNumber++;i={id:a},this.dataIdMap.set(i,{id:a,memoryOffset:n,shape:r,dtype:t,refCount:1});let o=O.sizeFromShape(r);this.wasm.tfjs.registerTensor(a,o,n)}return{dataId:i,shape:r,dtype:t}}typedArrayFromHeap({shape:r,dtype:t,dataId:n}){let s=this.wasm.HEAPU8.buffer,{memoryOffset:i}=this.dataIdMap.get(n),a=O.sizeFromShape(r);switch(t){case"float32":return new Float32Array(s,i,a);case"int32":return new Int32Array(s,i,a);case"bool":return new Uint8Array(s,i,a);default:throw new Error(`Unknown dtype ${t}`)}}};function aht(r){return(t,n)=>(O.fetch(r,{credentials:"same-origin"}).then(s=>{s.ok||t.env.a(`failed to load wasm binary file at '${r}'`),s.arrayBuffer().then(i=>{WebAssembly.instantiate(i,t).then(a=>{n(a.instance,a.module)})})}),{})}function cz(r,t,n){if(sS!=null)return sS;let s="tfjs-backend-wasm.wasm";return r&&t?s="tfjs-backend-wasm-threaded-simd.wasm":r&&(s="tfjs-backend-wasm-simd.wasm"),Jy!=null&&Jy[s]!=null?Jy[s]:n+s}async function oht(){let[r,t]=await Promise.all([Re().getAsync("WASM_HAS_SIMD_SUPPORT"),Re().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,s)=>{let i={};i.locateFile=(u,l)=>{if(u.endsWith(".worker.js")){let c=sht.wasmWorkerContents.replace(/\n/g,"\\n"),h=new Blob([c],{type:"application/javascript"});return URL.createObjectURL(h)}return u.endsWith(".wasm")?cz(r,t,By??l):l+u},vL&&(i.instantiateWasm=aht(cz(r,t,By??"")));let a=!1;i.onAbort=()=>{a||Qy||(Qy=!0,s({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let o;t&&r&&sS==null?(i.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+lz.toString()],{type:"text/javascript"}),o=lz(i)):o=iht(i),o.then(u=>{a=!0,Qy=!1;let l=null;u.tfjs={init:u.cwrap("init",null,[]),initWithThreadsCount:u.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:u.cwrap("get_threads_count","number",[]),registerTensor:u.cwrap("register_tensor",null,["number","number","number"]),disposeData:u.cwrap("dispose_data",l,["number"]),dispose:u.cwrap("dispose",l,[])},n({wasm:u})}).catch(s)})}function uht(r,t){switch(t){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${t}`)}}var lht=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],sS=null,By=null,Jy={},Qy=!1,vL=!1;function cht(r,t=!1){if(Rq("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Qy)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");sS=r,vL=t}function hht(r,t=!1){if(Qy)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")By=r;else{Jy=r;let n=lht.filter(s=>Jy[s]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}vL=t}var pre=-1,VN=-1;function dht(r){pre=r}function pht(){if(VN===-1)throw new Error("WASM backend not initialized.");return VN}var fht="4.22.0",mht=2;zC("wasm",async()=>{let{wasm:r}=await oht();return new dre(r)},mht);var hz="4.22.0",ght="4.22.0",yht="4.22.0",bht="4.22.0",xht="4.22.0",vht={tfjs:hz,"tfjs-core":hz,"tfjs-converter":ght,"tfjs-backend-cpu":yht,"tfjs-backend-webgl":bht,"tfjs-backend-wasm":xht},wht={};NR(wht,{AnchorPosition:()=>Tre,DrawBox:()=>Fre,DrawBoxOptions:()=>Dre,DrawFaceLandmarks:()=>Xre,DrawFaceLandmarksOptions:()=>Kre,DrawTextField:()=>kL,DrawTextFieldOptions:()=>IL,drawContour:()=>Rl,drawDetections:()=>Rht,drawFaceExpressions:()=>qht,drawFaceLandmarks:()=>Xht});function Rl(r,t,n=!1){if(r.beginPath(),t.slice(1).forEach(({x:s,y:i},a)=>{let o=t[a];r.moveTo(o.x,o.y),r.lineTo(s,i)}),n){let s=t[t.length-1],i=t[0];if(!s||!i)return;r.moveTo(s.x,s.y),r.lineTo(i.x,i.y)}r.stroke()}var Sht={};NR(Sht,{computeReshapedDimensions:()=>yre,getCenterPoint:()=>SL,isDimensions:()=>UN,isEven:()=>zN,isFloat:()=>gre,isTensor:()=>q0,isTensor1D:()=>Cht,isTensor2D:()=>mre,isTensor3D:()=>Mv,isTensor4D:()=>rl,isValidNumber:()=>Bh,isValidProbablitiy:()=>_ht,range:()=>sg,round:()=>wL});var bm=class fre{constructor(t,n){if(!Bh(t)||!Bh(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new fre(1/this.width,1/this.height)}};function q0(r,t){return r instanceof ur&&r.shape.length===t}function Cht(r){return q0(r,1)}function mre(r){return q0(r,2)}function Mv(r){return q0(r,3)}function rl(r){return q0(r,4)}function gre(r){return r%1!==0}function zN(r){return r%2===0}function wL(r,t=2){let n=10**t;return Math.floor(r*n)/n}function UN(r){return r&&r.width&&r.height}function yre({width:r,height:t},n){let s=n/Math.max(t,r);return new bm(Math.round(r*s),Math.round(t*s))}function SL(r){return r.reduce((t,n)=>t.add(n),new tn(0,0)).div(new tn(r.length,r.length))}function sg(r,t,n){return Array(r).fill(0).map((s,i)=>t+i*n)}function Bh(r){return!!r&&r!==1/0&&r!==-1/0&&!Number.isNaN(r)||r===0}function _ht(r){return Bh(r)&&r>=0&&r<=1}var tn=class mh{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new mh(this.x+t.x,this.y+t.y)}sub(t){return new mh(this.x-t.x,this.y-t.y)}mul(t){return new mh(this.x*t.x,this.y*t.y)}div(t){return new mh(this.x/t.x,this.y/t.y)}abs(){return new mh(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new mh(Math.floor(this.x),Math.floor(this.y))}},Td=class fo{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(Bh)}static assertIsValidBox(t,n,s=!1){if(!fo.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!s&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let s=t||{},i=[s.left,s.top,s.right,s.bottom].every(Bh),a=[s.x,s.y,s.width,s.height].every(Bh);if(!a&&!i)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(s)}`);let[o,u,l,c]=a?[s.x,s.y,s.width,s.height]:[s.left,s.top,s.right-s.left,s.bottom-s.top];fo.assertIsValidBox({x:o,y:u,width:l,height:c},"Box.constructor",n),this._x=o,this._y=u,this._width=l,this._height=c}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new tn(this.left,this.top)}get topRight(){return new tn(this.right,this.top)}get bottomLeft(){return new tn(this.left,this.bottom)}get bottomRight(){return new tn(this.right,this.bottom)}round(){let[t,n,s,i]=[this.x,this.y,this.width,this.height].map(a=>Math.round(a));return new fo({x:t,y:n,width:s,height:i})}floor(){let[t,n,s,i]=[this.x,this.y,this.width,this.height].map(a=>Math.floor(a));return new fo({x:t,y:n,width:s,height:i})}toSquare(){let{x:t,y:n,width:s,height:i}=this,a=Math.abs(s-i);return s<i&&(t-=a/2,s+=a),i<s&&(n-=a/2,i+=a),new fo({x:t,y:n,width:s,height:i})}rescale(t){let n=UN(t)?t.width:t,s=UN(t)?t.height:t;return new fo({x:this.x*n,y:this.y*s,width:this.width*n,height:this.height*s})}pad(t,n){let[s,i,a,o]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new fo({x:s,y:i,width:a,height:o})}clipAtImageBorders(t,n){let{x:s,y:i,right:a,bottom:o}=this,u=Math.max(s,0),l=Math.max(i,0),c=a-u,h=o-l,d=Math.min(c,t-u),p=Math.min(h,n-l);return new fo({x:u,y:l,width:d,height:p}).floor()}shift(t,n){let{width:s,height:i}=this,a=this.x+t,o=this.y+n;return new fo({x:a,y:o,width:s,height:i})}padAtBorders(t,n){let s=this.width+1,i=this.height+1,a=1,o=1,u=s,l=i,c=this.left,h=this.top,d=this.right,p=this.bottom;return d>n&&(u=-d+n+s,d=n),p>t&&(l=-p+t+i,p=t),c<1&&(l=2-c,c=1),h<1&&(l=2-h,h=1),{dy:o,edy:l,dx:a,edx:u,y:h,ey:p,x:c,ex:d,w:s,h:i}}calibrate(t){return new fo({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},bre=class extends Td{constructor(r,t,n,s,i=!1){super({left:r,top:t,right:n,bottom:s},i)}},xre=class vre{constructor(t,n,s,i,a){this._imageDims=new bm(a.width,a.height),this._score=t,this._classScore=n,this._className=s,this._box=new Td(i).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Td(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new vre(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},Po=class wre extends xre{constructor(t,n,s){super(t,t,"",n,s)}forSize(t,n){let{score:s,relativeBox:i,imageDims:a}=super.forSize(t,n);return new wre(s,i,a)}};function Eht(r,t,n=!0){let s=Math.max(0,Math.min(r.right,t.right)-Math.max(r.left,t.left)),i=Math.max(0,Math.min(r.bottom,t.bottom)-Math.max(r.top,t.top)),a=s*i;return n?a/(r.area+t.area-a):a/Math.min(r.area,t.area)}function Iht(r){let t=r.map(u=>u.x),n=r.map(u=>u.y),s=t.reduce((u,l)=>l<u?l:u,1/0),i=n.reduce((u,l)=>l<u?l:u,1/0),a=t.reduce((u,l)=>u<l?l:u,0),o=n.reduce((u,l)=>u<l?l:u,0);return new bre(s,i,a,o)}function kht(r,t,n,s=!0){let i=t.map((o,u)=>({score:o,boxIndex:u})).sort((o,u)=>o.score-u.score).map(o=>o.boxIndex),a=[];for(;i.length>0;){let o=i.pop();a.push(o);let u=i,l=[];for(let c=0;c<u.length;c++){let h=u[c],d=r[o],p=r[h];l.push(Eht(d,p,s))}i=i.filter((c,h)=>l[h]<=n)}return a}function Lv(r,t){return Ie(()=>{let[n,s,i]=t,a=Qi([...r.shape.slice(0,3),1],n,"float32"),o=Qi([...r.shape.slice(0,3),1],s,"float32"),u=Qi([...r.shape.slice(0,3),1],i,"float32"),l=an([a,o,u],3);return vt(r,l)})}function Nht(r,t=!1){return Ie(()=>{let[n,s]=r.shape.slice(1);if(n===s)return r;let i=Math.abs(n-s),a=Math.round(i*(t?.5:1)),o=n>s?2:1,u=d=>{let p=r.shape.slice();return p[o]=d,Qi(p,0,"float32")},l=u(a),c=i-l.shape[o],h=[t&&c?u(c):null,r,l].filter(d=>!!d).map(d=>at(d,"float32"));return an(h,o)})}function gI(r){return 1/(1+Math.exp(-r))}var Sre=class extends Td{constructor(r,t,n,s,i=!1){super({x:r,y:t,width:n,height:s},i)}},Tht=.5,Aht=.43,Dht=.45,iS=class{constructor(r,t,n=new tn(0,0)){let{width:s,height:i}=t;this._imgDims=new bm(s,i),this._shift=n,this._positions=r.map(a=>a.mul(new tn(s,i)).add(n))}get shift(){return new tn(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(r=>r.sub(this._shift).div(new tn(this.imageWidth,this.imageHeight)))}forSize(r,t){return new this.constructor(this.relativePositions,{width:r,height:t})}shiftBy(r,t){return new this.constructor(this.relativePositions,this._imgDims,new tn(r,t))}shiftByPoint(r){return this.shiftBy(r.x,r.y)}align(r,t={}){if(r){let i=r instanceof Po?r.box.floor():new Td(r);return this.shiftBy(i.x,i.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:s}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(s)}alignDlib(){let r=this.getRefPointsForAlignment(),[t,n,s]=r,i=h=>s.sub(h).magnitude(),a=(i(t)+i(n))/2,o=Math.floor(a/Dht),u=SL(r),l=Math.floor(Math.max(0,u.x-Tht*o)),c=Math.floor(Math.max(0,u.y-Aht*o));return new Sre(l,c,Math.min(o,this.imageWidth+l),Math.min(o,this.imageHeight+c))}alignMinBbox(r){let t=Iht(this.positions);return t.pad(t.width*r,t.height*r)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},Cre=class extends iS{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(SL)}};function aS(r){return r.detection instanceof Po}function _re(r,t){return{...r,detection:t}}function Ere(){let r=window.fetch;if(!r)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:r,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function CL(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function Ire(r){let t="";if(!r&&CL())try{r=fAe("fs")}catch(n){t=n.toString()}return{readFile:r?n=>new Promise((s,i)=>{r.readFile(n,(a,o)=>a?i(a):s(o))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function kre(){let r=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,s=()=>{if(r)return new r;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},i=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},a=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},o=global.fetch,u=Ire();return{Canvas:r||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:s,createImageElement:i,createVideoElement:a,fetch:o,...u}}function Nre(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var hs;function Fht(){if(!hs)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return hs}function WN(r){hs=r}function _L(){return Nre()?WN(Ere()):CL()?WN(kre()):null}function $ht(r){if(hs||_L(),!hs)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=hs.Canvas,Image:n=hs.Image}=r;hs.Canvas=t,hs.Image=n,hs.createCanvasElement=r.createCanvasElement||(()=>new t),hs.createImageElement=r.createImageElement||(()=>new n),hs.ImageData=r.ImageData||hs.ImageData,hs.Video=r.Video||hs.Video,hs.fetch=r.fetch||hs.fetch,hs.readFile=r.readFile||hs.readFile}var Di={getEnv:Fht,setEnv:WN,initialize:_L,createBrowserEnv:Ere,createFileSystem:Ire,createNodejsEnv:kre,monkeyPatch:$ht,isBrowser:Nre,isNodejs:CL};_L();function EL(r){return!Di.isNodejs()&&typeof r=="string"?document.getElementById(r):r}function Tc(r){let{Canvas:t,CanvasRenderingContext2D:n}=Di.getEnv();if(r instanceof n)return r;let s=EL(r);if(!(s instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let i=s.getContext("2d",{willReadFrequently:!0});if(!i)throw new Error("resolveContext2d - canvas 2d context is null");return i}var Tre=(r=>(r.TOP_LEFT="TOP_LEFT",r.TOP_RIGHT="TOP_RIGHT",r.BOTTOM_LEFT="BOTTOM_LEFT",r.BOTTOM_RIGHT="BOTTOM_RIGHT",r))(Tre||{}),IL=class{constructor(r={}){let{anchorPosition:t,backgroundColor:n,fontColor:s,fontSize:i,fontStyle:a,padding:o}=r;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=s||"rgba(255, 255, 255, 1)",this.fontSize=i||14,this.fontStyle=a||"Georgia",this.padding=o||4}},kL=class Are{constructor(t,n,s={}){this.text=typeof t=="string"?[t]:t instanceof Are?t.text:t,this.anchor=n,this.options=new IL(s)}measureWidth(t){let{padding:n}=this.options;return this.text.map(s=>t.measureText(s).width).reduce((s,i)=>s<i?i:s,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:s}=this.options,i=s==="BOTTOM_RIGHT"||s==="TOP_RIGHT",a=s==="BOTTOM_LEFT"||s==="BOTTOM_RIGHT",o=this.measureWidth(t),u=this.measureHeight(),l=i?this.anchor.x-o:this.anchor.x,c=a?this.anchor.y-u:this.anchor.y;if(n){let{width:h,height:d}=n,p=Math.max(Math.min(l,h-o),0),f=Math.max(Math.min(c,d-u),0);return{x:p,y:f}}return{x:l,y:c}}draw(t){let n=EL(t),s=Tc(n),{backgroundColor:i,fontColor:a,fontSize:o,fontStyle:u,padding:l}=this.options;s.font=`${o}px ${u}`;let c=this.measureWidth(s),h=this.measureHeight();s.fillStyle=i;let d=this.getUpperLeft(s,n);s.fillRect(d.x,d.y,c,h),s.fillStyle=a,this.text.forEach((p,f)=>{let m=l+d.x,g=l+d.y+(f+1)*o;s.fillText(p,m,g)})}},Dre=class{constructor(r={}){let{boxColor:t,lineWidth:n,label:s,drawLabelOptions:i}=r;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=s;let a={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new IL({...a,...i})}},Fre=class{constructor(r,t={}){this.box=new Td(r),this.options=new Dre(t)}draw(r){let t=Tc(r),{boxColor:n,lineWidth:s}=this.options,{x:i,y:a,width:o,height:u}=this.box;t.strokeStyle=n,t.lineWidth=s,t.strokeRect(i,a,o,u);let{label:l}=this.options;l&&new kL([l],{x:i-s/2,y:a},this.options.drawLabelOptions).draw(r)}};function Rht(r,t){(Array.isArray(t)?t:[t]).forEach(n=>{let s=n instanceof Po?n.score:aS(n)?n.detection.score:void 0,i=n instanceof Po?n.box:aS(n)?n.detection.box:new Td(n),a=s?`${wL(s)}`:void 0;new Fre(i,{label:a}).draw(r)})}function $re(r){let{Image:t,Video:n}=Di.getEnv();return r instanceof t&&r.complete||r instanceof n&&r.readyState>=3}function Oht(r){return new Promise((t,n)=>{if(r instanceof Di.getEnv().Canvas||$re(r)){t(null);return}function s(a){a.currentTarget&&(a.currentTarget.removeEventListener("load",i),a.currentTarget.removeEventListener("error",s),n(a))}function i(a){a.currentTarget&&(a.currentTarget.removeEventListener("load",i),a.currentTarget.removeEventListener("error",s),t(a))}r.addEventListener("load",i),r.addEventListener("error",s)})}function Rre(r){let{Image:t,Video:n}=Di.getEnv();return r instanceof t?new bm(r.naturalWidth,r.naturalHeight):r instanceof n?new bm(r.videoWidth,r.videoHeight):new bm(r.width,r.height)}function oS({width:r,height:t}){let{createCanvasElement:n}=Di.getEnv(),s=n();return s.width=r,s.height=t,s}function Ore(r,t){let{ImageData:n}=Di.getEnv();if(!(r instanceof n)&&!$re(r))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:s,height:i}=Rre(r),a=oS({width:s,height:i});return r instanceof n?Tc(a).putImageData(r,0,0):Tc(a).drawImage(r,0,0,s,i),a}async function Mht(r,t){let n=t||Di.getEnv().createCanvasElement(),[s,i,a]=r.shape.slice(rl(r)?1:0),o=Ie(()=>r.as3D(s,i,a).toInt());return await Sv.toPixels(o,n),o.dispose(),n}function dz(r){let{Image:t,Canvas:n,Video:s}=Di.getEnv();return r instanceof t||r instanceof n||r instanceof s}function Lht(r,t,n=!1){let{Image:s,Canvas:i}=Di.getEnv();if(!(r instanceof s||r instanceof i))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return oS({width:1,height:1});let a=Rre(r),o=t/Math.max(a.height,a.width),u=o*a.width,l=o*a.height,c=oS({width:t,height:t}),h=r instanceof i?r:Ore(r),d=Math.abs(u-l)/2,p=n&&u<l?d:0,f=n&&l<u?d:0;return h.width>0&&h.height>0&&Tc(c).drawImage(h,p,f,u,l),c}var uS=class{constructor(r,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(r))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${r}`);this._treatAsBatchInput=t,this._batchSize=r.length,r.forEach((n,s)=>{if(Mv(n)){this._imageTensors[s]=n,this._inputDimensions[s]=n.shape;return}if(rl(n)){let a=n.shape[0];if(a!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${a} passed, but not supported in input array`);this._imageTensors[s]=n,this._inputDimensions[s]=n.shape.slice(1);return}let i=n instanceof Di.getEnv().Canvas?n:Ore(n);this._canvases[s]=i,this._inputDimensions[s]=[i.height,i.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return sg(this.batchSize,0,1).map((r,t)=>this.getReshapedInputDimensions(t))}getInput(r){return this.canvases[r]||this.imageTensors[r]}getInputDimensions(r){return this._inputDimensions[r]}getInputHeight(r){return this._inputDimensions[r][0]}getInputWidth(r){return this._inputDimensions[r][1]}getReshapedInputDimensions(r){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(r),n=this.getInputHeight(r);return yre({width:t,height:n},this.inputSize)}toBatchTensor(r,t=!0){return this._inputSize=r,Ie(()=>{let n=sg(this.batchSize,0,1).map(s=>{let i=this.getInput(s);if(i instanceof ur){let a=rl(i)?i:bs(i);return a=Nht(a,t),(a.shape[1]!==r||a.shape[2]!==r)&&(a=pa.resizeBilinear(a,[r,r],!1,!1)),a.as3D(r,r,3)}if(i instanceof Di.getEnv().Canvas)return Sv.fromPixels(Lht(i,r,t));throw new Error(`toBatchTensor - at batchIdx ${s}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${i}`)});return Yn(n.map(s=>at(s,"float32"))).as4D(this.batchSize,r,r,3)})}};async function ci(r){if(r instanceof uS)return r;let t=Array.isArray(r)?r:[r];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=i=>Array.isArray(r)?` at input index ${i}:`:"",s=t.map(EL);return s.forEach((i,a)=>{if(!dz(i)&&!Mv(i)&&!rl(i))throw typeof t[a]=="string"?new Error(`toNetInput -${n(a)} string passed, but could not resolve HTMLElement for element id ${t[a]}`):new Error(`toNetInput -${n(a)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(rl(i)){let o=i.shape[0];if(o!==1)throw new Error(`toNetInput -${n(a)} tf.Tensor4D with batchSize ${o} passed, but not supported in input array`)}}),await Promise.all(s.map(i=>dz(i)&&Oht(i))),new uS(s,Array.isArray(r))}async function NL(r,t){let{Canvas:n}=Di.getEnv(),s=r;if(!(r instanceof n)){let a=await ci(r);if(a.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let o=a.getInput(0);s=o instanceof n?o:await Mht(o)}let i=Tc(s);return t.map(a=>a instanceof Po?a.forSize(s.width,s.height).box.floor():a).map(a=>a.clipAtImageBorders(s.width,s.height)).map(({x:a,y:o,width:u,height:l})=>{let c=oS({width:u,height:l});return u>0&&l>0&&Tc(c).putImageData(i.getImageData(a,o,u,l),0,0),c})}async function TL(r,t){if(!Mv(r)&&!rl(r))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(rl(r)&&r.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return Ie(()=>{let[n,s,i]=r.shape.slice(rl(r)?1:0);return t.map(a=>a instanceof Po?a.forSize(s,n).box:a).map(a=>a.clipAtImageBorders(s,n)).filter(a=>a.width>0&&a.height>0).map(({x:a,y:o,width:u,height:l})=>$0(r.as3D(n,s,i),[o,a,0],[l,u,i]))})}async function Pht(r,t){let{fetch:n}=Di.getEnv(),s=await n(r,t);if(!(s.status<400))throw new Error(`failed to fetch: (${s.status}) ${s.statusText}, from url: ${s.url}`);return s}async function Bht(r){return(await Pht(r)).json()}function Mre(r,t){let n=`${t}-weights_manifest.json`;if(!r)return{modelBaseUri:"",manifestUri:n};if(r==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let s=r.startsWith("http://")?"http://":r.startsWith("https://")?"https://":"";r=r.replace(s,"");let i=r.split("/").filter(u=>u),a=r.endsWith(".json")?i[i.length-1]:n,o=s+(r.endsWith(".json")?i.slice(0,i.length-1):i).join("/");return o=r.startsWith("/")?`/${o}`:o,{modelBaseUri:o,manifestUri:o==="/"?`/${a}`:`${o}/${a}`}}async function Vht(r,t){let{manifestUri:n,modelBaseUri:s}=Mre(r,t),i=await Bht(n);return $s.loadWeights(i,s)}var Xc=class{constructor(t){this._params=void 0,this._paramMappings=[],this._name=t}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(t){let{obj:n,objProp:s}=this.traversePropertyPath(t);return n[s]}reassignParamFromPath(t,n){let{obj:s,objProp:i}=this.traversePropertyPath(t);s[i].dispose(),s[i]=n}getParamList(){return this._paramMappings.map(({paramPath:t})=>({path:t,tensor:this.getParamFromPath(t)}))}getTrainableParams(){return this.getParamList().filter(t=>t.tensor instanceof pd)}getFrozenParams(){return this.getParamList().filter(t=>!(t.tensor instanceof pd))}variable(){this.getFrozenParams().forEach(({path:t,tensor:n})=>{this.reassignParamFromPath(t,n.variable())})}freeze(){this.getTrainableParams().forEach(({path:t,tensor:n})=>{let s=ai(n.dataSync());n.dispose(),this.reassignParamFromPath(t,s)})}dispose(t=!0){this.getParamList().forEach(n=>{if(t&&n.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${n.path}`);n.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:t})=>Array.from(t.dataSync())).reduce((t,n)=>t.concat(n)))}async load(t){if(t instanceof Float32Array){this.extractWeights(t);return}await this.loadFromUri(t)}async loadFromUri(t){if(t&&typeof t!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let n=await Vht(t,this.getDefaultModelName());this.loadFromWeightMap(n)}async loadFromDisk(t){if(t&&typeof t!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:n}=Di.getEnv(),{manifestUri:s,modelBaseUri:i}=Mre(t,this.getDefaultModelName()),a=c=>Promise.all(c.map(h=>n(h).then(d=>typeof d=="string"?Buffer.from(d):d.buffer))),o=$s.weightsLoaderFactory(a),u=JSON.parse((await n(s)).toString()),l=await o(u,i);this.loadFromWeightMap(l)}loadFromWeightMap(t){let{paramMappings:n,params:s}=this.extractParamsFromWeightMap(t);this._paramMappings=n,this._params=s}extractWeights(t){let{paramMappings:n,params:s}=this.extractParams(t);this._paramMappings=n,this._params=s}traversePropertyPath(t){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let n=t.split("/").reduce((a,o)=>{if(!a.nextObj.hasOwnProperty(o))throw new Error(`traversePropertyPath - object does not have property ${o}, for path ${t}`);return{obj:a.nextObj,objProp:o,nextObj:a.nextObj[o]}},{nextObj:this.params}),{obj:s,objProp:i}=n;if(!s||!i||!(s[i]instanceof ur))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${t}`);return{obj:s,objProp:i}}};function ga(r,t,n){return Ie(()=>{let s=F0(r,t.depthwise_filter,t.pointwise_filter,n,"same");return s=Ke(s,t.bias),s})}function yI(r,t,n=!1){return Ie(()=>{let s=Yr(n?Ke(ui(r,t.conv0.filters,[2,2],"same"),t.conv0.bias):ga(r,t.conv0,[2,2])),i=ga(s,t.conv1,[1,1]),a=Yr(Ke(s,i)),o=ga(a,t.conv2,[1,1]);return Yr(Ke(s,Ke(i,o)))})}function W1(r,t,n=!1,s=!0){return Ie(()=>{let i=Yr(n?Ke(ui(r,t.conv0.filters,s?[2,2]:[1,1],"same"),t.conv0.bias):ga(r,t.conv0,s?[2,2]:[1,1])),a=ga(i,t.conv1,[1,1]),o=Yr(Ke(i,a)),u=ga(o,t.conv2,[1,1]),l=Yr(Ke(i,Ke(a,u))),c=ga(l,t.conv3,[1,1]);return Yr(Ke(i,Ke(a,Ke(u,c))))})}function eb(r,t,n="same",s=!1){return Ie(()=>{let i=Ke(ui(r,t.filters,[1,1],n),t.bias);return s?Yr(i):i})}function Yc(r,t){Object.keys(r).forEach(n=>{t.some(s=>s.originalPath===n)||r[n].dispose()})}function AL(r,t){return(n,s,i,a)=>{let o=Sc(r(n*s*i*i),[i,i,n,s]),u=qr(r(s));return t.push({paramPath:`${a}/filters`},{paramPath:`${a}/bias`}),{filters:o,bias:u}}}function Lre(r,t){return(n,s,i)=>{let a=ou(r(n*s),[n,s]),o=qr(r(s));return t.push({paramPath:`${i}/weights`},{paramPath:`${i}/bias`}),{weights:a,bias:o}}}var Pre=class{constructor(r,t,n){this.depthwise_filter=r,this.pointwise_filter=t,this.bias=n}};function DL(r,t){return(n,s,i)=>{let a=Sc(r(9*n),[3,3,n,1]),o=Sc(r(n*s),[1,1,n,s]),u=qr(r(s));return t.push({paramPath:`${i}/depthwise_filter`},{paramPath:`${i}/pointwise_filter`},{paramPath:`${i}/bias`}),new Pre(a,o,u)}}function FL(r){return t=>{let n=r(`${t}/depthwise_filter`,4),s=r(`${t}/pointwise_filter`,4),i=r(`${t}/bias`,1);return new Pre(n,s,i)}}function wf(r,t){return(n,s,i)=>{let a=r[n];if(!q0(a,s))throw new Error(`expected weightMap[${n}] to be a Tensor${s}D, instead have ${a}`);return t.push({originalPath:n,paramPath:i||n}),a}}function Zc(r){let t=r;function n(i){let a=t.slice(0,i);return t=t.slice(i),a}function s(){return t}return{extractWeights:n,getRemainingWeights:s}}function Bre(r,t){let n=AL(r,t),s=DL(r,t);function i(o,u,l,c=!1){let h=c?n(o,u,3,`${l}/conv0`):s(o,u,`${l}/conv0`),d=s(u,u,`${l}/conv1`),p=s(u,u,`${l}/conv2`);return{conv0:h,conv1:d,conv2:p}}function a(o,u,l,c=!1){let{conv0:h,conv1:d,conv2:p}=i(o,u,l,c),f=s(u,u,`${l}/conv3`);return{conv0:h,conv1:d,conv2:p,conv3:f}}return{extractDenseBlock3Params:i,extractDenseBlock4Params:a}}function zht(r){let t=[],{extractWeights:n,getRemainingWeights:s}=Zc(r),{extractDenseBlock4Params:i}=Bre(n,t),a=i(3,32,"dense0",!0),o=i(32,64,"dense1"),u=i(64,128,"dense2"),l=i(128,256,"dense3");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:t,params:{dense0:a,dense1:o,dense2:u,dense3:l}}}function Vre(r){return t=>{let n=r(`${t}/filters`,4),s=r(`${t}/bias`,1);return{filters:n,bias:s}}}function zre(r,t){let n=wf(r,t),s=Vre(n),i=FL(n);function a(u,l=!1){let c=l?s(`${u}/conv0`):i(`${u}/conv0`),h=i(`${u}/conv1`),d=i(`${u}/conv2`);return{conv0:c,conv1:h,conv2:d}}function o(u,l=!1){let c=l?s(`${u}/conv0`):i(`${u}/conv0`),h=i(`${u}/conv1`),d=i(`${u}/conv2`),p=i(`${u}/conv3`);return{conv0:c,conv1:h,conv2:d,conv3:p}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:o}}function Uht(r){let t=[],{extractDenseBlock4Params:n}=zre(r,t),s={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return Yc(r,t),{params:s,paramMappings:t}}var Ure=class extends Xc{constructor(){super("FaceFeatureExtractor")}forwardInput(r){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return Ie(()=>{let n=at(r.toBatchTensor(112,!0),"float32"),s=Lv(n,[122.782,117.001,104.298]).div(255),i=W1(s,t.dense0,!0);return i=W1(i,t.dense1),i=W1(i,t.dense2),i=W1(i,t.dense3),i=wl(i,[7,7],[2,2],"valid"),i})}async forward(r){return this.forwardInput(await ci(r))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(r){return Uht(r)}extractParams(r){return zht(r)}};function GN(r,t){return Ie(()=>Ke(cr(r,t.weights),t.bias))}function Wht(r,t,n){let s=[],{extractWeights:i,getRemainingWeights:a}=Zc(r),o=Lre(i,s)(t,n,"fc");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:s,params:{fc:o}}}function Ght(r){let t=[],n=wf(r,t);function s(a){let o=n(`${a}/weights`,2),u=n(`${a}/bias`,1);return{weights:o,bias:u}}let i={fc:s("fc")};return Yc(r,t),{params:i,paramMappings:t}}function Wre(r){let t={},n={};return Object.keys(r).forEach(s=>{let i=s.startsWith("fc")?n:t;i[s]=r[s]}),{featureExtractorMap:t,classifierMap:n}}var Gre=class extends Xc{constructor(r,t){super(r),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(r){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return Ie(()=>{let n=r instanceof uS?this.faceFeatureExtractor.forwardInput(r):r;return GN(n.as2D(n.shape[0],-1),t.fc)})}dispose(r=!0){this.faceFeatureExtractor.dispose(r),super.dispose(r)}loadClassifierParams(r){let{params:t,paramMappings:n}=this.extractClassifierParams(r);this._params=t,this._paramMappings=n}extractClassifierParams(r){return Wht(r,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(r){let{featureExtractorMap:t,classifierMap:n}=Wre(r);return this.faceFeatureExtractor.loadFromWeightMap(t),Ght(n)}extractParams(r){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),s=n*t+n,i=r.slice(0,r.length-s),a=r.slice(r.length-s);return this.faceFeatureExtractor.extractWeights(i),this.extractClassifierParams(a)}},pz=["neutral","happy","sad","angry","fearful","disgusted","surprised"],$L=class{constructor(r){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,r.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${r.length}`);pz.forEach((t,n)=>{this[t]=r[n]})}asSortedArray(){return pz.map(r=>({expression:r,probability:this[r]})).sort((r,t)=>t.probability-r.probability)}},Hht=class extends Gre{constructor(r=new Ure){super("FaceExpressionNet",r)}forwardInput(r){return Ie(()=>Wc(this.runNet(r)))}async forward(r){return this.forwardInput(await ci(r))}async predictExpressions(r){let t=await ci(r),n=await this.forwardInput(t),s=await Promise.all(Bn(n).map(async a=>{let o=a.dataSync();return a.dispose(),o}));n.dispose();let i=s.map(a=>new $L(a));return t.isBatchInput?i:i[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function jht(r){return r.expressions instanceof $L}function Hre(r,t){return{...r,expressions:t}}function qht(r,t,n=.1,s){(Array.isArray(t)?t:[t]).forEach(i=>{let a=i instanceof $L?i:jht(i)?i.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let o=a.asSortedArray().filter(l=>l.probability>n),u=aS(i)?i.detection.box.bottomLeft:s||new tn(0,0);new kL(o.map(l=>`${l.expression} (${wL(l.probability)})`),u).draw(r)})}function jre(r){return aS(r)&&r.landmarks instanceof iS&&r.unshiftedLandmarks instanceof iS&&r.alignedRect instanceof Po}function Kht(r){let t=l=>l*180/Math.PI,n=(l,c)=>Math.sqrt((l.x-c.x)**2+(l.y-c.y)**2),s={roll:void 0,pitch:void 0,yaw:void 0},i=(l,c,h)=>{let d=Math.floor(l.x-c.x),p=Math.floor(c.x-h.x);return d-p},a=(l,c)=>{let h=Math.hypot(c.x-l.x,c.y-l.y),d=c.y-l.y,p=Math.asin(d/h),f=t(p),m=Math.floor(90-f),g=c.x-l.x<0?-1:1;return m*g},o=(l,c,h)=>{let d=n(l,h),p=new tn((l.x+h.x)/2,(l.y+h.y)/2),f=n(c,p),m=Math.atan(f/d),g=Math.floor(t(m)),y=p.y-c.y<0?-1:1;return g*y};if(!r||!r.positions||r.positions.length!==68)return s;let u=r.positions;return s.roll=a(u[27],u[66]),s.pitch=o(u[14],u[30],u[2]),s.yaw=i(u[14],u[33],u[2]),s}function qre(r,t){let{box:n}=r.detection,s=t.shiftBy(n.x,n.y),i=s.align(),{imageDims:a}=r.detection,o=new Po(r.detection.score,i.rescale(a.reverse()),a),u=Kht(t);return{...r,landmarks:s,unshiftedLandmarks:t,alignedRect:o,angle:u}}var Kre=class{constructor(r={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:s,lineColor:i,pointSize:a,pointColor:o}=r;this.drawLines=t,this.drawPoints=n,this.lineWidth=s||1,this.pointSize=a||2,this.lineColor=i||"rgba(0, 255, 255, 1)",this.pointColor=o||"rgba(255, 0, 255, 1)"}},Xre=class{constructor(r,t={}){this.faceLandmarks=r,this.options=new Kre(t)}draw(r){let t=Tc(r),{drawLines:n,drawPoints:s,lineWidth:i,lineColor:a,pointSize:o,pointColor:u}=this.options;if(n&&this.faceLandmarks instanceof Cre&&(t.strokeStyle=a,t.lineWidth=i,Rl(t,this.faceLandmarks.getJawOutline()),Rl(t,this.faceLandmarks.getLeftEyeBrow()),Rl(t,this.faceLandmarks.getRightEyeBrow()),Rl(t,this.faceLandmarks.getNose()),Rl(t,this.faceLandmarks.getLeftEye(),!0),Rl(t,this.faceLandmarks.getRightEye(),!0),Rl(t,this.faceLandmarks.getMouth(),!0)),s){t.strokeStyle=u,t.fillStyle=u;let l=c=>{t.beginPath(),t.arc(c.x,c.y,o,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(l)}}};function Xht(r,t){(Array.isArray(t)?t:[t]).forEach(n=>{let s=n instanceof iS?n:jre(n)?n.landmarks:void 0;if(!s)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new Xre(s).draw(r)})}function Yht(r,t){let n=AL(r,t),s=DL(r,t);function i(o,u,l){let c=s(o,u,`${l}/separable_conv0`),h=s(u,u,`${l}/separable_conv1`),d=n(o,u,1,`${l}/expansion_conv`);return{separable_conv0:c,separable_conv1:h,expansion_conv:d}}function a(o,u){let l=s(o,o,`${u}/separable_conv0`),c=s(o,o,`${u}/separable_conv1`),h=s(o,o,`${u}/separable_conv2`);return{separable_conv0:l,separable_conv1:c,separable_conv2:h}}return{extractConvParams:n,extractSeparableConvParams:s,extractReductionBlockParams:i,extractMainBlockParams:a}}function Zht(r,t){let n=[],{extractWeights:s,getRemainingWeights:i}=Zc(r),{extractConvParams:a,extractSeparableConvParams:o,extractReductionBlockParams:u,extractMainBlockParams:l}=Yht(s,n),c=a(3,32,3,"entry_flow/conv_in"),h=u(32,64,"entry_flow/reduction_block_0"),d=u(64,128,"entry_flow/reduction_block_1"),p={conv_in:c,reduction_block_0:h,reduction_block_1:d},f={};sg(t,0,1).forEach(b=>{f[`main_block_${b}`]=l(128,`middle_flow/main_block_${b}`)});let m=u(128,256,"exit_flow/reduction_block"),g=o(256,512,"exit_flow/separable_conv"),y={reduction_block:m,separable_conv:g};if(i().length!==0)throw new Error(`weights remaing after extract: ${i().length}`);return{paramMappings:n,params:{entry_flow:p,middle_flow:f,exit_flow:y}}}function Jht(r,t){let n=wf(r,t),s=Vre(n),i=FL(n);function a(u){let l=i(`${u}/separable_conv0`),c=i(`${u}/separable_conv1`),h=s(`${u}/expansion_conv`);return{separable_conv0:l,separable_conv1:c,expansion_conv:h}}function o(u){let l=i(`${u}/separable_conv0`),c=i(`${u}/separable_conv1`),h=i(`${u}/separable_conv2`);return{separable_conv0:l,separable_conv1:c,separable_conv2:h}}return{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:a,extractMainBlockParams:o}}function Qht(r,t){let n=[],{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:a,extractMainBlockParams:o}=Jht(r,n),u=s("entry_flow/conv_in"),l=a("entry_flow/reduction_block_0"),c=a("entry_flow/reduction_block_1"),h={conv_in:u,reduction_block_0:l,reduction_block_1:c},d={};sg(t,0,1).forEach(g=>{d[`main_block_${g}`]=o(`middle_flow/main_block_${g}`)});let p=a("exit_flow/reduction_block"),f=i("exit_flow/separable_conv"),m={reduction_block:p,separable_conv:f};return Yc(r,n),{params:{entry_flow:h,middle_flow:d,exit_flow:m},paramMappings:n}}function Yre(r,t,n){return Ke(ui(r,t.filters,n,"same"),t.bias)}function bI(r,t,n=!0){let s=n?Yr(r):r;return s=ga(s,t.separable_conv0,[1,1]),s=ga(Yr(s),t.separable_conv1,[1,1]),s=ps(s,[3,3],[2,2],"same"),s=Ke(s,Yre(r,t.expansion_conv,[2,2])),s}function edt(r,t){let n=ga(Yr(r),t.separable_conv0,[1,1]);return n=ga(Yr(n),t.separable_conv1,[1,1]),n=ga(Yr(n),t.separable_conv2,[1,1]),n=Ke(n,r),n}var tdt=class extends Xc{constructor(r){super("TinyXception"),this._numMainBlocks=r}forwardInput(r){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return Ie(()=>{let n=at(r.toBatchTensor(112,!0),"float32"),s=Lv(n,[122.782,117.001,104.298]).div(255),i=Yr(Yre(s,t.entry_flow.conv_in,[2,2]));return i=bI(i,t.entry_flow.reduction_block_0,!1),i=bI(i,t.entry_flow.reduction_block_1),sg(this._numMainBlocks,0,1).forEach(a=>{i=edt(i,t.middle_flow[`main_block_${a}`])}),i=bI(i,t.exit_flow.reduction_block),i=Yr(ga(i,t.exit_flow.separable_conv,[1,1])),i})}async forward(r){return this.forwardInput(await ci(r))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(r){return Qht(r,this._numMainBlocks)}extractParams(r){return Zht(r,this._numMainBlocks)}};function rdt(r){let t=[],{extractWeights:n,getRemainingWeights:s}=Zc(r),i=Lre(n,t),a=i(512,1,"fc/age"),o=i(512,2,"fc/gender");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:t,params:{fc:{age:a,gender:o}}}}function ndt(r){let t=[],n=wf(r,t);function s(a){let o=n(`${a}/weights`,2),u=n(`${a}/bias`,1);return{weights:o,bias:u}}let i={fc:{age:s("fc/age"),gender:s("fc/gender")}};return Yc(r,t),{params:i,paramMappings:t}}var sdt=(r=>(r.FEMALE="female",r.MALE="male",r))(sdt||{}),idt=class extends Xc{constructor(r=new tdt(2)){super("AgeGenderNet"),this._faceFeatureExtractor=r}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(r){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return Ie(()=>{let n=r instanceof uS?this.faceFeatureExtractor.forwardInput(r):r,s=wl(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),i=GN(s,t.fc.age).as1D(),a=GN(s,t.fc.gender);return{age:i,gender:a}})}forwardInput(r){return Ie(()=>{let{age:t,gender:n}=this.runNet(r);return{age:t,gender:Wc(n)}})}async forward(r){return this.forwardInput(await ci(r))}async predictAgeAndGender(r){let t=await ci(r),n=await this.forwardInput(t),s=Bn(n.age),i=Bn(n.gender),a=s.map((u,l)=>({ageTensor:u,genderTensor:i[l]})),o=await Promise.all(a.map(async({ageTensor:u,genderTensor:l})=>{let c=u.dataSync()[0],h=l.dataSync()[0],d=h>.5,p=d?"male":"female",f=d?h:1-h;return u.dispose(),l.dispose(),{age:c,gender:p,genderProbability:f}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?o:o[0]}getDefaultModelName(){return"age_gender_model"}dispose(r=!0){this.faceFeatureExtractor.dispose(r),super.dispose(r)}loadClassifierParams(r){let{params:t,paramMappings:n}=this.extractClassifierParams(r);this._params=t,this._paramMappings=n}extractClassifierParams(r){return rdt(r)}extractParamsFromWeightMap(r){let{featureExtractorMap:t,classifierMap:n}=Wre(r);return this.faceFeatureExtractor.loadFromWeightMap(t),ndt(n)}extractParams(r){let t=r.slice(0,r.length-1539),n=r.slice(r.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},Zre=class extends Gre{postProcess(r,t,n){let s=n.map(({width:a,height:o})=>{let u=t/Math.max(o,a);return{width:a*u,height:o*u}}),i=s.length;return Ie(()=>{let a=(c,h)=>Yn([Qi([68],c,"float32"),Qi([68],h,"float32")],1).as2D(1,136).as1D(),o=(c,h)=>{let{width:d,height:p}=s[c];return h(d,p)?Math.abs(d-p)/2:0},u=c=>o(c,(h,d)=>h<d),l=c=>o(c,(h,d)=>d<h);return r.mul(Qi([i,136],t,"float32")).sub(Yn(Array.from(Array(i),(c,h)=>a(u(h),l(h))))).div(Yn(Array.from(Array(i),(c,h)=>a(s[h].width,s[h].height))))})}forwardInput(r){return Ie(()=>{let t=this.runNet(r);return this.postProcess(t,r.inputSize,r.inputDimensions.map(([n,s])=>({height:n,width:s})))})}async forward(r){return this.forwardInput(await ci(r))}async detectLandmarks(r){let t=await ci(r),n=Ie(()=>Bn(this.forwardInput(t))),s=await Promise.all(n.map(async(i,a)=>{let o=Array.from(i.dataSync()),u=o.filter((c,h)=>zN(h)),l=o.filter((c,h)=>!zN(h));return new Cre(Array(68).fill(0).map((c,h)=>new tn(u[h],l[h])),{height:t.getInputHeight(a),width:t.getInputWidth(a)})}));return n.forEach(i=>i.dispose()),t.isBatchInput?s:s[0]}getClassifierChannelsOut(){return 136}},adt=class extends Zre{constructor(r=new Ure){super("FaceLandmark68Net",r)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function odt(r){let t=[],{extractDenseBlock3Params:n}=zre(r,t),s={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return Yc(r,t),{params:s,paramMappings:t}}function udt(r){let t=[],{extractWeights:n,getRemainingWeights:s}=Zc(r),{extractDenseBlock3Params:i}=Bre(n,t),a=i(3,32,"dense0",!0),o=i(32,64,"dense1"),u=i(64,128,"dense2");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:t,params:{dense0:a,dense1:o,dense2:u}}}var ldt=class extends Xc{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(t){let{params:n}=this;if(!n)throw new Error("TinyFaceFeatureExtractor - load model before inference");return Ie(()=>{let s=at(t.toBatchTensor(112,!0),"float32"),i=Lv(s,[122.782,117.001,104.298]).div(255),a=yI(i,n.dense0,!0);return a=yI(a,n.dense1),a=yI(a,n.dense2),a=wl(a,[14,14],[2,2],"valid"),a})}async forward(t){return this.forwardInput(await ci(t))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(t){return odt(t)}extractParams(t){return udt(t)}},cdt=class extends Zre{constructor(r=new ldt){super("FaceLandmark68TinyNet",r)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function hdt(r,t){return Ke(Se(r,t.weights),t.biases)}function RL(r,t,n,s,i="same"){let{filters:a,bias:o}=t.conv,u=ui(r,a,n,i);return u=Ke(u,o),u=hdt(u,t.scale),s?Yr(u):u}function ddt(r,t){return RL(r,t,[1,1],!0)}function Jre(r,t){return RL(r,t,[1,1],!1)}function Qre(r,t){return RL(r,t,[2,2],!0,"valid")}function pdt(r,t){function n(u,l,c){let h=r(u),d=h.length/(l*c*c);if(gre(d))throw new Error(`depth has to be an integer: ${d}, weights.length: ${h.length}, numFilters: ${l}, filterSize: ${c}`);return Ie(()=>dr(Sc(h,[l,d,c,c]),[2,3,1,0]))}function s(u,l,c,h){let d=n(u,l,c),p=qr(r(l));return t.push({paramPath:`${h}/filters`},{paramPath:`${h}/bias`}),{filters:d,bias:p}}function i(u,l){let c=qr(r(u)),h=qr(r(u));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:c,biases:h}}function a(u,l,c,h){let d=s(u,l,c,`${h}/conv`),p=i(l,`${h}/scale`);return{conv:d,scale:p}}function o(u,l,c,h,d=!1){let p=a((d?.5:1)*u,l,c,`${h}/conv1`),f=a(u,l,c,`${h}/conv2`);return{conv1:p,conv2:f}}return{extractConvLayerParams:a,extractResidualLayerParams:o}}function fdt(r){let{extractWeights:t,getRemainingWeights:n}=Zc(r),s=[],{extractConvLayerParams:i,extractResidualLayerParams:a}=pdt(t,s),o=i(4704,32,7,"conv32_down"),u=a(9216,32,3,"conv32_1"),l=a(9216,32,3,"conv32_2"),c=a(9216,32,3,"conv32_3"),h=a(36864,64,3,"conv64_down",!0),d=a(36864,64,3,"conv64_1"),p=a(36864,64,3,"conv64_2"),f=a(36864,64,3,"conv64_3"),m=a(147456,128,3,"conv128_down",!0),g=a(147456,128,3,"conv128_1"),y=a(147456,128,3,"conv128_2"),b=a(589824,256,3,"conv256_down",!0),x=a(589824,256,3,"conv256_1"),w=a(589824,256,3,"conv256_2"),v=a(589824,256,3,"conv256_down_out"),S=Ie(()=>dr(ou(t(256*128),[128,256]),[1,0]));if(s.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:o,conv32_1:u,conv32_2:l,conv32_3:c,conv64_down:h,conv64_1:d,conv64_2:p,conv64_3:f,conv128_down:m,conv128_1:g,conv128_2:y,conv256_down:b,conv256_1:x,conv256_2:w,conv256_down_out:v,fc:S},paramMappings:s}}function mdt(r,t){let n=wf(r,t);function s(o){let u=n(`${o}/scale/weights`,1),l=n(`${o}/scale/biases`,1);return{weights:u,biases:l}}function i(o){let u=n(`${o}/conv/filters`,4),l=n(`${o}/conv/bias`,1),c=s(o);return{conv:{filters:u,bias:l},scale:c}}function a(o){return{conv1:i(`${o}/conv1`),conv2:i(`${o}/conv2`)}}return{extractConvLayerParams:i,extractResidualLayerParams:a}}function gdt(r){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:s}=mdt(r,t),i=n("conv32_down"),a=s("conv32_1"),o=s("conv32_2"),u=s("conv32_3"),l=s("conv64_down"),c=s("conv64_1"),h=s("conv64_2"),d=s("conv64_3"),p=s("conv128_down"),f=s("conv128_1"),m=s("conv128_2"),g=s("conv256_down"),y=s("conv256_1"),b=s("conv256_2"),x=s("conv256_down_out"),{fc:w}=r;if(t.push({originalPath:"fc",paramPath:"fc"}),!mre(w))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${w}`);let v={conv32_down:i,conv32_1:a,conv32_2:o,conv32_3:u,conv64_down:l,conv64_1:c,conv64_2:h,conv64_3:d,conv128_down:p,conv128_1:f,conv128_2:m,conv256_down:g,conv256_1:y,conv256_2:b,conv256_down_out:x,fc:w};return Yc(r,t),{params:v,paramMappings:t}}function jo(r,t){let n=ddt(r,t.conv1);return n=Jre(n,t.conv2),n=Ke(n,r),n=Yr(n),n}function G1(r,t){let n=Qre(r,t.conv1);n=Jre(n,t.conv2);let s=wl(r,2,2,"valid"),i=On(s.shape),a=s.shape[3]!==n.shape[3];if(s.shape[1]!==n.shape[1]||s.shape[2]!==n.shape[2]){let o=[...n.shape];o[1]=1;let u=On(o);n=an([n,u],1);let l=[...n.shape];l[2]=1;let c=On(l);n=an([n,c],2)}return s=a?an([s,i],3):s,n=Ke(s,n),n=Yr(n),n}var ydt=class extends Xc{constructor(){super("FaceRecognitionNet")}forwardInput(r){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return Ie(()=>{let n=at(r.toBatchTensor(150,!0),"float32"),s=Lv(n,[122.782,117.001,104.298]).div(255),i=Qre(s,t.conv32_down);i=ps(i,3,2,"valid"),i=jo(i,t.conv32_1),i=jo(i,t.conv32_2),i=jo(i,t.conv32_3),i=G1(i,t.conv64_down),i=jo(i,t.conv64_1),i=jo(i,t.conv64_2),i=jo(i,t.conv64_3),i=G1(i,t.conv128_down),i=jo(i,t.conv128_1),i=jo(i,t.conv128_2),i=G1(i,t.conv256_down),i=jo(i,t.conv256_1),i=jo(i,t.conv256_2),i=G1(i,t.conv256_down_out);let a=i.mean([1,2]);return cr(a,t.fc)})}async forward(r){return this.forwardInput(await ci(r))}async computeFaceDescriptor(r){var t;if((t=r==null?void 0:r.shape)!=null&&t.some(a=>a<=0))return new Float32Array(128);let n=await ci(r),s=Ie(()=>Bn(this.forwardInput(n))),i=await Promise.all(s.map(a=>a.data()));return s.forEach(a=>a.dispose()),n.isBatchInput?i:i[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(r){return gdt(r)}extractParams(r){return fdt(r)}};function ene(r,t){return{...r,descriptor:t}}function tne(r,t){return{...r,age:t}}function rne(r,t,n){return{...r,gender:t,genderProbability:n}}function bdt(r,t){function n(l,c){let h=Sc(r(9*l),[3,3,l,1]),d=qr(r(l)),p=qr(r(l)),f=qr(r(l)),m=qr(r(l));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/batch_norm_scale`},{paramPath:`${c}/batch_norm_offset`},{paramPath:`${c}/batch_norm_mean`},{paramPath:`${c}/batch_norm_variance`}),{filters:h,batch_norm_scale:d,batch_norm_offset:p,batch_norm_mean:f,batch_norm_variance:m}}function s(l,c,h,d,p){let f=Sc(r(l*c*h*h),[h,h,l,c]),m=qr(r(c));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/${p?"batch_norm_offset":"bias"}`}),{filters:f,bias:m}}function i(l,c,h,d){let{filters:p,bias:f}=s(l,c,h,d,!0);return{filters:p,batch_norm_offset:f}}function a(l,c,h){let d=n(l,`${h}/depthwise_conv`),p=i(l,c,1,`${h}/pointwise_conv`);return{depthwise_conv:d,pointwise_conv:p}}function o(){let l=i(3,32,3,"mobilenetv1/conv_0"),c=a(32,64,"mobilenetv1/conv_1"),h=a(64,128,"mobilenetv1/conv_2"),d=a(128,128,"mobilenetv1/conv_3"),p=a(128,256,"mobilenetv1/conv_4"),f=a(256,256,"mobilenetv1/conv_5"),m=a(256,512,"mobilenetv1/conv_6"),g=a(512,512,"mobilenetv1/conv_7"),y=a(512,512,"mobilenetv1/conv_8"),b=a(512,512,"mobilenetv1/conv_9"),x=a(512,512,"mobilenetv1/conv_10"),w=a(512,512,"mobilenetv1/conv_11"),v=a(512,1024,"mobilenetv1/conv_12"),S=a(1024,1024,"mobilenetv1/conv_13");return{conv_0:l,conv_1:c,conv_2:h,conv_3:d,conv_4:p,conv_5:f,conv_6:m,conv_7:g,conv_8:y,conv_9:b,conv_10:x,conv_11:w,conv_12:v,conv_13:S}}function u(){let l=i(1024,256,1,"prediction_layer/conv_0"),c=i(256,512,3,"prediction_layer/conv_1"),h=i(512,128,1,"prediction_layer/conv_2"),d=i(128,256,3,"prediction_layer/conv_3"),p=i(256,128,1,"prediction_layer/conv_4"),f=i(128,256,3,"prediction_layer/conv_5"),m=i(256,64,1,"prediction_layer/conv_6"),g=i(64,128,3,"prediction_layer/conv_7"),y=s(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),b=s(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),x=s(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),w=s(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),v=s(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),S=s(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),E=s(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),C=s(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),I=s(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),_=s(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),A=s(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),k=s(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:l,conv_1:c,conv_2:h,conv_3:d,conv_4:p,conv_5:f,conv_6:m,conv_7:g,box_predictor_0:{box_encoding_predictor:y,class_predictor:b},box_predictor_1:{box_encoding_predictor:x,class_predictor:w},box_predictor_2:{box_encoding_predictor:v,class_predictor:S},box_predictor_3:{box_encoding_predictor:E,class_predictor:C},box_predictor_4:{box_encoding_predictor:I,class_predictor:_},box_predictor_5:{box_encoding_predictor:A,class_predictor:k}}}return{extractMobilenetV1Params:o,extractPredictionLayerParams:u}}function xdt(r){let t=[],{extractWeights:n,getRemainingWeights:s}=Zc(r),{extractMobilenetV1Params:i,extractPredictionLayerParams:a}=bdt(n,t),o=i(),u=a(),l={extra_dim:c_(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:{mobilenetv1:o,prediction_layer:u,output_layer:l},paramMappings:t}}function vdt(r,t){let n=wf(r,t);function s(c,h,d){let p=n(`${c}/Conv2d_${h}_pointwise/weights`,4,`${d}/filters`),f=n(`${c}/Conv2d_${h}_pointwise/convolution_bn_offset`,1,`${d}/batch_norm_offset`);return{filters:p,batch_norm_offset:f}}function i(c){let h=`mobilenetv1/conv_${c}`,d=`MobilenetV1/Conv2d_${c}_depthwise`,p=`${h}/depthwise_conv`,f=`${h}/pointwise_conv`,m=n(`${d}/depthwise_weights`,4,`${p}/filters`),g=n(`${d}/BatchNorm/gamma`,1,`${p}/batch_norm_scale`),y=n(`${d}/BatchNorm/beta`,1,`${p}/batch_norm_offset`),b=n(`${d}/BatchNorm/moving_mean`,1,`${p}/batch_norm_mean`),x=n(`${d}/BatchNorm/moving_variance`,1,`${p}/batch_norm_variance`);return{depthwise_conv:{filters:m,batch_norm_scale:g,batch_norm_offset:y,batch_norm_mean:b,batch_norm_variance:x},pointwise_conv:s("MobilenetV1",c,f)}}function a(){return{conv_0:s("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:i(1),conv_2:i(2),conv_3:i(3),conv_4:i(4),conv_5:i(5),conv_6:i(6),conv_7:i(7),conv_8:i(8),conv_9:i(9),conv_10:i(10),conv_11:i(11),conv_12:i(12),conv_13:i(13)}}function o(c,h){let d=n(`${c}/weights`,4,`${h}/filters`),p=n(`${c}/biases`,1,`${h}/bias`);return{filters:d,bias:p}}function u(c){let h=o(`Prediction/BoxPredictor_${c}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${c}/box_encoding_predictor`),d=o(`Prediction/BoxPredictor_${c}/ClassPredictor`,`prediction_layer/box_predictor_${c}/class_predictor`);return{box_encoding_predictor:h,class_predictor:d}}function l(){return{conv_0:s("Prediction",0,"prediction_layer/conv_0"),conv_1:s("Prediction",1,"prediction_layer/conv_1"),conv_2:s("Prediction",2,"prediction_layer/conv_2"),conv_3:s("Prediction",3,"prediction_layer/conv_3"),conv_4:s("Prediction",4,"prediction_layer/conv_4"),conv_5:s("Prediction",5,"prediction_layer/conv_5"),conv_6:s("Prediction",6,"prediction_layer/conv_6"),conv_7:s("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:u(0),box_predictor_1:u(1),box_predictor_2:u(2),box_predictor_3:u(3),box_predictor_4:u(4),box_predictor_5:u(5)}}return{extractMobilenetV1Params:a,extractPredictionLayerParams:l}}function wdt(r){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:s}=vdt(r,t),i=r["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!Mv(i))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${i}`);let a={mobilenetv1:n(),prediction_layer:s(),output_layer:{extra_dim:i}};return Yc(r,t),{params:a,paramMappings:t}}function Xo(r,t,n){return Ie(()=>{let s=ui(r,t.filters,n,"same");return s=Ke(s,t.batch_norm_offset),Us(s,0,6)})}var Sdt=.0010000000474974513;function Cdt(r,t,n){return Ie(()=>{let s=hf(r,t.filters,n,"same");return s=cf(s,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,Sdt),Us(s,0,6)})}function _dt(r){return[2,4,6,12].some(t=>t===r)?[2,2]:[1,1]}function Edt(r,t){return Ie(()=>{let n,s=Xo(r,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((i,a)=>{let o=a+1,u=_dt(o);s=Cdt(s,i.depthwise_conv,u),s=Xo(s,i.pointwise_conv,[1,1]),o===11&&(n=s)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:s,conv11:n}})}function Idt(r,t,n){let s=r.arraySync(),i=Math.min(s[t][0],s[t][2]),a=Math.min(s[t][1],s[t][3]),o=Math.max(s[t][0],s[t][2]),u=Math.max(s[t][1],s[t][3]),l=Math.min(s[n][0],s[n][2]),c=Math.min(s[n][1],s[n][3]),h=Math.max(s[n][0],s[n][2]),d=Math.max(s[n][1],s[n][3]),p=(o-i)*(u-a),f=(h-l)*(d-c);if(p<=0||f<=0)return 0;let m=Math.max(i,l),g=Math.max(a,c),y=Math.min(o,h),b=Math.min(u,d),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(p+f-x)}function kdt(r,t,n,s,i){let a=r.shape[0],o=Math.min(n,a),u=t.map((h,d)=>({score:h,boxIndex:d})).filter(h=>h.score>i).sort((h,d)=>d.score-h.score),l=h=>h<=s?1:0,c=[];return u.forEach(h=>{if(c.length>=o)return;let d=h.score;for(let p=c.length-1;p>=0;--p){let f=Idt(r,h.boxIndex,c[p]);if(f!==0&&(h.score*=l(f),h.score<=i))break}d===h.score&&c.push(h.boxIndex)}),c}function Ndt(r){let t=Bn(dr(r,[1,0])),n=[vt(t[2],t[0]),vt(t[3],t[1])],s=[Ke(t[0],_t(n[0],2)),Ke(t[1],_t(n[1],2))];return{sizes:n,centers:s}}function Tdt(r,t){let{sizes:n,centers:s}=Ndt(r),i=Bn(dr(t,[1,0])),a=_t(Se(Ws(_t(i[2],5)),n[0]),2),o=Ke(Se(_t(i[0],10),n[0]),s[0]),u=_t(Se(Ws(_t(i[3],5)),n[1]),2),l=Ke(Se(_t(i[1],10),n[1]),s[1]);return dr(Yn([vt(o,a),vt(l,u),Ke(o,a),Ke(l,u)]),[1,0])}function Adt(r,t,n){return Ie(()=>{let s=r.shape[0],i=Tdt(Ee(Zi(n.extra_dim,[s,1,1]),[-1,4]),Ee(r,[-1,4]));i=Ee(i,[s,i.shape[0]/s,4]);let a=Xa(vr(t,[0,0,1],[-1,-1,-1])),o=vr(a,[0,0,0],[-1,-1,1]);o=Ee(o,[s,o.shape[1]]);let u=Bn(i),l=Bn(o);return{boxes:u,scores:l}})}function Vf(r,t){return Ie(()=>{let n=r.shape[0],s=Ee(eb(r,t.box_encoding_predictor),[n,-1,1,4]),i=Ee(eb(r,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:s,classPrediction:i}})}function Ddt(r,t,n){return Ie(()=>{let s=Xo(r,n.conv_0,[1,1]),i=Xo(s,n.conv_1,[2,2]),a=Xo(i,n.conv_2,[1,1]),o=Xo(a,n.conv_3,[2,2]),u=Xo(o,n.conv_4,[1,1]),l=Xo(u,n.conv_5,[2,2]),c=Xo(l,n.conv_6,[1,1]),h=Xo(c,n.conv_7,[2,2]),d=Vf(t,n.box_predictor_0),p=Vf(r,n.box_predictor_1),f=Vf(i,n.box_predictor_2),m=Vf(o,n.box_predictor_3),g=Vf(l,n.box_predictor_4),y=Vf(h,n.box_predictor_5),b=an([d.boxPredictionEncoding,p.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding,y.boxPredictionEncoding],1),x=an([d.classPrediction,p.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction,y.classPrediction],1);return{boxPredictions:b,classPredictions:x}})}var Y_=class{constructor({minConfidence:r,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=r||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},Fdt=class extends Xc{constructor(){super("SsdMobilenetv1")}forwardInput(r){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return Ie(()=>{let n=at(r.toBatchTensor(512,!1),"float32"),s=vt(_t(n,127.5),1),i=Edt(s,t.mobilenetv1),{boxPredictions:a,classPredictions:o}=Ddt(i.out,i.conv11,t.prediction_layer);return Adt(a,o,t.output_layer)})}async forward(r){return this.forwardInput(await ci(r))}async locateFaces(r,t={}){let{maxResults:n,minConfidence:s}=new Y_(t),i=await ci(r),{boxes:a,scores:o}=this.forwardInput(i),u=a[0],l=o[0];for(let b=1;b<a.length;b++)a[b].dispose(),o[b].dispose();let c=Array.from(l.dataSync()),h=kdt(u,c,n,.5,s),d=i.getReshapedInputDimensions(0),p=i.inputSize,f=p/d.width,m=p/d.height,g=u.arraySync(),y=h.map(b=>{let[x,w]=[Math.max(0,g[b][0]),Math.min(1,g[b][2])].map(E=>E*m),[v,S]=[Math.max(0,g[b][1]),Math.min(1,g[b][3])].map(E=>E*f);return new Po(c[b],new Sre(v,x,S-v,w-x),{height:i.getInputHeight(0),width:i.getInputWidth(0)})});return u.dispose(),l.dispose(),y}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(r){return wdt(r)}extractParams(r){return xdt(r)}},$dt=.4,Rdt=[new tn(.738768,.874946),new tn(2.42204,2.65704),new tn(4.30971,7.04493),new tn(10.246,4.59428),new tn(12.6868,11.8741)],Odt=[new tn(1.603231,2.094468),new tn(6.041143,7.080126),new tn(2.882459,3.518061),new tn(4.266906,5.178857),new tn(9.041765,10.66308)],Mdt=[117.001,114.697,97.404],Ldt="tiny_yolov2_model",Pdt="tiny_yolov2_separable_conv_model",H1=r=>typeof r=="number";function Bdt(r){if(!r)throw new Error(`invalid config: ${r}`);if(typeof r.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${r.withSeparableConvs}`);if(!H1(r.iouThreshold)||r.iouThreshold<0||r.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${r.iouThreshold}`);if(!Array.isArray(r.classes)||!r.classes.length||!r.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(r.classes)}`);if(!Array.isArray(r.anchors)||!r.anchors.length||!r.anchors.map(t=>t||{}).every(t=>H1(t.x)&&H1(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(r.anchors)}`);if(r.meanRgb&&(!Array.isArray(r.meanRgb)||r.meanRgb.length!==3||!r.meanRgb.every(H1)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(r.meanRgb)}`)}function OL(r){return Ie(()=>{let t=Se(r,Pt(.10000000149011612));return Ke(Yr(vt(r,t)),t)})}function Tl(r,t){return Ie(()=>{let n=zo(r,[[0,0],[1,1],[1,1],[0,0]]);return n=ui(n,t.conv.filters,[1,1],"valid"),n=vt(n,t.bn.sub),n=Se(n,t.bn.truediv),n=Ke(n,t.conv.bias),OL(n)})}function Al(r,t){return Ie(()=>{let n=zo(r,[[0,0],[1,1],[1,1],[0,0]]);return n=F0(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=Ke(n,t.bias),OL(n)})}function Vdt(r,t){let n=AL(r,t);function s(o,u){let l=qr(r(o)),c=qr(r(o));return t.push({paramPath:`${u}/sub`},{paramPath:`${u}/truediv`}),{sub:l,truediv:c}}function i(o,u,l){let c=n(o,u,3,`${l}/conv`),h=s(u,`${l}/bn`);return{conv:c,bn:h}}let a=DL(r,t);return{extractConvParams:n,extractConvWithBatchNormParams:i,extractSeparableConvParams:a}}function zdt(r,t,n,s){let{extractWeights:i,getRemainingWeights:a}=Zc(r),o=[],{extractConvParams:u,extractConvWithBatchNormParams:l,extractSeparableConvParams:c}=Vdt(i,o),h;if(t.withSeparableConvs){let[d,p,f,m,g,y,b,x,w]=s,v=t.isFirstLayerConv2d?u(d,p,3,"conv0"):c(d,p,"conv0"),S=c(p,f,"conv1"),E=c(f,m,"conv2"),C=c(m,g,"conv3"),I=c(g,y,"conv4"),_=c(y,b,"conv5"),A=x?c(b,x,"conv6"):void 0,k=w?c(x,w,"conv7"):void 0,N=u(w||x||b,5*n,1,"conv8");h={conv0:v,conv1:S,conv2:E,conv3:C,conv4:I,conv5:_,conv6:A,conv7:k,conv8:N}}else{let[d,p,f,m,g,y,b,x,w]=s,v=l(d,p,"conv0"),S=l(p,f,"conv1"),E=l(f,m,"conv2"),C=l(m,g,"conv3"),I=l(g,y,"conv4"),_=l(y,b,"conv5"),A=l(b,x,"conv6"),k=l(x,w,"conv7"),N=u(w,5*n,1,"conv8");h={conv0:v,conv1:S,conv2:E,conv3:C,conv4:I,conv5:_,conv6:A,conv7:k,conv8:N}}if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:h,paramMappings:o}}function Udt(r,t){let n=wf(r,t);function s(u){let l=n(`${u}/sub`,1),c=n(`${u}/truediv`,1);return{sub:l,truediv:c}}function i(u){let l=n(`${u}/filters`,4),c=n(`${u}/bias`,1);return{filters:l,bias:c}}function a(u){let l=i(`${u}/conv`),c=s(`${u}/bn`);return{conv:l,bn:c}}let o=FL(n);return{extractConvParams:i,extractConvWithBatchNormParams:a,extractSeparableConvParams:o}}function Wdt(r,t){let n=[],{extractConvParams:s,extractConvWithBatchNormParams:i,extractSeparableConvParams:a}=Udt(r,n),o;if(t.withSeparableConvs){let u=t.filterSizes&&t.filterSizes.length||9;o={conv0:t.isFirstLayerConv2d?s("conv0"):a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:u>7?a("conv6"):void 0,conv7:u>8?a("conv7"):void 0,conv8:s("conv8")}}else o={conv0:i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:i("conv6"),conv7:i("conv7"),conv8:s("conv8")};return Yc(r,n),{params:o,paramMappings:n}}var ML=class{constructor({inputSize:r,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=r||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},nne=class sne extends Xc{constructor(t){super("TinyYolov2"),Bdt(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let s=Tl(t,n.conv0);return s=ps(s,[2,2],[2,2],"same"),s=Tl(s,n.conv1),s=ps(s,[2,2],[2,2],"same"),s=Tl(s,n.conv2),s=ps(s,[2,2],[2,2],"same"),s=Tl(s,n.conv3),s=ps(s,[2,2],[2,2],"same"),s=Tl(s,n.conv4),s=ps(s,[2,2],[2,2],"same"),s=Tl(s,n.conv5),s=ps(s,[2,2],[1,1],"same"),s=Tl(s,n.conv6),s=Tl(s,n.conv7),eb(s,n.conv8,"valid",!1)}runMobilenet(t,n){let s=this.config.isFirstLayerConv2d?OL(eb(t,n.conv0,"valid",!1)):Al(t,n.conv0);return s=ps(s,[2,2],[2,2],"same"),s=Al(s,n.conv1),s=ps(s,[2,2],[2,2],"same"),s=Al(s,n.conv2),s=ps(s,[2,2],[2,2],"same"),s=Al(s,n.conv3),s=ps(s,[2,2],[2,2],"same"),s=Al(s,n.conv4),s=ps(s,[2,2],[2,2],"same"),s=Al(s,n.conv5),s=ps(s,[2,2],[1,1],"same"),s=n.conv6?Al(s,n.conv6):s,s=n.conv7?Al(s,n.conv7):s,eb(s,n.conv8,"valid",!1)}forwardInput(t,n){let{params:s}=this;if(!s)throw new Error("TinyYolov2 - load model before inference");return Ie(()=>{let i=at(t.toBatchTensor(n,!1),"float32");return i=this.config.meanRgb?Lv(i,this.config.meanRgb):i,i=i.div(255),this.config.withSeparableConvs?this.runMobilenet(i,s):this.runTinyYolov2(i,s)})}async forward(t,n){return this.forwardInput(await ci(t),n)}async detect(t,n={}){let{inputSize:s,scoreThreshold:i}=new ML(n),a=await ci(t),o=await this.forwardInput(a,s),u=Ie(()=>Bn(o)[0].expandDims()),l={width:a.getInputWidth(0),height:a.getInputHeight(0)},c=await this.extractBoxes(u,a.getReshapedInputDimensions(0),i);o.dispose(),u.dispose();let h=c.map(m=>m.box),d=c.map(m=>m.score),p=c.map(m=>m.classScore),f=c.map(m=>this.config.classes[m.label]);return kht(h.map(m=>m.rescale(s)),d,this.config.iouThreshold,!0).map(m=>new xre(d[m],p[m],f[m],h[m],l))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return Wdt(t,this.config)}extractParams(t){let n=this.config.filterSizes||sne.DEFAULT_FILTER_SIZES,s=n?n.length:void 0;if(s!==7&&s!==8&&s!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${s} filterSizes in config`);return zdt(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,s){let{width:i,height:a}=n,o=Math.max(i,a),u=o/i,l=o/a,c=t.shape[1],h=this.config.anchors.length,[d,p,f]=Ie(()=>{let b=t.reshape([c,c,h,this.boxEncodingSize]),x=b.slice([0,0,0,0],[c,c,h,4]),w=b.slice([0,0,0,4],[c,c,h,1]),v=this.withClassScores?Wc(b.slice([0,0,0,5],[c,c,h,this.config.classes.length]),3):Pt(0);return[x,w,v]}),m=[],g=await p.array(),y=await d.array();for(let b=0;b<c;b++)for(let x=0;x<c;x++)for(let w=0;w<h;w++){let v=gI(g[b][x][w][0]);if(!s||v>s){let S=(x+gI(y[b][x][w][0]))/c*u,E=(b+gI(y[b][x][w][1]))/c*l,C=Math.exp(y[b][x][w][2])*this.config.anchors[w].x/c*u,I=Math.exp(y[b][x][w][3])*this.config.anchors[w].y/c*l,_=S-C/2,A=E-I/2,k={row:b,col:x,anchor:w},{classScore:N,label:D}=this.withClassScores?await this.extractPredictedClass(f,k):{classScore:1,label:0};m.push({box:new bre(_,A,_+C,A+I),score:v,classScore:v*N,label:D,...k})}}return d.dispose(),p.dispose(),f.dispose(),m}async extractPredictedClass(t,n){let{row:s,col:i,anchor:a}=n,o=await t.array();return Array(this.config.classes.length).fill(0).map((u,l)=>o[s][i][a][l]).map((u,l)=>({classScore:u,label:l})).reduce((u,l)=>u.classScore>l.classScore?u:l)}};nne.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var ine=nne,Gdt=class extends ine{constructor(r=!0){let t={withSeparableConvs:r,iouThreshold:$dt,classes:["face"],...r?{anchors:Odt,meanRgb:Mdt}:{anchors:Rdt,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(r,t){return(await this.detect(r,t)).map(n=>new Po(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?Pdt:Ldt}extractParamsFromWeightMap(r){return super.extractParamsFromWeightMap(r)}},ane=class extends ML{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Pv=class{async then(r){return r(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function Z_(r,t,n,s,i=({alignedRect:a})=>a){let a=r.map(l=>jre(l)?i(l):l.detection),o=s||(t instanceof ur?await TL(t,a):await NL(t,a)),u=await n(o);return o.forEach(l=>l instanceof ur&&l.dispose()),u}async function LL(r,t,n,s,i){return Z_([r],t,async a=>n(a[0]),s,i)}var Hdt=.4,jdt=[new tn(1.603231,2.094468),new tn(6.041143,7.080126),new tn(2.882459,3.518061),new tn(4.266906,5.178857),new tn(9.041765,10.66308)],qdt=[117.001,114.697,97.404],Kdt=class extends ine{constructor(){let r={withSeparableConvs:!0,iouThreshold:Hdt,classes:["face"],anchors:jdt,meanRgb:qdt,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(r)}get anchors(){return this.config.anchors}async locateFaces(r,t){return(await this.detect(r,t)).map(n=>new Po(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(r){return super.extractParamsFromWeightMap(r)}},ba={ssdMobilenetv1:new Fdt,tinyFaceDetector:new Kdt,tinyYolov2:new Gdt,faceLandmark68Net:new adt,faceLandmark68TinyNet:new cdt,faceRecognitionNet:new ydt,faceExpressionNet:new Hht,ageGenderNet:new idt},Xdt=r=>ba.tinyFaceDetector.load(r),Ydt=r=>ba.faceLandmark68TinyNet.load(r),one=class extends Pv{constructor(r,t,n){super(),this.parentTask=r,this.input=t,this.extractedFaces=n}},PL=class extends one{async run(){let r=await this.parentTask,t=await Z_(r,this.input,async n=>Promise.all(n.map(s=>ba.faceExpressionNet.predictExpressions(s))),this.extractedFaces);return r.map((n,s)=>Hre(n,t[s]))}withAgeAndGender(){return new UL(this,this.input)}},BL=class extends one{async run(){let r=await this.parentTask;if(!r)return;let t=await LL(r,this.input,n=>ba.faceExpressionNet.predictExpressions(n),this.extractedFaces);return Hre(r,t)}withAgeAndGender(){return new WL(this,this.input)}},VL=class extends PL{withAgeAndGender(){return new GL(this,this.input)}withFaceDescriptors(){return new jL(this,this.input)}},zL=class extends BL{withAgeAndGender(){return new HL(this,this.input)}withFaceDescriptor(){return new qL(this,this.input)}},une=class extends Pv{constructor(r,t,n){super(),this.parentTask=r,this.input=t,this.extractedFaces=n}},UL=class extends une{async run(){let r=await this.parentTask,t=await Z_(r,this.input,async n=>Promise.all(n.map(s=>ba.ageGenderNet.predictAgeAndGender(s))),this.extractedFaces);return r.map((n,s)=>{let{age:i,gender:a,genderProbability:o}=t[s];return tne(rne(n,a,o),i)})}withFaceExpressions(){return new PL(this,this.input)}},WL=class extends une{async run(){let r=await this.parentTask;if(!r)return;let{age:t,gender:n,genderProbability:s}=await LL(r,this.input,i=>ba.ageGenderNet.predictAgeAndGender(i),this.extractedFaces);return tne(rne(r,n,s),t)}withFaceExpressions(){return new BL(this,this.input)}},GL=class extends UL{withFaceExpressions(){return new VL(this,this.input)}withFaceDescriptors(){return new jL(this,this.input)}},HL=class extends WL{withFaceExpressions(){return new zL(this,this.input)}withFaceDescriptor(){return new qL(this,this.input)}},lne=class extends Pv{constructor(r,t){super(),this.parentTask=r,this.input=t}},jL=class extends lne{async run(){let r=await this.parentTask;return(await Z_(r,this.input,t=>Promise.all(t.map(n=>ba.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>ene(r[n],t))}withFaceExpressions(){return new VL(this,this.input)}withAgeAndGender(){return new GL(this,this.input)}},qL=class extends lne{async run(){let r=await this.parentTask;if(!r)return;let t=await LL(r,this.input,n=>ba.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return ene(r,t)}withFaceExpressions(){return new zL(this,this.input)}withAgeAndGender(){return new HL(this,this.input)}},cne=class extends Pv{constructor(r,t,n){super(),this.parentTask=r,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?ba.faceLandmark68TinyNet:ba.faceLandmark68Net}},Zdt=class extends cne{async run(){let r=await this.parentTask,t=r.map(i=>i.detection),n=this.input instanceof ur?await TL(this.input,t):await NL(this.input,t),s=await Promise.all(n.map(i=>this.landmarkNet.detectLandmarks(i)));return n.forEach(i=>i instanceof ur&&i.dispose()),r.filter((i,a)=>s[a]).map((i,a)=>qre(i,s[a]))}withFaceExpressions(){return new VL(this,this.input)}withAgeAndGender(){return new GL(this,this.input)}withFaceDescriptors(){return new jL(this,this.input)}},Jdt=class extends cne{async run(){let r=await this.parentTask;if(!r)return;let{detection:t}=r,n=this.input instanceof ur?await TL(this.input,[t]):await NL(this.input,[t]),s=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(i=>i instanceof ur&&i.dispose()),qre(r,s)}withFaceExpressions(){return new zL(this,this.input)}withAgeAndGender(){return new HL(this,this.input)}withFaceDescriptor(){return new qL(this,this.input)}},hne=class extends Pv{constructor(r,t=new Y_){super(),this.input=r,this.options=t}},Qdt=class extends hne{async run(){let{input:r,options:t}=this,n;if(t instanceof ane)n=ba.tinyFaceDetector.locateFaces(r,t);else if(t instanceof Y_)n=ba.ssdMobilenetv1.locateFaces(r,t);else if(t instanceof ML)n=ba.tinyYolov2.locateFaces(r,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((r,t)=>{this.run().then(n=>r(n.map(s=>_re({},s)))).catch(n=>t(n))})}withFaceLandmarks(r=!1){return new Zdt(this.runAndExtendWithFaceDetections(),this.input,r)}withFaceExpressions(){return new PL(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new UL(this.runAndExtendWithFaceDetections(),this.input)}},ept=class extends hne{async run(){let r=await new Qdt(this.input,this.options),t=r[0];return r.forEach(n=>{n.score>t.score&&(t=n)}),t}runAndExtendWithFaceDetection(){return new Promise(async r=>{let t=await this.run();r(t?_re({},t):void 0)})}withFaceLandmarks(r=!1){return new Jdt(this.runAndExtendWithFaceDetection(),this.input,r)}withFaceExpressions(){return new BL(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new WL(this.runAndExtendWithFaceDetection(),this.input)}};function tpt(r,t=new Y_){return new ept(r,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rpt=Be();rpt.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Ui;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF"})(Ui||(Ui={}));var fz;(function(r){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(fz||(fz={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const npt={};function dne(r){return npt[r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L(r,t,n,s,i){const a=t.inputParams[r];if(a&&a.inputIndexStart!==void 0){const u=a.inputIndexStart,l=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?u+1:a.inputIndexEnd,c=u<0?t.inputNames.length+u:u;if(a.type==="tensor")return Fs(t.inputNames[c],n,s,i);if(a.type==="tensors"){const p=t.inputs.slice(u,l);return t.inputNames.slice(u,l).filter((m,g)=>{var y;return((y=p[g])===null||y===void 0?void 0:y.op)!=="NoOp"}).map(m=>Fs(m,n,s,i))}const h=Fs(t.inputNames[c],n,s,i),d=h.dataSync();return a.type==="number"?d[0]:$h(h.shape,d)}const o=t.attrParams[r];return o&&o.value}function Fs(r,t,n,s){const[i,a]=ji(r,n);if(s!=null){const u=s.getHashTableHandleByName(i);if(u!=null)return u}const o=n.currentContextIds.find(u=>!!t[lS(i,u)]);return o!==void 0?t[lS(i,o)][a]:void 0}function mz(r,t,n){return t[lS(r,n.currentContextId)]}function Vu(r,t){const[n,s,i]=ji(r,t);return[lS(n,t&&t.currentContextId),s,i]}function lS(r,t){return t?`${r}-${t}`:r}function ji(r,t){if(r==="")return["",0,void 0];const n=t!=null&&t.parseNodeNameCache!=null;if(n){const a=t.parseNodeNameCache.get(r);if(a!=null)return a}const s=r.split(":");let i;if(s.length===1)i=[r,0,void 0];else{const a=s[0],o=s.length===3?s[1]:void 0,u=Number(s[s.length-1]);i=[a,u,o]}return n&&t.parseNodeNameCache.set(r,i),i}function $w(r,t,n){let s=L("pad",r,t,n);if(s==="explicit"){s=L("explicitPaddings",r,t,n);const i=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)i[a][0]=s[a*2],i[a][1]=s[a*2+1];return i}return s}function zu(r){return r.kept?r:Ju(r)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const spt=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ipt=Object.freeze(Object.defineProperty({__proto__:null,json:spt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const apt=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],opt=Object.freeze(Object.defineProperty({__proto__:null,json:apt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const upt=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],lpt=Object.freeze(Object.defineProperty({__proto__:null,json:upt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cpt=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],hpt=Object.freeze(Object.defineProperty({__proto__:null,json:cpt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dpt=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],ppt=Object.freeze(Object.defineProperty({__proto__:null,json:dpt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fpt=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],mpt=Object.freeze(Object.defineProperty({__proto__:null,json:fpt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gpt=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],ypt=Object.freeze(Object.defineProperty({__proto__:null,json:gpt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bpt=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],xpt=Object.freeze(Object.defineProperty({__proto__:null,json:bpt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vpt=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],wpt=Object.freeze(Object.defineProperty({__proto__:null,json:vpt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Spt=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Cpt=Object.freeze(Object.defineProperty({__proto__:null,json:Spt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _pt=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Ept=Object.freeze(Object.defineProperty({__proto__:null,json:_pt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ipt=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],kpt=Object.freeze(Object.defineProperty({__proto__:null,json:Ipt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Npt=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Tpt=Object.freeze(Object.defineProperty({__proto__:null,json:Npt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Apt=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Dpt=Object.freeze(Object.defineProperty({__proto__:null,json:Apt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fpt=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],$pt=Object.freeze(Object.defineProperty({__proto__:null,json:Fpt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rpt=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Opt=Object.freeze(Object.defineProperty({__proto__:null,json:Rpt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mpt=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Lpt=Object.freeze(Object.defineProperty({__proto__:null,json:Mpt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ppt=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Bpt=Object.freeze(Object.defineProperty({__proto__:null,json:Ppt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vpt=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],zpt=Object.freeze(Object.defineProperty({__proto__:null,json:Vpt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gz{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[ipt,opt,lpt,hpt,ppt,mpt,ypt,xpt,wpt,Cpt,Ept,kpt,Tpt,Dpt,$pt,Opt,Lpt,Bpt,zpt],n=[].concat(...t.map(s=>s.json));this.opMappers=n.reduce((s,i)=>(s[i.tfOpName]=i,s),{})}transformGraph(t,n={}){const s=t.node,i=[],a=[],o=[],u=s.reduce((g,y)=>(g[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?i.push(g[y.name]):y.op==="Const"?a.push(g[y.name]):(y.input==null||y.input.length===0)&&o.push(g[y.name]),g),{});let l=[];const c=[];let h={},d={};n!=null&&(h=this.mapSignatureEntries(n.inputs),d=this.mapSignatureEntries(n.outputs));const p=Object.keys(u);p.forEach(g=>{const y=u[g];y.inputNames.forEach((b,x)=>{const[w,,v]=Vu(b),S=u[w];if(S.outputs!=null){const E=S.outputs.indexOf(v);if(E!==-1){const C=`${w}:${E}`;y.inputNames[x]=C}}y.inputs.push(S),S.children.push(y)})}),Object.keys(d).length===0?p.forEach(g=>{const y=u[g];y.children.length===0&&c.push(y)}):Object.keys(d).forEach(g=>{const[y]=Vu(g),b=u[y];b!=null&&(b.signatureKey=d[g],c.push(b))}),Object.keys(h).length>0?Object.keys(h).forEach(g=>{const[y]=Vu(g),b=u[y];b&&(b.signatureKey=h[g],l.push(b))}):l=i;let f={};t.library!=null&&t.library.function!=null&&(f=t.library.function.reduce((g,y)=>(g[y.signature.name]=this.mapFunction(y),g),{}));const m={nodes:u,inputs:l,outputs:c,weights:a,placeholders:i,signature:n,functions:f};return o.length>0&&(m.initNodes=o),m}mapSignatureEntries(t){return Object.keys(t||{}).reduce((n,s)=>(n[t[s].name]=s,n),{})}mapNode(t){const n=dne(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});const s={name:t.name,op:t.op,category:n.category,inputNames:(t.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:n.outputs};return n.inputs!=null&&(s.inputParams=n.inputs.reduce((i,a)=>(i[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},i),{})),n.attrs!=null&&(s.attrParams=n.attrs.reduce((i,a)=>{const o=a.type;let u;switch(a.type){case"string":u=HN(t.attr,a.tfName,a.defaultValue),u===void 0&&a.tfDeprecatedName&&(u=HN(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":u=JN(t.attr,a.tfName,a.defaultValue),u===void 0&&a.tfDeprecatedName&&(u=JN(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":u=qN(t.attr,a.tfName,a.defaultValue||0),u===void 0&&a.tfDeprecatedName&&(u=qN(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":u=ZN(t.attr,a.tfName,a.defaultValue),u===void 0&&a.tfDeprecatedName&&(u=ZN(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":u=jN(t.attr,a.tfName,a.defaultValue),u===void 0&&a.tfDeprecatedName&&(u=jN(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":u=eT(t.attr,a.tfName,a.defaultValue),u===void 0&&a.tfDeprecatedName&&(u=eT(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":u=YN(t.attr,a.tfName,a.defaultValue),u===void 0&&a.tfDeprecatedName&&(u=YN(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":u=QN(t.attr,a.tfName,a.defaultValue),u===void 0&&a.tfDeprecatedName&&(u=QN(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":u=KN(t.attr,a.tfName,a.defaultValue),u===void 0&&a.tfDeprecatedName&&(u=KN(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":u=XN(t.attr,a.tfName,a.defaultValue),u===void 0&&a.tfDeprecatedName&&(u=XN(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":u=yz(t.attr,a.tfName,a.defaultValue),u===void 0&&a.tfDeprecatedName&&(u=yz(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${t.op}`)}return i[a.name]={value:u,type:o},i},{})),s}mapFunction(t){const n=t.nodeDef,s=[],i=[];let a={};n!=null&&(a=n.reduce((d,p)=>(d[p.name]=this.mapNode(p),p.op==="Const"&&i.push(d[p.name]),d),{}));const o=[],u=[];t.signature.inputArg.forEach(d=>{const[p]=Vu(d.name),f={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:KL(d.type),type:"dtype"}},children:[]};f.signatureKey=d.name,o.push(f),a[p]=f}),Object.keys(a).forEach(d=>{const p=a[d];p.inputNames.forEach((f,m)=>{const[g,,y]=Vu(f),b=a[g];if(b.outputs!=null){const x=b.outputs.indexOf(y);if(x!==-1){const w=`${g}:${x}`;p.inputNames[m]=w}}p.inputs.push(b),b.children.push(p)})});const c=t.ret;t.signature.outputArg.forEach(d=>{const[p,f]=Vu(c[d.name]),m=a[p];m!=null&&(m.defaultOutput=f,u.push(m))});const h=this.mapArgsToSignature(t);return{nodes:a,inputs:o,outputs:u,weights:i,placeholders:s,signature:h}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s),n),{}),outputs:t.signature.outputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s,t.ret),n),{})}}mapArgToTensorInfo(t,n){let s=t.name;return n!=null&&(s=n[s]),{name:s,dtype:t.type}}}function Upt(r){const t=Be().global;if(typeof t.atob<"u")return t.atob(r);if(typeof Buffer<"u")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function pne(r,t){const n=Array.isArray(r)?String.fromCharCode.apply(null,r):Upt(r);return t?n:n.toLowerCase()}function HN(r,t,n,s=!1){const i=r[t];return i!=null?pne(i.s,s):n}function jN(r,t,n){const s=r[t];return s?s.b:n}function qN(r,t,n){const s=r[t]||{},i=s.i!=null?s.i:s.f!=null?s.f:n;return typeof i=="number"?i:parseInt(i,10)}function KL(r){switch(typeof r=="string"&&(r=Ui[r]),r){case Ui.DT_FLOAT:case Ui.DT_HALF:return"float32";case Ui.DT_INT32:case Ui.DT_INT64:case Ui.DT_INT8:case Ui.DT_UINT8:return"int32";case Ui.DT_BOOL:return"bool";case Ui.DT_DOUBLE:return"float32";case Ui.DT_STRING:return"string";case Ui.DT_COMPLEX64:case Ui.DT_COMPLEX128:return"complex64";default:return null}}function yz(r,t,n){const s=r[t];return s&&s.func?s.func.name:n}function KN(r,t,n){const s=r[t];return s&&s.type?KL(s.type):n}function XN(r,t,n){const s=r[t];return s&&s.list&&s.list.type?s.list.type.map(i=>KL(i)):n}function fne(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function YN(r,t,n){const s=r[t];return s&&s.shape?fne(s.shape):n}function ZN(r,t,n){const s=r[t];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):n}function JN(r,t,n,s=!1){const i=r[t];return i&&i.list&&i.list.s?i.list.s.map(a=>pne(a,s)):n}function QN(r,t,n){const s=r[t];return s&&s.list&&s.list.shape?s.list.shape.map(i=>fne(i)):n}function eT(r,t,n){const s=r[t];return s&&s.list&&s.list.b?s.list.b:n}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wpt{constructor(t,n,s){this.node=t,this.tensorMap=n,this.context=s,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(i=>this.getInput(i)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((i,a)=>(i[a]=this.getAttr(a),i),{}))}getInput(t){return Fs(t,this.tensorMap,this.context)}getAttr(t,n){const s=this.node.rawAttrs[t];if(s.tensor!=null)return Fs(t,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return qN(this.node.rawAttrs,t,n);if(s.s!=null)return HN(this.node.rawAttrs,t,n);if(s.b!=null)return jN(this.node.rawAttrs,t,n);if(s.shape!=null)return YN(this.node.rawAttrs,t,n);if(s.type!=null)return KN(this.node.rawAttrs,t,n);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return ZN(this.node.rawAttrs,t,n);if(s.list.s!=null)return JN(this.node.rawAttrs,t,n);if(s.list.shape!=null)return QN(this.node.rawAttrs,t,n);if(s.list.b!=null)return eT(this.node.rawAttrs,t,n);if(s.list.type!=null)return XN(this.node.rawAttrs,t,n)}return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ms=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:i$,abs:qi,acos:VG,acosh:zG,add:jt,addN:UG,all:WG,any:GG,argMax:d$,argMin:HG,asin:jG,asinh:qG,atan:KG,atan2:XG,atanh:YG,avgPool:f$,avgPool3d:JG,basicLSTMCell:QG,batchNorm:Sx,batchNorm2d:eH,batchNorm3d:tH,batchNorm4d:rH,batchToSpaceND:m$,bincount:g$,bitwiseAnd:nH,booleanMaskAsync:Vj,broadcastArgs:sH,broadcastTo:dm,buffer:Tn,cast:Or,ceil:iH,clipByValue:aH,clone:Ju,complex:cl,concat:zs,concat1d:oH,concat2d:uH,concat3d:lH,concat4d:cH,conv1d:hH,conv2d:Cx,conv2dTranspose:pH,conv3d:fH,conv3dTranspose:mH,cos:gH,cosh:yH,cosineWindow:uC,cumprod:bH,cumsum:xH,denseBincount:vH,depthToSpace:wH,depthwiseConv2d:eC,diag:SH,dilation2d:CH,div:hn,divNoNan:_H,dot:EH,dropout:Hj,einsum:vh,elu:b$,enclosingPowerOfTwo:J$,ensureShape:IH,equal:_x,erf:kH,euclideanNorm:AH,exp:hc,expandDims:vi,expm1:DH,eye:w$,fft:iC,fill:pg,floor:S$,floorDiv:h$,fused:qj,gather:C$,gatherND:Gj,greater:fg,greaterEqual:_$,ifft:Pb,imag:Ix,image:ad,inTopKAsync:jj,irfft:H$,isFinite:FH,isInf:$H,isNaN:RH,leakyRelu:E$,less:E2,lessEqual:tC,linalg:Jj,linspace:OH,localResponseNormalization:MH,log:Om,log1p:I$,logSigmoid:PH,logSoftmax:BH,logSumExp:N$,logicalAnd:Rb,logicalNot:T$,logicalOr:A$,logicalXor:VH,losses:Qj,lowerBound:zH,matMul:Vr,max:Rh,maxPool:D$,maxPool3d:UH,maxPoolWithArgmax:WH,maximum:F$,mean:Ob,meshgrid:GH,min:_2,minimum:Mb,mirrorPad:$$,mod:HH,moments:jH,movingAverage:zj,mul:xt,multiRNNCell:qH,multinomial:KH,neg:ko,norm:Ex,notEqual:R$,oneHot:Lb,ones:ql,onesLike:XH,op:we,outerProduct:YH,pad:Bd,pad1d:ZH,pad2d:JH,pad3d:O$,pad4d:QH,pool:ej,pow:Rm,prelu:L$,print:c$,prod:tj,raggedGather:rj,raggedRange:nj,raggedTensorToTensor:sj,rand:ij,randomGamma:uj,randomNormal:U$,randomStandardNormal:lj,randomUniform:sC,randomUniformInt:cj,range:pc,real:Mm,reciprocal:hj,relu:kx,relu6:W$,reshape:Qe,reverse:fc,reverse1d:dj,reverse2d:pj,reverse3d:fj,reverse4d:mj,rfft:aC,round:G$,rsqrt:gj,scalar:mr,scatterND:Uj,searchSorted:nC,selu:yj,separableConv2d:bj,setdiff1dAsync:xj,sigmoid:iu,sign:vj,signal:Zj,sin:wj,sinh:Sj,slice:en,slice1d:Cj,slice2d:_j,slice3d:Ej,slice4d:Ij,softmax:kj,softplus:k$,spaceToBatchND:M$,sparse:e9,sparseToDense:Wj,spectral:Yj,split:Lm,sqrt:pu,square:Ka,squaredDifference:j$,squeeze:Ga,stack:mu,step:q$,stridedSlice:Nj,string:t9,sub:hr,sum:bn,tan:Tj,tanh:C2,tensor:qa,tensor1d:ha,tensor2d:Oh,tensor3d:K$,tensor4d:Aj,tensor5d:Dj,tensor6d:Fj,tensorScatterUpdate:$j,tile:pm,topk:Rj,transpose:Bb,truncatedNormal:Oj,unique:Mj,unsortedSegmentSum:Lj,unstack:Fc,upperBound:Pj,variable:Bj,where:Qu,whereAsync:Z$,zeros:dc,zerosLike:Ji},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gpt=(r,t,n,s=Ms)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(L("a",r,t,n),L("b",r,t,n))];case"AddN":return[s.addN(L("tensors",r,t,n))];case"FloorMod":case"Mod":return[s.mod(L("a",r,t,n),L("b",r,t,n))];case"Mul":return[s.mul(L("a",r,t,n),L("b",r,t,n))];case"RealDiv":case"Div":return[s.div(L("a",r,t,n),L("b",r,t,n))];case"DivNoNan":return[s.divNoNan(L("a",r,t,n),L("b",r,t,n))];case"FloorDiv":return[s.floorDiv(L("a",r,t,n),L("b",r,t,n))];case"Sub":return[s.sub(L("a",r,t,n),L("b",r,t,n))];case"Minimum":return[s.minimum(L("a",r,t,n),L("b",r,t,n))];case"Maximum":return[s.maximum(L("a",r,t,n),L("b",r,t,n))];case"Pow":return[s.pow(L("a",r,t,n),L("b",r,t,n))];case"SquaredDifference":return[s.squaredDifference(L("a",r,t,n),L("b",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hpt=(r,t,n,s=Ms)=>{switch(r.op){case"Abs":case"ComplexAbs":return[s.abs(L("x",r,t,n))];case"Acos":return[s.acos(L("x",r,t,n))];case"Acosh":return[s.acosh(L("x",r,t,n))];case"Asin":return[s.asin(L("x",r,t,n))];case"Asinh":return[s.asinh(L("x",r,t,n))];case"Atan":return[s.atan(L("x",r,t,n))];case"Atan2":return[s.atan2(L("x",r,t,n),L("y",r,t,n))];case"Atanh":return[s.atanh(L("x",r,t,n))];case"Ceil":return[s.ceil(L("x",r,t,n))];case"Complex":return[s.complex(L("real",r,t,n),L("imag",r,t,n))];case"Cos":return[s.cos(L("x",r,t,n))];case"Cosh":return[s.cosh(L("x",r,t,n))];case"Elu":return[s.elu(L("x",r,t,n))];case"Erf":return[s.erf(L("x",r,t,n))];case"Exp":return[s.exp(L("x",r,t,n))];case"Expm1":return[s.expm1(L("x",r,t,n))];case"Floor":return[s.floor(L("x",r,t,n))];case"Log":return[s.log(L("x",r,t,n))];case"Log1p":return[s.log1p(L("x",r,t,n))];case"Imag":return[s.imag(L("x",r,t,n))];case"Neg":return[s.neg(L("x",r,t,n))];case"Reciprocal":return[s.reciprocal(L("x",r,t,n))];case"Real":return[s.real(L("x",r,t,n))];case"Relu":return[s.relu(L("x",r,t,n))];case"Round":return[s.round(L("x",r,t,n))];case"Selu":return[s.selu(L("x",r,t,n))];case"Sigmoid":return[s.sigmoid(L("x",r,t,n))];case"Sin":return[s.sin(L("x",r,t,n))];case"Sign":return[s.sign(L("x",r,t,n))];case"Sinh":return[s.sinh(L("x",r,t,n))];case"Softplus":return[s.softplus(L("x",r,t,n))];case"Sqrt":return[s.sqrt(L("x",r,t,n))];case"Square":return[s.square(L("x",r,t,n))];case"Tanh":return[s.tanh(L("x",r,t,n))];case"Tan":return[s.tan(L("x",r,t,n))];case"ClipByValue":return[s.clipByValue(L("x",r,t,n),L("clipValueMin",r,t,n),L("clipValueMax",r,t,n))];case"Relu6":return[s.relu6(L("x",r,t,n))];case"Rsqrt":return[s.rsqrt(Fs(r.inputNames[0],t,n))];case"LeakyRelu":return[s.leakyRelu(L("x",r,t,n),L("alpha",r,t,n))];case"Prelu":return[s.prelu(L("x",r,t,n),L("alpha",r,t,n))];case"IsNan":return[s.isNaN(Fs(r.inputNames[0],t,n))];case"IsInf":return[s.isInf(Fs(r.inputNames[0],t,n))];case"IsFinite":return[s.isFinite(Fs(r.inputNames[0],t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pa(r,t,n=""){if(!(typeof r=="number"||typeof t=="number")){oe(r.length===t.length,()=>n+` Shapes ${r} and ${t} must match`);for(let s=0;s<r.length;s++){const i=r[s],a=t[s];oe(i<0||a<0||i===a,()=>n+` Shapes ${r} and ${t} must match`)}}}function bz(r){return!(typeof r=="number"||r.some(t=>t<0))}function by(r,t,n){let s=tT(r,n);const i=!bz(s);if(i&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(i&&t.forEach(a=>{s=tT(a.shape,s)}),!bz(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function tT(r,t){if(typeof r=="number")return t;if(typeof t=="number")return r;if(r.length!==t.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${t}`);const n=[];for(let s=0;s<r.length;++s){const i=r[s],a=t[s];if(i>=0&&a>=0&&i!==a)throw new Error(`Incompatible shape during merge: ${r} vs. ${t}`);n[s]=i>=0?i:a}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jpt{constructor(t,n,s,i,a,o,u){this.name=t,this.dtype=n,this.maxSize=s,this.elementShape=i,this.identicalElementShapes=a,this.dynamicSize=o,this.clearAfterRead=u,this.tensors=[],this.closed_=!1,this.idTensor=mr(0),Co(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const n=this.tensors[t];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(t){return t.map(n=>this.read(n))}write(t,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[t]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),Pa(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);s.tensor=n,Co(n),s.written=!0,this.tensors[t]=s}writeMany(t,n){if(t.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${n.length}.`);t.forEach((s,i)=>this.write(s,n[i]))}gather(t,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(t)t=t.slice(0,this.size());else{t=[];for(let i=0;i<this.size();i++)t.push(i)}if(t.length===0)return qa([],[0].concat(this.elementShape));const s=this.readMany(t);return Pa(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),mu(s,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return qa([],[0].concat(this.elementShape));const n=[];for(let i=0;i<this.size();i++)n.push(i);const s=this.readMany(n);return Pa(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),zs(s,0)}scatter(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const s=Math.max(...t);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(t,Fc(n,0))}split(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let s=0;const i=t.map(l=>(s+=l,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const a=s===0?0:n.size/s,o=[];qt(()=>{n=Qe(n,[1,s,a]);for(let l=0;l<t.length;++l){const h=[0,l===0?0:i[l-1],0],d=[1,t[l],a];o[l]=Qe(en(n,h,d),this.elementShape)}return o});const u=[];for(let l=0;l<t.length;l++)u[l]=l;this.writeMany(u,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ad{get id(){return this.idTensor.id}constructor(t,n,s,i=-1){this.tensors=t,this.elementShape=n,this.elementDtype=s,t!=null&&t.forEach(a=>{if(s!==a.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${a.dtype}`);Pa(n,a.shape,"TensorList shape mismatch: "),Co(a)}),this.idTensor=mr(0),this.maxNumElements=i,Co(this.idTensor)}copy(){return new Ad([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,s=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);Pa(t,this.elementShape,"TensorList shape mismatch: ");const i=by(this.elementShape,this.tensors,t);return qt(()=>{const a=this.tensors.map(o=>Qe(o,i));return mu(a,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=by(this.elementShape,this.tensors,t),i=this.tensors.pop();return i.kept=!1,Pa(i.shape,t,"TensorList shape mismatch: "),Qe(i,s)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Pa(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Co(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const n=new Ad([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let s=0;s<Math.min(this.tensors.length,t);++s)n.tensors[s]=this.tensors[s];return n}getItem(t,n,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Pa(this.tensors[t].shape,n,"TensorList shape mismatch: ");const i=by(this.elementShape,this.tensors,n);return Qe(this.tensors[t],i)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Pa(this.elementShape,n.shape,"TensorList shape mismatch: "),Co(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,s){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Pa(this.elementShape,s,"TensorList shape mismatch: "),t=t.slice(0,this.size());const i=by(this.elementShape,this.tensors,s);return t.length===0?qa([],[0].concat(i)):qt(()=>{const a=t.map(o=>Qe(this.tensors[o],i));return mu(a,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Pa(this.elementShape,n,"TensorList shape mismatch: ");const s=by(this.elementShape,this.tensors,n);return this.size()===0?qa([],[0].concat(s)):qt(()=>{const i=this.tensors.map(a=>Qe(a,s));return zs(i,0)})}}function qpt(r,t,n){const s=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==n)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${n}`);const i=r.shape.slice(1);Pa(i,t,"TensorList shape mismatch: ");const a=Fc(r);return new Ad(a,t,s)}function Kpt(r,t,n,s){return new Ad([],r,t,s)}function Xpt(r,t,n,s){if(t.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${r.shape[0]}`);const i=Math.max(...t);if(s!=null&&s!==-1&&i>=s)throw new Error(`Max index must be < array size (${i}  vs. ${s})`);const a=new Ad([],n,r.dtype,s),o=Fc(r,0);return t.forEach((u,l)=>{a.setItem(u,o[l])}),a}function Ypt(r,t,n){let s=0;const i=t.map(h=>(s+=h,s));if(s!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${r.shape}`);const a=r.shape.slice(1),o=tT(a,n),u=s===0?0:r.size/s,l=qt(()=>{const h=[];r=Qe(r,[1,s,u]);for(let d=0;d<t.length;++d){const f=[0,d===0?0:i[d-1],0],m=[1,t[d],u];h[d]=Qe(en(r,f,m),o)}return r.dispose(),h}),c=new Ad([],n,r.dtype,t.length);for(let h=0;h<l.length;h++)c.setItem(h,l[h]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zpt=async(r,t,n)=>{switch(r.op){case"If":case"StatelessIf":{const s=L("thenBranch",r,t,n),i=L("elseBranch",r,t,n),a=L("cond",r,t,n),o=L("args",r,t,n);return(await a.data())[0]?n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[i].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const s=L("body",r,t,n),i=L("cond",r,t,n),a=L("args",r,t,n),o=await n.functionMap[i].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),u=a.map(h=>h.id);let l=await o[0].data();o.forEach(h=>{!h.kept&&u.indexOf(h.id)===-1&&h.dispose()});let c=a;for(;l[0];){const h=c;c=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const d=c.map(f=>f.id);h.forEach(f=>{!f.kept&&u.indexOf(f.id)===-1&&d.indexOf(f.id)===-1&&f.dispose()});const p=await n.functionMap[i].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await p[0].data(),p.forEach(f=>{!f.kept&&u.indexOf(f.id)===-1&&d.indexOf(f.id)===-1&&f.dispose()})}return c}case"LoopCond":{const s=L("pred",r,t,n);return[zu(s)]}case"Switch":{const s=L("pred",r,t,n);let i=L("data",r,t,n);return i.kept||(i=zu(i)),(await s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=r.inputNames.find(i=>Fs(i,t,n)!==void 0);if(s){const i=Fs(s,t,n);return[zu(i)]}return}case"Enter":{const s=L("frameName",r,t,n),i=L("tensor",r,t,n);return n.enterFrame(s),[zu(i)]}case"Exit":{const s=L("tensor",r,t,n);return n.exitFrame(),[zu(s)]}case"NextIteration":{const s=L("tensor",r,t,n);return n.nextIteration(),[zu(s)]}case"TensorArrayV3":{const s=L("size",r,t,n),i=L("dtype",r,t,n),a=L("elementShape",r,t,n),o=L("dynamicSize",r,t,n),u=L("clearAfterRead",r,t,n),l=L("identicalElementShapes",r,t,n),c=L("name",r,t,n),h=new jpt(c,i,s,a,l,o,u);return n.addTensorArray(h),[h.idTensor,mr(1)]}case"TensorArrayWriteV3":{const s=L("tensorArrayId",r,t,n),i=L("index",r,t,n),a=L("tensor",r,t,n),o=n.getTensorArray(s.id);return o.write(i,a),[o.idTensor]}case"TensorArrayReadV3":{const s=L("tensorArrayId",r,t,n),i=L("index",r,t,n);return[n.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=L("tensorArrayId",r,t,n),i=L("indices",r,t,n),a=L("dtype",r,t,n);return[n.getTensorArray(s.id).gather(i,a)]}case"TensorArrayScatterV3":{const s=L("tensorArrayId",r,t,n),i=L("indices",r,t,n),a=L("tensor",r,t,n),o=n.getTensorArray(s.id);return o.scatter(i,a),[o.idTensor]}case"TensorArrayConcatV3":{const s=L("tensorArrayId",r,t,n),i=n.getTensorArray(s.id),a=L("dtype",r,t,n);return[i.concat(a)]}case"TensorArraySplitV3":{const s=L("tensorArrayId",r,t,n),i=L("tensor",r,t,n),a=L("lengths",r,t,n),o=n.getTensorArray(s.id);return o.split(a,i),[o.idTensor]}case"TensorArraySizeV3":{const s=L("tensorArrayId",r,t,n),i=n.getTensorArray(s.id);return[mr(i.size(),"int32")]}case"TensorArrayCloseV3":{const s=L("tensorArrayId",r,t,n),i=n.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=L("tensorListId",r,t,n),i=L("index",r,t,n),a=L("tensor",r,t,n),o=n.getTensorList(s.id);return o.setItem(i,a),[o.idTensor]}case"TensorListGetItem":{const s=L("tensorListId",r,t,n),i=L("index",r,t,n),a=L("elementShape",r,t,n),o=L("elementDType",r,t,n);return[n.getTensorList(s.id).getItem(i,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=L("indices",r,t,n),i=L("tensor",r,t,n),a=L("elementShape",r,t,n),o=L("numElements",r,t,n),u=Xpt(i,s,a,o);return n.addTensorList(u),[u.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=L("elementShape",r,t,n),i=L("elementDType",r,t,n);let a;r.op==="TensorListReserve"?a="numElements":a="maxNumElements";const o=L(a,r,t,n),u=r.op==="TensorListReserve"?-1:o,l=Kpt(s,i,o,u);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=L("tensorListId",r,t,n),i=L("indices",r,t,n),a=L("elementShape",r,t,n),o=L("elementDType",r,t,n);return[n.getTensorList(s.id).gather(i,o,a)]}case"TensorListStack":{const s=L("tensorListId",r,t,n),i=L("elementShape",r,t,n),a=L("elementDType",r,t,n),o=L("numElements",r,t,n);return[n.getTensorList(s.id).stack(i,a,o)]}case"TensorListFromTensor":{const s=L("tensor",r,t,n),i=L("elementShape",r,t,n),a=L("elementDType",r,t,n),o=qpt(s,i,a);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=L("tensorListId",r,t,n),i=n.getTensorList(s.id),a=L("dtype",r,t,n),o=L("elementShape",r,t,n);return[i.concat(a,o)]}case"TensorListPushBack":{const s=L("tensorListId",r,t,n),i=L("tensor",r,t,n),a=n.getTensorList(s.id);return a.pushBack(i),[a.idTensor]}case"TensorListPopBack":{const s=L("tensorListId",r,t,n),i=L("elementShape",r,t,n),a=L("elementDType",r,t,n);return[n.getTensorList(s.id).popBack(i,a)]}case"TensorListSplit":{const s=L("tensor",r,t,n),i=L("elementShape",r,t,n),a=L("lengths",r,t,n),o=Ypt(s,a,i);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{const s=L("tensorListId",r,t,n),i=n.getTensorList(s.id);return[mr(i.size(),"int32")]}case"TensorListResize":{const s=L("tensorListId",r,t,n),i=L("size",r,t,n),o=n.getTensorList(s.id).resize(i);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xz(r,t,n){const[s,i]=L("fusedOps",r,t,n),a=s==="biasadd",o=!a,u=i==="prelu",l=s==="fusedbatchnorm",c=L("numArgs",r,t,n);if(a){if(u&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!u&&a&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const h=L("strides",r,t,n),d=$w(r,t,n),p=L("dataFormat",r,t,n).toUpperCase(),f=L("dilations",r,t,n);let[m,g]=L("args",r,t,n);o&&(g=m,m=void 0);const y=L("leakyreluAlpha",r,t,n);return{stride:h,pad:d,dataFormat:p,dilations:f,biasArg:m,preluArg:g,activationFunc:i,leakyreluAlpha:y}}const Jpt=(r,t,n,s=Ms)=>{switch(r.op){case"Conv1D":{const i=L("stride",r,t,n),a=L("pad",r,t,n),o=L("dataFormat",r,t,n).toUpperCase(),u=L("dilation",r,t,n);return[s.conv1d(L("x",r,t,n),L("filter",r,t,n),i,a,o,u)]}case"Conv2D":{const i=L("strides",r,t,n),a=$w(r,t,n),o=L("dataFormat",r,t,n).toUpperCase(),u=L("dilations",r,t,n);return[s.conv2d(L("x",r,t,n),L("filter",r,t,n),[i[1],i[2]],a,o,[u[1],u[2]])]}case"_FusedConv2D":{const{stride:i,pad:a,dataFormat:o,dilations:u,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:d}=xz(r,t,n);return[s.fused.conv2d({x:L("x",r,t,n),filter:L("filter",r,t,n),strides:[i[1],i[2]],pad:a,dataFormat:o,dilations:[u[1],u[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:a,dataFormat:o,dilations:u,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:d}=xz(r,t,n);return[s.fused.depthwiseConv2d({x:L("x",r,t,n),filter:L("filter",r,t,n),strides:[i[1],i[2]],pad:a,dataFormat:o,dilations:[u[1],u[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=L("outputShape",r,t,n),a=L("strides",r,t,n),o=$w(r,t,n);return[s.conv2dTranspose(L("x",r,t,n),L("filter",r,t,n),i,[a[1],a[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=L("strides",r,t,n),a=$w(r,t,n),o=L("dilations",r,t,n),u=L("dataFormat",r,t,n).toUpperCase();return[s.depthwiseConv2d(L("input",r,t,n),L("filter",r,t,n),[i[1],i[2]],a,u,[o[1],o[2]])]}case"Conv3D":{const i=L("strides",r,t,n),a=L("pad",r,t,n),o=L("dataFormat",r,t,n).toUpperCase(),u=L("dilations",r,t,n);return[s.conv3d(L("x",r,t,n),L("filter",r,t,n),[i[1],i[2],i[3]],a,o,[u[1],u[2],u[3]])]}case"AvgPool":{const i=L("strides",r,t,n),a=L("pad",r,t,n),o=L("kernelSize",r,t,n);return[s.avgPool(L("x",r,t,n),[o[1],o[2]],[i[1],i[2]],a)]}case"MaxPool":{const i=L("strides",r,t,n),a=L("pad",r,t,n),o=L("kernelSize",r,t,n);return[s.maxPool(L("x",r,t,n),[o[1],o[2]],[i[1],i[2]],a)]}case"MaxPoolWithArgmax":{const i=L("strides",r,t,n),a=L("pad",r,t,n),o=L("kernelSize",r,t,n),u=L("includeBatchInIndex",r,t,n),{result:l,indexes:c}=s.maxPoolWithArgmax(L("x",r,t,n),[o[1],o[2]],[i[1],i[2]],a,u);return[l,c]}case"AvgPool3D":{const i=L("strides",r,t,n),a=L("pad",r,t,n),o=L("kernelSize",r,t,n);return[s.avgPool3d(L("x",r,t,n),[o[1],o[2],o[3]],[i[1],i[2],i[3]],a)]}case"MaxPool3D":{const i=L("strides",r,t,n),a=L("pad",r,t,n),o=L("kernelSize",r,t,n);return[s.maxPool3d(L("x",r,t,n),[o[1],o[2],o[3]],[i[1],i[2],i[3]],a)]}case"Dilation2D":{const i=L("strides",r,t,n),a=L("pad",r,t,n),o=L("dilations",r,t,n),u=i[1],l=i[2],c=o[1],h=o[2];return[s.dilation2d(L("x",r,t,n),L("filter",r,t,n),[u,l],a,[c,h],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qpt=(r,t,n,s=Ms)=>{switch(r.op){case"Fill":{const i=L("shape",r,t,n),a=L("dtype",r,t,n),o=L("value",r,t,n);return[s.fill(i,o,a)]}case"LinSpace":{const i=L("start",r,t,n),a=L("stop",r,t,n),o=L("num",r,t,n);return[s.linspace(i,a,o)]}case"Multinomial":{const i=L("logits",r,t,n),a=L("numSamples",r,t,n),o=L("seed",r,t,n);return[s.multinomial(i,a,o)]}case"OneHot":{const i=L("indices",r,t,n),a=L("depth",r,t,n),o=L("onValue",r,t,n),u=L("offValue",r,t,n),l=L("dtype",r,t,n);return[s.oneHot(i,a,o,u,l)]}case"Ones":return[s.ones(L("shape",r,t,n),L("dtype",r,t,n))];case"OnesLike":return[s.onesLike(L("x",r,t,n))];case"RandomStandardNormal":return[s.randomStandardNormal(L("shape",r,t,n),L("dtype",r,t,n),L("seed",r,t,n))];case"RandomUniform":return[s.randomUniform(L("shape",r,t,n),L("minval",r,t,n),L("maxval",r,t,n),L("dtype",r,t,n))];case"RandomUniformInt":return[s.randomUniformInt(L("shape",r,t,n),L("minval",r,t,n),L("maxval",r,t,n),L("seed",r,t,n))];case"Range":{const i=L("start",r,t,n),a=L("stop",r,t,n),o=L("step",r,t,n);return[s.range(i,a,o,L("dtype",r,t,n))]}case"TruncatedNormal":{const i=L("shape",r,t,n),a=L("mean",r,t,n),o=L("stdDev",r,t,n),u=L("seed",r,t,n);return[s.truncatedNormal(i,a,o,L("dtype",r,t,n),u)]}case"Zeros":return[s.zeros(L("shape",r,t,n),L("dtype",r,t,n))];case"ZerosLike":return[s.zerosLike(L("x",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xI(r,t,n){const s=L("boxes",r,t,n),i=L("scores",r,t,n),a=L("maxOutputSize",r,t,n),o=L("iouThreshold",r,t,n),u=L("scoreThreshold",r,t,n),l=L("softNmsSigma",r,t,n);return{boxes:s,scores:i,maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}}const eft=async(r,t,n,s,i=Ms)=>{switch(r.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:o,maxOutputSize:u,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=xI(r,t,n),d=await i.image.nonMaxSuppressionWithScoreAsync(a,o,u,l,c,h);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:o,maxOutputSize:u,iouThreshold:l,scoreThreshold:c}=xI(r,t,n),h=L("padToMaxOutputSize",r,t,n),d=await i.image.nonMaxSuppressionPaddedAsync(a,o,u,l,c,h);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:o,maxOutputSize:u,iouThreshold:l,scoreThreshold:c}=xI(r,t,n);return[await i.image.nonMaxSuppressionAsync(a,o,u,l,c)]}case"Where":{const a=i.cast(L("condition",r,t,n),"bool"),o=[await i.whereAsync(a)];return a.dispose(),o}case"ListDiff":return i.setdiff1dAsync(L("x",r,t,n),L("y",r,t,n));default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tft=(r,t,n,s=Ms)=>{switch(r.op){case"LowerBound":{const i=L("sortedSequence",r,t,n),a=L("values",r,t,n);return[s.lowerBound(i,a)]}case"TopKV2":{const i=L("x",r,t,n),a=L("k",r,t,n),o=L("sorted",r,t,n),u=s.topk(i,a,o);return[u.values,u.indices]}case"UpperBound":{const i=L("sortedSequence",r,t,n),a=L("values",r,t,n);return[s.upperBound(i,a)]}case"Unique":{const i=L("x",r,t,n),a=s.unique(i);return[a.values,a.indices]}case"UniqueV2":{const i=L("x",r,t,n),a=L("axis",r,t,n),o=s.unique(i,a);return[o.values,o.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rft=(r,t,n,s=Ms)=>{switch(r.op){case"Const":return t[r.name];case"PlaceholderWithDefault":const i=L("default",r,t,n);return[Fs(r.name,t,n)||i];case"Placeholder":return[Fs(r.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const h=L("x",r,t,n);return[zu(h)]}case"IdentityN":return L("x",r,t,n).map(h=>zu(h));case"Snapshot":const a=L("x",r,t,n);return[zu(a)];case"Shape":return[s.tensor1d(L("x",r,t,n).shape,"int32")];case"ShapeN":return L("x",r,t,n).map(h=>s.tensor1d(h.shape));case"Size":return[s.scalar(L("x",r,t,n).size,"int32")];case"Rank":return[s.scalar(L("x",r,t,n).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const o=L("x",r,t,n),u=L("data",r,t,n),l=L("message",r,t,n),c=L("summarize",r,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let h=0;h<u.length;h++)console.log(Array.prototype.slice.call(u[h].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nft{get id(){return this.handle.id}constructor(t,n){this.keyDType=t,this.valueDType=n,this.handle=mr(0),this.tensorMap=new Map,Co(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return mr(this.size(),"int32")}async import(t,n){this.checkKeyAndValueTensor(t,n);const s=await t.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),qt(()=>{const i=Fc(n),a=s.length,o=i.length;oe(a===o,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${o} elements.`);for(let u=0;u<a;u++){const l=s[u],c=i[u];Co(c),this.tensorMap.set(l,c)}return this.handle})}async find(t,n){this.checkKeyAndValueTensor(t,n);const s=await t.data();return qt(()=>{const i=[];for(let a=0;a<s.length;a++){const o=s[a],u=this.findWithDefault(o,n);i.push(u)}return mu(i)})}findWithDefault(t,n){const s=this.tensorMap.get(t);return s??n}checkKeyAndValueTensor(t,n){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sft=async(r,t,n,s)=>{switch(r.op){case"HashTable":case"HashTableV2":{const i=s.getHashTableHandleByName(r.name);if(i!=null)return[i];{const a=L("keyDType",r,t,n),o=L("valueDType",r,t,n),u=new nft(a,o);return s.addHashTable(r.name,u),[u.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=L("tableHandle",r,t,n,s),a=L("keys",r,t,n),o=L("values",r,t,n);return[await s.getHashTableById(i.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{const i=L("tableHandle",r,t,n,s),a=L("keys",r,t,n),o=L("defaultValue",r,t,n);return[await s.getHashTableById(i.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=L("tableHandle",r,t,n,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ift=(r,t,n,s=Ms)=>{switch(r.op){case"ResizeBilinear":{const i=L("images",r,t,n),a=L("size",r,t,n),o=L("alignCorners",r,t,n),u=L("halfPixelCenters",r,t,n);return[s.image.resizeBilinear(i,[a[0],a[1]],o,u)]}case"ResizeNearestNeighbor":{const i=L("images",r,t,n),a=L("size",r,t,n),o=L("alignCorners",r,t,n),u=L("halfPixelCenters",r,t,n);return[s.image.resizeNearestNeighbor(i,[a[0],a[1]],o,u)]}case"CropAndResize":{const i=L("image",r,t,n),a=L("boxes",r,t,n),o=L("boxInd",r,t,n),u=L("cropSize",r,t,n),l=L("method",r,t,n),c=L("extrapolationValue",r,t,n);return[s.image.cropAndResize(i,a,o,u,l,c)]}case"ImageProjectiveTransformV3":{const i=L("images",r,t,n),a=L("transforms",r,t,n),o=L("outputShape",r,t,n),u=L("fillValue",r,t,n),l=L("interpolation",r,t,n),c=L("fillMode",r,t,n);return[s.image.transform(i,a,l.toLowerCase(),c.toLowerCase(),u,o)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aft=(r,t,n,s=Ms)=>{switch(r.op){case"Equal":return[s.equal(L("a",r,t,n),L("b",r,t,n))];case"NotEqual":return[s.notEqual(L("a",r,t,n),L("b",r,t,n))];case"Greater":return[s.greater(L("a",r,t,n),L("b",r,t,n))];case"GreaterEqual":return[s.greaterEqual(L("a",r,t,n),L("b",r,t,n))];case"Less":return[s.less(L("a",r,t,n),L("b",r,t,n))];case"LessEqual":return[s.lessEqual(L("a",r,t,n),L("b",r,t,n))];case"LogicalAnd":return[s.logicalAnd(L("a",r,t,n),L("b",r,t,n))];case"LogicalNot":return[s.logicalNot(L("a",r,t,n))];case"LogicalOr":return[s.logicalOr(L("a",r,t,n),L("b",r,t,n))];case"Select":case"SelectV2":return[s.where(L("condition",r,t,n),L("a",r,t,n),L("b",r,t,n))];case"BitwiseAnd":return[s.bitwiseAnd(L("a",r,t,n),L("b",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oft=(r,t,n,s=Ms)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(L("a",r,t,n),L("b",r,t,n),L("transposeA",r,t,n),L("transposeB",r,t,n))];case"Einsum":return[s.einsum(L("equation",r,t,n),...L("tensors",r,t,n))];case"Transpose":return[s.transpose(L("x",r,t,n),L("perm",r,t,n))];case"_FusedMatMul":const[i,a]=L("fusedOps",r,t,n),o=i==="biasadd",u=a==="prelu",l=L("numArgs",r,t,n),c=L("leakyreluAlpha",r,t,n);if(o){if(u&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!u&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[h,d]=L("args",r,t,n);return[s.fused.matMul({a:L("a",r,t,n),b:L("b",r,t,n),transposeA:L("transposeA",r,t,n),transposeB:L("transposeB",r,t,n),bias:h,activation:a,preluActivationWeights:d,leakyreluAlpha:c})];case"MatrixBandPart":return[s.linalg.bandPart(L("a",r,t,n),L("numLower",r,t,n),L("numUpper",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uft=(r,t,n,s=Ms)=>{switch(r.op){case"EuclideanNorm":return[s.euclideanNorm(L("x",r,t,n),L("axis",r,t,n),L("keepDims",r,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(L("x",r,t,n),L("mean",r,t,n),L("variance",r,t,n),L("offset",r,t,n),L("scale",r,t,n),L("epsilon",r,t,n))];case"FusedBatchNormV3":return[s.batchNorm(L("x",r,t,n),L("mean",r,t,n),L("variance",r,t,n),L("offset",r,t,n),L("scale",r,t,n),L("epsilon",r,t,n))];case"LRN":return[s.localResponseNormalization(L("x",r,t,n),L("radius",r,t,n),L("bias",r,t,n),L("alpha",r,t,n),L("beta",r,t,n))];case"Softmax":return[s.softmax(L("x",r,t,n))];case"LogSoftmax":return[s.logSoftmax(L("x",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lft=(r,t,n,s=Ms)=>{switch(r.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:a}=s.raggedGather(L("paramsNestedSplits",r,t,n),L("paramsDenseValues",r,t,n),L("indices",r,t,n),L("outputRaggedRank",r,t,n));return i.concat(a)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:a}=s.raggedRange(L("starts",r,t,n),L("limits",r,t,n),L("splits",r,t,n));return[i,a]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(L("shape",r,t,n),L("values",r,t,n),L("defaultValue",r,t,n),L("rowPartitionTensors",r,t,n),L("rowPartitionTypes",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cft=(r,t,n,s=Ms)=>{switch(r.op){case"Max":{const u=L("axis",r,t,n),l=L("keepDims",r,t,n);return[s.max(L("x",r,t,n),u,l)]}case"Mean":{const u=L("axis",r,t,n),l=L("keepDims",r,t,n);return[s.mean(L("x",r,t,n),u,l)]}case"Min":{const u=L("axis",r,t,n),l=L("keepDims",r,t,n);return[s.min(L("x",r,t,n),u,l)]}case"Sum":{const u=L("axis",r,t,n),l=L("keepDims",r,t,n);return[s.sum(L("x",r,t,n),u,l)]}case"All":{const u=L("axis",r,t,n),l=L("keepDims",r,t,n);return[s.all(L("x",r,t,n),u,l)]}case"Any":{const u=L("axis",r,t,n),l=L("keepDims",r,t,n);return[s.any(L("x",r,t,n),u,l)]}case"ArgMax":{const u=L("axis",r,t,n);return[s.argMax(L("x",r,t,n),u)]}case"ArgMin":{const u=L("axis",r,t,n);return[s.argMin(L("x",r,t,n),u)]}case"Prod":{const u=L("axis",r,t,n),l=L("keepDims",r,t,n);return[s.prod(L("x",r,t,n),u,l)]}case"Cumprod":{const u=L("axis",r,t,n),l=L("exclusive",r,t,n),c=L("reverse",r,t,n);return[s.cumprod(L("x",r,t,n),u,l,c)]}case"Cumsum":{const u=L("axis",r,t,n),l=L("exclusive",r,t,n),c=L("reverse",r,t,n);return[s.cumsum(L("x",r,t,n),u,l,c)]}case"Bincount":const i=L("x",r,t,n),a=L("weights",r,t,n),o=L("size",r,t,n);return[s.bincount(i,a,o)];case"DenseBincount":{const u=L("x",r,t,n),l=L("weights",r,t,n),c=L("size",r,t,n),h=L("binaryOutput",r,t,n);return[s.denseBincount(u,l,c,h)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hft=(r,t,n,s=Ms)=>{switch(r.op){case"ConcatV2":case"Concat":{const i=L("n",r,t,n),a=L("axis",r,t,n);let o=L("tensors",r,t,n);return o=o.slice(0,i),[s.concat(o,a)]}case"Gather":{const i=L("x",r,t,n),a=L("indices",r,t,n);return[s.gather(i,s.cast(a,"int32"),0)]}case"GatherV2":{const i=L("axis",r,t,n),a=L("batchDims",r,t,n),o=L("x",r,t,n),u=L("indices",r,t,n);return[s.gather(o,s.cast(u,"int32"),i,a)]}case"Reverse":{const i=L("dims",r,t,n),a=[];for(let u=0;u<i.length;u++)i[u]&&a.push(u);const o=L("x",r,t,n);return[s.reverse(o,a)]}case"ReverseV2":{const i=L("axis",r,t,n),a=L("x",r,t,n);return[s.reverse(a,i)]}case"Slice":{const i=L("begin",r,t,n),a=L("size",r,t,n);return[s.slice(L("x",r,t,n),i,a)]}case"StridedSlice":{const i=L("begin",r,t,n),a=L("end",r,t,n),o=L("strides",r,t,n),u=L("beginMask",r,t,n),l=L("endMask",r,t,n),c=L("ellipsisMask",r,t,n),h=L("newAxisMask",r,t,n),d=L("shrinkAxisMask",r,t,n),p=L("x",r,t,n);return[s.stridedSlice(p,i,a,o,u,l,c,h,d)]}case"Pack":return qt(()=>{const i=L("axis",r,t,n),a=L("tensors",r,t,n),o=a[0].shape,u=s.squeeze(a[0]).shape,l=a.map(c=>{const h=En(c.shape,o);if(!h&&!En(s.squeeze(c).shape,u))throw new Error("the input tensors shape does not match");return h?c:s.reshape(c,o)});return[s.stack(l,i)]});case"Unpack":{const i=L("axis",r,t,n),a=L("tensor",r,t,n);return s.unstack(a,i)}case"Tile":{const i=L("reps",r,t,n);return[s.tile(L("x",r,t,n),i)]}case"Split":case"SplitV":{const i=L("axis",r,t,n),a=L("numOrSizeSplits",r,t,n),o=L("x",r,t,n);return s.split(o,a,i)}case"ScatterNd":{const i=L("indices",r,t,n),a=L("values",r,t,n),o=L("shape",r,t,n);return[s.scatterND(i,a,o)]}case"GatherNd":{const i=L("x",r,t,n),a=L("indices",r,t,n);return[s.gatherND(i,a)]}case"SparseToDense":{const i=L("sparseIndices",r,t,n),a=L("outputShape",r,t,n),o=L("sparseValues",r,t,n),u=L("defaultValue",r,t,n);return[s.sparseToDense(i,o,a,o.dtype===u.dtype?u:s.cast(u,o.dtype))]}case"TensorScatterUpdate":{const i=L("indices",r,t,n),a=L("values",r,t,n),o=L("tensor",r,t,n);return[s.tensorScatterUpdate(o,i,a)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dft=(r,t,n,s=Ms)=>{switch(r.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:a,emptyRowIndicator:o,reverseIndexMap:u}=s.sparse.sparseFillEmptyRows(L("indices",r,t,n),L("values",r,t,n),L("denseShape",r,t,n),L("defaultValue",r,t,n));return[i,a,o,u]}case"SparseReshape":{const{outputIndices:i,outputShape:a}=s.sparse.sparseReshape(L("inputIndices",r,t,n),L("inputShape",r,t,n),L("newShape",r,t,n));return[i,a]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(L("data",r,t,n),L("indices",r,t,n),L("segmentIds",r,t,n))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(L("data",r,t,n),L("indices",r,t,n),L("segmentIds",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pft=(r,t,n,s=Ms)=>{switch(r.op){case"FFT":return[s.fft(L("x",r,t,n))];case"IFFT":return[s.ifft(L("x",r,t,n))];case"RFFT":return[s.rfft(L("x",r,t,n))];case"IRFFT":return[s.irfft(L("x",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fft=(r,t,n,s=Ms)=>{switch(r.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(L("input",r,t,n),L("pattern",r,t,n),L("rewrite",r,t,n),L("replaceGlobal",r,t,n))];case"StringNGrams":{const{nGrams:i,nGramsSplits:a}=s.string.stringNGrams(L("data",r,t,n),L("dataSplits",r,t,n),L("separator",r,t,n),L("nGramWidths",r,t,n),L("leftPad",r,t,n),L("rightPad",r,t,n),L("padWidth",r,t,n),L("preserveShortSequences",r,t,n));return[i,a]}case"StringSplit":{const{indices:i,values:a,shape:o}=s.string.stringSplit(L("input",r,t,n),L("delimiter",r,t,n),L("skipEmpty",r,t,n));return[i,a,o]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(L("input",r,t,n),L("numBuckets",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mft=(r,t,n,s=Ms)=>{switch(r.op){case"Cast":return[s.cast(L("x",r,t,n),L("dtype",r,t,n))];case"ExpandDims":{const i=L("axis",r,t,n);return[s.expandDims(L("x",r,t,n),i)]}case"Squeeze":{const i=L("axis",r,t,n);return[s.squeeze(L("x",r,t,n),i)]}case"Reshape":return[s.reshape(L("x",r,t,n),L("shape",r,t,n))];case"EnsureShape":return[s.ensureShape(L("x",r,t,n),L("shape",r,t,n))];case"MirrorPad":return[s.mirrorPad(L("x",r,t,n),L("padding",r,t,n),L("mode",r,t,n))];case"PadV2":case"Pad":return[s.pad(L("x",r,t,n),L("padding",r,t,n),L("constantValue",r,t,n))];case"SpaceToBatchND":{const i=L("blockShape",r,t,n),a=L("paddings",r,t,n);return[s.spaceToBatchND(L("x",r,t,n),i,a)]}case"BatchToSpaceND":{const i=L("blockShape",r,t,n),a=L("crops",r,t,n);return[s.batchToSpaceND(L("x",r,t,n),i,a)]}case"DepthToSpace":{const i=L("blockSize",r,t,n),a=L("dataFormat",r,t,n).toUpperCase();return[s.depthToSpace(L("x",r,t,n),i,a)]}case"BroadcastTo":return[s.broadcastTo(L("x",r,t,n),L("shape",r,t,n))];case"BroadcastArgs":return[s.broadcastArgs(L("s0",r,t,n),L("s1",r,t,n))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vz(r,t,n,s,i=qt){const a=((o,u,l)=>{switch(o.category){case"arithmetic":return i(()=>Gpt(o,u,l));case"basic_math":return i(()=>Hpt(o,u,l));case"control":return Zpt(o,u,l);case"convolution":return i(()=>Jpt(o,u,l));case"creation":return i(()=>Qpt(o,u,l));case"dynamic":return eft(o,u,l);case"evaluation":return i(()=>tft(o,u,l));case"image":return i(()=>ift(o,u,l));case"graph":return i(()=>rft(o,u,l));case"logical":return i(()=>aft(o,u,l));case"matrices":return i(()=>oft(o,u,l));case"normalization":return i(()=>uft(o,u,l));case"ragged":return i(()=>lft(o,u,l));case"reduction":return i(()=>cft(o,u,l));case"slice_join":return i(()=>hft(o,u,l));case"sparse":return i(()=>dft(o,u,l));case"spectral":return i(()=>pft(o,u,l));case"string":return i(()=>fft(o,u,l));case"transformation":return i(()=>mft(o,u,l));case"hash_table":return sft(o,u,l,s);case"custom":const c=dne(o.op);if(c&&c.customExecutor)return c.customExecutor(new Wpt(o,u,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,t,n);return lc(a)?a.then(o=>[].concat(o)):[].concat(a)}class wz{constructor(t={},n={},s={},i={},a){this.weightMap=t,this.tensorArrayMap=n,this.tensorListMap=s,this.functionMap=i,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,n){return{id:t,frameName:n,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let n=0;n<this.contexts.length-1;n++){const s=this.contexts.slice(0,this.contexts.length-n);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(t);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(t)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sz(r,t,n,s){const i=new Set,a=[];let o=null,u=null;const l=new Set,c=new Set(Object.keys(r).map(p=>ji(p)[0]));s=s||[];const h=new Set(s.map(p=>ji(p.name)[0])),d=[...t];for(;d.length>0;){const p=d.pop();if((kh(p)||Cft(p)||_ft(p))&&o==null&&(o=p,u=o.children.map(f=>f.name).filter(f=>i.has(f))),i.add(p.name),n[p.name]==null&&!c.has(p.name)&&!h.has(p.name)){if(p.inputs.length===0){a.push(p.name);continue}p.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),d.push(f))})}}return{inputs:r,outputs:t,usedNodes:i,missingInputs:a,dynamicNode:o,syncInputs:u}}function gft(r,t){const{usedNodes:n,inputs:s}=t,i=Object.keys(s).map(y=>ji(y)[0]).map(y=>r.nodes[y]),a=r.initNodes||[],o=y=>n.has(typeof y=="string"?y:y.name);function u(y){return[...new Map(y.map(b=>[b.name,b])).values()]}const l=u([...i,...r.weights,...a]).filter(o),c=u([...l,...Object.values(r.nodes)]).filter(o),h=new Map(c.map(y=>[y.name,y])),d={};for(const y of c){d[y.name]=d[y.name]||0;for(const b of y.children)o(b)||(d[b.name]=Number.POSITIVE_INFINITY),d[b.name]=(d[b.name]||0)+1}const p=Object.entries(d).filter(([,y])=>y===0).map(([y])=>y),f=[...p];for(;p.length>0;){const y=p.pop(),b=h.get(y);for(const x of b.children.filter(o))--d[x.name]===0&&(f.push(x.name),p.push(x.name))}const m=f.map(y=>h.get(y)),g=yft(m,l);return bft(g,l),g}function yft(r,t){const n=new Map(r.map(o=>[o.name,o])),s=t.map(o=>o.name),i=new Set(s);for(;s.length>0;){const o=s.pop(),u=n.get(o);for(const l of u.children)!n.has(l.name)||i.has(l.name)||(i.add(l.name),s.push(l.name))}return r.filter(o=>i.has(o.name))}class j1 extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}function bft(r,t){const n=new Map(r.map((u,l)=>[u.name,l])),s=new Set(t.map(u=>u.name)),i=u=>s.has(typeof u=="string"?u:u.name),a=new Set(r.map(u=>u.name)),o=u=>a.has(typeof u=="string"?u:u.name);for(const u of r){for(const l of u.children.filter(o)){if(!n.has(l.name))throw new j1(`Child ${l.name} of node ${u.name} is unreachable.`);if(n.get(u.name)>n.get(l.name))throw new j1(`Node ${u.name} is scheduled to run after its child ${l.name}.`)}if(!i(u))for(const l of u.inputs){if(!n.has(l.name))throw new j1(`Input ${l.name} of node ${u.name} is unreachable.`);if(n.get(l.name)>n.get(u.name))throw new j1(`Node ${u.name} is scheduled to run before its input ${l.name}.`)}}}function xft(r){const t=new Map(r.map((u,l)=>[u.name,l])),n=Number.MAX_SAFE_INTEGER,s=r.map((u,l)=>kh(u)?n:l),i=u=>{const l=s[t.get(u.name)];return l??-1},a=r.map((u,l)=>u.children.map(i).reduce((c,h)=>Math.max(c,h),s[l])),o=new Map;for(let u=0;u<r.length;++u){const l=a[u];if(l===n)continue;const c=r[u],h=r[l];o.has(h.name)||o.set(h.name,[]),o.get(h.name).push(c)}return o}const vft=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),wft=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Sft=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function kh(r){return vft.has(r.op)}function Cft(r){return wft.has(r.op)}function _ft(r){return Sft.has(r.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cS{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const n=Object.keys(t).map(s=>t[s].map(i=>i.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(s=>{this._functionExecutorMap[s]=new cS(t.functions[s],this)})}getCompilationKey(t,n){const s=t.map(a=>a.name).sort(),i=n.map(a=>a.name).sort();return s.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(t,n){const s=Sz(t,n,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:a,syncInputs:o}=s;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(i.length>0){const c=n.map(d=>d.name),h=Object.keys(t);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${h}]. Missing the following inputs: [${i}]`)}const u=gft(this.graph,s),l=xft(u);return{orderedNodes:u,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;const n=t.clone();return Co(n),n}cloneTensorList(t){return t?t.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,s])=>[n,this.cloneTensorList(s)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);const s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);const i=s.map(p=>this.graph.nodes[ji(p)[0]]),a=n.map(p=>ji(p)[0]),o=new Set(a);let u=a.map(p=>this.graph.nodes[p]);u.length===0&&(u=this._outputs);const l=this.getCompilationKey(i,u);let c=this.compiledMap.get(l);c==null&&(c=this.compile(t,u),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=Be().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const h={},d={};return qt(()=>{const p=new wz(this.weightMap,h,d,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(b=>{const[x,w]=ji(b,p),v=[];v[w]=t[b],f[x]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[x]=this.cloneTensorList(v))});const m=this.getFrozenTensorIds(f),{orderedNodes:g,nodeLiveUntilMap:y}=c;for(const b of g){if(f[b.name])continue;const x=vz(b,f,p,this._resourceManager);if(lc(x))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);f[b.name]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(x)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,f,p,m,o,y.get(b.name))}return this.parent==null&&p.dispose(m),n.map(b=>Fs(b,f,p))})}getFrozenTensorIds(t){const n=[].concat.apply([],Object.keys(t).map(s=>t[s]).map(s=>s.map(i=>i.id)));return new Set(n)}checkTensorForDisposal(t,n,s,i,a,o,u){if(!(kh(n)||o.has(t))){for(const l of s[t])l!=null&&(u[l.id]=(u[l.id]||0)+n.children.length);for(const l of n.inputs){if(kh(l))continue;const c=mz(l.name,s,i);if(c!=null)for(const h of c){if(!h||h.kept||a.has(h.id))continue;const d=u[h.id];d===1?(h.dispose(),delete u[h.id]):d!=null&&u[h.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,s,i,a,o){function u(l){return kh(l)||a.has(l.name)}if(!(kh(t)||o==null))for(const l of o){if(u(l))continue;const c=mz(l.name,n,s);for(const h of c)!h||h.kept||i.has(h.id)||h.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,s=!1,i={},a={}){this.disposeIntermediateTensors(),s||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=Be().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const o=new wz(this.weightMap,i,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const u=await this.executeWithControlFlow(t,o,n,s),l=n.map(p=>Fs(p,u,o)),c=l.map(p=>p.id),h=Object.keys(t).map(p=>t[p].id),d=new Set([...c,...h,...this.weightIds]);return Object.values(u).forEach(p=>{p.forEach(f=>{f&&!f.isDisposed&&!d.has(f.id)&&f.dispose()})}),this.parent==null&&o.dispose(d),l}async executeFunctionAsync(t,n,s){const i=t.reduce((a,o,u)=>(a[this.inputs[u].name]=o,a),{});return this._executeAsync(i,this.outputNodes,!0,n,s)}async executeWithControlFlow(t,n,s,i){const a=Object.keys(t),o=a.map(v=>this.graph.nodes[ji(v)[0]]),u=s.map(v=>ji(v)[0]),l=new Set(u);let c=u.map(v=>this.graph.nodes[v]);c.length===0&&(c=this._outputs);const{usedNodes:h,missingInputs:d,dynamicNode:p,syncInputs:f}=Sz(t,c,this.weightMap,this._initNodes),m=[...o,...this.graph.weights,...this._initNodes||[]].map(v=>({node:v,contexts:n.currentContext})),g=Object.assign({},this.weightMap);Object.keys(t).forEach(v=>{const[S,E]=ji(v),C=[];C[E]=t[v],g[S]=C});const y={},b=this.getFrozenTensorIds(g),x={};for(;m.length>0;){const v=this.processStack(o,m,n,g,x,b,l,y,h);await Promise.all(v)}p==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const w=c.filter(v=>!kh(v)&&!Fs(v.name,g,n)).map(v=>v.name);if(w.length>0){let v="";throw p!=null&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${a}]. Consider providing the following inputs: [${d}]. ${v}`)}return g}processStack(t,n,s,i,a,o,u,l,c){const h=[];for(;n.length>0;){const d=n.pop();s.currentContext=d.contexts;let p="";if(d.node.op==="Enter"&&L("isConstant",d.node,i,s)&&([p]=Vu(d.node.name,s)),i[d.node.name]==null){const f=vz(d.node,i,s,this._resourceManager);p||([p]=Vu(d.node.name,s));const m=s.currentContext;lc(f)?h.push(f.then(g=>(i[p]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(g)),s.currentContext=m,this.checkTensorForDisposal(p,d.node,i,s,o,u,l),this.processChildNodes(d.node,n,s,i,a,c),g))):(i[p]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(f)),this.checkTensorForDisposal(p,d.node,i,s,o,u,l),this.processChildNodes(d.node,n,s,i,a,c))}else this.processChildNodes(d.node,n,s,i,a,c)}return h}processChildNodes(t,n,s,i,a,o){t.children.forEach(u=>{const[l]=Vu(u.name,s);a[l]||!o.has(u.name)||(u.op==="Merge"?u.inputNames.some(c=>!!Fs(c,i,s))&&(a[l]=!0,n.push({contexts:s.currentContext,node:u})):u.inputNames.every(c=>!!Fs(c,i,s))&&(a[l]=!0,n.push({contexts:s.currentContext,node:u})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{const s=t[n],[i]=ji(n),a=this.graph.nodes[i];if(a.attrParams.shape&&a.attrParams.shape.value){const o=a.attrParams.shape.value,u=o.length===s.shape.length&&s.shape.every((l,c)=>o[c]===-1||o[c]===l);oe(u,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&oe(s.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(t){var n,s;const i={};for(const a in t){const o=(s=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||s===void 0?void 0:s[a];o!=null?i[o.name]=t[a]:i[a]=t[a]}return i}checkInputs(t){const n=Object.keys(t).filter(s=>{const[i]=ji(s);return this.graph.nodes[i]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var s,i;const a=(i=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||i===void 0?void 0:i[n];return a!=null?a.name:n},{})}checkOutputs(t){t.forEach(n=>{const[s]=ji(n);if(!this.graph.nodes[s])throw new Error(`The output '${n}' is not found in the graph`)})}}class Eft{constructor(t={},n={}){this.hashTableNameToHandle=t,this.hashTableMap=n}addHashTable(t,n){this.hashTableNameToHandle[t]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ift="?tfjs-format=file",kft="model.json";class Nft{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,n={},s=hR){this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=s,n==null&&(this.loadOptions={}),this.resourceManager=new Eft}findIOHandler(){const t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const n=this.io.getLoadHandlers(t,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[t]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return lc(t)?t.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(t)}loadSync(t){const n=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,n)}async loadStreaming(t){if(t.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await AG(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,n)}loadWithWeightMap(t,n){this.artifacts=t;const s=this.artifacts.modelTopology;let i=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(i=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=i,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new cS(gz.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){const a=gz.Instance.transformGraph(t.modelInitializer);this.initializer=new cS(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,n){if(typeof t=="string"){const s=this.io.getSaveHandlers(t);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const n=t instanceof Xr?[t]:t,s={};return n.forEach((i,a)=>s[this.structuredOutputKeys[a]]=i),s}return t}predict(t,n){const s=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(t,n){const s=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(t){var n;if(!(t instanceof Xr)&&!Array.isArray(t)){const a=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(a!=null)for(const o in a){const u=a[o];u.resourceId!=null&&(t[o]=this.resourceIdToCapturedInput[u.resourceId])}return t}t=Array.isArray(t)?t:[t];const s=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${t.length} input tensors provided.`);let i=0;return this.inputNodes.reduce((a,o)=>{var u,l,c;const h=(c=(l=(u=this.signature)===null||u===void 0?void 0:u.inputs)===null||l===void 0?void 0:l[o])===null||c===void 0?void 0:c.resourceId;return h!=null?a[o]=this.resourceIdToCapturedInput[h]:a[o]=t[i++],a},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,s=Object.keys(n);for(let i=0;i<s.length;i++){const a=s[i],o=n[a];this.resourceIdToCapturedInput[o.resourceId]=t[i]}}}execute(t,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const s=this.executor.execute(t,n);return s.length>1?s:s[0]}async executeAsync(t,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const s=await this.executor.executeAsync(t,n);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((n,s)=>(n[s]=[t[s]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&ii(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function XL(r,t={},n=hR){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof r=="string"&&(r=Tft(r));const s=new Nft(r,t,n);return await s.load(),s}function Tft(r){return r.endsWith("/")||(r=r+"/"),`${r}${kft}${Ift}`}var vI={},Cz;function Aft(){return Cz||(Cz=1,(function(){var r;function t(T){var R=0;return function(){return R<T.length?{done:!1,value:T[R++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(T,R,U){return T==Array.prototype||T==Object.prototype||(T[R]=U.value),T};function s(T){T=[typeof globalThis=="object"&&globalThis,T,typeof window=="object"&&window,typeof self=="object"&&self,typeof jI=="object"&&jI];for(var R=0;R<T.length;++R){var U=T[R];if(U&&U.Math==Math)return U}throw Error("Cannot find global object")}var i=s(this);function a(T,R){if(R)e:{var U=i;T=T.split(".");for(var j=0;j<T.length-1;j++){var de=T[j];if(!(de in U))break e;U=U[de]}T=T[T.length-1],j=U[T],R=R(j),R!=j&&R!=null&&n(U,T,{configurable:!0,writable:!0,value:R})}}a("Symbol",function(T){function R(ge){if(this instanceof R)throw new TypeError("Symbol is not a constructor");return new U(j+(ge||"")+"_"+de++,ge)}function U(ge,fe){this.h=ge,n(this,"description",{configurable:!0,writable:!0,value:fe})}if(T)return T;U.prototype.toString=function(){return this.h};var j="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",de=0;return R}),a("Symbol.iterator",function(T){if(T)return T;T=Symbol("Symbol.iterator");for(var R="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),U=0;U<R.length;U++){var j=i[R[U]];typeof j=="function"&&typeof j.prototype[T]!="function"&&n(j.prototype,T,{configurable:!0,writable:!0,value:function(){return o(t(this))}})}return T});function o(T){return T={next:T},T[Symbol.iterator]=function(){return this},T}function u(T){var R=typeof Symbol<"u"&&Symbol.iterator&&T[Symbol.iterator];return R?R.call(T):{next:t(T)}}function l(T){if(!(T instanceof Array)){T=u(T);for(var R,U=[];!(R=T.next()).done;)U.push(R.value);T=U}return T}var c=typeof Object.assign=="function"?Object.assign:function(T,R){for(var U=1;U<arguments.length;U++){var j=arguments[U];if(j)for(var de in j)Object.prototype.hasOwnProperty.call(j,de)&&(T[de]=j[de])}return T};a("Object.assign",function(T){return T||c});var h=typeof Object.create=="function"?Object.create:function(T){function R(){}return R.prototype=T,new R},d;if(typeof Object.setPrototypeOf=="function")d=Object.setPrototypeOf;else{var p;e:{var f={a:!0},m={};try{m.__proto__=f,p=m.a;break e}catch{}p=!1}d=p?function(T,R){if(T.__proto__=R,T.__proto__!==R)throw new TypeError(T+" is not extensible");return T}:null}var g=d;function y(T,R){if(T.prototype=h(R.prototype),T.prototype.constructor=T,g)g(T,R);else for(var U in R)if(U!="prototype")if(Object.defineProperties){var j=Object.getOwnPropertyDescriptor(R,U);j&&Object.defineProperty(T,U,j)}else T[U]=R[U];T.za=R.prototype}function b(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function x(T){if(T.m)throw new TypeError("Generator is already running");T.m=!0}b.prototype.u=function(T){this.i=T};function w(T,R){T.l={ma:R,na:!0},T.h=T.s||T.v}b.prototype.return=function(T){this.l={return:T},this.h=this.v};function v(T,R,U){return T.h=U,{value:R}}function S(T){this.h=new b,this.i=T}function E(T,R){x(T.h);var U=T.h.j;return U?C(T,"return"in U?U.return:function(j){return{value:j,done:!0}},R,T.h.return):(T.h.return(R),I(T))}function C(T,R,U,j){try{var de=R.call(T.h.j,U);if(!(de instanceof Object))throw new TypeError("Iterator result "+de+" is not an object");if(!de.done)return T.h.m=!1,de;var ge=de.value}catch(fe){return T.h.j=null,w(T.h,fe),I(T)}return T.h.j=null,j.call(T.h,ge),I(T)}function I(T){for(;T.h.h;)try{var R=T.i(T.h);if(R)return T.h.m=!1,{value:R.value,done:!1}}catch(U){T.h.i=void 0,w(T.h,U)}if(T.h.m=!1,T.h.l){if(R=T.h.l,T.h.l=null,R.na)throw R.ma;return{value:R.return,done:!0}}return{value:void 0,done:!0}}function _(T){this.next=function(R){return x(T.h),T.h.j?R=C(T,T.h.j.next,R,T.h.u):(T.h.u(R),R=I(T)),R},this.throw=function(R){return x(T.h),T.h.j?R=C(T,T.h.j.throw,R,T.h.u):(w(T.h,R),R=I(T)),R},this.return=function(R){return E(T,R)},this[Symbol.iterator]=function(){return this}}function A(T){function R(j){return T.next(j)}function U(j){return T.throw(j)}return new Promise(function(j,de){function ge(fe){fe.done?j(fe.value):Promise.resolve(fe.value).then(R,U).then(ge,de)}ge(T.next())})}function k(T){return A(new _(new S(T)))}a("Promise",function(T){function R(fe){this.i=0,this.j=void 0,this.h=[],this.u=!1;var Ne=this.l();try{fe(Ne.resolve,Ne.reject)}catch(je){Ne.reject(je)}}function U(){this.h=null}function j(fe){return fe instanceof R?fe:new R(function(Ne){Ne(fe)})}if(T)return T;U.prototype.i=function(fe){if(this.h==null){this.h=[];var Ne=this;this.j(function(){Ne.m()})}this.h.push(fe)};var de=i.setTimeout;U.prototype.j=function(fe){de(fe,0)},U.prototype.m=function(){for(;this.h&&this.h.length;){var fe=this.h;this.h=[];for(var Ne=0;Ne<fe.length;++Ne){var je=fe[Ne];fe[Ne]=null;try{je()}catch(st){this.l(st)}}}this.h=null},U.prototype.l=function(fe){this.j(function(){throw fe})},R.prototype.l=function(){function fe(st){return function(yt){je||(je=!0,st.call(Ne,yt))}}var Ne=this,je=!1;return{resolve:fe(this.I),reject:fe(this.m)}},R.prototype.I=function(fe){if(fe===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(fe instanceof R)this.L(fe);else{e:switch(typeof fe){case"object":var Ne=fe!=null;break e;case"function":Ne=!0;break e;default:Ne=!1}Ne?this.F(fe):this.s(fe)}},R.prototype.F=function(fe){var Ne=void 0;try{Ne=fe.then}catch(je){this.m(je);return}typeof Ne=="function"?this.M(Ne,fe):this.s(fe)},R.prototype.m=function(fe){this.v(2,fe)},R.prototype.s=function(fe){this.v(1,fe)},R.prototype.v=function(fe,Ne){if(this.i!=0)throw Error("Cannot settle("+fe+", "+Ne+"): Promise already settled in state"+this.i);this.i=fe,this.j=Ne,this.i===2&&this.K(),this.H()},R.prototype.K=function(){var fe=this;de(function(){if(fe.D()){var Ne=i.console;typeof Ne<"u"&&Ne.error(fe.j)}},1)},R.prototype.D=function(){if(this.u)return!1;var fe=i.CustomEvent,Ne=i.Event,je=i.dispatchEvent;return typeof je>"u"?!0:(typeof fe=="function"?fe=new fe("unhandledrejection",{cancelable:!0}):typeof Ne=="function"?fe=new Ne("unhandledrejection",{cancelable:!0}):(fe=i.document.createEvent("CustomEvent"),fe.initCustomEvent("unhandledrejection",!1,!0,fe)),fe.promise=this,fe.reason=this.j,je(fe))},R.prototype.H=function(){if(this.h!=null){for(var fe=0;fe<this.h.length;++fe)ge.i(this.h[fe]);this.h=null}};var ge=new U;return R.prototype.L=function(fe){var Ne=this.l();fe.T(Ne.resolve,Ne.reject)},R.prototype.M=function(fe,Ne){var je=this.l();try{fe.call(Ne,je.resolve,je.reject)}catch(st){je.reject(st)}},R.prototype.then=function(fe,Ne){function je(Wt,It){return typeof Wt=="function"?function(Jt){try{st(Wt(Jt))}catch(xr){yt(xr)}}:It}var st,yt,Zt=new R(function(Wt,It){st=Wt,yt=It});return this.T(je(fe,st),je(Ne,yt)),Zt},R.prototype.catch=function(fe){return this.then(void 0,fe)},R.prototype.T=function(fe,Ne){function je(){switch(st.i){case 1:fe(st.j);break;case 2:Ne(st.j);break;default:throw Error("Unexpected state: "+st.i)}}var st=this;this.h==null?ge.i(je):this.h.push(je),this.u=!0},R.resolve=j,R.reject=function(fe){return new R(function(Ne,je){je(fe)})},R.race=function(fe){return new R(function(Ne,je){for(var st=u(fe),yt=st.next();!yt.done;yt=st.next())j(yt.value).T(Ne,je)})},R.all=function(fe){var Ne=u(fe),je=Ne.next();return je.done?j([]):new R(function(st,yt){function Zt(Jt){return function(xr){Wt[Jt]=xr,It--,It==0&&st(Wt)}}var Wt=[],It=0;do Wt.push(void 0),It++,j(je.value).T(Zt(Wt.length-1),yt),je=Ne.next();while(!je.done)})},R});function N(T,R){T instanceof String&&(T+="");var U=0,j=!1,de={next:function(){if(!j&&U<T.length){var ge=U++;return{value:R(ge,T[ge]),done:!1}}return j=!0,{done:!0,value:void 0}}};return de[Symbol.iterator]=function(){return de},de}a("Array.prototype.keys",function(T){return T||function(){return N(this,function(R){return R})}}),a("Array.prototype.fill",function(T){return T||function(R,U,j){var de=this.length||0;for(0>U&&(U=Math.max(0,de+U)),(j==null||j>de)&&(j=de),j=Number(j),0>j&&(j=Math.max(0,de+j)),U=Number(U||0);U<j;U++)this[U]=R;return this}});function D(T){return T||Array.prototype.fill}a("Int8Array.prototype.fill",D),a("Uint8Array.prototype.fill",D),a("Uint8ClampedArray.prototype.fill",D),a("Int16Array.prototype.fill",D),a("Uint16Array.prototype.fill",D),a("Int32Array.prototype.fill",D),a("Uint32Array.prototype.fill",D),a("Float32Array.prototype.fill",D),a("Float64Array.prototype.fill",D),a("Object.is",function(T){return T||function(R,U){return R===U?R!==0||1/R===1/U:R!==R&&U!==U}}),a("Array.prototype.includes",function(T){return T||function(R,U){var j=this;j instanceof String&&(j=String(j));var de=j.length;for(U=U||0,0>U&&(U=Math.max(U+de,0));U<de;U++){var ge=j[U];if(ge===R||Object.is(ge,R))return!0}return!1}}),a("String.prototype.includes",function(T){return T||function(R,U){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(R instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(R,U||0)!==-1}});var F=this||self;function P(T,R){T=T.split(".");var U=F;T[0]in U||typeof U.execScript>"u"||U.execScript("var "+T[0]);for(var j;T.length&&(j=T.shift());)T.length||R===void 0?U[j]&&U[j]!==Object.prototype[j]?U=U[j]:U=U[j]={}:U[j]=R}function G(T){var R;e:{if((R=F.navigator)&&(R=R.userAgent))break e;R=""}return R.indexOf(T)!=-1}var Y=Array.prototype.map?function(T,R){return Array.prototype.map.call(T,R,void 0)}:function(T,R){for(var U=T.length,j=Array(U),de=typeof T=="string"?T.split(""):T,ge=0;ge<U;ge++)ge in de&&(j[ge]=R.call(void 0,de[ge],ge,T));return j},Z={},ee=null;function se(T){var R=T.length,U=3*R/4;U%3?U=Math.floor(U):"=.".indexOf(T[R-1])!=-1&&(U="=.".indexOf(T[R-2])!=-1?U-2:U-1);var j=new Uint8Array(U),de=0;return re(T,function(ge){j[de++]=ge}),de!==U?j.subarray(0,de):j}function re(T,R){function U(je){for(;j<T.length;){var st=T.charAt(j++),yt=ee[st];if(yt!=null)return yt;if(!/^[\s\xa0]*$/.test(st))throw Error("Unknown base64 encoding at char: "+st)}return je}J();for(var j=0;;){var de=U(-1),ge=U(0),fe=U(64),Ne=U(64);if(Ne===64&&de===-1)break;R(de<<2|ge>>4),fe!=64&&(R(ge<<4&240|fe>>2),Ne!=64&&R(fe<<6&192|Ne))}}function J(){if(!ee){ee={};for(var T="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),R=["+/=","+/","-_=","-_.","-_"],U=0;5>U;U++){var j=T.concat(R[U].split(""));Z[U]=j;for(var de=0;de<j.length;de++){var ge=j[de];ee[ge]===void 0&&(ee[ge]=de)}}}}var le=typeof Uint8Array<"u",he=!(G("Trident")||G("MSIE"))&&typeof F.btoa=="function";function xe(T){if(!he){var R;R===void 0&&(R=0),J(),R=Z[R];for(var U=Array(Math.floor(T.length/3)),j=R[64]||"",de=0,ge=0;de<T.length-2;de+=3){var fe=T[de],Ne=T[de+1],je=T[de+2],st=R[fe>>2];fe=R[(fe&3)<<4|Ne>>4],Ne=R[(Ne&15)<<2|je>>6],je=R[je&63],U[ge++]=st+fe+Ne+je}switch(st=0,je=j,T.length-de){case 2:st=T[de+1],je=R[(st&15)<<2]||j;case 1:T=T[de],U[ge]=R[T>>2]+R[(T&3)<<4|st>>4]+je+j}return U.join("")}for(R="";10240<T.length;)R+=String.fromCharCode.apply(null,T.subarray(0,10240)),T=T.subarray(10240);return R+=String.fromCharCode.apply(null,T),btoa(R)}var Fe=RegExp("[-_.]","g");function Le(T){switch(T){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function Ve(T){if(!he)return se(T);Fe.test(T)&&(T=T.replace(Fe,Le)),T=atob(T);for(var R=new Uint8Array(T.length),U=0;U<T.length;U++)R[U]=T.charCodeAt(U);return R}var $e;function Ae(){return $e||($e=new Uint8Array(0))}var Te={},Ue=typeof Uint8Array.prototype.slice=="function",qe=0,Me=0;function ie(T){var R=0>T;T=Math.abs(T);var U=T>>>0;T=Math.floor((T-U)/4294967296),R&&(U=u(pe(U,T)),R=U.next().value,T=U.next().value,U=R),qe=U>>>0,Me=T>>>0}var K=typeof BigInt=="function";function pe(T,R){return R=~R,T?T=~T+1:R+=1,[T,R]}function _e(T,R){this.i=T>>>0,this.h=R>>>0}function We(T){if(!T)return Oe||(Oe=new _e(0,0));if(!/^-?\d+$/.test(T))return null;if(16>T.length)ie(Number(T));else if(K)T=BigInt(T),qe=Number(T&BigInt(4294967295))>>>0,Me=Number(T>>BigInt(32)&BigInt(4294967295));else{var R=+(T[0]==="-");Me=qe=0;for(var U=T.length,j=R,de=(U-R)%6+R;de<=U;j=de,de+=6)j=Number(T.slice(j,de)),Me*=1e6,qe=1e6*qe+j,4294967296<=qe&&(Me+=qe/4294967296|0,qe%=4294967296);R&&(R=u(pe(qe,Me)),T=R.next().value,R=R.next().value,qe=T,Me=R)}return new _e(qe,Me)}var Oe;function nt(T,R){return Error("Invalid wire type: "+T+" (at position "+R+")")}function rt(){return Error("Failed to read varint, encoding is invalid.")}function pt(T,R){return Error("Tried to read past the end of the data "+R+" > "+T)}function Et(){throw Error("Invalid UTF8")}function ht(T,R){return R=String.fromCharCode.apply(null,R),T==null?R:T+R}var Mt=void 0,it,kt=typeof TextDecoder<"u",Lt,wn=typeof TextEncoder<"u",Gr;function lr(T){if(T!==Te)throw Error("illegal external caller")}function Pr(T,R){if(lr(R),this.V=T,T!=null&&T.length===0)throw Error("ByteString should be constructed with non-empty values")}function V(){return Gr||(Gr=new Pr(null,Te))}function H(T){lr(Te);var R=T.V;return R=R==null||le&&R!=null&&R instanceof Uint8Array?R:typeof R=="string"?Ve(R):null,R==null?R:T.V=R}function ae(T){if(typeof T=="string")return{buffer:Ve(T),C:!1};if(Array.isArray(T))return{buffer:new Uint8Array(T),C:!1};if(T.constructor===Uint8Array)return{buffer:T,C:!1};if(T.constructor===ArrayBuffer)return{buffer:new Uint8Array(T),C:!1};if(T.constructor===Pr)return{buffer:H(T)||Ae(),C:!0};if(T instanceof Uint8Array)return{buffer:new Uint8Array(T.buffer,T.byteOffset,T.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function ce(T,R){this.i=null,this.m=!1,this.h=this.j=this.l=0,ve(this,T,R)}function ve(T,R,U){U=U===void 0?{}:U,T.S=U.S===void 0?!1:U.S,R&&(R=ae(R),T.i=R.buffer,T.m=R.C,T.l=0,T.j=T.i.length,T.h=T.l)}ce.prototype.reset=function(){this.h=this.l};function He(T,R){if(T.h=R,R>T.j)throw pt(T.j,R)}function Ze(T){var R=T.i,U=T.h,j=R[U++],de=j&127;if(j&128&&(j=R[U++],de|=(j&127)<<7,j&128&&(j=R[U++],de|=(j&127)<<14,j&128&&(j=R[U++],de|=(j&127)<<21,j&128&&(j=R[U++],de|=j<<28,j&128&&R[U++]&128&&R[U++]&128&&R[U++]&128&&R[U++]&128&&R[U++]&128)))))throw rt();return He(T,U),de}function dt(T,R){if(0>R)throw Error("Tried to read a negative byte length: "+R);var U=T.h,j=U+R;if(j>T.j)throw pt(R,T.j-U);return T.h=j,U}var Bt=[];function Ut(){this.h=[]}Ut.prototype.length=function(){return this.h.length},Ut.prototype.end=function(){var T=this.h;return this.h=[],T};function Tr(T,R,U){for(;0<U||127<R;)T.h.push(R&127|128),R=(R>>>7|U<<25)>>>0,U>>>=7;T.h.push(R)}function $(T,R){for(;127<R;)T.h.push(R&127|128),R>>>=7;T.h.push(R)}function B(T,R){if(Bt.length){var U=Bt.pop();ve(U,T,R),T=U}else T=new ce(T,R);this.h=T,this.j=this.h.h,this.i=this.l=-1,this.setOptions(R)}B.prototype.setOptions=function(T){T=T===void 0?{}:T,this.ca=T.ca===void 0?!1:T.ca},B.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function z(T){var R=T.h;if(R.h==R.j)return!1;T.j=T.h.h;var U=Ze(T.h)>>>0;if(R=U>>>3,U&=7,!(0<=U&&5>=U))throw nt(U,T.j);if(1>R)throw Error("Invalid field number: "+R+" (at position "+T.j+")");return T.l=R,T.i=U,!0}function W(T){switch(T.i){case 0:if(T.i!=0)W(T);else e:{T=T.h;for(var R=T.h,U=R+10,j=T.i;R<U;)if((j[R++]&128)===0){He(T,R);break e}throw rt()}break;case 1:T=T.h,He(T,T.h+8);break;case 2:T.i!=2?W(T):(R=Ze(T.h)>>>0,T=T.h,He(T,T.h+R));break;case 5:T=T.h,He(T,T.h+4);break;case 3:R=T.l;do{if(!z(T))throw Error("Unmatched start-group tag: stream EOF");if(T.i==4){if(T.l!=R)throw Error("Unmatched end-group tag");break}W(T)}while(!0);break;default:throw nt(T.i,T.j)}}var X=[];function ze(){this.j=[],this.i=0,this.h=new Ut}function Ge(T,R){R.length!==0&&(T.j.push(R),T.i+=R.length)}function Ye(T,R){if(R=R.R){Ge(T,T.h.end());for(var U=0;U<R.length;U++)Ge(T,H(R[U])||Ae())}}var Je=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function At(T,R){return Je?T[Je]|=R:T.A!==void 0?T.A|=R:(Object.defineProperties(T,{A:{value:R,configurable:!0,writable:!0,enumerable:!1}}),R)}function Er(T,R){Je?T[Je]&&(T[Je]&=~R):T.A!==void 0&&(T.A&=~R)}function br(T){var R;return Je?R=T[Je]:R=T.A,R??0}function Vn(T,R){Je?T[Je]=R:T.A!==void 0?T.A=R:Object.defineProperties(T,{A:{value:R,configurable:!0,writable:!0,enumerable:!1}})}function Ia(T){return At(T,1),T}function Tu(T,R){Vn(R,(T|0)&-51)}function Ur(T,R){Vn(R,(T|18)&-41)}var ka={};function Au(T){return T!==null&&typeof T=="object"&&!Array.isArray(T)&&T.constructor===Object}var Jc,Sf=[];Vn(Sf,23),Jc=Object.freeze(Sf);function K0(T){if(br(T.o)&2)throw Error("Cannot mutate an immutable Message")}function X0(T){var R=T.length;(R=R?T[R-1]:void 0)&&Au(R)?R.g=1:(R={},T.push((R.g=1,R)))}function Uv(T){var R=T.i+T.G;return T.B||(T.B=T.o[R]={})}function Ls(T,R){return R===-1?null:R>=T.i?T.B?T.B[R]:void 0:T.o[R+T.G]}function Na(T,R,U,j){K0(T),Qc(T,R,U,j)}function Qc(T,R,U,j){T.j&&(T.j=void 0),R>=T.i||j?Uv(T)[R]=U:(T.o[R+T.G]=U,(T=T.B)&&R in T&&delete T[R])}function Cf(T,R,U,j){var de=Ls(T,R);Array.isArray(de)||(de=Jc);var ge=br(de);if(ge&1||Ia(de),j)ge&2||At(de,2),U&1||Object.freeze(de);else{j=!(U&2);var fe=ge&2;U&1||!fe?j&&ge&16&&!fe&&Er(de,16):(de=Ia(Array.prototype.slice.call(de)),Qc(T,R,de))}return de}function Y0(T,R){var U=Ls(T,R),j=U==null?U:typeof U=="number"||U==="NaN"||U==="Infinity"||U==="-Infinity"?Number(U):void 0;return j!=null&&j!==U&&Qc(T,R,j),j}function _f(T,R,U,j,de){T.h||(T.h={});var ge=T.h[U],fe=Cf(T,U,3,de);if(!ge){var Ne=fe;ge=[];var je=!!(br(T.o)&16);fe=!!(br(Ne)&2);var st=Ne;!de&&fe&&(Ne=Array.prototype.slice.call(Ne));for(var yt=fe,Zt=0;Zt<Ne.length;Zt++){var Wt=Ne[Zt],It=R,Jt=!1;if(Jt=Jt===void 0?!1:Jt,Wt=Array.isArray(Wt)?new It(Wt):Jt?new It:void 0,Wt!==void 0){It=Wt.o;var xr=Jt=br(It);fe&&(xr|=2),je&&(xr|=16),xr!=Jt&&Vn(It,xr),It=xr,yt=yt||!!(2&It),ge.push(Wt)}}return T.h[U]=ge,je=br(Ne),R=je|33,R=yt?R&-9:R|8,je!=R&&(yt=Ne,Object.isFrozen(yt)&&(yt=Array.prototype.slice.call(yt)),Vn(yt,R),Ne=yt),st!==Ne&&Qc(T,U,Ne),(de||j&&fe)&&At(ge,2),j&&Object.freeze(ge),ge}return de||(de=Object.isFrozen(ge),j&&!de?Object.freeze(ge):!j&&de&&(ge=Array.prototype.slice.call(ge),T.h[U]=ge)),ge}function Z0(T,R,U){var j=!!(br(T.o)&2);if(R=_f(T,R,U,j,j),T=Cf(T,U,3,j),!(j||br(T)&8)){for(j=0;j<R.length;j++){if(U=R[j],br(U.o)&2){var de=ey(U,!1);de.j=U}else de=U;U!==de&&(R[j]=de,T[j]=de.o)}At(T,8)}return R}function Ta(T,R,U){if(U!=null&&typeof U!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof U+": "+U);Na(T,R,U)}function Wv(T,R,U,j,de){K0(T);var ge=_f(T,U,R,!1,!1);return U=j??new U,T=Cf(T,R,2,!1),de!=null?(ge.splice(de,0,U),T.splice(de,0,U.o)):(ge.push(U),T.push(U.o)),U.C()&&Er(T,8),U}function uo(T,R){return T??R}function Ri(T,R,U){return U=U===void 0?0:U,uo(Y0(T,R),U)}var Ef;function eE(T){switch(typeof T){case"number":return isFinite(T)?T:String(T);case"object":if(T)if(Array.isArray(T)){if((br(T)&128)!==0)return T=Array.prototype.slice.call(T),X0(T),T}else{if(le&&T!=null&&T instanceof Uint8Array)return xe(T);if(T instanceof Pr){var R=T.V;return R==null?"":typeof R=="string"?R:T.V=xe(R)}}}return T}function Gv(T,R,U,j){if(T!=null){if(Array.isArray(T))T=J0(T,R,U,j!==void 0);else if(Au(T)){var de={},ge;for(ge in T)de[ge]=Gv(T[ge],R,U,j);T=de}else T=R(T,j);return T}}function J0(T,R,U,j){var de=br(T);j=j?!!(de&16):void 0,T=Array.prototype.slice.call(T);for(var ge=0;ge<T.length;ge++)T[ge]=Gv(T[ge],R,U,j);return U(de,T),T}function Hv(T){return T.ja===ka?T.toJSON():eE(T)}function jv(T,R){T&128&&X0(R)}function qv(T,R,U){if(U=U===void 0?Ur:U,T!=null){if(le&&T instanceof Uint8Array)return T.length?new Pr(new Uint8Array(T),Te):V();if(Array.isArray(T)){var j=br(T);return j&2?T:R&&!(j&32)&&(j&16||j===0)?(Vn(T,j|2),T):(T=J0(T,qv,j&4?Ur:U,!0),R=br(T),R&4&&R&2&&Object.freeze(T),T)}return T.ja===ka?Q0(T):T}}function Kv(T,R,U,j,de,ge,fe){if(T=T.h&&T.h[U]){if(j=br(T),j&2?j=T:(ge=Y(T,Q0),Ur(j,ge),Object.freeze(ge),j=ge),K0(R),fe=j==null?Jc:Ia([]),j!=null){for(ge=!!j.length,T=0;T<j.length;T++){var Ne=j[T];ge=ge&&!(br(Ne.o)&2),fe[T]=Ne.o}ge=(ge?8:0)|1,T=br(fe),(T&ge)!==ge&&(Object.isFrozen(fe)&&(fe=Array.prototype.slice.call(fe)),Vn(fe,T|ge)),R.h||(R.h={}),R.h[U]=j}else R.h&&(R.h[U]=void 0);Qc(R,U,fe,de)}else Na(R,U,qv(j,ge,fe),de)}function Q0(T){return br(T.o)&2||(T=ey(T,!0),At(T.o,2)),T}function ey(T,R){var U=T.o,j=[];At(j,16);var de=T.constructor.h;if(de&&j.push(de),de=T.B,de){j.length=U.length,j.fill(void 0,j.length,U.length);var ge={};j[j.length-1]=ge}(br(U)&128)!==0&&X0(j),R=R||T.C()?Ur:Tu,ge=T.constructor,Ef=j,j=new ge(j),Ef=void 0,T.R&&(j.R=T.R.slice()),ge=!!(br(U)&16);for(var fe=de?U.length-1:U.length,Ne=0;Ne<fe;Ne++)Kv(T,j,Ne-T.G,U[Ne],!1,ge,R);if(de)for(var je in de)Kv(T,j,+je,de[je],!0,ge,R);return j}function Ks(T,R,U){T==null&&(T=Ef),Ef=void 0;var j=this.constructor.i||0,de=0<j,ge=this.constructor.h,fe=!1;if(T==null){T=ge?[ge]:[];var Ne=48,je=!0;de&&(j=0,Ne|=128),Vn(T,Ne)}else{if(!Array.isArray(T)||ge&&ge!==T[0])throw Error();var st=Ne=At(T,0);if((je=(16&st)!==0)&&((fe=(32&st)!==0)||(st|=32)),de){if(128&st)j=0;else if(0<T.length){var yt=T[T.length-1];if(Au(yt)&&"g"in yt){j=0,st|=128,delete yt.g;var Zt=!0,Wt;for(Wt in yt){Zt=!1;break}Zt&&T.pop()}}}else if(128&st)throw Error();Ne!==st&&Vn(T,st)}this.G=(ge?0:-1)-j,this.h=void 0,this.o=T;e:{if(ge=this.o.length,j=ge-1,ge&&(ge=this.o[j],Au(ge))){this.B=ge,this.i=j-this.G;break e}R!==void 0&&-1<R?(this.i=Math.max(R,j+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!de&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(U){R=je&&!fe&&!0,de=this.i;var It;for(je=0;je<U.length;je++)fe=U[je],fe<de?(fe+=this.G,(j=T[fe])?Xv(j,R):T[fe]=Jc):(It||(It=Uv(this)),(j=It[fe])?Xv(j,R):It[fe]=Jc)}}Ks.prototype.toJSON=function(){return J0(this.o,Hv,jv)},Ks.prototype.C=function(){return!!(br(this.o)&2)};function Xv(T,R){if(Array.isArray(T)){var U=br(T),j=1;!R||U&2||(j|=16),(U&j)!==j&&Vn(T,U|j)}}Ks.prototype.ja=ka,Ks.prototype.toString=function(){return this.o.toString()};function Yv(T,R,U){if(U){var j={},de;for(de in U){var ge=U[de],fe=ge.ra;fe||(j.J=ge.xa||ge.oa.W,ge.ia?(j.aa=ny(ge.ia),fe=function(Ne){return function(je,st,yt){return Ne.J(je,st,yt,Ne.aa)}}(j)):ge.ka?(j.Z=Nf(ge.da.P,ge.ka),fe=function(Ne){return function(je,st,yt){return Ne.J(je,st,yt,Ne.Z)}}(j)):fe=j.J,ge.ra=fe),fe(R,T,ge.da),j={J:j.J,aa:j.aa,Z:j.Z}}}Ye(R,T)}var If=Symbol();function ty(T,R,U){return T[If]||(T[If]=function(j,de){return R(j,de,U)})}function eh(T){var R=T[If];if(!R){var U=Yt(T);R=function(j,de){return tr(j,de,U)},T[If]=R}return R}function Zv(T){var R=T.ia;if(R)return eh(R);if(R=T.wa)return ty(T.da.P,R,T.ka)}function Jv(T){var R=Zv(T),U=T.da,j=T.oa.U;return R?function(de,ge){return j(de,ge,U,R)}:function(de,ge){return j(de,ge,U)}}function ry(T,R){var U=T[R];return typeof U=="function"&&U.length===0&&(U=U(),T[R]=U),Array.isArray(U)&&(rh in U||Wo in U||0<U.length&&typeof U[0]=="function")?U:void 0}function kf(T,R,U,j,de,ge){R.P=T[0];var fe=1;if(T.length>fe&&typeof T[fe]!="number"){var Ne=T[fe++];U(R,Ne)}for(;fe<T.length;){U=T[fe++];for(var je=fe+1;je<T.length&&typeof T[je]!="number";)je++;switch(Ne=T[fe++],je-=fe,je){case 0:j(R,U,Ne);break;case 1:(je=ry(T,fe))?(fe++,de(R,U,Ne,je)):j(R,U,Ne,T[fe++]);break;case 2:je=fe++,je=ry(T,je),de(R,U,Ne,je,T[fe++]);break;case 3:ge(R,U,Ne,T[fe++],T[fe++],T[fe++]);break;case 4:ge(R,U,Ne,T[fe++],T[fe++],T[fe++],T[fe++]);break;default:throw Error("unexpected number of binary field arguments: "+je)}}return R}var th=Symbol();function ny(T){var R=T[th];if(!R){var U=kl(T);R=function(j,de){return wt(j,de,U)},T[th]=R}return R}function Nf(T,R){var U=T[th];return U||(U=function(j,de){return Yv(j,de,R)},T[th]=U),U}var Wo=Symbol();function Tf(T,R){T.push(R)}function Af(T,R,U){T.push(R,U.W)}function Qv(T,R,U,j){var de=ny(j),ge=kl(j).P,fe=U.W;T.push(R,function(Ne,je,st){return fe(Ne,je,st,ge,de)})}function Df(T,R,U,j,de,ge){var fe=Nf(j,ge),Ne=U.W;T.push(R,function(je,st,yt){return Ne(je,st,yt,j,fe)})}function kl(T){var R=T[Wo];return R||(R=kf(T,T[Wo]=[],Tf,Af,Qv,Df),rh in T&&Wo in T&&(T.length=0),R)}var rh=Symbol();function me(T,R){T[0]=R}function Pe(T,R,U,j){var de=U.U;T[R]=j?function(ge,fe,Ne){return de(ge,fe,Ne,j)}:de}function ct(T,R,U,j,de){var ge=U.U,fe=eh(j),Ne=Yt(j).P;T[R]=function(je,st,yt){return ge(je,st,yt,Ne,fe,de)}}function Ht(T,R,U,j,de,ge,fe){var Ne=U.U,je=ty(j,de,ge);T[R]=function(st,yt,Zt){return Ne(st,yt,Zt,j,je,fe)}}function Yt(T){var R=T[rh];return R||(R=kf(T,T[rh]={},me,Pe,ct,Ht),rh in T&&Wo in T&&(T.length=0),R)}function tr(T,R,U){for(;z(R)&&R.i!=4;){var j=R.l,de=U[j];if(!de){var ge=U[0];ge&&(ge=ge[j])&&(de=U[j]=Jv(ge))}if(!de||!de(R,T,j)){de=R,j=T,ge=de.j,W(de);var fe=de;if(!fe.ca){if(de=fe.h.h-ge,fe.h.h=ge,fe=fe.h,de==0)de=V();else{if(ge=dt(fe,de),fe.S&&fe.m)de=fe.i.subarray(ge,ge+de);else{fe=fe.i;var Ne=ge;de=ge+de,de=Ne===de?Ae():Ue?fe.slice(Ne,de):new Uint8Array(fe.subarray(Ne,de))}de=de.length==0?V():new Pr(de,Te)}(ge=j.R)?ge.push(de):j.R=[de]}}}return T}function wt(T,R,U){for(var j=U.length,de=j%2==1,ge=de?1:0;ge<j;ge+=2)(0,U[ge+1])(R,T,U[ge]);Yv(T,R,de?U[0]:void 0)}function Ft(T,R){return{U:T,W:R}}var Ir=Ft(function(T,R,U){if(T.i!==5)return!1;T=T.h;var j=T.i,de=T.h,ge=j[de],fe=j[de+1],Ne=j[de+2];return j=j[de+3],He(T,T.h+4),fe=(ge<<0|fe<<8|Ne<<16|j<<24)>>>0,T=2*(fe>>31)+1,ge=fe>>>23&255,fe&=8388607,Na(R,U,ge==255?fe?NaN:1/0*T:ge==0?T*Math.pow(2,-149)*fe:T*Math.pow(2,ge-150)*(fe+Math.pow(2,23))),!0},function(T,R,U){if(R=Y0(R,U),R!=null){$(T.h,8*U+5),T=T.h;var j=+R;j===0?0<1/j?qe=Me=0:(Me=0,qe=2147483648):isNaN(j)?(Me=0,qe=2147483647):(j=(U=0>j?-2147483648:0)?-j:j,34028234663852886e22<j?(Me=0,qe=(U|2139095040)>>>0):11754943508222875e-54>j?(j=Math.round(j/Math.pow(2,-149)),Me=0,qe=(U|j)>>>0):(R=Math.floor(Math.log(j)/Math.LN2),j*=Math.pow(2,-R),j=Math.round(8388608*j),16777216<=j&&++R,Me=0,qe=(U|R+127<<23|j&8388607)>>>0)),U=qe,T.h.push(U>>>0&255),T.h.push(U>>>8&255),T.h.push(U>>>16&255),T.h.push(U>>>24&255)}}),gi=Ft(function(T,R,U){if(T.i!==0)return!1;var j=T.h,de=0,ge=T=0,fe=j.i,Ne=j.h;do{var je=fe[Ne++];de|=(je&127)<<ge,ge+=7}while(32>ge&&je&128);for(32<ge&&(T|=(je&127)>>4),ge=3;32>ge&&je&128;ge+=7)je=fe[Ne++],T|=(je&127)<<ge;if(He(j,Ne),128>je)j=de>>>0,je=T>>>0,(T=je&2147483648)&&(j=~j+1>>>0,je=~je>>>0,j==0&&(je=je+1>>>0)),j=4294967296*je+(j>>>0);else throw rt();return Na(R,U,T?-j:j),!0},function(T,R,U){R=Ls(R,U),R!=null&&(typeof R=="string"&&We(R),R!=null&&($(T.h,8*U),typeof R=="number"?(T=T.h,ie(R),Tr(T,qe,Me)):(U=We(R),Tr(T.h,U.i,U.h))))}),lo=Ft(function(T,R,U){return T.i!==0?!1:(Na(R,U,Ze(T.h)),!0)},function(T,R,U){if(R=Ls(R,U),R!=null&&R!=null)if($(T.h,8*U),T=T.h,U=R,0<=U)$(T,U);else{for(R=0;9>R;R++)T.h.push(U&127|128),U>>=7;T.h.push(1)}}),sy=Ft(function(T,R,U){if(T.i!==2)return!1;var j=Ze(T.h)>>>0;T=T.h;var de=dt(T,j);if(T=T.i,kt){var ge=T,fe;(fe=it)||(fe=it=new TextDecoder("utf-8",{fatal:!0})),T=de+j,ge=de===0&&T===ge.length?ge:ge.subarray(de,T);try{var Ne=fe.decode(ge)}catch(Zt){if(Mt===void 0){try{fe.decode(new Uint8Array([128]))}catch{}try{fe.decode(new Uint8Array([97])),Mt=!0}catch{Mt=!1}}throw!Mt&&(it=void 0),Zt}}else{Ne=de,j=Ne+j,de=[];for(var je=null,st,yt;Ne<j;)st=T[Ne++],128>st?de.push(st):224>st?Ne>=j?Et():(yt=T[Ne++],194>st||(yt&192)!==128?(Ne--,Et()):de.push((st&31)<<6|yt&63)):240>st?Ne>=j-1?Et():(yt=T[Ne++],(yt&192)!==128||st===224&&160>yt||st===237&&160<=yt||((ge=T[Ne++])&192)!==128?(Ne--,Et()):de.push((st&15)<<12|(yt&63)<<6|ge&63)):244>=st?Ne>=j-2?Et():(yt=T[Ne++],(yt&192)!==128||(st<<28)+(yt-144)>>30!==0||((ge=T[Ne++])&192)!==128||((fe=T[Ne++])&192)!==128?(Ne--,Et()):(st=(st&7)<<18|(yt&63)<<12|(ge&63)<<6|fe&63,st-=65536,de.push((st>>10&1023)+55296,(st&1023)+56320))):Et(),8192<=de.length&&(je=ht(je,de),de.length=0);Ne=ht(je,de)}return Na(R,U,Ne),!0},function(T,R,U){if(R=Ls(R,U),R!=null){var j=!1;if(j=j===void 0?!1:j,wn){if(j&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(R))throw Error("Found an unpaired surrogate");R=(Lt||(Lt=new TextEncoder)).encode(R)}else{for(var de=0,ge=new Uint8Array(3*R.length),fe=0;fe<R.length;fe++){var Ne=R.charCodeAt(fe);if(128>Ne)ge[de++]=Ne;else{if(2048>Ne)ge[de++]=Ne>>6|192;else{if(55296<=Ne&&57343>=Ne){if(56319>=Ne&&fe<R.length){var je=R.charCodeAt(++fe);if(56320<=je&&57343>=je){Ne=1024*(Ne-55296)+je-56320+65536,ge[de++]=Ne>>18|240,ge[de++]=Ne>>12&63|128,ge[de++]=Ne>>6&63|128,ge[de++]=Ne&63|128;continue}else fe--}if(j)throw Error("Found an unpaired surrogate");Ne=65533}ge[de++]=Ne>>12|224,ge[de++]=Ne>>6&63|128}ge[de++]=Ne&63|128}}R=de===ge.length?ge:ge.subarray(0,de)}$(T.h,8*U+2),$(T.h,R.length),Ge(T,T.h.end()),Ge(T,R)}}),Ff=Ft(function(T,R,U,j,de){if(T.i!==2)return!1;R=Wv(R,U,j),U=T.h.j,j=Ze(T.h)>>>0;var ge=T.h.h+j,fe=ge-U;if(0>=fe&&(T.h.j=ge,de(R,T,void 0,void 0,void 0),fe=ge-T.h.h),fe)throw Error("Message parsing ended unexpectedly. Expected to read "+(j+" bytes, instead read "+(j-fe)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return T.h.h=ge,T.h.j=U,!0},function(T,R,U,j,de){if(R=Z0(R,j,U),R!=null)for(j=0;j<R.length;j++){var ge=T;$(ge.h,8*U+2);var fe=ge.h.end();Ge(ge,fe),fe.push(ge.i),ge=fe,de(R[j],T),fe=T;var Ne=ge.pop();for(Ne=fe.i+fe.h.length()-Ne;127<Ne;)ge.push(Ne&127|128),Ne>>>=7,fe.i++;ge.push(Ne),fe.i++}});function iy(T){return function(R,U){e:{if(X.length){var j=X.pop();j.setOptions(U),ve(j.h,R,U),R=j}else R=new B(R,U);try{var de=Yt(T),ge=tr(new de.P,R,de);break e}finally{de=R.h,de.i=null,de.m=!1,de.l=0,de.j=0,de.h=0,de.S=!1,R.l=-1,R.i=-1,100>X.length&&X.push(R)}ge=void 0}return ge}}function Ps(T){return function(){var R=new ze;wt(this,R,kl(T)),Ge(R,R.h.end());for(var U=new Uint8Array(R.i),j=R.j,de=j.length,ge=0,fe=0;fe<de;fe++){var Ne=j[fe];U.set(Ne,ge),ge+=Ne.length}return R.j=[U],U}}function la(T){Ks.call(this,T)}y(la,Ks);var ay=[la,1,lo,2,Ir,3,sy,4,sy];la.prototype.l=Ps(ay);function tE(T){Ks.call(this,T,-1,Dne)}y(tE,Ks),tE.prototype.addClassification=function(T,R){return Wv(this,1,la,T,R),this};var Dne=[1],Fne=iy([tE,1,Ff,ay]);function oy(T){Ks.call(this,T)}y(oy,Ks);var QL=[oy,1,Ir,2,Ir,3,Ir,4,Ir,5,Ir];oy.prototype.l=Ps(QL);function eP(T){Ks.call(this,T,-1,$ne)}y(eP,Ks);var $ne=[1],Rne=iy([eP,1,Ff,QL]);function e1(T){Ks.call(this,T)}y(e1,Ks);var tP=[e1,1,Ir,2,Ir,3,Ir,4,Ir,5,Ir,6,gi],One=iy(tP);e1.prototype.l=Ps(tP);function rP(T,R,U){if(U=T.createShader(U===0?T.VERTEX_SHADER:T.FRAGMENT_SHADER),T.shaderSource(U,R),T.compileShader(U),!T.getShaderParameter(U,T.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+T.getShaderInfoLog(U));return U}function Mne(T){return Z0(T,la,1).map(function(R){var U=Ls(R,1);return{index:U??0,qa:Ri(R,2),label:Ls(R,3)!=null?uo(Ls(R,3),""):void 0,displayName:Ls(R,4)!=null?uo(Ls(R,4),""):void 0}})}function Lne(T){return{x:Ri(T,1),y:Ri(T,2),z:Ri(T,3),visibility:Y0(T,4)!=null?Ri(T,4):void 0}}function rE(T,R){this.i=T,this.h=R,this.m=0}function nP(T,R,U){return Pne(T,R),typeof T.h.canvas.transferToImageBitmap=="function"?Promise.resolve(T.h.canvas.transferToImageBitmap()):U?Promise.resolve(T.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(T.h.canvas):(T.j===void 0&&(T.j=document.createElement("canvas")),new Promise(function(j){T.j.height=T.h.canvas.height,T.j.width=T.h.canvas.width,T.j.getContext("2d",{}).drawImage(T.h.canvas,0,0,T.h.canvas.width,T.h.canvas.height),j(T.j)}))}function Pne(T,R){var U=T.h;if(T.s===void 0){var j=rP(U,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),de=rP(U,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),ge=U.createProgram();if(U.attachShader(ge,j),U.attachShader(ge,de),U.linkProgram(ge),!U.getProgramParameter(ge,U.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+U.getProgramInfoLog(ge));j=T.s=ge,U.useProgram(j),de=U.getUniformLocation(j,"sampler0"),T.l={O:U.getAttribLocation(j,"aVertex"),N:U.getAttribLocation(j,"aTex"),ya:de},T.v=U.createBuffer(),U.bindBuffer(U.ARRAY_BUFFER,T.v),U.enableVertexAttribArray(T.l.O),U.vertexAttribPointer(T.l.O,2,U.FLOAT,!1,0,0),U.bufferData(U.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),U.STATIC_DRAW),U.bindBuffer(U.ARRAY_BUFFER,null),T.u=U.createBuffer(),U.bindBuffer(U.ARRAY_BUFFER,T.u),U.enableVertexAttribArray(T.l.N),U.vertexAttribPointer(T.l.N,2,U.FLOAT,!1,0,0),U.bufferData(U.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),U.STATIC_DRAW),U.bindBuffer(U.ARRAY_BUFFER,null),U.uniform1i(de,0)}j=T.l,U.useProgram(T.s),U.canvas.width=R.width,U.canvas.height=R.height,U.viewport(0,0,R.width,R.height),U.activeTexture(U.TEXTURE0),T.i.bindTexture2d(R.glName),U.enableVertexAttribArray(j.O),U.bindBuffer(U.ARRAY_BUFFER,T.v),U.vertexAttribPointer(j.O,2,U.FLOAT,!1,0,0),U.enableVertexAttribArray(j.N),U.bindBuffer(U.ARRAY_BUFFER,T.u),U.vertexAttribPointer(j.N,2,U.FLOAT,!1,0,0),U.bindFramebuffer(U.DRAW_FRAMEBUFFER?U.DRAW_FRAMEBUFFER:U.FRAMEBUFFER,null),U.clearColor(0,0,0,0),U.clear(U.COLOR_BUFFER_BIT),U.colorMask(!0,!0,!0,!0),U.drawArrays(U.TRIANGLE_FAN,0,4),U.disableVertexAttribArray(j.O),U.disableVertexAttribArray(j.N),U.bindBuffer(U.ARRAY_BUFFER,null),T.i.bindTexture2d(0)}function Bne(T){this.h=T}var Vne=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function zne(T,R){return R+T}function sP(T,R){window[T]=R}function Une(T){var R=document.createElement("script");return R.setAttribute("src",T),R.setAttribute("crossorigin","anonymous"),new Promise(function(U){R.addEventListener("load",function(){U()},!1),R.addEventListener("error",function(){U()},!1),document.body.appendChild(R)})}function Wne(){return k(function(T){switch(T.h){case 1:return T.s=2,v(T,WebAssembly.instantiate(Vne),4);case 4:T.h=3,T.s=0;break;case 2:return T.s=0,T.l=null,T.return(!1);case 3:return T.return(!0)}})}function nE(T){if(this.h=T,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=T&&T.locateFile||zne,typeof window=="object")var R=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")R=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=R,T.options){R=u(Object.keys(T.options));for(var U=R.next();!U.done;U=R.next()){U=U.value;var j=T.options[U].default;j!==void 0&&(this.l[U]=typeof j=="function"?j():j)}}}r=nE.prototype,r.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function Gne(T){var R,U,j,de,ge,fe,Ne,je,st,yt,Zt;return k(function(Wt){switch(Wt.h){case 1:return T.ga?(R=T.h.files===void 0?[]:typeof T.h.files=="function"?T.h.files(T.l):T.h.files,v(Wt,Wne(),2)):Wt.return();case 2:if(U=Wt.i,typeof window=="object")return sP("createMediapipeSolutionsWasm",{locateFile:T.locateFile}),sP("createMediapipeSolutionsPackedAssets",{locateFile:T.locateFile}),fe=R.filter(function(It){return It.data!==void 0}),Ne=R.filter(function(It){return It.data===void 0}),je=Promise.all(fe.map(function(It){var Jt=t1(T,It.url);if(It.path!==void 0){var xr=It.path;Jt=Jt.then(function(In){return T.overrideFile(xr,In),Promise.resolve(In)})}return Jt})),st=Promise.all(Ne.map(function(It){return It.simd===void 0||It.simd&&U||!It.simd&&!U?Une(T.locateFile(It.url,T.ha)):Promise.resolve()})).then(function(){var It,Jt,xr;return k(function(In){if(In.h==1)return It=window.createMediapipeSolutionsWasm,Jt=window.createMediapipeSolutionsPackedAssets,xr=T,v(In,It(Jt),2);xr.i=In.i,In.h=0})}),yt=function(){return k(function(It){return T.h.graph&&T.h.graph.url?It=v(It,t1(T,T.h.graph.url),0):(It.h=0,It=void 0),It})}(),v(Wt,Promise.all([st,je,yt]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return j=R.filter(function(It){return It.simd===void 0||It.simd&&U||!It.simd&&!U}).map(function(It){return T.locateFile(It.url,T.ha)}),importScripts.apply(null,l(j)),de=T,v(Wt,createMediapipeSolutionsWasm(Module),6);case 6:de.i=Wt.i,T.m=new OffscreenCanvas(1,1),T.i.canvas=T.m,ge=T.i.GL.createContext(T.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),T.i.GL.makeContextCurrent(ge),Wt.h=4;break;case 7:if(T.m=document.createElement("canvas"),Zt=T.m.getContext("webgl2",{}),!Zt&&(Zt=T.m.getContext("webgl",{}),!Zt))return alert("Failed to create WebGL canvas context when passing video frame."),Wt.return();T.K=Zt,T.i.canvas=T.m,T.i.createContext(T.m,!0,!0,{});case 4:T.j=new T.i.SolutionWasm,T.ga=!1,Wt.h=0}})}function Hne(T){var R,U,j,de,ge,fe,Ne,je;return k(function(st){if(st.h==1){if(T.h.graph&&T.h.graph.url&&T.fa===T.h.graph.url)return st.return();if(T.u=!0,!T.h.graph||!T.h.graph.url){st.h=2;return}return T.fa=T.h.graph.url,v(st,t1(T,T.h.graph.url),3)}for(st.h!=2&&(R=st.i,T.j.loadGraph(R)),U=u(Object.keys(T.D)),j=U.next();!j.done;j=U.next())de=j.value,T.j.overrideFile(de,T.D[de]);if(T.D={},T.h.listeners)for(ge=u(T.h.listeners),fe=ge.next();!fe.done;fe=ge.next())Ne=fe.value,Xne(T,Ne);je=T.l,T.l={},T.setOptions(je),st.h=0})}r.reset=function(){var T=this;return k(function(R){T.j&&(T.j.reset(),T.s={},T.v={}),R.h=0})},r.setOptions=function(T,R){var U=this;if(R=R||this.h.options){for(var j=[],de=[],ge={},fe=u(Object.keys(T)),Ne=fe.next();!Ne.done;ge={X:ge.X,Y:ge.Y},Ne=fe.next())if(Ne=Ne.value,!(Ne in this.l&&this.l[Ne]===T[Ne])){this.l[Ne]=T[Ne];var je=R[Ne];je!==void 0&&(je.onChange&&(ge.X=je.onChange,ge.Y=T[Ne],j.push(function(st){return function(){var yt;return k(function(Zt){if(Zt.h==1)return v(Zt,st.X(st.Y),2);yt=Zt.i,yt===!0&&(U.u=!0),Zt.h=0})}}(ge))),je.graphOptionXref&&(Ne=Object.assign({},{calculatorName:"",calculatorIndex:0},je.graphOptionXref,{valueNumber:je.type===1?T[Ne]:0,valueBoolean:je.type===0?T[Ne]:!1,valueString:je.type===2?T[Ne]:""}),de.push(Ne)))}(j.length!==0||de.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(de),this.F=(this.F===void 0?[]:this.F).concat(j))}};function jne(T){var R,U,j,de,ge,fe,Ne;return k(function(je){switch(je.h){case 1:if(!T.u)return je.return();if(!T.F){je.h=2;break}R=u(T.F),U=R.next();case 3:if(U.done){je.h=5;break}return j=U.value,v(je,j(),4);case 4:U=R.next(),je.h=3;break;case 5:T.F=void 0;case 2:if(T.H){for(de=new T.i.GraphOptionChangeRequestList,ge=u(T.H),fe=ge.next();!fe.done;fe=ge.next())Ne=fe.value,de.push_back(Ne);T.j.changeOptions(de),de.delete(),T.H=void 0}T.u=!1,je.h=0}})}r.initialize=function(){var T=this;return k(function(R){return R.h==1?v(R,Gne(T),2):R.h!=3?v(R,Hne(T),3):v(R,jne(T),0)})};function t1(T,R){var U,j;return k(function(de){return R in T.L?de.return(T.L[R]):(U=T.locateFile(R,""),j=fetch(U).then(function(ge){return ge.arrayBuffer()}),T.L[R]=j,de.return(j))})}r.overrideFile=function(T,R){this.j?this.j.overrideFile(T,R):this.D[T]=R},r.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},r.send=function(T,R){var U=this,j,de,ge,fe,Ne,je,st,yt,Zt;return k(function(Wt){switch(Wt.h){case 1:return U.h.inputs?(j=1e3*(R??performance.now()),v(Wt,U.I,2)):Wt.return();case 2:return v(Wt,U.initialize(),3);case 3:for(de=new U.i.PacketDataList,ge=u(Object.keys(T)),fe=ge.next();!fe.done;fe=ge.next())if(Ne=fe.value,je=U.h.inputs[Ne]){e:{var It=T[Ne];switch(je.type){case"video":var Jt=U.s[je.stream];if(Jt||(Jt=new rE(U.i,U.K),U.s[je.stream]=Jt),Jt.m===0&&(Jt.m=Jt.i.createTexture()),typeof HTMLVideoElement<"u"&&It instanceof HTMLVideoElement)var xr=It.videoWidth,In=It.videoHeight;else typeof HTMLImageElement<"u"&&It instanceof HTMLImageElement?(xr=It.naturalWidth,In=It.naturalHeight):(xr=It.width,In=It.height);In={glName:Jt.m,width:xr,height:In},xr=Jt.h,xr.canvas.width=In.width,xr.canvas.height=In.height,xr.activeTexture(xr.TEXTURE0),Jt.i.bindTexture2d(Jt.m),xr.texImage2D(xr.TEXTURE_2D,0,xr.RGBA,xr.RGBA,xr.UNSIGNED_BYTE,It),Jt.i.bindTexture2d(0),Jt=In;break e;case"detections":for(Jt=U.s[je.stream],Jt||(Jt=new Bne(U.i),U.s[je.stream]=Jt),Jt.data||(Jt.data=new Jt.h.DetectionListData),Jt.data.reset(It.length),In=0;In<It.length;++In){xr=It[In];var Sn=Jt.data,Bs=Sn.setBoundingBox,Aa=In,Oi=xr.la,Wr=new e1;if(Ta(Wr,1,Oi.sa),Ta(Wr,2,Oi.ta),Ta(Wr,3,Oi.height),Ta(Wr,4,Oi.width),Ta(Wr,5,Oi.rotation),Na(Wr,6,Oi.pa),Oi=Wr.l(),Bs.call(Sn,Aa,Oi),xr.ea)for(Sn=0;Sn<xr.ea.length;++Sn){Wr=xr.ea[Sn],Bs=Jt.data,Aa=Bs.addNormalizedLandmark,Oi=In,Wr=Object.assign({},Wr,{visibility:Wr.visibility?Wr.visibility:0});var Vs=new oy;Ta(Vs,1,Wr.x),Ta(Vs,2,Wr.y),Ta(Vs,3,Wr.z),Wr.visibility&&Ta(Vs,4,Wr.visibility),Wr=Vs.l(),Aa.call(Bs,Oi,Wr)}if(xr.ba)for(Sn=0;Sn<xr.ba.length;++Sn)Bs=Jt.data,Aa=Bs.addClassification,Oi=In,Wr=xr.ba[Sn],Vs=new la,Ta(Vs,2,Wr.qa),Wr.index&&Na(Vs,1,Wr.index),Wr.label&&Na(Vs,3,Wr.label),Wr.displayName&&Na(Vs,4,Wr.displayName),Wr=Vs.l(),Aa.call(Bs,Oi,Wr)}Jt=Jt.data;break e;default:Jt={}}}switch(st=Jt,yt=je.stream,je.type){case"video":de.pushTexture2d(Object.assign({},st,{stream:yt,timestamp:j}));break;case"detections":Zt=st,Zt.stream=yt,Zt.timestamp=j,de.pushDetectionList(Zt);break;default:throw Error("Unknown input config type: '"+je.type+"'")}}return U.j.send(de),v(Wt,U.I,4);case 4:de.delete(),Wt.h=0}})};function qne(T,R,U){var j,de,ge,fe,Ne,je,st,yt,Zt,Wt,It,Jt,xr,In;return k(function(Sn){switch(Sn.h){case 1:if(!U)return Sn.return(R);for(j={},de=0,ge=u(Object.keys(U)),fe=ge.next();!fe.done;fe=ge.next())Ne=fe.value,je=U[Ne],typeof je!="string"&&je.type==="texture"&&R[je.stream]!==void 0&&++de;1<de&&(T.M=!1),st=u(Object.keys(U)),fe=st.next();case 2:if(fe.done){Sn.h=4;break}if(yt=fe.value,Zt=U[yt],typeof Zt=="string")return xr=j,In=yt,v(Sn,Kne(T,yt,R[Zt]),14);if(Wt=R[Zt.stream],Zt.type==="detection_list"){if(Wt){for(var Bs=Wt.getRectList(),Aa=Wt.getLandmarksList(),Oi=Wt.getClassificationsList(),Wr=[],Vs=0;Vs<Bs.size();++Vs){var Nl=One(Bs.get(Vs)),Yne=Ri(Nl,1),Zne=Ri(Nl,2),Jne=Ri(Nl,3),Qne=Ri(Nl,4),ese=Ri(Nl,5,0),r1=void 0;r1=r1===void 0?0:r1,Nl={la:{sa:Yne,ta:Zne,height:Jne,width:Qne,rotation:ese,pa:uo(Ls(Nl,6),r1)},ea:Z0(Rne(Aa.get(Vs)),oy,1).map(Lne),ba:Mne(Fne(Oi.get(Vs)))},Wr.push(Nl)}Bs=Wr}else Bs=[];j[yt]=Bs,Sn.h=7;break}if(Zt.type==="proto_list"){if(Wt){for(Bs=Array(Wt.size()),Aa=0;Aa<Wt.size();Aa++)Bs[Aa]=Wt.get(Aa);Wt.delete()}else Bs=[];j[yt]=Bs,Sn.h=7;break}if(Wt===void 0){Sn.h=3;break}if(Zt.type==="float_list"){j[yt]=Wt,Sn.h=7;break}if(Zt.type==="proto"){j[yt]=Wt,Sn.h=7;break}if(Zt.type!=="texture")throw Error("Unknown output config type: '"+Zt.type+"'");return It=T.v[yt],It||(It=new rE(T.i,T.K),T.v[yt]=It),v(Sn,nP(It,Wt,T.M),13);case 13:Jt=Sn.i,j[yt]=Jt;case 7:Zt.transform&&j[yt]&&(j[yt]=Zt.transform(j[yt])),Sn.h=3;break;case 14:xr[In]=Sn.i;case 3:fe=st.next(),Sn.h=2;break;case 4:return Sn.return(j)}})}function Kne(T,R,U){var j;return k(function(de){return typeof U=="number"||U instanceof Uint8Array||U instanceof T.i.Uint8BlobList?de.return(U):U instanceof T.i.Texture2dDataOut?(j=T.v[R],j||(j=new rE(T.i,T.K),T.v[R]=j),de.return(nP(j,U,T.M))):de.return(void 0)})}function Xne(T,R){for(var U=R.name||"$",j=[].concat(l(R.wants)),de=new T.i.StringList,ge=u(R.wants),fe=ge.next();!fe.done;fe=ge.next())de.push_back(fe.value);ge=T.i.PacketListener.implement({onResults:function(Ne){for(var je={},st=0;st<R.wants.length;++st)je[j[st]]=Ne.get(st);var yt=T.listeners[U];yt&&(T.I=qne(T,je,R.outs).then(function(Zt){Zt=yt(Zt);for(var Wt=0;Wt<R.wants.length;++Wt){var It=je[j[Wt]];typeof It=="object"&&It.hasOwnProperty&&It.hasOwnProperty("delete")&&It.delete()}Zt&&(T.I=Zt)}))}}),T.j.attachMultiListener(de,ge),de.delete()}r.onResults=function(T,R){this.listeners[R||"$"]=T},P("Solution",nE),P("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function iP(T){switch(T===void 0&&(T=0),T){case 1:return"selfie_segmentation_landscape.tflite";default:return"selfie_segmentation.tflite"}}function aP(T){var R=this;T=T||{},this.h=new nE({locateFile:T.locateFile,files:function(U){return[{simd:!0,url:"selfie_segmentation_solution_simd_wasm_bin.js"},{simd:!1,url:"selfie_segmentation_solution_wasm_bin.js"},{data:!0,url:iP(U.modelSelection)}]},graph:{url:"selfie_segmentation.binarypb"},listeners:[{wants:["segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelSelection:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelSelection",fieldName:"int_value"},onChange:function(U){var j,de,ge;return k(function(fe){return fe.h==1?(j=iP(U),de="third_party/mediapipe/modules/selfie_segmentation/"+j,v(fe,t1(R.h,j),2)):(ge=fe.i,R.h.overrideFile(de,ge),fe.return(!0))})}}}})}r=aP.prototype,r.close=function(){return this.h.close(),Promise.resolve()},r.onResults=function(T){this.h.onResults(T)},r.initialize=function(){var T=this;return k(function(R){return v(R,T.h.initialize(),0)})},r.reset=function(){this.h.reset()},r.send=function(T){var R=this;return k(function(U){return v(U,R.h.send(T),0)})},r.setOptions=function(T){this.h.setOptions(T)},P("SelfieSegmentation",aP),P("VERSION","0.1.1675465747")}).call(vI)),vI}var Dft=Aft();/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var rT=function(r,t){return rT=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,s){n.__proto__=s}||function(n,s){for(var i in s)s.hasOwnProperty(i)&&(n[i]=s[i])},rT(r,t)};function mne(r,t){function n(){this.constructor=r}rT(r,t),r.prototype=t===null?Object.create(t):(n.prototype=t.prototype,new n)}var Ys=function(){return Ys=Object.assign||function(r){for(var t,n=1,s=arguments.length;n<s;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(r[i]=t[i]);return r},Ys.apply(this,arguments)};function nn(r,t,n,s){return new(n||(n=Promise))(function(i,a){function o(c){try{l(s.next(c))}catch(h){a(h)}}function u(c){try{l(s.throw(c))}catch(h){a(h)}}function l(c){var h;c.done?i(c.value):(h=c.value,h instanceof n?h:new n(function(d){d(h)})).then(o,u)}l((s=s.apply(r,[])).next())})}function sn(r,t){var n,s,i,a,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return a={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function u(l){return function(c){return function(h){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,s&&(i=2&h[0]?s.return:h[0]?s.throw||((i=s.return)&&i.call(s),0):s.next)&&!(i=i.call(s,h[1])).done)return i;switch(s=0,i&&(h=[2&h[0],i.value]),h[0]){case 0:case 1:i=h;break;case 4:return o.label++,{value:h[1],done:!1};case 5:o.label++,s=h[1],h=[0];continue;case 7:h=o.ops.pop(),o.trys.pop();continue;default:if(i=o.trys,!((i=i.length>0&&i[i.length-1])||h[0]!==6&&h[0]!==2)){o=0;continue}if(h[0]===3&&(!i||h[1]>i[0]&&h[1]<i[3])){o.label=h[1];break}if(h[0]===6&&o.label<i[1]){o.label=i[1],i=h;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(h);break}i[2]&&o.ops.pop(),o.trys.pop();continue}h=t.call(r,o)}catch(d){h=[6,d],s=0}finally{n=i=0}if(5&h[0])throw h[1];return{value:h[0]?h[1]:void 0,done:!0}}([l,c])}}}function hS(r){return r instanceof SVGAnimatedLength?r.baseVal.value:r}function YL(r){return nn(this,void 0,void 0,function(){var t,n;return sn(this,function(s){switch(s.label){case 0:return t=document.createElement("canvas"),r instanceof Xr?[4,fC(r,t)]:[3,2];case 1:return s.sent(),[3,3];case 2:t.width=hS(r.width),t.height=hS(r.height),n=t.getContext("2d"),r instanceof ImageData?n.putImageData(r,0,0):n.drawImage(r,0,0),s.label=3;case 3:return[2,t]}})})}function gne(r){return nn(this,void 0,void 0,function(){var t,n,s,i,a,o;return sn(this,function(u){switch(u.label){case 0:return r instanceof Xr?(t=r.shape.slice(0,2),n=t[0],s=t[1],i=ImageData.bind,[4,fC(r)]):[3,2];case 1:return[2,new(i.apply(ImageData,[void 0,u.sent(),s,n]))];case 2:return a=document.createElement("canvas"),o=a.getContext("2d"),a.width=hS(r.width),a.height=hS(r.height),o.drawImage(r,0,0),[2,o.getImageData(0,0,a.width,a.height)]}})})}function yne(r){return nn(this,void 0,void 0,function(){var t,n;return sn(this,function(s){switch(s.label){case 0:return r instanceof SVGImageElement||r instanceof OffscreenCanvas?[4,YL(r)]:[3,2];case 1:return n=s.sent(),[3,3];case 2:n=r,s.label=3;case 3:return t=n,[2,mC(t,4)]}})})}function J_(r){if(r<0||r>=256)throw new Error("Mask value must be in range [0, 255] but got "+r);if(!Number.isInteger(r))throw new Error("Mask value must be an integer but got "+r)}function bne(r){var t=r.shape[2],n=d$(r,2),s=Qe(n,[-1]);return Lb(s,t)}function q1(r,t){return qt(function(){return Or(fg(r,mr(t)),"int32")})}function Fft(r,t){var n=t.shape,s=n[0],i=n[1],a=n[2];return qt(function(){var o=bne(t),u=vi(pc(0,a,1,"int32"),1),l=Or(Vr(o,u),"int32"),c=Qe(l,[s,i]),h=jt(c,mr(1,"int32"));return hr(function(d,p){return xt(d,p)}(h,r),mr(1,"int32"))})}var xne=function(){function r(t,n){this.model=t,this.outputStride=n;var s=this.model.inputs[0].shape;oe(s[1]===-1&&s[2]===-1,function(){return"Input shape ["+s[1]+", "+s[2]+"] must both be equal to or -1"})}return r.prototype.predict=function(t){var n=this;return qt(function(){var s=n.preprocessInput(Or(t,"float32")),i=vi(s,0),a=n.model.predict(i).map(function(u){return Ga(u,[0])}),o=n.nameOutputResults(a);return{heatmapScores:iu(o.heatmap),offsets:o.offsets,displacementFwd:o.displacementFwd,displacementBwd:o.displacementBwd,segmentation:o.segmentation,partHeatmaps:o.partHeatmaps,longOffsets:o.longOffsets,partOffsets:o.partOffsets}})},r.prototype.dispose=function(){this.model.dispose()},r}(),$ft=function(r){function t(){return r!==null&&r.apply(this,arguments)||this}return mne(t,r),t.prototype.preprocessInput=function(n){return qt(function(){return hr(hn(n,127.5),1)})},t.prototype.nameOutputResults=function(n){return{offsets:n[0],segmentation:n[1],partHeatmaps:n[2],longOffsets:n[3],heatmap:n[4],displacementFwd:n[5],displacementBwd:n[6],partOffsets:n[7]}},t}(xne),Q_=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],wo=Q_.length,dS=Q_.reduce(function(r,t,n){return r[t]=n,r},{});[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]].map(function(r){var t=r[0],n=r[1];return[dS[t],dS[n]]});function ZL(r,t,n){var s=r[0],i=r[1],a=t[0],o=t[1],u=n.top,l=n.bottom;return[o/(n.left+n.right+i),a/(u+l+s)]}function vne(r,t,n,s){return{y:s.get(r,t,n),x:s.get(r,t,n+wo)}}function wne(r,t,n){var s=vne(r.heatmapY,r.heatmapX,r.id,n),i=s.y,a=s.x;return{x:r.heatmapX*t+a,y:r.heatmapY*t+i}}function _z(r,t,n){return r<t?t:r>n?n:r}function Ez(r,t){return{x:r.x+t.x,y:r.y+t.y}}function Rft(r,t,n){n===void 0&&(n=.3);for(var s=0,i=0,a=0;a<r.length;a++)t.keypoints[a].score>n&&(i+=1,s+=Math.pow(r[a].x-t.keypoints[a].position.x,2)+Math.pow(r[a].y-t.keypoints[a].position.y,2));return i===0?s=1/0:s/=i,s}function Oft(r,t,n,s,i,a,o){for(var u=o[0],l=o[1],c=n(r),h=c.y*s+c.x,d=i[wo*(2*h)+t],p=i[wo*(2*h+1)+t],f=r.y+d,m=r.x+p,g=0;g<a;g++){f=Math.min(f,u-1);var y=n({x:m=Math.min(m,l-1),y:f}),b=y.y*s+y.x;f+=d=i[wo*(2*b)+t],m+=p=i[wo*(2*b+1)+t]}return{x:m,y:f}}function Sne(r,t,n,s,i,a,o,u,l,c){for(var h=i[0],d=i[1],p=a[0],f=a[1],m=u[0],g=u[1],y=[],b=function(I){return function(_,A,k,N){var D=A[0],F=A[1],P=k[0],G=k[1],Y=Math.round(((D+_.y+1)*G-1)/N);return{x:Math.round(((F+_.x+1)*P-1)/N),y:Y}}(I,[h,d],[p,f],l)},x=0;x<s;x++){var w=Oft(r,x,b,o,t,c,[m,g]);y.push(w)}for(var v=-1,S=1/0,E=0;E<n.length;E++){var C=Rft(y,n[E]);C<S&&(v=E,S=C)}return v}function Cne(r,t){var n=r[0],s=r[1];return[Math.round((s-1)/t+1),Math.round((n-1)/t+1)]}function _ne(r,t,n,s,i,a,o,u,l,c,h){for(var d=o[0],p=o[1],f=r.shape,m=f[0],g=f[1],y=t.shape.slice(0,2),b=y[0],x=y[1],w=Qe(t,[b,x,2,wo]),v=new Float32Array(h*wo*3).fill(0),S=0;S<n.length;S++)for(var E=S*wo*3,C=n[S],I=0;I<wo;I++){var _=C.keypoints[I],A=E+3*I;v[A]=_.score,v[A+1]=_.position.y,v[A+2]=_.position.x}var k=ZL([s,i],[d,p],u),N=k[0],D=k[1],F=qa(v,[h,wo,3]),P=u.top,G=u.left,Y={variableNames:["segmentation","longOffsets","poses"],outputShape:[m,g],userCode:`
    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {
      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));
    }

    float convertToPositionInOutputFloat(
        int pos, int pad, float scale, int stride) {
      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);
    }

    float dist(float x1, float y1, float x2, float y2) {
      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);
    }

    float sampleLongOffsets(float h, float w, int d, int k) {
      float fh = fract(h);
      float fw = fract(w);
      int clH = int(ceil(h));
      int clW = int(ceil(w));
      int flH = int(floor(h));
      int flW = int(floor(w));
      float o11 = getLongOffsets(flH, flW, d, k);
      float o12 = getLongOffsets(flH, clW, d, k);
      float o21 = getLongOffsets(clH, flW, d, k);
      float o22 = getLongOffsets(clH, clW, d, k);
      float o1 = mix(o11, o12, fw);
      float o2 = mix(o21, o22, fw);
      return mix(o1, o2, fh);
    }

    int findNearestPose(int h, int w) {
      float prob = getSegmentation(h, w);
      if (prob < 1.0) {
        return -1;
      }

      // Done(Tyler): convert from output space h/w to strided space.
      float stridedH = convertToPositionInOutputFloat(
        h, `+P+", "+D+", "+a+`);
      float stridedW = convertToPositionInOutputFloat(
        w, `+G+", "+N+", "+a+`);

      float minDist = 1000000.0;
      int iMin = -1;
      for (int i = 0; i < `+h+`; i++) {
        float curDistSum = 0.0;
        int numKpt = 0;
        for (int k = 0; k < `+wo+`; k++) {
          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);
          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);

          float y = float(h) + dy;
          float x = float(w) + dx;

          for (int s = 0; s < `+l+`; s++) {
            int yRounded = round(min(y, float(`+(s-1)+`)));
            int xRounded = round(min(x, float(`+(i-1)+`)));

            float yStrided = convertToPositionInOutputFloat(
              yRounded, `+P+", "+D+", "+a+`);
            float xStrided = convertToPositionInOutputFloat(
              xRounded, `+G+", "+N+", "+a+`);

            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);
            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);

            y = y + dy;
            x = x + dx;
          }

          float poseScore = getPoses(i, k, 0);
          float poseY = getPoses(i, k, 1);
          float poseX = getPoses(i, k, 2);
          if (poseScore > `+c+`) {
            numKpt = numKpt + 1;
            curDistSum = curDistSum + dist(x, y, poseX, poseY);
          }
        }
        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {
          minDist = curDistSum / float(numKpt);
          iMin = i;
        }
      }
      return iMin;
    }

    void main() {
        ivec2 coords = getOutputCoords();
        int nearestPose = findNearestPose(coords[0], coords[1]);
        setOutput(float(nearestPose));
      }
  `};return o$().compileAndRun(Y,[r,w,F])}function Ene(){return a$()==="webgl"}function Mft(r,t,n,s,i,a,o,u,l,c,h,d){var p=o[0],f=o[1];return l===void 0&&(l=.2),c===void 0&&(c=8),h===void 0&&(h=.3),d===void 0&&(d=10),nn(this,void 0,void 0,function(){var m,g,y,b,x;return sn(this,function(w){switch(w.label){case 0:return m=n.filter(function(v){return v.score>=l}),Ene()?(y=qt(function(){var v=_ne(r,t,m,s,i,a,[p,f],u,c,h,d),S=mo().makeTensorFromDataId(v.dataId,v.shape,v.dtype);return m.map(function(E,C){return function(I,_){return qt(function(){return Or(_x(I,mr(_)),"int32")})}(S,C)})}),[4,Promise.all(y.map(function(v){return v.data()}))]):[3,2];case 1:return g=w.sent(),y.forEach(function(v){return v.dispose()}),[3,5];case 2:return[4,r.data()];case 3:return b=w.sent(),[4,t.data()];case 4:x=w.sent(),g=function(v,S,E,C,I,_,A,k,N,D){var F=A[0],P=A[1];D===void 0&&(D=5);for(var G=E.map(function(Le){return new Uint8Array(C*I).fill(0)}),Y=k.top,Z=k.left,ee=ZL([C,I],[F,P],k),se=ee[0],re=ee[1],J=Cne([F,P],_)[0],le=0;le<C;le+=1)for(var he=0;he<I;he+=1){var xe=le*I+he;if(v[xe]===1){var Fe=Sne({x:he,y:le},S,E,D,[Y,Z],[se,re],J,[C,I],_,N);Fe>=0&&(G[Fe][xe]=1)}}return G}(b,x,m,s,i,a,[p,f],u,c),w.label=5;case 5:return[2,g.map(function(v,S){return{data:v,pose:m[S],width:i,height:s}})]}})})}function Lft(r,t,n,s,i,a,o,u,l,c,h,d,p){var f=u[0],m=u[1];return c===void 0&&(c=.2),h===void 0&&(h=8),d===void 0&&(d=.3),p===void 0&&(p=10),nn(this,void 0,void 0,function(){var g,y,b,x,w,v;return sn(this,function(S){switch(S.label){case 0:return g=s.filter(function(E){return E.score>=c}),Ene()?(b=qt(function(){var E=_ne(r,t,g,i,a,o,[f,m],l,h,d,p),C=mo().makeTensorFromDataId(E.dataId,E.shape,E.dtype);return g.map(function(I,_){return function(A,k,N){return qt(function(){return hr(xt(Or(_x(A,mr(N)),"int32"),jt(k,1)),1)})}(C,n,_)})}),[4,Promise.all(b.map(function(E){return E.data()}))]):[3,2];case 1:return y=S.sent(),b.forEach(function(E){return E.dispose()}),[3,6];case 2:return[4,r.data()];case 3:return x=S.sent(),[4,t.data()];case 4:return w=S.sent(),[4,n.data()];case 5:v=S.sent(),y=function(E,C,I,_,A,k,N,D,F,P,G){var Y=D[0],Z=D[1];G===void 0&&(G=5);for(var ee=_.map(function(Ae){return new Int32Array(A*k).fill(-1)}),se=F.top,re=F.left,J=ZL([A,k],[Y,Z],F),le=J[0],he=J[1],xe=Cne([Y,Z],N)[0],Fe=0;Fe<A;Fe+=1)for(var Le=0;Le<k;Le+=1){var Ve=Fe*k+Le;if(E[Ve]===1){var $e=Sne({x:Le,y:Fe},C,_,G,[se,re],[le,he],xe,[A,k],N,P);$e>=0&&(ee[$e][Ve]=I[Ve])}}return ee}(x,w,v,g,i,a,o,[f,m],l,h),S.label=6;case 6:return[2,y.map(function(E,C){return{pose:g[C],data:E,height:i,width:a}})]}})})}function wI(r){return Math.floor(r/2)}var Pft=function(){function r(t,n){this.priorityQueue=new Array(t),this.numberOfElements=-1,this.getElementValue=n}return r.prototype.enqueue=function(t){this.priorityQueue[++this.numberOfElements]=t,this.swim(this.numberOfElements)},r.prototype.dequeue=function(){var t=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,t},r.prototype.empty=function(){return this.numberOfElements===-1},r.prototype.size=function(){return this.numberOfElements+1},r.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},r.prototype.max=function(){return this.priorityQueue[0]},r.prototype.swim=function(t){for(;t>0&&this.less(wI(t),t);)this.exchange(t,wI(t)),t=wI(t)},r.prototype.sink=function(t){for(;2*t<=this.numberOfElements;){var n=2*t;if(n<this.numberOfElements&&this.less(n,n+1)&&n++,!this.less(t,n))break;this.exchange(t,n),t=n}},r.prototype.getValueAt=function(t){return this.getElementValue(this.priorityQueue[t])},r.prototype.less=function(t,n){return this.getValueAt(t)<this.getValueAt(n)},r.prototype.exchange=function(t,n){var s=this.priorityQueue[t];this.priorityQueue[t]=this.priorityQueue[n],this.priorityQueue[n]=s},r}();function Bft(r,t,n,s,i,a){for(var o=a.shape,u=o[0],l=o[1],c=!0,h=Math.max(n-i,0),d=Math.min(n+i+1,u),p=h;p<d;++p){for(var f=Math.max(s-i,0),m=Math.min(s+i+1,l),g=f;g<m;++g)if(a.get(p,g,r)>t){c=!1;break}if(!c)break}return c}var Ine=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]].map(function(r){var t=r[0],n=r[1];return[dS[t],dS[n]]}),SI=Ine.map(function(r){return r[1]}),Iz=Ine.map(function(r){return r[0]});function CI(r,t,n,s){return{y:_z(Math.round(r.y/t),0,n-1),x:_z(Math.round(r.x/t),0,s-1)}}function kz(r,t,n,s,i,a,o,u){u===void 0&&(u=2);for(var l=s.shape,c=l[0],h=l[1],d=function(x,w,v){var S=v.shape[2]/2;return{y:v.get(w.y,w.x,x),x:v.get(w.y,w.x,S+x)}}(r,CI(t.position,a,c,h),o),p=Ez(t.position,d),f=0;f<u;f++){var m=CI(p,a,c,h),g=vne(m.y,m.x,n,i);p=Ez({x:m.x*a,y:m.y*a},{x:g.x,y:g.y})}var y=CI(p,a,c,h),b=s.get(y.y,y.x,n);return{position:p,part:Q_[n],score:b}}function Vft(r,t,n,s,i,a){var o=t.shape[2],u=SI.length,l=new Array(o),c=r.part,h=r.score,d=wne(c,s,n);l[c.id]={score:h,part:Q_[c.id],position:d};for(var p=u-1;p>=0;--p){var f=SI[p],m=Iz[p];l[f]&&!l[m]&&(l[m]=kz(p,l[f],m,t,n,s,a))}for(p=0;p<u;++p)f=Iz[p],m=SI[p],l[f]&&!l[m]&&(l[m]=kz(p,l[f],m,t,n,s,i));return l}function kne(r,t,n,s){var i=n.x,a=n.y;return r.some(function(o){var u,l,c,h,d,p,f=o.keypoints[s].position;return u=a,l=i,c=f.y,h=f.x,(d=c-u)*d+(p=h-l)*p<=t})}function zft(r,t,n){var s=n.reduce(function(i,a,o){var u=a.position,l=a.score;return kne(r,t,u,o)||(i+=l),i},0);return s/n.length}function K1(r,t,n,s,i,a,o,u){o===void 0&&(o=.5),u===void 0&&(u=20);for(var l=[],c=function(m,g,y){for(var b=y.shape,x=b[0],w=b[1],v=b[2],S=new Pft(x*w*v,function(A){return A.score}),E=0;E<x;++E)for(var C=0;C<w;++C)for(var I=0;I<v;++I){var _=y.get(E,C,I);_<m||Bft(I,_,E,C,g,y)&&S.enqueue({score:_,part:{heatmapY:E,heatmapX:C,id:I}})}return S}(o,1,r),h=u*u;l.length<a&&!c.empty();){var d=c.dequeue();if(!kne(l,h,wne(d.part,i,t),d.part.id)){var p=Vft(d,r,t,i,n,s),f=zft(l,h,p);l.push({keypoints:p,score:f})}}return l}var xy,Uft=[-123.15,-115.9,-103.06],Wft=function(r){function t(){return r!==null&&r.apply(this,arguments)||this}return mne(t,r),t.prototype.preprocessInput=function(n){return jt(n,Uft)},t.prototype.nameOutputResults=function(n){var s=n[0],i=n[1],a=n[2],o=n[3],u=n[4],l=n[5];return{offsets:u,segmentation:n[6],partHeatmaps:l,longOffsets:o,heatmap:a,displacementFwd:i,displacementBwd:s,partOffsets:n[7]}},t}(xne),Nz="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/",Tz="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";function Vy(r){if(typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&r instanceof OffscreenCanvas||typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement)return function(t){if("offsetHeight"in t&&t.offsetHeight!==0&&"offsetWidth"in t&&t.offsetWidth!==0)return[t.offsetHeight,t.offsetWidth];if(t.height!=null&&t.width!=null)return[t.height,t.width];throw new Error("HTMLImageElement must have height and width attributes set.")}(r);if(typeof ImageData<"u"&&r instanceof ImageData)return[r.height,r.width];if(typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement)return function(t){return t.hasAttribute("height")&&t.hasAttribute("width")?[t.height,t.width]:[t.videoHeight,t.videoWidth]}(r);if(r instanceof Xr)return[r.shape[0],r.shape[1]];throw new Error("error: Unknown input type: "+r+".")}function Az(r,t){return function(n,s){return(n-1)%s==0}(r,t)?r:Math.floor(r/t)*t+1}var zy={low:"low",medium:"medium",high:"high",full:"full"},Gft=((xy={})[zy.low]=.25,xy[zy.medium]=.5,xy[zy.high]=.75,xy[zy.full]=1,xy);function X1(r,t,n){var s=n[0],i=n[1],a=function(o){if(typeof o=="string"){var u=Gft[o];return oe(typeof u=="number",function(){return"string value of inputResolution must be one of "+Object.values(zy).join(",")+" but was "+o+"."}),u}return oe(typeof o=="number"&&o<=2&&o>=.1,function(){return"inputResolution must be a string or number between 0.1 and 2, but was "+o}),o}(r);return[Az(s*a,t),Az(i*a,t)]}function zf(r,t,n,s,i){var a=t[0],o=t[1],u=n[0],l=n[1],c=s[0],h=c[0],d=c[1],p=s[1],f=p[0],m=p[1];return qt(function(){var g=ad.resizeBilinear(r,[u,l],!0);return g=iu(g),function(y,b,x){var w=b[0],v=b[1],S=x[0],E=S[0],C=S[1],I=x[1],_=I[0],A=I[1];return qt(function(){var k=vi(y);return Ga(ad.cropAndResize(k,[[E/(w+E+C-1),_/(v+_+A-1),(E+w-1)/(w+E+C-1),(_+v-1)/(v+_+A-1)]],[0],[w,v]),[0])})}(g,[a,o],[[h,d],[f,m]])})}function Y1(r,t){var n=t[0],s=t[1],i=Vy(r),a=i[0],o=i[1],u=s/n,l=[0,0,0,0],c=l[0],h=l[1],d=l[2],p=l[3];o/a<u?(c=0,h=0,d=Math.round(.5*(u*a-o)),p=Math.round(.5*(u*a-o))):(c=Math.round(.5*(1/u*o-a)),h=Math.round(.5*(1/u*o-a)),d=0,p=0);var f=qt(function(){var m=function(g){return g instanceof Xr?g:mC(g)}(r);return m=O$(m,[[c,h],[d,p],[0,0]]),ad.resizeBilinear(m,[n,s])});return{resized:f,padding:{top:c,left:d,right:p,bottom:h}}}function Z1(r){return nn(this,void 0,void 0,function(){return sn(this,function(t){return[2,Promise.all(r.map(function(n){return n.buffer()}))]})})}function J1(r,t,n,s,i){var a=t[0],o=t[1],u=n[0],l=n[1],c=function(h,d,p,f,m){return f===void 0&&(f=0),m===void 0&&(m=0),p===1&&d===1&&f===0&&m===0?h:h.map(function(g){return function(y,b,x,w,v){return w===void 0&&(w=0),v===void 0&&(v=0),{score:y.score,keypoints:y.keypoints.map(function(S){var E=S.score,C=S.part,I=S.position;return{score:E,part:C,position:{x:I.x*x+v,y:I.y*b+w}}})}}(g,d,p,f,m)})}(r,(a+s.top+s.bottom)/u,(o+s.left+s.right)/l,-s.top,-s.left);return i?function(h,d){return d<=0?h:h.map(function(p){return function(f,m){return{score:f.score,keypoints:f.keypoints.map(function(g){var y=g.score,b=g.part,x=g.position;return{score:y,part:b,position:{x:m-1-x.x,y:x.y}}})}}(p,d)})}(c,o):c}var Dz={architecture:"MobileNetV1",outputStride:16,quantBytes:4,multiplier:.75},Fz=["MobileNetV1","ResNet50"],$z={MobileNetV1:[8,16,32],ResNet50:[32,16]},Rz={MobileNetV1:[.5,.75,1],ResNet50:[1]},Oz=[1,2,4],Q1={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20},ew={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20,minKeypointScore:.3,refineSteps:10};function Mz(r){var t=r.segmentationThreshold,n=r.maxDetections,s=r.scoreThreshold,i=r.nmsRadius;if(t<0||t>1)throw new Error("segmentationThreshold "+t+". Should be in range [0.0, 1.0]");if(n<=0)throw new Error("Invalid maxDetections "+n+". Should be > 0");if(s<0||s>1)throw new Error("Invalid scoreThreshold "+s+". Should be in range [0.0, 1.0]");if(i<=0)throw new Error("Invalid nmsRadius "+i+".")}function Lz(r){var t=r.segmentationThreshold,n=r.maxDetections,s=r.scoreThreshold,i=r.nmsRadius,a=r.minKeypointScore,o=r.refineSteps;if(t<0||t>1)throw new Error("segmentationThreshold "+t+". Should be in range [0.0, 1.0]");if(n<=0)throw new Error("Invalid maxDetections "+n+". Should be > 0");if(s<0||s>1)throw new Error("Invalid scoreThreshold "+s+". Should be in range [0.0, 1.0]");if(i<=0)throw new Error("Invalid nmsRadius "+i+".");if(a<0||a>1)throw new Error("Invalid minKeypointScore "+a+".Should be in range [0.0, 1.0]");if(o<=0||o>20)throw new Error("Invalid refineSteps "+o+".Should be in range [1, 20]")}var Nne=function(){function r(t){this.baseModel=t}return r.prototype.predictForPersonSegmentation=function(t){var n=this.baseModel.predict(t);return{segmentLogits:n.segmentation,heatmapScores:n.heatmapScores,offsets:n.offsets,displacementFwd:n.displacementFwd,displacementBwd:n.displacementBwd}},r.prototype.predictForPersonSegmentationAndPart=function(t){var n=this.baseModel.predict(t);return{segmentLogits:n.segmentation,partHeatmapLogits:n.partHeatmaps,heatmapScores:n.heatmapScores,offsets:n.offsets,displacementFwd:n.displacementFwd,displacementBwd:n.displacementBwd}},r.prototype.predictForMultiPersonInstanceSegmentationAndPart=function(t){var n=this.baseModel.predict(t);return{segmentLogits:n.segmentation,longOffsets:n.longOffsets,heatmapScores:n.heatmapScores,offsets:n.offsets,displacementFwd:n.displacementFwd,displacementBwd:n.displacementBwd,partHeatmaps:n.partHeatmaps}},r.prototype.segmentPersonActivation=function(t,n,s){var i=this;s===void 0&&(s=.5);var a=Vy(t),o=a[0],u=a[1],l=X1(n,this.baseModel.outputStride,[o,u]),c=Y1(t,l),h=c.resized,d=c.padding,p=qt(function(){var x=i.predictForPersonSegmentation(h),w=x.segmentLogits,v=x.heatmapScores,S=x.offsets,E=x.displacementFwd,C=x.displacementBwd,I=h.shape,_=I[0],A=I[1],k=zf(w,[o,u],[_,A],[[d.top,d.bottom],[d.left,d.right]]);return{segmentation:q1(Ga(k),s),heatmapScores:v,offsets:S,displacementFwd:E,displacementBwd:C}}),f=p.segmentation,m=p.heatmapScores,g=p.offsets,y=p.displacementFwd,b=p.displacementBwd;return h.dispose(),{segmentation:f,heatmapScores:m,offsets:g,displacementFwd:y,displacementBwd:b,padding:d,internalResolutionHeightAndWidth:l}},r.prototype.segmentPerson=function(t,n){return n===void 0&&(n=Q1),nn(this,void 0,void 0,function(){var s,i,a,o,u,l,c,h,d,p,f,m,g,y,b,x,w,v;return sn(this,function(S){switch(S.label){case 0:return Mz(n=Ys(Ys({},Q1),n)),s=this.segmentPersonActivation(t,n.internalResolution,n.segmentationThreshold),i=s.segmentation,a=s.heatmapScores,o=s.offsets,u=s.displacementFwd,l=s.displacementBwd,c=s.padding,h=s.internalResolutionHeightAndWidth,d=i.shape,p=d[0],f=d[1],[4,i.data()];case 1:return m=S.sent(),i.dispose(),[4,Z1([a,o,u,l])];case 2:return g=S.sent(),y=g[0],b=g[1],x=g[2],w=g[3],v=J1(v=K1(y,b,x,w,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[p,f],h,c,!1),a.dispose(),o.dispose(),u.dispose(),l.dispose(),[2,{height:p,width:f,data:m,allPoses:v}]}})})},r.prototype.segmentMultiPerson=function(t,n){return n===void 0&&(n=ew),nn(this,void 0,void 0,function(){var s,i,a,o,u,l,c,h,d,p,f,m,g,y,b,x,w,v,S,E,C,I=this;return sn(this,function(_){switch(_.label){case 0:return Lz(n=Ys(Ys({},ew),n)),s=Vy(t),i=s[0],a=s[1],o=X1(n.internalResolution,this.baseModel.outputStride,[i,a]),u=Y1(t,o),l=u.resized,c=u.padding,h=qt(function(){var A,k=I.predictForMultiPersonInstanceSegmentationAndPart(l),N=k.segmentLogits,D=k.longOffsets,F=k.heatmapScores,P=k.offsets,G=k.displacementFwd,Y=k.displacementBwd,Z=zf(N,[i,a],o,[[c.top,c.bottom],[c.left,c.right]]);return A=D,{segmentation:q1(Ga(Z),n.segmentationThreshold),longOffsets:A,heatmapScoresRaw:F,offsetsRaw:P,displacementFwdRaw:G,displacementBwdRaw:Y}}),d=h.segmentation,p=h.longOffsets,f=h.heatmapScoresRaw,m=h.offsetsRaw,g=h.displacementFwdRaw,y=h.displacementBwdRaw,[4,Z1([f,m,g,y])];case 1:return b=_.sent(),x=b[0],w=b[1],v=b[2],S=b[3],E=J1(E=K1(x,w,v,S,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[i,a],o,c,!1),[4,Mft(d,p,E,i,a,this.baseModel.outputStride,o,c,n.scoreThreshold,n.refineSteps,n.minKeypointScore,n.maxDetections)];case 2:return C=_.sent(),l.dispose(),d.dispose(),p.dispose(),f.dispose(),m.dispose(),g.dispose(),y.dispose(),[2,C]}})})},r.prototype.segmentPersonPartsActivation=function(t,n,s){var i=this;s===void 0&&(s=.5);var a=Vy(t),o=a[0],u=a[1],l=X1(n,this.baseModel.outputStride,[o,u]),c=Y1(t,l),h=c.resized,d=c.padding,p=qt(function(){var x=i.predictForPersonSegmentationAndPart(h),w=x.segmentLogits,v=x.partHeatmapLogits,S=x.heatmapScores,E=x.offsets,C=x.displacementFwd,I=x.displacementBwd,_=h.shape,A=_[0],k=_[1],N=zf(w,[o,u],[A,k],[[d.top,d.bottom],[d.left,d.right]]),D=zf(v,[o,u],[A,k],[[d.top,d.bottom],[d.left,d.right]]);return{partSegmentation:Fft(q1(Ga(N),s),D),heatmapScores:S,offsets:E,displacementFwd:C,displacementBwd:I}}),f=p.partSegmentation,m=p.heatmapScores,g=p.offsets,y=p.displacementFwd,b=p.displacementBwd;return h.dispose(),{partSegmentation:f,heatmapScores:m,offsets:g,displacementFwd:y,displacementBwd:b,padding:d,internalResolutionHeightAndWidth:l}},r.prototype.segmentPersonParts=function(t,n){return n===void 0&&(n=Q1),nn(this,void 0,void 0,function(){var s,i,a,o,u,l,c,h,d,p,f,m,g,y,b,x,w,v;return sn(this,function(S){switch(S.label){case 0:return Mz(n=Ys(Ys({},Q1),n)),s=this.segmentPersonPartsActivation(t,n.internalResolution,n.segmentationThreshold),i=s.partSegmentation,a=s.heatmapScores,o=s.offsets,u=s.displacementFwd,l=s.displacementBwd,c=s.padding,h=s.internalResolutionHeightAndWidth,d=i.shape,p=d[0],f=d[1],[4,i.data()];case 1:return m=S.sent(),i.dispose(),[4,Z1([a,o,u,l])];case 2:return g=S.sent(),y=g[0],b=g[1],x=g[2],w=g[3],v=J1(v=K1(y,b,x,w,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[p,f],h,c,!1),a.dispose(),o.dispose(),u.dispose(),l.dispose(),[2,{height:p,width:f,data:m,allPoses:v}]}})})},r.prototype.segmentMultiPersonParts=function(t,n){return n===void 0&&(n=ew),nn(this,void 0,void 0,function(){var s,i,a,o,u,l,c,h,d,p,f,m,g,y,b,x,w,v,S,E,C,I,_=this;return sn(this,function(A){switch(A.label){case 0:return Lz(n=Ys(Ys({},ew),n)),s=Vy(t),i=s[0],a=s[1],o=X1(n.internalResolution,this.baseModel.outputStride,[i,a]),u=Y1(t,o),l=u.resized,c=u.padding,h=qt(function(){var k=_.predictForMultiPersonInstanceSegmentationAndPart(l),N=k.segmentLogits,D=k.longOffsets,F=k.heatmapScores,P=k.offsets,G=k.displacementFwd,Y=k.displacementBwd,Z=k.partHeatmaps,ee=zf(N,[i,a],o,[[c.top,c.bottom],[c.left,c.right]]),se=zf(Z,[i,a],o,[[c.top,c.bottom],[c.left,c.right]]),re=D,J=q1(Ga(ee),n.segmentationThreshold),le=function(he){var xe=he.shape,Fe=xe[0],Le=xe[1],Ve=xe[2];return qt(function(){var $e=bne(he),Ae=vi(pc(0,Ve,1,"int32"),1),Te=Or(Vr($e,Ae),"int32");return Qe(Te,[Fe,Le])})}(se);return{segmentation:J,longOffsets:re,heatmapScoresRaw:F,offsetsRaw:P,displacementFwdRaw:G,displacementBwdRaw:Y,partSegmentation:le}}),d=h.segmentation,p=h.longOffsets,f=h.heatmapScoresRaw,m=h.offsetsRaw,g=h.displacementFwdRaw,y=h.displacementBwdRaw,b=h.partSegmentation,[4,Z1([f,m,g,y])];case 1:return x=A.sent(),w=x[0],v=x[1],S=x[2],E=x[3],C=J1(C=K1(w,v,S,E,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[i,a],o,c,!1),[4,Lft(d,p,b,C,i,a,this.baseModel.outputStride,o,c,n.scoreThreshold,n.refineSteps,n.minKeypointScore,n.maxDetections)];case 2:return I=A.sent(),l.dispose(),d.dispose(),p.dispose(),f.dispose(),m.dispose(),g.dispose(),y.dispose(),b.dispose(),[2,I]}})})},r.prototype.dispose=function(){this.baseModel.dispose()},r}();function Hft(r){return nn(this,void 0,void 0,function(){var t,n,s,i,a,o;return sn(this,function(u){switch(u.label){case 0:if(t=r.outputStride,n=r.quantBytes,s=r.multiplier,c7==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return i=function(l,c,h){var d={1:"100",.75:"075",.5:"050"},p="model-stride"+l+".json";return h===4?Tz+"float/"+d[c]+"/"+p:Tz+"quant"+h+"/"+d[c]+"/"+p}(t,s,n),[4,XL(r.modelUrl||i)];case 1:return a=u.sent(),o=new $ft(a,t),[2,new Nne(o)]}})})}function jft(r){return nn(this,void 0,void 0,function(){var t,n,s,i,a;return sn(this,function(o){switch(o.label){case 0:if(t=r.outputStride,n=r.quantBytes,c7==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return s=function(u,l){var c="model-stride"+u+".json";return l===4?Nz+"float/"+c:Nz+"quant"+l+"/"+c}(t,n),[4,XL(r.modelUrl||s)];case 1:return i=o.sent(),a=new Wft(i,t),[2,new Nne(a)]}})})}function qft(r){return r===void 0&&(r=Dz),nn(this,void 0,void 0,function(){return sn(this,function(t){return(r=function(n){if((n=n||Dz).architecture==null&&(n.architecture="MobileNetV1"),Fz.indexOf(n.architecture)<0)throw new Error("Invalid architecture "+n.architecture+". Should be one of "+Fz);if(n.outputStride==null&&(n.outputStride=16),$z[n.architecture].indexOf(n.outputStride)<0)throw new Error("Invalid outputStride "+n.outputStride+". Should be one of "+$z[n.architecture]+" for architecture "+n.architecture+".");if(n.multiplier==null&&(n.multiplier=1),Rz[n.architecture].indexOf(n.multiplier)<0)throw new Error("Invalid multiplier "+n.multiplier+". Should be one of "+Rz[n.architecture]+" for architecture "+n.architecture+".");if(n.quantBytes==null&&(n.quantBytes=4),Oz.indexOf(n.quantBytes)<0)throw new Error("Invalid quantBytes "+n.quantBytes+". Should be one of "+Oz+" for architecture "+n.architecture+".");return n}(r)).architecture==="ResNet50"?[2,jft(r)]:r.architecture==="MobileNetV1"?[2,Hft(r)]:[2,null]})})}var nT=["left_face","right_face","left_upper_arm_front","left_upper_arm_back","right_upper_arm_front","right_upper_arm_back","left_lower_arm_front","left_lower_arm_back","right_lower_arm_front","right_lower_arm_back","left_hand","right_hand","torso_front","torso_back","left_upper_leg_front","left_upper_leg_back","right_upper_leg_front","right_upper_leg_back","left_lower_leg_front","left_lower_leg_back","right_lower_leg_front","right_lower_leg_back","left_feet","right_feet"],Pz=function(){function r(t){this.mask=t}return r.prototype.toCanvasImageSource=function(){return nn(this,void 0,void 0,function(){return sn(this,function(t){return[2,YL(this.mask)]})})},r.prototype.toImageData=function(){return nn(this,void 0,void 0,function(){return sn(this,function(t){return[2,this.mask]})})},r.prototype.toTensor=function(){return nn(this,void 0,void 0,function(){return sn(this,function(t){return[2,yne(this.mask)]})})},r.prototype.getUnderlyingType=function(){return"imagedata"},r}();function Kft(r){if(J_(r),r!==255)throw new Error("Foreground id must be 255 but got "+r);return"person"}function Xft(r){if(J_(r),r>=nT.length)throw new Error("Invalid body part value "+r);return nT[r]}var Yft=function(){function r(t){this.bodyPixModel=t}return r.prototype.segmentPeople=function(t,n){return nn(this,void 0,void 0,function(){var s,i,a,o;return sn(this,function(u){switch(u.label){case 0:return t instanceof ImageBitmap&&((s=document.createElement("canvas")).getContext("2d").drawImage(t,0,0),t=s),n.segmentBodyParts?n.multiSegmentation?[4,this.bodyPixModel.segmentMultiPersonParts(t,n)]:[3,2]:[3,5];case 1:return a=u.sent(),[3,4];case 2:return[4,this.bodyPixModel.segmentPersonParts(t,n)];case 3:a=[u.sent()],u.label=4;case 4:return i=a.map(function(l){var c=l.data,h=l.width,d=l.height,p=new Uint8ClampedArray(h*d*4).fill(0);return c.forEach(function(f,m){f===-1?(p[4*m]=nT.length,p[4*m+3]=0):(p[4*m]=f,p[4*m+3]=255)}),{maskValueToLabel:Xft,mask:new Pz(new ImageData(p,h,d))}}),[3,10];case 5:return n.multiSegmentation?[4,this.bodyPixModel.segmentMultiPerson(t,n)]:[3,7];case 6:return o=u.sent(),[3,9];case 7:return[4,this.bodyPixModel.segmentPerson(t,n)];case 8:o=[u.sent()],u.label=9;case 9:i=o.map(function(l){var c=l.data,h=l.width,d=l.height,p=new Uint8ClampedArray(h*d*4).fill(0);return c.forEach(function(f,m){f===0?(p[4*m]=0,p[4*m+3]=0):(p[4*m]=255,p[4*m+3]=255)}),{maskValueToLabel:Kft,mask:new Pz(new ImageData(p,h,d))}}),u.label=10;case 10:return[2,i]}})})},r.prototype.dispose=function(){this.bodyPixModel.dispose()},r.prototype.reset=function(){},r}();function Zft(r){return nn(this,void 0,void 0,function(){return sn(this,function(t){return[2,qft(r).then(function(n){return new Yft(n)})]})})}var Bz={runtime:"mediapipe",modelType:"general"},Jft=function(){function r(t){this.mask=t}return r.prototype.toCanvasImageSource=function(){return nn(this,void 0,void 0,function(){return sn(this,function(t){return[2,this.mask]})})},r.prototype.toImageData=function(){return nn(this,void 0,void 0,function(){return sn(this,function(t){return[2,gne(this.mask)]})})},r.prototype.toTensor=function(){return nn(this,void 0,void 0,function(){return sn(this,function(t){return[2,yne(this.mask)]})})},r.prototype.getUnderlyingType=function(){return"canvasimagesource"},r}();function Qft(r){return J_(r),"person"}var emt=function(){function r(t){var n,s=this;this.selfieMode=!1;var i;this.selfieSegmentationSolution=new Dft.SelfieSegmentation({locateFile:(n=t.locateFile)!==null&&n!==void 0?n:function(a,o){return t.solutionPath?t.solutionPath.replace(/\/+$/,"")+"/"+a:o+"/"+a}}),t.modelType==="landscape"?i=1:i=0,this.selfieSegmentationSolution.setOptions({modelSelection:i,selfieMode:this.selfieMode}),this.selfieSegmentationSolution.onResults(function(a){s.segmentation=[{maskValueToLabel:Qft,mask:new Jft(a.segmentationMask)}]})}return r.prototype.segmentPeople=function(t,n){return nn(this,void 0,void 0,function(){var s,i;return sn(this,function(a){switch(a.label){case 0:return n&&n.flipHorizontal&&n.flipHorizontal!==this.selfieMode&&(this.selfieMode=n.flipHorizontal,this.selfieSegmentationSolution.setOptions({selfieMode:this.selfieMode})),t instanceof Xr?(i=ImageData.bind,[4,fC(t)]):[3,2];case 1:return s=new(i.apply(ImageData,[void 0,a.sent(),t.shape[1],t.shape[0]])),[3,3];case 2:s=t,a.label=3;case 3:return t=s,[4,this.selfieSegmentationSolution.send({image:t})];case 4:return a.sent(),[2,this.segmentation]}})})},r.prototype.dispose=function(){this.selfieSegmentationSolution.close()},r.prototype.reset=function(){this.selfieSegmentationSolution.reset(),this.segmentation=null,this.selfieMode=!1},r.prototype.initialize=function(){return this.selfieSegmentationSolution.initialize()},r}();function tmt(r){return nn(this,void 0,void 0,function(){var t,n;return sn(this,function(s){switch(s.label){case 0:return t=function(i){if(i==null)return Ys({},Bz);var a=Ys({},i);return a.runtime="mediapipe",a.modelType==null&&(a.modelType=Bz.modelType),a}(r),[4,(n=new emt(t)).initialize()];case 1:return s.sent(),[2,n]}})})}function rmt(r,t,n,s){var i=r.width,a=r.height,o=1,u=Math.cos(r.rotation),l=Math.sin(r.rotation),c=r.xCenter,h=r.yCenter,d=1/t,p=1/n,f=new Array(16);return f[0]=i*u*o*d,f[1]=-a*l*d,f[2]=0,f[3]=(-.5*i*u*o+.5*a*l+c)*d,f[4]=i*l*o*p,f[5]=a*u*p,f[6]=0,f[7]=(-.5*a*u-.5*i*l*o+h)*p,f[8]=0,f[9]=0,f[10]=i*d,f[11]=0,f[12]=0,f[13]=0,f[14]=0,f[15]=1,function(m){if(m.length!==16)throw new Error("Array length must be 16 but got "+m.length);return[[m[0],m[1],m[2],m[3]],[m[4],m[5],m[6],m[7]],[m[8],m[9],m[10],m[11]],[m[12],m[13],m[14],m[15]]]}(f)}function Tne(r){return r instanceof Xr?{height:r.shape[0],width:r.shape[1]}:{height:r.height,width:r.width}}function _I(r,t){oe(r.width!==0,function(){return t+" width cannot be 0."}),oe(r.height!==0,function(){return t+" height cannot be 0."})}function nmt(r,t){var n=function(s,i,a,o){var u=i-s,l=o-a,c=l/u;return{scale:c,offset:a-s*c}}(0,255,t[0],t[1]);return qt(function(){return jt(xt(r,n.scale),n.offset)})}function smt(r,t,n){var s=t.outputTensorSize,i=t.keepAspectRatio,a=t.borderMode,o=t.outputTensorFloatRange,u=Tne(r),l=function(p,f){return{xCenter:.5*p.width,yCenter:.5*p.height,width:p.width,height:p.height,rotation:0}}(u),c=function(p,f,m){if(m===void 0&&(m=!1),!m)return{top:0,left:0,right:0,bottom:0};var g=f.height,y=f.width;_I(f,"targetSize"),_I(p,"roi");var b,x,w=g/y,v=p.height/p.width,S=0,E=0;return w>v?(b=p.width,x=p.width*w,E=(1-v/w)/2):(b=p.height/w,x=p.height,S=(1-w/v)/2),p.width=b,p.height=x,{top:E,left:S,right:S,bottom:E}}(l,s,i),h=rmt(l,u.width,u.height),d=qt(function(){var p,f=(p=r)instanceof Xr?p:mC(p),m=Oh(function(b,x,w){return _I(w,"inputResolution"),[1/w.width*b[0][0]*x.width,1/w.height*b[0][1]*x.width,b[0][3]*x.width,1/w.width*b[1][0]*x.height,1/w.height*b[1][1]*x.height,b[1][3]*x.height,0,0]}(h,u,s),[1,8]),g=a==="zero"?"constant":"nearest",y=ad.transform(vi(Or(f,"float32")),m,"bilinear",g,0,[s.height,s.width]);return o!=null?nmt(y,o):y});return{imageTensor:d,padding:c,transformationMatrix:h}}function imt(r,t,n){return qt(function(){var s=Ga(r,[0]),i=s.shape[2];if(i===1){var a=s;switch(t.activation){case"none":break;case"sigmoid":a=iu(a);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported ("+t.activation+")")}var o=n?ad.resizeBilinear(a,[n.height,n.width]):a;return Ga(o,[2])}throw new Error("Unsupported number of tensor channels "+i)})}var Vz={runtime:"tfjs",modelType:"general",modelUrl:"https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/general/1"},zz={flipHorizontal:!1},amt={outputTensorSize:{width:256,height:256},keepAspectRatio:!1,borderMode:"zero",outputTensorFloatRange:[0,1]},omt={outputTensorSize:{width:256,height:144},keepAspectRatio:!1,borderMode:"zero",outputTensorFloatRange:[0,1]},umt={activation:"none"},lmt=function(){function r(t){this.mask=t}return r.prototype.toCanvasImageSource=function(){return nn(this,void 0,void 0,function(){return sn(this,function(t){return[2,YL(this.mask)]})})},r.prototype.toImageData=function(){return nn(this,void 0,void 0,function(){return sn(this,function(t){return[2,gne(this.mask)]})})},r.prototype.toTensor=function(){return nn(this,void 0,void 0,function(){return sn(this,function(t){return[2,this.mask]})})},r.prototype.getUnderlyingType=function(){return"tensor"},r}();function cmt(r){return J_(r),"person"}var ux,hmt=function(){function r(t,n){this.modelType=t,this.model=n}return r.prototype.segmentPeople=function(t,n){return nn(this,void 0,void 0,function(){var s,i=this;return sn(this,function(a){return n=function(o){if(o==null)return Ys({},zz);var u=Ys({},o);return u.flipHorizontal==null&&(u.flipHorizontal=zz.flipHorizontal),u}(n),t==null?(this.reset(),[2,[]]):(s=qt(function(){var o=smt(t,i.modelType==="general"?amt:omt).imageTensor,u=en(i.model.predict(o),[0,0,0,1],-1),l=Tne(t),c=imt(u,umt,l),h=vi(c,2),d=Bd(h,[[0,0],[0,0],[0,1]]);return $$(d,[[0,0],[0,0],[0,2]],"symmetric")}),[2,[{maskValueToLabel:cmt,mask:new lmt(s)}]])})})},r.prototype.dispose=function(){this.model.dispose()},r.prototype.reset=function(){},r}();function dmt(r){return nn(this,void 0,void 0,function(){var t,n,s;return sn(this,function(i){switch(i.label){case 0:return t=function(a){if(a==null)return Ys({},Vz);var o=Ys({},a);if(o.runtime="tfjs",o.modelType==null&&(o.modelType=Vz.modelType),o.modelType!=="general"&&o.modelType!=="landscape")throw new Error("Model type must be one of general or landscape, but got "+o.modelType);return o.modelUrl==null&&(o.modelType==="general"?o.modelUrl="https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/general/1":o.modelUrl="https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/landscape/1"),o}(r),n=typeof t.modelUrl=="string"&&t.modelUrl.indexOf("https://tfhub.dev")>-1,[4,XL(t.modelUrl,{fromTFHub:n})];case 1:return s=i.sent(),[2,new hmt(t.modelType,s)]}})})}function pmt(r,t){return nn(this,void 0,void 0,function(){var n,s;return sn(this,function(i){switch(r){case ux.MediaPipeSelfieSegmentation:if(n=void 0,(s=t)!=null){if(s.runtime==="tfjs")return[2,dmt(s)];if(s.runtime==="mediapipe")return[2,tmt(s)];n=s.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+n);case ux.BodyPix:return[2,Zft(s=t)];default:throw new Error(r+" is not a supported model name.")}})})}(function(r){r.BodyPix="BodyPix",r.MediaPipeSelfieSegmentation="MediaPipeSelfieSegmentation"})(ux||(ux={}));typeof window.OffscreenCanvas>"u"&&(window.OffscreenCanvas=function(r,t){const n=document.createElement("canvas");return n.width=r,n.height=t,n});const fmt=["000000","FFFFFF","FCCBB4","F1A582","E0885F"],mmt=["2152FF","FFE35B","C351F4","81D282","5C9EFF","9C0DDF","CAAEFF","9C5035"];function Ane(r){let t=r.replace(/^#/,"");t.length===3&&(t=t.split("").map(s=>s+s).join(""));const n=parseInt(t,16);return[n>>16&255,n>>8&255,n&255]}function gmt(r,t,n){let s=Uz[0],i=1/0;for(const[a,o,u]of Uz){const l=r-a,c=t-o,h=n-u,d=l*l+c*c+h*h;d<i&&(i=d,s=[a,o,u])}return s}const Uz=fmt.map(Ane),Bv=mmt.map(Ane),tw=20,rw=10;let Rw,Wz=null,EI=null,nw=null,II=null,sT,iT,aT,oT,sw=!1,Ou,Gz,kI=!1,NI=!1,Dl,TI;function Vv(r,t=new Set){let n,s;do n=Math.floor(Math.random()*r.length),s=r[n];while(t.has(n)&&t.size<r.length);return t.add(n),s}const zv=new Set,ymt=Vv(Bv,zv),Hz=Vv(Bv,zv),bmt=Vv(Bv,zv),xmt=Vv(Bv,zv),vmt=Vv(Bv,zv);async function wmt(){await Xdt("/kinetic-blocky-face/models"),await Ydt("/kinetic-blocky-face/models"),console.log("Models loaded")}function iw(r){if(r.length<3)return r.slice();r=r.slice().sort(([i,a],[o,u])=>i-o||a-u);const t=(i,a,o)=>(a[0]-i[0])*(o[1]-i[1])-(a[1]-i[1])*(o[0]-i[0]),n=[];for(const i of r){for(;n.length>=2&&t(n[n.length-2],n[n.length-1],i)<=0;)n.pop();n.push(i)}const s=[];for(let i=r.length-1;i>=0;i--){const a=r[i];for(;s.length>=2&&t(s[s.length-2],s[s.length-1],a)<=0;)s.pop();s.push(a)}return s.pop(),n.pop(),n.concat(s)}function aw(r,t,n){let s=!1;for(let i=0,a=n.length-1;i<n.length;a=i++){const[o,u]=n[i],[l,c]=n[a];u>t!=c>t&&r<(l-o)*(t-u)/(c-u||1e-10)+o&&(s=!s)}return s}function Smt(r,t){if(!(r!=null&&r.landmarks)||!t)return;const{w:n,h:s}=t,i=Ou.elt.videoWidth,a=Ou.elt.videoHeight,o=n/i,u=s/a;function l(c){return[c.x*o,c.y*u]}iT=iw(r.landmarks.getRightEye().map(l)),sT=iw(r.landmarks.getLeftEye().map(l)),aT=iw(r.landmarks.getNose().map(l)),oT=iw(r.landmarks.getMouth().map(l))}const Cmt=r=>{const t=new ane({inputSize:160,scoreThreshold:.5});r.setup=async()=>{const o=window.innerWidth,u=window.innerHeight;let l=700,c=800,h=l,d=c,p=o/u;h/d>p?h=Math.round(d*p):d=Math.round(h/p),r.pixelDensity(1),r.createCanvas(h,d,r.WEBGL).parent("p5-container"),Ou=r.createCapture({video:{width:l,height:c},audio:!1},()=>sw=!0),Ou.hide(),Dl=document.createElement("canvas"),Dl.width=l,Dl.height=c,TI=Dl.getContext("2d"),Gz=r.createGraphics(l,c),Gz.pixelDensity(1),i(),a(t)};const n=400;let s=!0;r.draw=(()=>{let o=0,u=null,l=20;return()=>{const c=Date.now(),h=Ou.elt.videoWidth,d=Ou.elt.videoHeight;if(c-o>=n&&h&&((Dl.width!==h||Dl.height!==d)&&(Dl.width=h,Dl.height=d),TI.drawImage(Ou.elt,0,0,h,d),u=TI.getImageData(0,0,h,d).data,l=h,o=c),!sw||!Rw||!EI||!nw||!II||!u||!l)return;r.orbitControl(),(NI||kI)&&(Smt(Wz,nw),NI=!1,kI=!1);const{w:p,h:f,c:m}=nw,{minX:g,minY:y,cropW:b,cropH:x}=II;if(s){s=!1;const w=window.innerWidth<window.innerHeight,v=w?1e3:2e3,S=w?.4:.75,E=(Math.random()*(2*S)-S)*v,C=(Math.random()*(2*S)-S)*v,I=Math.sqrt(Math.max(0,v*v-E*E-C*C));r.camera(E,C,I,0,0,0,0,1,0)}r.background(255),r.stroke(xmt),r.strokeWeight(1);for(let w=0;w<x;w+=rw)for(let v=0;v<b;v+=tw){const S=g+v+tw/2,E=p-1-S,C=y+w+rw/2,I=(C*p+E)*m;if(EI[I]>.5){const _=(C*l+E)*4;let A=!1,k=u[_],N=u[_+1],D=u[_+2];iT&&aw(E,C,iT)?(A=!0,[k,N,D]=Hz):sT&&aw(E,C,sT)?(A=!0,[k,N,D]=Hz):aT&&aw(E,C,aT)?(A=!0,[k,N,D]=bmt):oT&&aw(E,C,oT)?(A=!0,[k,N,D]=ymt):[k,N,D]=gmt(k,N,D),r.push(),r.fill(k,N,D),A&&(r.stroke(vmt),r.strokeWeight(2)),r.translate(v-b/2+tw/2,w-x/2+rw/2,0),r.box(tw,rw,100),r.pop()}}}})();function i(){sw&&Rw&&Rw.segmentPeople(Ou.elt).then(([o])=>{let u=o.mask.toTensor?o.mask.toTensor():o.mask;Promise.resolve(u).then(async l=>{const c=await l.data(),[h,d,p]=l.shape;let f=d,m=h,g=0,y=0;for(let b=0;b<c.length;b+=p)if(c[b]>.5){const x=b/p,w=Math.floor(x/d),v=x%d;f=Math.min(f,v),m=Math.min(m,w),g=Math.max(g,v),y=Math.max(y,w)}EI=c,nw={w:d,h,c:p},II={minX:f,minY:m,cropW:g-f,cropH:y-m},l.dispose&&l.dispose(),kI=!0})}),setTimeout(i,n)}function a(o){sw&&tpt(Ou.elt,o).withFaceLandmarks(!0).then(u=>{Wz=u,NI=!0}).catch(()=>{}),setTimeout(()=>a(o),n)}};document.getElementById("start-btn").addEventListener("click",async()=>{const r=document.getElementById("start-btn");r.disabled=!0,r.textContent="LOADING...",await wmt(),Rw=await pmt(ux.MediaPipeSelfieSegmentation,{runtime:"mediapipe",solutionPath:"https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation",modelType:"general"}),r.style.display="none",document.getElementById("p5-container").style.display="block",new Zr(Cmt)});
